// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = RenderCopyNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = RenderCopyNative(renderer, texture, srcrect, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyNative((SDLRenderer*)prenderer, texture, srcrect, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyNative(renderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopy(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = RenderCopyNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderCopyExNative(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLRect*, SDLRect*, double, SDLPoint*, SDLRendererFlip, int>)funcTable[781])(renderer, texture, srcrect, dstrect, angle, center, flip);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, double, nint, SDLRendererFlip, int>)funcTable[781])((nint)renderer, (nint)texture, (nint)srcrect, (nint)dstrect, angle, (nint)center, flip);
			#endif
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			int ret = RenderCopyExNative(renderer, texture, srcrect, dstrect, angle, center, flip);
			return ret;
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = RenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = RenderCopyExNative(renderer, texture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, SDLPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLPoint* pcenter = &center)
			{
				int ret = RenderCopyExNative(renderer, texture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLRect* dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative(renderer, texture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLRect dstrect, double angle, ref SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							fixed (SDLPoint* pcenter = &center)
							{
								int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawPointFNative(SDLRenderer* renderer, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, int>)funcTable[782])(renderer, x, y);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, float, int>)funcTable[782])((nint)renderer, x, y);
			#endif
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointF(SDLRenderer* renderer, float x, float y)
		{
			int ret = RenderDrawPointFNative(renderer, x, y);
			return ret;
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointF(ref SDLRenderer renderer, float x, float y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawPointFNative((SDLRenderer*)prenderer, x, y);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawPointsFNative(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFPoint*, int, int>)funcTable[783])(renderer, points, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[783])((nint)renderer, (nint)points, count);
			#endif
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			int ret = RenderDrawPointsFNative(renderer, points, count);
			return ret;
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(ref SDLRenderer renderer, SDLFPoint* points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawPointsFNative((SDLRenderer*)prenderer, points, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(SDLRenderer* renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				int ret = RenderDrawPointsFNative(renderer, (SDLFPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(ref SDLRenderer renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					int ret = RenderDrawPointsFNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawLineFNative(SDLRenderer* renderer, float x1, float y1, float x2, float y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, float, float, int>)funcTable[784])(renderer, x1, y1, x2, y2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, int>)funcTable[784])((nint)renderer, x1, y1, x2, y2);
			#endif
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLineF(SDLRenderer* renderer, float x1, float y1, float x2, float y2)
		{
			int ret = RenderDrawLineFNative(renderer, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLineF(ref SDLRenderer renderer, float x1, float y1, float x2, float y2)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawLineFNative((SDLRenderer*)prenderer, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawLinesFNative(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFPoint*, int, int>)funcTable[785])(renderer, points, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[785])((nint)renderer, (nint)points, count);
			#endif
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			int ret = RenderDrawLinesFNative(renderer, points, count);
			return ret;
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(ref SDLRenderer renderer, SDLFPoint* points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawLinesFNative((SDLRenderer*)prenderer, points, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(SDLRenderer* renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				int ret = RenderDrawLinesFNative(renderer, (SDLFPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(ref SDLRenderer renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					int ret = RenderDrawLinesFNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawRectFNative(SDLRenderer* renderer, SDLFRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int>)funcTable[786])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[786])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(SDLRenderer* renderer, SDLFRect* rect)
		{
			int ret = RenderDrawRectFNative(renderer, rect);
			return ret;
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(ref SDLRenderer renderer, SDLFRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawRectFNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(SDLRenderer* renderer, ref SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				int ret = RenderDrawRectFNative(renderer, (SDLFRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(ref SDLRenderer renderer, ref SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					int ret = RenderDrawRectFNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawRectsFNative(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int, int>)funcTable[787])(renderer, rects, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[787])((nint)renderer, (nint)rects, count);
			#endif
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			int ret = RenderDrawRectsFNative(renderer, rects, count);
			return ret;
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(ref SDLRenderer renderer, SDLFRect* rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawRectsFNative((SDLRenderer*)prenderer, rects, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(SDLRenderer* renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				int ret = RenderDrawRectsFNative(renderer, (SDLFRect*)prects, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(ref SDLRenderer renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					int ret = RenderDrawRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderFillRectFNative(SDLRenderer* renderer, SDLFRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int>)funcTable[788])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[788])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(SDLRenderer* renderer, SDLFRect* rect)
		{
			int ret = RenderFillRectFNative(renderer, rect);
			return ret;
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(ref SDLRenderer renderer, SDLFRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderFillRectFNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(SDLRenderer* renderer, ref SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				int ret = RenderFillRectFNative(renderer, (SDLFRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(ref SDLRenderer renderer, ref SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					int ret = RenderFillRectFNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderFillRectsFNative(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int, int>)funcTable[789])(renderer, rects, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[789])((nint)renderer, (nint)rects, count);
			#endif
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			int ret = RenderFillRectsFNative(renderer, rects, count);
			return ret;
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(ref SDLRenderer renderer, SDLFRect* rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderFillRectsFNative((SDLRenderer*)prenderer, rects, count);
				return ret;
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(SDLRenderer* renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				int ret = RenderFillRectsFNative(renderer, (SDLFRect*)prects, count);
				return ret;
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(ref SDLRenderer renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					int ret = RenderFillRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderCopyFNative(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLRect*, SDLFRect*, int>)funcTable[790])(renderer, texture, srcrect, dstrect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[790])((nint)renderer, (nint)texture, (nint)srcrect, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect)
		{
			int ret = RenderCopyFNative(renderer, texture, srcrect, dstrect);
			return ret;
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderCopyFNative((SDLRenderer*)prenderer, texture, srcrect, dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderCopyFNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = RenderCopyFNative(renderer, texture, (SDLRect*)psrcrect, dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				int ret = RenderCopyFNative(renderer, texture, srcrect, (SDLFRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyFNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyFNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyFNative(renderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderCopyExFNative(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLRect*, SDLFRect*, double, SDLFPoint*, SDLRendererFlip, int>)funcTable[791])(renderer, texture, srcrect, dstrect, angle, center, flip);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, double, nint, SDLRendererFlip, int>)funcTable[791])((nint)renderer, (nint)texture, (nint)srcrect, (nint)dstrect, angle, (nint)center, flip);
			#endif
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			int ret = RenderCopyExFNative(renderer, texture, srcrect, dstrect, angle, center, flip);
			return ret;
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = RenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				int ret = RenderCopyExFNative(renderer, texture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLFPoint* pcenter = &center)
			{
				int ret = RenderCopyExFNative(renderer, texture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative(renderer, texture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexture* texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRenderer* renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							fixed (SDLFPoint* pcenter = &center)
							{
								int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderGeometryNative(SDLRenderer* renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLVertex*, int, int*, int, int>)funcTable[792])(renderer, texture, vertices, numVertices, indices, numIndices);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, int>)funcTable[792])((nint)renderer, (nint)texture, (nint)vertices, numVertices, (nint)indices, numIndices);
			#endif
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			int ret = RenderGeometryNative(renderer, texture, vertices, numVertices, indices, numIndices);
			return ret;
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, vertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, vertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, vertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				int ret = RenderGeometryNative(renderer, texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					int ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					int ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (int* pindices = &indices)
			{
				int ret = RenderGeometryNative(renderer, texture, vertices, numVertices, (int*)pindices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pindices = &indices)
				{
					int ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, vertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pindices = &indices)
				{
					int ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, vertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (int* pindices = &indices)
					{
						int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, vertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				fixed (int* pindices = &indices)
				{
					int ret = RenderGeometryNative(renderer, texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						int ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						int ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						fixed (int* pindices = &indices)
						{
							int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderGeometryRawNative(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, float*, int, SDLColor*, int, float*, int, int, void*, int, int, int>)funcTable[793])(renderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int, int, nint, int, int, int>)funcTable[793])((nint)renderer, (nint)texture, (nint)xy, xyStride, (nint)color, colorStride, (nint)uv, uvStride, numVertices, (nint)indices, numIndices, sizeIndices);
			#endif
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			int ret = RenderGeometryRawNative(renderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
			return ret;
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, float* xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, ref float xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				int ret = RenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, ref float xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, ref float xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, ref float xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				int ret = RenderGeometryRawNative(renderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, float* xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, float* xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* puv = &uv)
			{
				int ret = RenderGeometryRawNative(renderer, texture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, float* xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, ref float xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, ref float xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, ref float xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, ref float xy, int xyStride, SDLColor* color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative(renderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, float* xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, float* xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, ref float xy, int xyStride, ref SDLColor color, int colorStride, ref float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							fixed (float* puv = &uv)
							{
								int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderReadPixelsNative(SDLRenderer* renderer, SDLRect* rect, uint format, void* pixels, int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, uint, void*, int, int>)funcTable[794])(renderer, rect, format, pixels, pitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, int, int>)funcTable[794])((nint)renderer, (nint)rect, format, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(SDLRenderer* renderer, SDLRect* rect, uint format, void* pixels, int pitch)
		{
			int ret = RenderReadPixelsNative(renderer, rect, format, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(ref SDLRenderer renderer, SDLRect* rect, uint format, void* pixels, int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderReadPixelsNative((SDLRenderer*)prenderer, rect, format, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(SDLRenderer* renderer, ref SDLRect rect, uint format, void* pixels, int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = RenderReadPixelsNative(renderer, (SDLRect*)prect, format, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(ref SDLRenderer renderer, ref SDLRect rect, uint format, void* pixels, int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = RenderReadPixelsNative((SDLRenderer*)prenderer, (SDLRect*)prect, format, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the screen with any rendering performed since the previous call.<br/>
		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>
		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>
		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>
		/// complete picture.<br/>
		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
		/// for the frame, and then calls this function once per frame to present the<br/>
		/// final drawing to the user.<br/>
		/// The backbuffer should be considered invalidated after each present; do not<br/>
		/// assume that previous contents will exist between frames. You are strongly<br/>
		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
		/// starting each new frame's drawing, even if you plan to overwrite every<br/>
		/// pixel.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function on the main thread. If this<br/>
		/// happens to work on a background thread on any given platform<br/>
		/// or backend, it's purely by luck and you should not rely on it<br/>
		/// to work next time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderPresentNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, void>)funcTable[795])(renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[795])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Update the screen with any rendering performed since the previous call.<br/>
		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>
		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>
		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>
		/// complete picture.<br/>
		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
		/// for the frame, and then calls this function once per frame to present the<br/>
		/// final drawing to the user.<br/>
		/// The backbuffer should be considered invalidated after each present; do not<br/>
		/// assume that previous contents will exist between frames. You are strongly<br/>
		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
		/// starting each new frame's drawing, even if you plan to overwrite every<br/>
		/// pixel.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function on the main thread. If this<br/>
		/// happens to work on a background thread on any given platform<br/>
		/// or backend, it's purely by luck and you should not rely on it<br/>
		/// to work next time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RenderPresent(SDLRenderer* renderer)
		{
			RenderPresentNative(renderer);
		}

		/// <summary>
		/// Update the screen with any rendering performed since the previous call.<br/>
		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>
		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>
		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>
		/// complete picture.<br/>
		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
		/// for the frame, and then calls this function once per frame to present the<br/>
		/// final drawing to the user.<br/>
		/// The backbuffer should be considered invalidated after each present; do not<br/>
		/// assume that previous contents will exist between frames. You are strongly<br/>
		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
		/// starting each new frame's drawing, even if you plan to overwrite every<br/>
		/// pixel.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function on the main thread. If this<br/>
		/// happens to work on a background thread on any given platform<br/>
		/// or backend, it's purely by luck and you should not rely on it<br/>
		/// to work next time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RenderPresent(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				RenderPresentNative((SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Destroy the specified texture.<br/>
		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
		/// to "Invalid texture".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyTextureNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTexture*, void>)funcTable[796])(texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[796])((nint)texture);
			#endif
		}

		/// <summary>
		/// Destroy the specified texture.<br/>
		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
		/// to "Invalid texture".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyTexture(SDLTexture* texture)
		{
			DestroyTextureNative(texture);
		}

		/// <summary>
		/// Destroy the specified texture.<br/>
		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
		/// to "Invalid texture".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyTexture(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				DestroyTextureNative((SDLTexture*)ptexture);
			}
		}

		/// <summary>
		/// Destroy the rendering context for a window and free associated textures.<br/>
		/// If `renderer` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyRendererNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, void>)funcTable[797])(renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[797])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Destroy the rendering context for a window and free associated textures.<br/>
		/// If `renderer` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyRenderer(SDLRenderer* renderer)
		{
			DestroyRendererNative(renderer);
		}

		/// <summary>
		/// Destroy the rendering context for a window and free associated textures.<br/>
		/// If `renderer` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyRenderer(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				DestroyRendererNative((SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Force the rendering context to flush any pending commands to the underlying<br/>
		/// rendering API.<br/>
		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>
		/// addition to using an SDL_Renderer.<br/>
		/// This is for a very-specific case: if you are using SDL's render API, you<br/>
		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>
		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>
		/// calls in addition to SDL render API calls. If all of this applies, you<br/>
		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>
		/// low-level API you're using in cooperation.<br/>
		/// In all other cases, you can ignore this function. This is only here to get<br/>
		/// maximum performance out of a specific situation. In all other cases, SDL<br/>
		/// will do the right thing, perhaps at a performance loss.<br/>
		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>
		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>
		/// instead flushing them to the OS immediately.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderFlushNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int>)funcTable[798])(renderer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[798])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Force the rendering context to flush any pending commands to the underlying<br/>
		/// rendering API.<br/>
		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>
		/// addition to using an SDL_Renderer.<br/>
		/// This is for a very-specific case: if you are using SDL's render API, you<br/>
		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>
		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>
		/// calls in addition to SDL render API calls. If all of this applies, you<br/>
		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>
		/// low-level API you're using in cooperation.<br/>
		/// In all other cases, you can ignore this function. This is only here to get<br/>
		/// maximum performance out of a specific situation. In all other cases, SDL<br/>
		/// will do the right thing, perhaps at a performance loss.<br/>
		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>
		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>
		/// instead flushing them to the OS immediately.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFlush(SDLRenderer* renderer)
		{
			int ret = RenderFlushNative(renderer);
			return ret;
		}

		/// <summary>
		/// Force the rendering context to flush any pending commands to the underlying<br/>
		/// rendering API.<br/>
		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>
		/// addition to using an SDL_Renderer.<br/>
		/// This is for a very-specific case: if you are using SDL's render API, you<br/>
		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>
		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>
		/// calls in addition to SDL render API calls. If all of this applies, you<br/>
		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>
		/// low-level API you're using in cooperation.<br/>
		/// In all other cases, you can ignore this function. This is only here to get<br/>
		/// maximum performance out of a specific situation. In all other cases, SDL<br/>
		/// will do the right thing, perhaps at a performance loss.<br/>
		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>
		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>
		/// instead flushing them to the OS immediately.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFlush(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderFlushNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLBindTextureNative(SDLTexture* texture, float* texw, float* texh)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, float*, float*, int>)funcTable[799])(texture, texw, texh);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[799])((nint)texture, (nint)texw, (nint)texh);
			#endif
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexture* texture, float* texw, float* texh)
		{
			int ret = GLBindTextureNative(texture, texw, texh);
			return ret;
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, float* texw, float* texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GLBindTextureNative((SDLTexture*)ptexture, texw, texh);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexture* texture, ref float texw, float* texh)
		{
			fixed (float* ptexw = &texw)
			{
				int ret = GLBindTextureNative(texture, (float*)ptexw, texh);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, ref float texw, float* texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexw = &texw)
				{
					int ret = GLBindTextureNative((SDLTexture*)ptexture, (float*)ptexw, texh);
					return ret;
				}
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexture* texture, float* texw, ref float texh)
		{
			fixed (float* ptexh = &texh)
			{
				int ret = GLBindTextureNative(texture, texw, (float*)ptexh);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, float* texw, ref float texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexh = &texh)
				{
					int ret = GLBindTextureNative((SDLTexture*)ptexture, texw, (float*)ptexh);
					return ret;
				}
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexture* texture, ref float texw, ref float texh)
		{
			fixed (float* ptexw = &texw)
			{
				fixed (float* ptexh = &texh)
				{
					int ret = GLBindTextureNative(texture, (float*)ptexw, (float*)ptexh);
					return ret;
				}
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, ref float texw, ref float texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexw = &texw)
				{
					fixed (float* ptexh = &texh)
					{
						int ret = GLBindTextureNative((SDLTexture*)ptexture, (float*)ptexw, (float*)ptexh);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>
		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLUnbindTextureNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, int>)funcTable[800])(texture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[800])((nint)texture);
			#endif
		}

		/// <summary>
		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>
		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLUnbindTexture(SDLTexture* texture)
		{
			int ret = GLUnbindTextureNative(texture);
			return ret;
		}

		/// <summary>
		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>
		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLUnbindTexture(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GLUnbindTextureNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* RenderGetMetalLayerNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, void*>)funcTable[801])(renderer);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[801])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalLayer(SDLRenderer* renderer)
		{
			void* ret = RenderGetMetalLayerNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalLayer(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				void* ret = RenderGetMetalLayerNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the Metal command encoder for the current frame<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to an `id<br/>
		/// <MTLRenderCommandEncoder<br/>
		/// >`.<br/>
		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>
		/// SDL a drawable to render to, which might happen if the window is<br/>
		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>
		/// render targets, just the window's backbuffer. Check your return values!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* RenderGetMetalCommandEncoderNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, void*>)funcTable[802])(renderer);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[802])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the Metal command encoder for the current frame<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to an `id<br/>
		/// <MTLRenderCommandEncoder<br/>
		/// >`.<br/>
		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>
		/// SDL a drawable to render to, which might happen if the window is<br/>
		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>
		/// render targets, just the window's backbuffer. Check your return values!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalCommandEncoder(SDLRenderer* renderer)
		{
			void* ret = RenderGetMetalCommandEncoderNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the Metal command encoder for the current frame<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to an `id<br/>
		/// <MTLRenderCommandEncoder<br/>
		/// >`.<br/>
		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>
		/// SDL a drawable to render to, which might happen if the window is<br/>
		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>
		/// render targets, just the window's backbuffer. Check your return values!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalCommandEncoder(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				void* ret = RenderGetMetalCommandEncoderNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Toggle VSync of the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderSetVSyncNative(SDLRenderer* renderer, int vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int, int>)funcTable[803])(renderer, vsync);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[803])((nint)renderer, vsync);
			#endif
		}

		/// <summary>
		/// Toggle VSync of the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderSetVSync(SDLRenderer* renderer, int vsync)
		{
			int ret = RenderSetVSyncNative(renderer, vsync);
			return ret;
		}

		/// <summary>
		/// Toggle VSync of the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderSetVSync(ref SDLRenderer renderer, int vsync)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderSetVSyncNative((SDLRenderer*)prenderer, vsync);
				return ret;
			}
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* CreateShapedWindowNative(byte* title, uint x, uint y, uint w, uint h, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, uint, uint, uint, uint, SDLWindow*>)funcTable[804])(title, x, y, w, h, flags);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, uint, uint, nint>)funcTable[804])((nint)title, x, y, w, h, flags);
			#endif
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateShapedWindow(byte* title, uint x, uint y, uint w, uint h, uint flags)
		{
			SDLWindow* ret = CreateShapedWindowNative(title, x, y, w, h, flags);
			return ret;
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateShapedWindow(ref byte title, uint x, uint y, uint w, uint h, uint flags)
		{
			fixed (byte* ptitle = &title)
			{
				SDLWindow* ret = CreateShapedWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateShapedWindow(ReadOnlySpan<byte> title, uint x, uint y, uint w, uint h, uint flags)
		{
			fixed (byte* ptitle = title)
			{
				SDLWindow* ret = CreateShapedWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateShapedWindow(string title, uint x, uint y, uint w, uint h, uint flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLWindow* ret = CreateShapedWindowNative(pStr0, x, y, w, h, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Return whether the given window is a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsShapedWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[805])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[805])((nint)window);
			#endif
		}

		/// <summary>
		/// Return whether the given window is a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsShapedWindow(SDLWindow* window)
		{
			SDLBool ret = IsShapedWindowNative(window);
			return ret;
		}

		/// <summary>
		/// Return whether the given window is a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsShapedWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = IsShapedWindowNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowShapeNative(SDLWindow* window, SDLSurface* shape, SDLWindowShapeMode* shapeMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*, SDLWindowShapeMode*, int>)funcTable[806])(window, shape, shapeMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[806])((nint)window, (nint)shape, (nint)shapeMode);
			#endif
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindow* window, SDLSurface* shape, SDLWindowShapeMode* shapeMode)
		{
			int ret = SetWindowShapeNative(window, shape, shapeMode);
			return ret;
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, SDLSurface* shape, SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowShapeNative((SDLWindow*)pwindow, shape, shapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindow* window, ref SDLSurface shape, SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				int ret = SetWindowShapeNative(window, (SDLSurface*)pshape, shapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, ref SDLSurface shape, SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					int ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape, shapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindow* window, SDLSurface* shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
			{
				int ret = SetWindowShapeNative(window, shape, (SDLWindowShapeMode*)pshapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, SDLSurface* shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = SetWindowShapeNative((SDLWindow*)pwindow, shape, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindow* window, ref SDLSurface shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = SetWindowShapeNative(window, (SDLSurface*)pshape, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, ref SDLSurface shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
					{
						int ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape, (SDLWindowShapeMode*)pshapeMode);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetShapedWindowModeNative(SDLWindow* window, SDLWindowShapeMode* shapeMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLWindowShapeMode*, int>)funcTable[807])(window, shapeMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[807])((nint)window, (nint)shapeMode);
			#endif
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(SDLWindow* window, SDLWindowShapeMode* shapeMode)
		{
			int ret = GetShapedWindowModeNative(window, shapeMode);
			return ret;
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(ref SDLWindow window, SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetShapedWindowModeNative((SDLWindow*)pwindow, shapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(SDLWindow* window, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
			{
				int ret = GetShapedWindowModeNative(window, (SDLWindowShapeMode*)pshapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(ref SDLWindow window, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = GetShapedWindowModeNative((SDLWindow*)pwindow, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowsMessageHookNative(SDLWindowsMessageHook callback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, void*, uint, ulong, long, void>, void*, void>)funcTable[808])((delegate*<void*, void*, uint, ulong, long, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[808])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowsMessageHook(SDLWindowsMessageHook callback, void* userdata)
		{
			SetWindowsMessageHookNative(callback, userdata);
		}

		/// <summary>
		/// Get the D3D9 adapter index that matches the specified display index.<br/>
		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
		/// controls on which monitor a full screen application will appear.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Direct3D9GetAdapterIndexNative(int displayIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[809])(displayIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[809])(displayIndex);
			#endif
		}

		/// <summary>
		/// Get the D3D9 adapter index that matches the specified display index.<br/>
		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
		/// controls on which monitor a full screen application will appear.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Direct3D9GetAdapterIndex(int displayIndex)
		{
			int ret = Direct3D9GetAdapterIndexNative(displayIndex);
			return ret;
		}
	}
}
