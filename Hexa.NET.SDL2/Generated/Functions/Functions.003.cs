// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort ReadLE16(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = ReadLE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ReadBE16Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort>)funcTable[200])(src);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[200])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort ReadBE16(SDLRWops* src)
		{
			ushort ret = ReadBE16Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort ReadBE16(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = ReadBE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ReadLE32Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)funcTable[201])(src);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[201])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadLE32(SDLRWops* src)
		{
			uint ret = ReadLE32Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadLE32(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = ReadLE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ReadBE32Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)funcTable[202])(src);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[202])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadBE32(SDLRWops* src)
		{
			uint ret = ReadBE32Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadBE32(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = ReadBE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ReadLE64Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)funcTable[203])(src);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[203])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadLE64(SDLRWops* src)
		{
			ulong ret = ReadLE64Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadLE64(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = ReadLE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ReadBE64Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)funcTable[204])(src);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[204])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadBE64(SDLRWops* src)
		{
			ulong ret = ReadBE64Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadBE64(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = ReadBE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteU8Native(SDLRWops* dst, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, byte, nuint>)funcTable[205])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, byte, nuint>)funcTable[205])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteU8(SDLRWops* dst, byte value)
		{
			nuint ret = WriteU8Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteU8(ref SDLRWops dst, byte value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteU8Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteLE16Native(SDLRWops* dst, ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, nuint>)funcTable[206])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ushort, nuint>)funcTable[206])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE16(SDLRWops* dst, ushort value)
		{
			nuint ret = WriteLE16Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE16(ref SDLRWops dst, ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteLE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteBE16Native(SDLRWops* dst, ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, nuint>)funcTable[207])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ushort, nuint>)funcTable[207])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE16(SDLRWops* dst, ushort value)
		{
			nuint ret = WriteBE16Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE16(ref SDLRWops dst, ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteBE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteLE32Native(SDLRWops* dst, uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, nuint>)funcTable[208])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, uint, nuint>)funcTable[208])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE32(SDLRWops* dst, uint value)
		{
			nuint ret = WriteLE32Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE32(ref SDLRWops dst, uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteLE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteBE32Native(SDLRWops* dst, uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, nuint>)funcTable[209])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, uint, nuint>)funcTable[209])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE32(SDLRWops* dst, uint value)
		{
			nuint ret = WriteBE32Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE32(ref SDLRWops dst, uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteBE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteLE64Native(SDLRWops* dst, ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, nuint>)funcTable[210])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ulong, nuint>)funcTable[210])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE64(SDLRWops* dst, ulong value)
		{
			nuint ret = WriteLE64Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE64(ref SDLRWops dst, ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteLE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteBE64Native(SDLRWops* dst, ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, nuint>)funcTable[211])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ulong, nuint>)funcTable[211])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE64(SDLRWops* dst, ulong value)
		{
			nuint ret = WriteBE64Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE64(ref SDLRWops dst, ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteBE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumAudioDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[212])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[212])();
			#endif
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumAudioDrivers()
		{
			int ret = GetNumAudioDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioDriverNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[213])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[213])(index);
			#endif
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetAudioDriver(int index)
		{
			byte* ret = GetAudioDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetAudioDriverS(int index)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioInitNative(byte* driverName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[214])(driverName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[214])((nint)driverName);
			#endif
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(byte* driverName)
		{
			int ret = AudioInitNative(driverName);
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(ref byte driverName)
		{
			fixed (byte* pdriverName = &driverName)
			{
				int ret = AudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(ReadOnlySpan<byte> driverName)
		{
			fixed (byte* pdriverName = driverName)
			{
				int ret = AudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(string driverName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (driverName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(driverName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(driverName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AudioInitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AudioQuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[215])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[215])();
			#endif
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AudioQuit()
		{
			AudioQuitNative();
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCurrentAudioDriverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[216])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[216])();
			#endif
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetCurrentAudioDriver()
		{
			byte* ret = GetCurrentAudioDriverNative();
			return ret;
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetCurrentAudioDriverS()
		{
			string ret = Utils.DecodeStringUTF8(GetCurrentAudioDriverNative());
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OpenAudioNative(SDLAudioSpec* desired, SDLAudioSpec* obtained)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioSpec*, SDLAudioSpec*, int>)funcTable[217])(desired, obtained);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[217])((nint)desired, (nint)obtained);
			#endif
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(SDLAudioSpec* desired, SDLAudioSpec* obtained)
		{
			int ret = OpenAudioNative(desired, obtained);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(ref SDLAudioSpec desired, SDLAudioSpec* obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				int ret = OpenAudioNative((SDLAudioSpec*)pdesired, obtained);
				return ret;
			}
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(SDLAudioSpec* desired, ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				int ret = OpenAudioNative(desired, (SDLAudioSpec*)pobtained);
				return ret;
			}
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(ref SDLAudioSpec desired, ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					int ret = OpenAudioNative((SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumAudioDevicesNative(int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[218])(iscapture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[218])(iscapture);
			#endif
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumAudioDevices(int iscapture)
		{
			int ret = GetNumAudioDevicesNative(iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioDeviceNameNative(int index, int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte*>)funcTable[219])(index, iscapture);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, int, nint>)funcTable[219])(index, iscapture);
			#endif
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetAudioDeviceName(int index, int iscapture)
		{
			byte* ret = GetAudioDeviceNameNative(index, iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetAudioDeviceNameS(int index, int iscapture)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioDeviceNameNative(index, iscapture));
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAudioDeviceSpecNative(int index, int iscapture, SDLAudioSpec* spec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLAudioSpec*, int>)funcTable[220])(index, iscapture, spec);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, nint, int>)funcTable[220])(index, iscapture, (nint)spec);
			#endif
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetAudioDeviceSpec(int index, int iscapture, SDLAudioSpec* spec)
		{
			int ret = GetAudioDeviceSpecNative(index, iscapture, spec);
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetAudioDeviceSpec(int index, int iscapture, ref SDLAudioSpec spec)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = GetAudioDeviceSpecNative(index, iscapture, (SDLAudioSpec*)pspec);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDefaultAudioInfoNative(byte** name, SDLAudioSpec* spec, int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLAudioSpec*, int, int>)funcTable[221])(name, spec, iscapture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[221])((nint)name, (nint)spec, iscapture);
			#endif
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(byte** name, SDLAudioSpec* spec, int iscapture)
		{
			int ret = GetDefaultAudioInfoNative(name, spec, iscapture);
			return ret;
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(ref byte* name, SDLAudioSpec* spec, int iscapture)
		{
			fixed (byte** pname = &name)
			{
				int ret = GetDefaultAudioInfoNative((byte**)pname, spec, iscapture);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(byte** name, ref SDLAudioSpec spec, int iscapture)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = GetDefaultAudioInfoNative(name, (SDLAudioSpec*)pspec, iscapture);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(ref byte* name, ref SDLAudioSpec spec, int iscapture)
		{
			fixed (byte** pname = &name)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					int ret = GetDefaultAudioInfoNative((byte**)pname, (SDLAudioSpec*)pspec, iscapture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint OpenAudioDeviceNative(byte* device, int iscapture, SDLAudioSpec* desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, SDLAudioSpec*, SDLAudioSpec*, int, uint>)funcTable[222])(device, iscapture, desired, obtained, allowedChanges);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, uint>)funcTable[222])((nint)device, iscapture, (nint)desired, (nint)obtained, allowedChanges);
			#endif
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, SDLAudioSpec* desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			uint ret = OpenAudioDeviceNative(device, iscapture, desired, obtained, allowedChanges);
			return ret;
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ref byte device, int iscapture, SDLAudioSpec* desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, desired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, SDLAudioSpec* desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, desired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, SDLAudioSpec* desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = OpenAudioDeviceNative(pStr0, iscapture, desired, obtained, allowedChanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, ref SDLAudioSpec desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = OpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ref byte device, int iscapture, ref SDLAudioSpec desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, ref SDLAudioSpec desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, ref SDLAudioSpec desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = OpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, SDLAudioSpec* desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = OpenAudioDeviceNative(device, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ref byte device, int iscapture, SDLAudioSpec* desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, SDLAudioSpec* desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, SDLAudioSpec* desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = OpenAudioDeviceNative(pStr0, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, ref SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ref byte device, int iscapture, ref SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, ref SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, ref SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioStatus GetAudioStatusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStatus>)funcTable[223])();
			#else
			return (SDLAudioStatus)((delegate* unmanaged[Cdecl]<SDLAudioStatus>)funcTable[223])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioStatus GetAudioStatus()
		{
			SDLAudioStatus ret = GetAudioStatusNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioStatus GetAudioDeviceStatusNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLAudioStatus>)funcTable[224])(dev);
			#else
			return (SDLAudioStatus)((delegate* unmanaged[Cdecl]<uint, SDLAudioStatus>)funcTable[224])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioStatus GetAudioDeviceStatus(uint dev)
		{
			SDLAudioStatus ret = GetAudioDeviceStatusNative(dev);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PauseAudioNative(int pauseOn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[225])(pauseOn);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[225])(pauseOn);
			#endif
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void PauseAudio(int pauseOn)
		{
			PauseAudioNative(pauseOn);
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PauseAudioDeviceNative(uint dev, int pauseOn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[226])(dev, pauseOn);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[226])(dev, pauseOn);
			#endif
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void PauseAudioDevice(uint dev, int pauseOn)
		{
			PauseAudioDeviceNative(dev, pauseOn);
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioSpec* LoadWAVRWNative(SDLRWops* src, int freesrc, SDLAudioSpec* spec, byte** audioBuf, uint* audioLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, SDLAudioSpec*, byte**, uint*, SDLAudioSpec*>)funcTable[227])(src, freesrc, spec, audioBuf, audioLen);
			#else
			return (SDLAudioSpec*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, nint, nint>)funcTable[227])((nint)src, freesrc, (nint)spec, (nint)audioBuf, (nint)audioLen);
			#endif
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, SDLAudioSpec* spec, byte** audioBuf, uint* audioLen)
		{
			SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, spec, audioBuf, audioLen);
			return ret;
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpec* spec, byte** audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, SDLAudioSpec* spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, spec, (byte**)paudioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpec* spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, SDLAudioSpec* spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (uint* paudioLen = &audioLen)
			{
				SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, spec, audioBuf, (uint*)paudioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpec* spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, SDLAudioSpec* spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, spec, (byte**)paudioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpec* spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(SDLRWops* src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = LoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpec* LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							SDLAudioSpec* ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>
		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>
		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>
		/// this function with a NULL pointer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeWAVNative(byte* audioBuf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[228])(audioBuf);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[228])((nint)audioBuf);
			#endif
		}

		/// <summary>
		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>
		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>
		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>
		/// this function with a NULL pointer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeWAV(byte* audioBuf)
		{
			FreeWAVNative(audioBuf);
		}

		/// <summary>
		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>
		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>
		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>
		/// this function with a NULL pointer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeWAV(ref byte audioBuf)
		{
			fixed (byte* paudioBuf = &audioBuf)
			{
				FreeWAVNative((byte*)paudioBuf);
			}
		}

		/// <summary>
		/// Initialize an SDL_AudioCVT structure for conversion.<br/>
		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>
		/// be initialized with source and destination information.<br/>
		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>
		/// called before the application fills in the final buffer information.<br/>
		/// Once this function has returned successfully, and reported that a<br/>
		/// conversion is necessary, the application fills in the rest of the fields in<br/>
		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>
		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BuildAudioCVTNative(SDLAudioCVT* cvt, ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioCVT*, ushort, byte, int, ushort, byte, int, int>)funcTable[229])(cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, byte, int, ushort, byte, int, int>)funcTable[229])((nint)cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#endif
		}

		/// <summary>
		/// Initialize an SDL_AudioCVT structure for conversion.<br/>
		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>
		/// be initialized with source and destination information.<br/>
		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>
		/// called before the application fills in the final buffer information.<br/>
		/// Once this function has returned successfully, and reported that a<br/>
		/// conversion is necessary, the application fills in the rest of the fields in<br/>
		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>
		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int BuildAudioCVT(SDLAudioCVT* cvt, ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			int ret = BuildAudioCVTNative(cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			return ret;
		}

		/// <summary>
		/// Initialize an SDL_AudioCVT structure for conversion.<br/>
		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>
		/// be initialized with source and destination information.<br/>
		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>
		/// called before the application fills in the final buffer information.<br/>
		/// Once this function has returned successfully, and reported that a<br/>
		/// conversion is necessary, the application fills in the rest of the fields in<br/>
		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>
		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int BuildAudioCVT(ref SDLAudioCVT cvt, ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			fixed (SDLAudioCVT* pcvt = &cvt)
			{
				int ret = BuildAudioCVTNative((SDLAudioCVT*)pcvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
				return ret;
			}
		}

		/// <summary>
		/// Convert audio data to a desired audio format.<br/>
		/// This function does the actual audio data conversion, after the application<br/>
		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>
		/// then filled in the buffer details.<br/>
		/// Once the application has initialized the `cvt` structure using<br/>
		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>
		/// data in the source format, this function will convert the buffer, in-place,<br/>
		/// to the desired format.<br/>
		/// The data conversion may go through several passes; any given pass may<br/>
		/// possibly temporarily increase the size of the data. For example, SDL might<br/>
		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>
		/// shrinking the data size after having grown it briefly. Since the supplied<br/>
		/// buffer will be both the source and destination, converting as necessary<br/>
		/// in-place, the application must allocate a buffer that will fully contain<br/>
		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>
		/// returns, the application should set the `cvt->len` field to the size, in<br/>
		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>
		/// cvt->len_mult` bytes long for the `buf` field.<br/>
		/// The source data should be copied into this buffer before the call to<br/>
		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>
		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>
		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>
		/// this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ConvertAudioNative(SDLAudioCVT* cvt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioCVT*, int>)funcTable[230])(cvt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[230])((nint)cvt);
			#endif
		}

		/// <summary>
		/// Convert audio data to a desired audio format.<br/>
		/// This function does the actual audio data conversion, after the application<br/>
		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>
		/// then filled in the buffer details.<br/>
		/// Once the application has initialized the `cvt` structure using<br/>
		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>
		/// data in the source format, this function will convert the buffer, in-place,<br/>
		/// to the desired format.<br/>
		/// The data conversion may go through several passes; any given pass may<br/>
		/// possibly temporarily increase the size of the data. For example, SDL might<br/>
		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>
		/// shrinking the data size after having grown it briefly. Since the supplied<br/>
		/// buffer will be both the source and destination, converting as necessary<br/>
		/// in-place, the application must allocate a buffer that will fully contain<br/>
		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>
		/// returns, the application should set the `cvt->len` field to the size, in<br/>
		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>
		/// cvt->len_mult` bytes long for the `buf` field.<br/>
		/// The source data should be copied into this buffer before the call to<br/>
		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>
		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>
		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>
		/// this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ConvertAudio(SDLAudioCVT* cvt)
		{
			int ret = ConvertAudioNative(cvt);
			return ret;
		}

		/// <summary>
		/// Convert audio data to a desired audio format.<br/>
		/// This function does the actual audio data conversion, after the application<br/>
		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>
		/// then filled in the buffer details.<br/>
		/// Once the application has initialized the `cvt` structure using<br/>
		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>
		/// data in the source format, this function will convert the buffer, in-place,<br/>
		/// to the desired format.<br/>
		/// The data conversion may go through several passes; any given pass may<br/>
		/// possibly temporarily increase the size of the data. For example, SDL might<br/>
		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>
		/// shrinking the data size after having grown it briefly. Since the supplied<br/>
		/// buffer will be both the source and destination, converting as necessary<br/>
		/// in-place, the application must allocate a buffer that will fully contain<br/>
		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>
		/// returns, the application should set the `cvt->len` field to the size, in<br/>
		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>
		/// cvt->len_mult` bytes long for the `buf` field.<br/>
		/// The source data should be copied into this buffer before the call to<br/>
		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>
		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>
		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>
		/// this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ConvertAudio(ref SDLAudioCVT cvt)
		{
			fixed (SDLAudioCVT* pcvt = &cvt)
			{
				int ret = ConvertAudioNative((SDLAudioCVT*)pcvt);
				return ret;
			}
		}

		/// <summary>
		/// Create a new audio stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioStream* NewAudioStreamNative(ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, byte, int, ushort, byte, int, SDLAudioStream*>)funcTable[231])(srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#else
			return (SDLAudioStream*)((delegate* unmanaged[Cdecl]<ushort, byte, int, ushort, byte, int, nint>)funcTable[231])(srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#endif
		}

		/// <summary>
		/// Create a new audio stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioStream* NewAudioStream(ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			SDLAudioStream* ret = NewAudioStreamNative(srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			return ret;
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamPutNative(SDLAudioStream* stream, void* buf, int len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, void*, int, int>)funcTable[232])(stream, buf, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[232])((nint)stream, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamPut(SDLAudioStream* stream, void* buf, int len)
		{
			int ret = AudioStreamPutNative(stream, buf, len);
			return ret;
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamPut(ref SDLAudioStream stream, void* buf, int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamPutNative((SDLAudioStream*)pstream, buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamGetNative(SDLAudioStream* stream, void* buf, int len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, void*, int, int>)funcTable[233])(stream, buf, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[233])((nint)stream, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamGet(SDLAudioStream* stream, void* buf, int len)
		{
			int ret = AudioStreamGetNative(stream, buf, len);
			return ret;
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamGet(ref SDLAudioStream stream, void* buf, int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamGetNative((SDLAudioStream*)pstream, buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of converted/resampled bytes available.<br/>
		/// The stream may be buffering data behind the scenes until it has enough to<br/>
		/// resample correctly, so this number might be lower than what you expect, or<br/>
		/// even be zero. Add more data or flush the stream if you need the data now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamAvailableNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, int>)funcTable[234])(stream);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[234])((nint)stream);
			#endif
		}

		/// <summary>
		/// Get the number of converted/resampled bytes available.<br/>
		/// The stream may be buffering data behind the scenes until it has enough to<br/>
		/// resample correctly, so this number might be lower than what you expect, or<br/>
		/// even be zero. Add more data or flush the stream if you need the data now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamAvailable(SDLAudioStream* stream)
		{
			int ret = AudioStreamAvailableNative(stream);
			return ret;
		}

		/// <summary>
		/// Get the number of converted/resampled bytes available.<br/>
		/// The stream may be buffering data behind the scenes until it has enough to<br/>
		/// resample correctly, so this number might be lower than what you expect, or<br/>
		/// even be zero. Add more data or flush the stream if you need the data now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamAvailable(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamAvailableNative((SDLAudioStream*)pstream);
				return ret;
			}
		}

		/// <summary>
		/// Tell the stream that you're done sending data, and anything being buffered<br/>
		/// should be converted/resampled and made available immediately.<br/>
		/// It is legal to add more data to a stream after flushing, but there will be<br/>
		/// audio gaps in the output. Generally this is intended to signal the end of<br/>
		/// input, so the complete output becomes available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamFlushNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, int>)funcTable[235])(stream);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[235])((nint)stream);
			#endif
		}

		/// <summary>
		/// Tell the stream that you're done sending data, and anything being buffered<br/>
		/// should be converted/resampled and made available immediately.<br/>
		/// It is legal to add more data to a stream after flushing, but there will be<br/>
		/// audio gaps in the output. Generally this is intended to signal the end of<br/>
		/// input, so the complete output becomes available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamFlush(SDLAudioStream* stream)
		{
			int ret = AudioStreamFlushNative(stream);
			return ret;
		}

		/// <summary>
		/// Tell the stream that you're done sending data, and anything being buffered<br/>
		/// should be converted/resampled and made available immediately.<br/>
		/// It is legal to add more data to a stream after flushing, but there will be<br/>
		/// audio gaps in the output. Generally this is intended to signal the end of<br/>
		/// input, so the complete output becomes available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamFlush(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamFlushNative((SDLAudioStream*)pstream);
				return ret;
			}
		}

		/// <summary>
		/// Clear any pending data in the stream without converting it<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AudioStreamClearNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAudioStream*, void>)funcTable[236])(stream);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[236])((nint)stream);
			#endif
		}

		/// <summary>
		/// Clear any pending data in the stream without converting it<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AudioStreamClear(SDLAudioStream* stream)
		{
			AudioStreamClearNative(stream);
		}

		/// <summary>
		/// Clear any pending data in the stream without converting it<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AudioStreamClear(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				AudioStreamClearNative((SDLAudioStream*)pstream);
			}
		}

		/// <summary>
		/// Free an audio stream<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeAudioStreamNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAudioStream*, void>)funcTable[237])(stream);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[237])((nint)stream);
			#endif
		}

		/// <summary>
		/// Free an audio stream<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeAudioStream(SDLAudioStream* stream)
		{
			FreeAudioStreamNative(stream);
		}

		/// <summary>
		/// Free an audio stream<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeAudioStream(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				FreeAudioStreamNative((SDLAudioStream*)pstream);
			}
		}

		/// <summary>
		/// This function is a legacy means of mixing audio.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>
		/// ```<br/>
		/// ...where `format` is the obtained format of the audio device from the<br/>
		/// legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MixAudioNative(byte* dst, byte* src, uint len, int volume)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, uint, int, void>)funcTable[238])(dst, src, len, volume);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, int, void>)funcTable[238])((nint)dst, (nint)src, len, volume);
			#endif
		}
	}
}
