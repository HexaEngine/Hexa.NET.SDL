// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TLSSet(uint id, void* value, SDLTLSDestructorCallback destructor)
		{
			int ret = TLSSetNative(id, value, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(destructor));
			return ret;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TLSSet(uint id, nint value, SDLTLSDestructorCallback destructor)
		{
			int ret = TLSSetNative(id, (void*)value, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(destructor));
			return ret;
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TLSCleanupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[183])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[183])();
			#endif
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// <br/>
		/// </summary>
		public static void TLSCleanup()
		{
			TLSCleanupNative();
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWops* RWFromFileNative(byte* file, byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLRWops*>)funcTable[184])(file, mode);
			#else
			return (SDLRWops*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[184])((nint)file, (nint)mode);
			#endif
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(byte* file, byte* mode)
		{
			SDLRWopsPtr ret = RWFromFileNative(file, mode);
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(in byte file, byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLRWopsPtr ret = RWFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(ReadOnlySpan<byte> file, byte* mode)
		{
			fixed (byte* pfile = file)
			{
				SDLRWopsPtr ret = RWFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(string file, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRWopsPtr ret = RWFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(byte* file, in byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLRWopsPtr ret = RWFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(byte* file, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				SDLRWopsPtr ret = RWFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(byte* file, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRWopsPtr ret = RWFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(in byte file, in byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLRWopsPtr ret = RWFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(ReadOnlySpan<byte> file, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfile = file)
			{
				fixed (byte* pmode = mode)
				{
					SDLRWopsPtr ret = RWFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFile(string file, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLRWopsPtr ret = RWFromFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>
		/// pointer (stdio.h's `FILE*`).<br/>
		/// This function is not available on Windows, since files opened in an<br/>
		/// application on that platform cannot be used by a dynamically linked<br/>
		/// library.<br/>
		/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>
		/// `FILE*`, depending on what system headers are available to SDL. It is<br/>
		/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWops* RWFromFPNative(void* fp, SDLBool autoclose)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, SDLBool, SDLRWops*>)funcTable[185])(fp, autoclose);
			#else
			return (SDLRWops*)((delegate* unmanaged[Cdecl]<nint, SDLBool, nint>)funcTable[185])((nint)fp, autoclose);
			#endif
		}

		/// <summary>
		/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>
		/// pointer (stdio.h's `FILE*`).<br/>
		/// This function is not available on Windows, since files opened in an<br/>
		/// application on that platform cannot be used by a dynamically linked<br/>
		/// library.<br/>
		/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>
		/// `FILE*`, depending on what system headers are available to SDL. It is<br/>
		/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFP(void* fp, SDLBool autoclose)
		{
			SDLRWopsPtr ret = RWFromFPNative(fp, autoclose);
			return ret;
		}

		/// <summary>
		/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>
		/// pointer (stdio.h's `FILE*`).<br/>
		/// This function is not available on Windows, since files opened in an<br/>
		/// application on that platform cannot be used by a dynamically linked<br/>
		/// library.<br/>
		/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>
		/// `FILE*`, depending on what system headers are available to SDL. It is<br/>
		/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromFP(nint fp, SDLBool autoclose)
		{
			SDLRWopsPtr ret = RWFromFPNative((void*)fp, autoclose);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to make sure the RWops never writes to the memory buffer, you<br/>
		/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWops* RWFromMemNative(void* mem, int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, SDLRWops*>)funcTable[186])(mem, size);
			#else
			return (SDLRWops*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[186])((nint)mem, size);
			#endif
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to make sure the RWops never writes to the memory buffer, you<br/>
		/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromMem(void* mem, int size)
		{
			SDLRWopsPtr ret = RWFromMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to make sure the RWops never writes to the memory buffer, you<br/>
		/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromMem(nint mem, int size)
		{
			SDLRWopsPtr ret = RWFromMemNative((void*)mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this RWops stream will report an error without<br/>
		/// writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWops* RWFromConstMemNative(void* mem, int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, SDLRWops*>)funcTable[187])(mem, size);
			#else
			return (SDLRWops*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[187])((nint)mem, size);
			#endif
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this RWops stream will report an error without<br/>
		/// writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromConstMem(void* mem, int size)
		{
			SDLRWopsPtr ret = RWFromConstMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this RWops stream will report an error without<br/>
		/// writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr RWFromConstMem(nint mem, int size)
		{
			SDLRWopsPtr ret = RWFromConstMemNative((void*)mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>
		/// operating system and compiler, there may be a difference between the<br/>
		/// malloc() and free() your program uses and the versions SDL calls<br/>
		/// internally. Trying to mix the two can cause crashing such as segmentation<br/>
		/// faults. Since all SDL_RWops must free themselves when their **close**<br/>
		/// method is called, all SDL_RWops must be allocated through this function, so<br/>
		/// they can all be freed correctly with SDL_FreeRW().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWops* AllocRWNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*>)funcTable[188])();
			#else
			return (SDLRWops*)((delegate* unmanaged[Cdecl]<nint>)funcTable[188])();
			#endif
		}

		/// <summary>
		/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>
		/// operating system and compiler, there may be a difference between the<br/>
		/// malloc() and free() your program uses and the versions SDL calls<br/>
		/// internally. Trying to mix the two can cause crashing such as segmentation<br/>
		/// faults. Since all SDL_RWops must free themselves when their **close**<br/>
		/// method is called, all SDL_RWops must be allocated through this function, so<br/>
		/// they can all be freed correctly with SDL_FreeRW().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWopsPtr AllocRW()
		{
			SDLRWopsPtr ret = AllocRWNative();
			return ret;
		}

		/// <summary>
		/// Use this function to free an SDL_RWops structure allocated by<br/>
		/// SDL_AllocRW().<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>
		/// call the **close** method on those SDL_RWops pointers when you are done<br/>
		/// with them.<br/>
		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>
		/// invalid as soon as this function returns. Any extra memory allocated during<br/>
		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>
		/// be responsible for managing that memory in their **close** method.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeRWNative(SDLRWops* area)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWops*, void>)funcTable[189])(area);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[189])((nint)area);
			#endif
		}

		/// <summary>
		/// Use this function to free an SDL_RWops structure allocated by<br/>
		/// SDL_AllocRW().<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>
		/// call the **close** method on those SDL_RWops pointers when you are done<br/>
		/// with them.<br/>
		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>
		/// invalid as soon as this function returns. Any extra memory allocated during<br/>
		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>
		/// be responsible for managing that memory in their **close** method.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeRW(SDLRWopsPtr area)
		{
			FreeRWNative((SDLRWops*)area);
		}

		/// <summary>
		/// Use this function to free an SDL_RWops structure allocated by<br/>
		/// SDL_AllocRW().<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>
		/// call the **close** method on those SDL_RWops pointers when you are done<br/>
		/// with them.<br/>
		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>
		/// invalid as soon as this function returns. Any extra memory allocated during<br/>
		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>
		/// be responsible for managing that memory in their **close** method.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeRW(ref SDLRWops area)
		{
			fixed (SDLRWops* parea = &area)
			{
				FreeRWNative((SDLRWops*)parea);
			}
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long RWsizeNative(SDLRWops* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, long>)funcTable[190])(context);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[190])((nint)context);
			#endif
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long RWsize(SDLRWopsPtr context)
		{
			long ret = RWsizeNative((SDLRWops*)context);
			return ret;
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long RWsize(ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = RWsizeNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Seek within an SDL_RWops data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>
		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>
		/// - `RW_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>
		/// `seek` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long RWseekNative(SDLRWops* context, long offset, int whence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, long, int, long>)funcTable[191])(context, offset, whence);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long, int, long>)funcTable[191])((nint)context, offset, whence);
			#endif
		}

		/// <summary>
		/// Seek within an SDL_RWops data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>
		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>
		/// - `RW_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>
		/// `seek` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long RWseek(SDLRWopsPtr context, long offset, int whence)
		{
			long ret = RWseekNative((SDLRWops*)context, offset, whence);
			return ret;
		}

		/// <summary>
		/// Seek within an SDL_RWops data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>
		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>
		/// - `RW_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>
		/// `seek` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long RWseek(ref SDLRWops context, long offset, int whence)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = RWseekNative((SDLRWops*)pcontext, offset, whence);
				return ret;
			}
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>
		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>
		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>
		/// application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long RWtellNative(SDLRWops* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, long>)funcTable[192])(context);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[192])((nint)context);
			#endif
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>
		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>
		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>
		/// application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long RWtell(SDLRWopsPtr context)
		{
			long ret = RWtellNative((SDLRWops*)context);
			return ret;
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>
		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>
		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>
		/// application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long RWtell(ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = RWtellNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint RWreadNative(SDLRWops* context, void* ptr, nuint size, nuint maxnum)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, void*, nuint, nuint, nuint>)funcTable[193])(context, ptr, size, maxnum);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint, nuint>)funcTable[193])((nint)context, (nint)ptr, size, maxnum);
			#endif
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWread(SDLRWopsPtr context, void* ptr, nuint size, nuint maxnum)
		{
			nuint ret = RWreadNative((SDLRWops*)context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWread(ref SDLRWops context, void* ptr, nuint size, nuint maxnum)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				nuint ret = RWreadNative((SDLRWops*)pcontext, ptr, size, maxnum);
				return ret;
			}
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWread(SDLRWopsPtr context, nint ptr, nuint size, nuint maxnum)
		{
			nuint ret = RWreadNative((SDLRWops*)context, (void*)ptr, size, maxnum);
			return ret;
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWread(ref SDLRWops context, nint ptr, nuint size, nuint maxnum)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				nuint ret = RWreadNative((SDLRWops*)pcontext, (void*)ptr, size, maxnum);
				return ret;
			}
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint RWwriteNative(SDLRWops* context, void* ptr, nuint size, nuint num)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, void*, nuint, nuint, nuint>)funcTable[194])(context, ptr, size, num);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint, nuint>)funcTable[194])((nint)context, (nint)ptr, size, num);
			#endif
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWwrite(SDLRWopsPtr context, void* ptr, nuint size, nuint num)
		{
			nuint ret = RWwriteNative((SDLRWops*)context, ptr, size, num);
			return ret;
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWwrite(ref SDLRWops context, void* ptr, nuint size, nuint num)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				nuint ret = RWwriteNative((SDLRWops*)pcontext, ptr, size, num);
				return ret;
			}
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWwrite(SDLRWopsPtr context, nint ptr, nuint size, nuint num)
		{
			nuint ret = RWwriteNative((SDLRWops*)context, (void*)ptr, size, num);
			return ret;
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint RWwrite(ref SDLRWops context, nint ptr, nuint size, nuint num)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				nuint ret = RWwriteNative((SDLRWops*)pcontext, (void*)ptr, size, num);
				return ret;
			}
		}

		/// <summary>
		/// Close and free an allocated SDL_RWops structure.<br/>
		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_RWops itself with<br/>
		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>
		/// flush to its output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RWcloseNative(SDLRWops* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[195])(context);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[195])((nint)context);
			#endif
		}

		/// <summary>
		/// Close and free an allocated SDL_RWops structure.<br/>
		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_RWops itself with<br/>
		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>
		/// flush to its output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RWclose(SDLRWopsPtr context)
		{
			int ret = RWcloseNative((SDLRWops*)context);
			return ret;
		}

		/// <summary>
		/// Close and free an allocated SDL_RWops structure.<br/>
		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_RWops itself with<br/>
		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>
		/// flush to its output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RWclose(ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				int ret = RWcloseNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadFileRWNative(SDLRWops* src, nuint* datasize, int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, nuint*, int, void*>)funcTable[196])(src, datasize, freesrc);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)funcTable[196])((nint)src, (nint)datasize, freesrc);
			#endif
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFileRW(SDLRWopsPtr src, nuint* datasize, int freesrc)
		{
			void* ret = LoadFileRWNative((SDLRWops*)src, datasize, freesrc);
			return ret;
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFileRW(ref SDLRWops src, nuint* datasize, int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				void* ret = LoadFileRWNative((SDLRWops*)psrc, datasize, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFileRW(SDLRWopsPtr src, ref nuint datasize, int freesrc)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileRWNative((SDLRWops*)src, (nuint*)pdatasize, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFileRW(ref SDLRWops src, ref nuint datasize, int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileRWNative((SDLRWops*)psrc, (nuint*)pdatasize, freesrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadFileNative(byte* file, nuint* datasize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint*, void*>)funcTable[197])(file, datasize);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[197])((nint)file, (nint)datasize);
			#endif
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(byte* file, nuint* datasize)
		{
			void* ret = LoadFileNative(file, datasize);
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(in byte file, nuint* datasize)
		{
			fixed (byte* pfile = &file)
			{
				void* ret = LoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(ReadOnlySpan<byte> file, nuint* datasize)
		{
			fixed (byte* pfile = file)
			{
				void* ret = LoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(string file, nuint* datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = LoadFileNative(pStr0, datasize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(byte* file, ref nuint datasize)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileNative(file, (nuint*)pdatasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(in byte file, ref nuint datasize)
		{
			fixed (byte* pfile = &file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileNative((byte*)pfile, (nuint*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(ReadOnlySpan<byte> file, ref nuint datasize)
		{
			fixed (byte* pfile = file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileNative((byte*)pfile, (nuint*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFile(string file, ref nuint datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileNative(pStr0, (nuint*)pdatasize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadU8Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, byte>)funcTable[198])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[198])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte ReadU8(SDLRWopsPtr src)
		{
			byte ret = ReadU8Native((SDLRWops*)src);
			return ret;
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte ReadU8(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte ret = ReadU8Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ReadLE16Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort>)funcTable[199])(src);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[199])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort ReadLE16(SDLRWopsPtr src)
		{
			ushort ret = ReadLE16Native((SDLRWops*)src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort ReadLE16(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = ReadLE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ReadBE16Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort>)funcTable[200])(src);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[200])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort ReadBE16(SDLRWopsPtr src)
		{
			ushort ret = ReadBE16Native((SDLRWops*)src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort ReadBE16(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = ReadBE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ReadLE32Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)funcTable[201])(src);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[201])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadLE32(SDLRWopsPtr src)
		{
			uint ret = ReadLE32Native((SDLRWops*)src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadLE32(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = ReadLE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ReadBE32Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)funcTable[202])(src);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[202])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadBE32(SDLRWopsPtr src)
		{
			uint ret = ReadBE32Native((SDLRWops*)src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ReadBE32(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = ReadBE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ReadLE64Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)funcTable[203])(src);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[203])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadLE64(SDLRWopsPtr src)
		{
			ulong ret = ReadLE64Native((SDLRWops*)src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadLE64(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = ReadLE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ReadBE64Native(SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)funcTable[204])(src);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[204])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadBE64(SDLRWopsPtr src)
		{
			ulong ret = ReadBE64Native((SDLRWops*)src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong ReadBE64(ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = ReadBE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteU8Native(SDLRWops* dst, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, byte, nuint>)funcTable[205])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, byte, nuint>)funcTable[205])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteU8(SDLRWopsPtr dst, byte value)
		{
			nuint ret = WriteU8Native((SDLRWops*)dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteU8(ref SDLRWops dst, byte value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteU8Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteLE16Native(SDLRWops* dst, ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, nuint>)funcTable[206])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ushort, nuint>)funcTable[206])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE16(SDLRWopsPtr dst, ushort value)
		{
			nuint ret = WriteLE16Native((SDLRWops*)dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE16(ref SDLRWops dst, ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteLE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteBE16Native(SDLRWops* dst, ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, nuint>)funcTable[207])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ushort, nuint>)funcTable[207])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE16(SDLRWopsPtr dst, ushort value)
		{
			nuint ret = WriteBE16Native((SDLRWops*)dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE16(ref SDLRWops dst, ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteBE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteLE32Native(SDLRWops* dst, uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, nuint>)funcTable[208])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, uint, nuint>)funcTable[208])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE32(SDLRWopsPtr dst, uint value)
		{
			nuint ret = WriteLE32Native((SDLRWops*)dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE32(ref SDLRWops dst, uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteLE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteBE32Native(SDLRWops* dst, uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, nuint>)funcTable[209])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, uint, nuint>)funcTable[209])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE32(SDLRWopsPtr dst, uint value)
		{
			nuint ret = WriteBE32Native((SDLRWops*)dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE32(ref SDLRWops dst, uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteBE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteLE64Native(SDLRWops* dst, ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, nuint>)funcTable[210])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ulong, nuint>)funcTable[210])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE64(SDLRWopsPtr dst, ulong value)
		{
			nuint ret = WriteLE64Native((SDLRWops*)dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteLE64(ref SDLRWops dst, ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteLE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteBE64Native(SDLRWops* dst, ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, nuint>)funcTable[211])(dst, value);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, ulong, nuint>)funcTable[211])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE64(SDLRWopsPtr dst, ulong value)
		{
			nuint ret = WriteBE64Native((SDLRWops*)dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint WriteBE64(ref SDLRWops dst, ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = WriteBE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumAudioDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[212])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[212])();
			#endif
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumAudioDrivers()
		{
			int ret = GetNumAudioDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioDriverNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[213])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[213])(index);
			#endif
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetAudioDriver(int index)
		{
			byte* ret = GetAudioDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetAudioDriverS(int index)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioInitNative(byte* driverName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[214])(driverName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[214])((nint)driverName);
			#endif
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(byte* driverName)
		{
			int ret = AudioInitNative(driverName);
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(in byte driverName)
		{
			fixed (byte* pdriverName = &driverName)
			{
				int ret = AudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(ReadOnlySpan<byte> driverName)
		{
			fixed (byte* pdriverName = driverName)
			{
				int ret = AudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioInit(string driverName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (driverName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(driverName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(driverName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AudioInitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AudioQuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[215])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[215])();
			#endif
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AudioQuit()
		{
			AudioQuitNative();
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCurrentAudioDriverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[216])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[216])();
			#endif
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetCurrentAudioDriver()
		{
			byte* ret = GetCurrentAudioDriverNative();
			return ret;
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetCurrentAudioDriverS()
		{
			string ret = Utils.DecodeStringUTF8(GetCurrentAudioDriverNative());
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OpenAudioNative(SDLAudioSpec* desired, SDLAudioSpec* obtained)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioSpec*, SDLAudioSpec*, int>)funcTable[217])(desired, obtained);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[217])((nint)desired, (nint)obtained);
			#endif
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(SDLAudioSpecPtr desired, SDLAudioSpecPtr obtained)
		{
			int ret = OpenAudioNative((SDLAudioSpec*)desired, (SDLAudioSpec*)obtained);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(ref SDLAudioSpec desired, SDLAudioSpecPtr obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				int ret = OpenAudioNative((SDLAudioSpec*)pdesired, (SDLAudioSpec*)obtained);
				return ret;
			}
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(SDLAudioSpecPtr desired, ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				int ret = OpenAudioNative((SDLAudioSpec*)desired, (SDLAudioSpec*)pobtained);
				return ret;
			}
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenAudio(ref SDLAudioSpec desired, ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					int ret = OpenAudioNative((SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumAudioDevicesNative(int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[218])(iscapture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[218])(iscapture);
			#endif
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumAudioDevices(int iscapture)
		{
			int ret = GetNumAudioDevicesNative(iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioDeviceNameNative(int index, int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte*>)funcTable[219])(index, iscapture);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, int, nint>)funcTable[219])(index, iscapture);
			#endif
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetAudioDeviceName(int index, int iscapture)
		{
			byte* ret = GetAudioDeviceNameNative(index, iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetAudioDeviceNameS(int index, int iscapture)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioDeviceNameNative(index, iscapture));
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAudioDeviceSpecNative(int index, int iscapture, SDLAudioSpec* spec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLAudioSpec*, int>)funcTable[220])(index, iscapture, spec);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, nint, int>)funcTable[220])(index, iscapture, (nint)spec);
			#endif
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetAudioDeviceSpec(int index, int iscapture, SDLAudioSpecPtr spec)
		{
			int ret = GetAudioDeviceSpecNative(index, iscapture, (SDLAudioSpec*)spec);
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetAudioDeviceSpec(int index, int iscapture, ref SDLAudioSpec spec)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = GetAudioDeviceSpecNative(index, iscapture, (SDLAudioSpec*)pspec);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDefaultAudioInfoNative(byte** name, SDLAudioSpec* spec, int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLAudioSpec*, int, int>)funcTable[221])(name, spec, iscapture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[221])((nint)name, (nint)spec, iscapture);
			#endif
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(byte** name, SDLAudioSpecPtr spec, int iscapture)
		{
			int ret = GetDefaultAudioInfoNative(name, (SDLAudioSpec*)spec, iscapture);
			return ret;
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(ref byte* name, SDLAudioSpecPtr spec, int iscapture)
		{
			fixed (byte** pname = &name)
			{
				int ret = GetDefaultAudioInfoNative((byte**)pname, (SDLAudioSpec*)spec, iscapture);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(byte** name, ref SDLAudioSpec spec, int iscapture)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = GetDefaultAudioInfoNative(name, (SDLAudioSpec*)pspec, iscapture);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDefaultAudioInfo(ref byte* name, ref SDLAudioSpec spec, int iscapture)
		{
			fixed (byte** pname = &name)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					int ret = GetDefaultAudioInfoNative((byte**)pname, (SDLAudioSpec*)pspec, iscapture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint OpenAudioDeviceNative(byte* device, int iscapture, SDLAudioSpec* desired, SDLAudioSpec* obtained, int allowedChanges)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, SDLAudioSpec*, SDLAudioSpec*, int, uint>)funcTable[222])(device, iscapture, desired, obtained, allowedChanges);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, uint>)funcTable[222])((nint)device, iscapture, (nint)desired, (nint)obtained, allowedChanges);
			#endif
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, SDLAudioSpecPtr desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			uint ret = OpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)obtained, allowedChanges);
			return ret;
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(in byte device, int iscapture, SDLAudioSpecPtr desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, SDLAudioSpecPtr desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, SDLAudioSpecPtr desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = OpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)obtained, allowedChanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, in SDLAudioSpec desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = OpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(in byte device, int iscapture, in SDLAudioSpec desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, in SDLAudioSpec desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, in SDLAudioSpec desired, SDLAudioSpecPtr obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = OpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)obtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, SDLAudioSpecPtr desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = OpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)pobtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(in byte device, int iscapture, SDLAudioSpecPtr desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, SDLAudioSpecPtr desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, SDLAudioSpecPtr desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = OpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)desired, (SDLAudioSpec*)pobtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(byte* device, int iscapture, in SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(in byte device, int iscapture, in SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(ReadOnlySpan<byte> device, int iscapture, in SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = OpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 4096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint OpenAudioDevice(string device, int iscapture, in SDLAudioSpec desired, ref SDLAudioSpec obtained, int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = OpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioStatus GetAudioStatusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStatus>)funcTable[223])();
			#else
			return (SDLAudioStatus)((delegate* unmanaged[Cdecl]<SDLAudioStatus>)funcTable[223])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioStatus GetAudioStatus()
		{
			SDLAudioStatus ret = GetAudioStatusNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioStatus GetAudioDeviceStatusNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLAudioStatus>)funcTable[224])(dev);
			#else
			return (SDLAudioStatus)((delegate* unmanaged[Cdecl]<uint, SDLAudioStatus>)funcTable[224])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioStatus GetAudioDeviceStatus(uint dev)
		{
			SDLAudioStatus ret = GetAudioDeviceStatusNative(dev);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PauseAudioNative(int pauseOn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[225])(pauseOn);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[225])(pauseOn);
			#endif
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void PauseAudio(int pauseOn)
		{
			PauseAudioNative(pauseOn);
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PauseAudioDeviceNative(uint dev, int pauseOn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[226])(dev, pauseOn);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[226])(dev, pauseOn);
			#endif
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void PauseAudioDevice(uint dev, int pauseOn)
		{
			PauseAudioDeviceNative(dev, pauseOn);
		}
	}
}
