// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGlobalMouseState(ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = GetGlobalMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGlobalMouseState(int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = GetGlobalMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGlobalMouseState(ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = GetGlobalMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetRelativeMouseStateNative(int* x, int* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)funcTable[462])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[462])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(int* x, int* y)
		{
			uint ret = GetRelativeMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = GetRelativeMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = GetRelativeMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = GetRelativeMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarpMouseInWindowNative(SDLWindow* window, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[463])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[463])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WarpMouseInWindow(SDLWindow* window, int x, int y)
		{
			WarpMouseInWindowNative(window, x, y);
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WarpMouseInWindow(ref SDLWindow window, int x, int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				WarpMouseInWindowNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WarpMouseGlobalNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[464])(x, y);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[464])(x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int WarpMouseGlobal(int x, int y)
		{
			int ret = WarpMouseGlobalNative(x, y);
			return ret;
		}

		/// <summary>
		/// Set relative mouse mode.<br/>
		/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>
		/// position is constrained to the window, and SDL will report continuous<br/>
		/// relative mouse motion even if the mouse is at the edge of the window.<br/>
		/// This function will flush any pending mouse motion.<br/>
		/// <br/>
		/// If relative mode is not supported, this returns -1.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetRelativeMouseModeNative(SDLBool enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[465])(enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[465])(enabled);
			#endif
		}

		/// <summary>
		/// Set relative mouse mode.<br/>
		/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>
		/// position is constrained to the window, and SDL will report continuous<br/>
		/// relative mouse motion even if the mouse is at the edge of the window.<br/>
		/// This function will flush any pending mouse motion.<br/>
		/// <br/>
		/// If relative mode is not supported, this returns -1.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetRelativeMouseMode(SDLBool enabled)
		{
			int ret = SetRelativeMouseModeNative(enabled);
			return ret;
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>
		/// on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>
		/// mouse while the user is pressing a button; this is to try and make mouse<br/>
		/// behavior more consistent between platforms, and deal with the common case<br/>
		/// of a user dragging the mouse outside of the window. This means that if you<br/>
		/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>
		/// longer have to (although it is safe to do so). If this causes problems for<br/>
		/// your app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CaptureMouseNative(SDLBool enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[466])(enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[466])(enabled);
			#endif
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>
		/// on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>
		/// mouse while the user is pressing a button; this is to try and make mouse<br/>
		/// behavior more consistent between platforms, and deal with the common case<br/>
		/// of a user dragging the mouse outside of the window. This means that if you<br/>
		/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>
		/// longer have to (although it is safe to do so). If this causes problems for<br/>
		/// your app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CaptureMouse(SDLBool enabled)
		{
			int ret = CaptureMouseNative(enabled);
			return ret;
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetRelativeMouseModeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[467])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[467])();
			#endif
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetRelativeMouseMode()
		{
			SDLBool ret = GetRelativeMouseModeNative();
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateCursorNative(byte* data, byte* mask, int w, int h, int hotX, int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int, int, int, SDLCursor*>)funcTable[468])(data, mask, w, h, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int, nint>)funcTable[468])((nint)data, (nint)mask, w, h, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* CreateCursor(byte* data, byte* mask, int w, int h, int hotX, int hotY)
		{
			SDLCursor* ret = CreateCursorNative(data, mask, w, h, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* CreateCursor(ref byte data, byte* mask, int w, int h, int hotX, int hotY)
		{
			fixed (byte* pdata = &data)
			{
				SDLCursor* ret = CreateCursorNative((byte*)pdata, mask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* CreateCursor(byte* data, ref byte mask, int w, int h, int hotX, int hotY)
		{
			fixed (byte* pmask = &mask)
			{
				SDLCursor* ret = CreateCursorNative(data, (byte*)pmask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* CreateCursor(ref byte data, ref byte mask, int w, int h, int hotX, int hotY)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pmask = &mask)
				{
					SDLCursor* ret = CreateCursorNative((byte*)pdata, (byte*)pmask, w, h, hotX, hotY);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateColorCursorNative(SDLSurface* surface, int hotX, int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, SDLCursor*>)funcTable[469])(surface, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)funcTable[469])((nint)surface, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* CreateColorCursor(SDLSurface* surface, int hotX, int hotY)
		{
			SDLCursor* ret = CreateColorCursorNative(surface, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* CreateColorCursor(ref SDLSurface surface, int hotX, int hotY)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLCursor* ret = CreateColorCursorNative((SDLSurface*)psurface, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateSystemCursorNative(SDLSystemCursor id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSystemCursor, SDLCursor*>)funcTable[470])(id);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<SDLSystemCursor, nint>)funcTable[470])(id);
			#endif
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* CreateSystemCursor(SDLSystemCursor id)
		{
			SDLCursor* ret = CreateSystemCursorNative(id);
			return ret;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCursorNative(SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)funcTable[471])(cursor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[471])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetCursor(SDLCursor* cursor)
		{
			SetCursorNative(cursor);
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetCursor(ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				SetCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[472])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[472])();
			#endif
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* GetCursor()
		{
			SDLCursor* ret = GetCursorNative();
			return ret;
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetDefaultCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[473])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[473])();
			#endif
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursor* GetDefaultCursor()
		{
			SDLCursor* ret = GetDefaultCursorNative();
			return ret;
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeCursorNative(SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)funcTable[474])(cursor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[474])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeCursor(SDLCursor* cursor)
		{
			FreeCursorNative(cursor);
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeCursor(ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				FreeCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Toggle whether or not the cursor is shown.<br/>
		/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>
		/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>
		/// The current state of the mouse cursor can be queried by passing<br/>
		/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShowCursorNative(int toggle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[475])(toggle);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[475])(toggle);
			#endif
		}

		/// <summary>
		/// Toggle whether or not the cursor is shown.<br/>
		/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>
		/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>
		/// The current state of the mouse cursor can be queried by passing<br/>
		/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowCursor(int toggle)
		{
			int ret = ShowCursorNative(toggle);
			return ret;
		}

		/// <summary>
		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GUIDToStringNative(SdlGuid guid, byte* pszGUID, int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, byte*, int, void>)funcTable[476])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, int, void>)funcTable[476])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, byte* pszGUID, int cbGUID)
		{
			GUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, ref byte pszGUID, int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				GUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, ref string pszGUID, int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a ::SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GUIDFromStringNative(byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SdlGuid>)funcTable[477])(pchGUID);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[477])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a ::SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(byte* pchGUID)
		{
			SdlGuid ret = GUIDFromStringNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a ::SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdlGuid ret = GUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a ::SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				SdlGuid ret = GUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a ::SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdlGuid ret = GUIDFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Locking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>
		/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>
		/// uninitialized state. However, all open joysticks will be closed and SDL<br/>
		/// functions called with them will fail.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[478])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[478])();
			#endif
		}

		/// <summary>
		/// Locking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>
		/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>
		/// uninitialized state. However, all open joysticks will be closed and SDL<br/>
		/// functions called with them will fail.<br/>
		/// <br/>
		/// </summary>
		public static void LockJoysticks()
		{
			LockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[479])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[479])();
			#endif
		}

		/// <summary>
		/// Unlocking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		public static void UnlockJoysticks()
		{
			UnlockJoysticksNative();
		}

		/// <summary>
		/// Count the number of joysticks attached to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int NumJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[480])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[480])();
			#endif
		}

		/// <summary>
		/// Count the number of joysticks attached to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int NumJoysticks()
		{
			int ret = NumJoysticksNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickNameForIndexNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[481])(deviceIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[481])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickNameForIndex(int deviceIndex)
		{
			byte* ret = JoystickNameForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickNameForIndexS(int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(JoystickNameForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickPathForIndexNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[482])(deviceIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[482])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickPathForIndex(int deviceIndex)
		{
			byte* ret = JoystickPathForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickPathForIndexS(int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(JoystickPathForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick, or -1 if it's not available This can be<br/>
		/// called before any joysticks are opened.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetDevicePlayerIndexNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[483])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[483])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the player index of a joystick, or -1 if it's not available This can be<br/>
		/// called before any joysticks are opened.<br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetDevicePlayerIndex(int deviceIndex)
		{
			int ret = JoystickGetDevicePlayerIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick at a given device<br/>
		/// index.<br/>
		/// This function can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Guid JoystickGetDeviceGUIDNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, Guid>)funcTable[484])(deviceIndex);
			#else
			return (Guid)((delegate* unmanaged[Cdecl]<int, Guid>)funcTable[484])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick at a given device<br/>
		/// index.<br/>
		/// This function can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetDeviceGUID(int deviceIndex)
		{
			Guid ret = JoystickGetDeviceGUIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetDeviceVendorNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[485])(deviceIndex);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[485])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetDeviceVendor(int deviceIndex)
		{
			ushort ret = JoystickGetDeviceVendorNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetDeviceProductNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[486])(deviceIndex);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[486])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetDeviceProduct(int deviceIndex)
		{
			ushort ret = JoystickGetDeviceProductNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetDeviceProductVersionNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[487])(deviceIndex);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[487])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetDeviceProductVersion(int deviceIndex)
		{
			ushort ret = JoystickGetDeviceProductVersionNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType JoystickGetDeviceTypeNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[488])(deviceIndex);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[488])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType JoystickGetDeviceType(int deviceIndex)
		{
			SDLJoystickType ret = JoystickGetDeviceTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetDeviceInstanceIDNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[489])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[489])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetDeviceInstanceID(int deviceIndex)
		{
			int ret = JoystickGetDeviceInstanceIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The `device_index` argument refers to the N'th joystick presently<br/>
		/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>
		/// used to identify the joystick in future events. See<br/>
		/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* JoystickOpenNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[490])(deviceIndex);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[490])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The `device_index` argument refers to the N'th joystick presently<br/>
		/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>
		/// used to identify the joystick in future events. See<br/>
		/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* JoystickOpen(int deviceIndex)
		{
			SDLJoystick* ret = JoystickOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* JoystickFromInstanceIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[491])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[491])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* JoystickFromInstanceID(int instanceId)
		{
			SDLJoystick* ret = JoystickFromInstanceIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* JoystickFromPlayerIndexNative(int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[492])(playerIndex);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[492])(playerIndex);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* JoystickFromPlayerIndex(int playerIndex)
		{
			SDLJoystick* ret = JoystickFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickAttachVirtualNative(SDLJoystickType type, int naxes, int nbuttons, int nhats)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystickType, int, int, int, int>)funcTable[493])(type, naxes, nbuttons, nhats);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLJoystickType, int, int, int, int>)funcTable[493])(type, naxes, nbuttons, nhats);
			#endif
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickAttachVirtual(SDLJoystickType type, int naxes, int nbuttons, int nhats)
		{
			int ret = JoystickAttachVirtualNative(type, naxes, nbuttons, nhats);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickAttachVirtualExNative(SDLVirtualJoystickDesc* desc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLVirtualJoystickDesc*, int>)funcTable[494])(desc);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[494])((nint)desc);
			#endif
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickAttachVirtualEx(SDLVirtualJoystickDesc* desc)
		{
			int ret = JoystickAttachVirtualExNative(desc);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickAttachVirtualEx(ref SDLVirtualJoystickDesc desc)
		{
			fixed (SDLVirtualJoystickDesc* pdesc = &desc)
			{
				int ret = JoystickAttachVirtualExNative((SDLVirtualJoystickDesc*)pdesc);
				return ret;
			}
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickDetachVirtualNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[495])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[495])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickDetachVirtual(int deviceIndex)
		{
			int ret = JoystickDetachVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Query whether or not the joystick at a given device index is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickIsVirtualNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[496])(deviceIndex);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[496])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Query whether or not the joystick at a given device index is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickIsVirtual(int deviceIndex)
		{
			SDLBool ret = JoystickIsVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetVirtualAxisNative(SDLJoystick* joystick, int axis, short value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, int>)funcTable[497])(joystick, axis, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, short, int>)funcTable[497])((nint)joystick, axis, value);
			#endif
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualAxis(SDLJoystick* joystick, int axis, short value)
		{
			int ret = JoystickSetVirtualAxisNative(joystick, axis, value);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualAxis(ref SDLJoystick joystick, int axis, short value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetVirtualAxisNative((SDLJoystick*)pjoystick, axis, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetVirtualButtonNative(SDLJoystick* joystick, int button, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)funcTable[498])(joystick, button, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, byte, int>)funcTable[498])((nint)joystick, button, value);
			#endif
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualButton(SDLJoystick* joystick, int button, byte value)
		{
			int ret = JoystickSetVirtualButtonNative(joystick, button, value);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualButton(ref SDLJoystick joystick, int button, byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetVirtualButtonNative((SDLJoystick*)pjoystick, button, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetVirtualHatNative(SDLJoystick* joystick, int hat, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)funcTable[499])(joystick, hat, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, byte, int>)funcTable[499])((nint)joystick, hat, value);
			#endif
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualHat(SDLJoystick* joystick, int hat, byte value)
		{
			int ret = JoystickSetVirtualHatNative(joystick, hat, value);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualHat(ref SDLJoystick joystick, int hat, byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetVirtualHatNative((SDLJoystick*)pjoystick, hat, value);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickNameNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[500])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[500])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickName(SDLJoystick* joystick)
		{
			byte* ret = JoystickNameNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickNameS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(JoystickNameNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickName(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = JoystickNameNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickNameS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(JoystickNameNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickPathNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[501])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[501])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickPath(SDLJoystick* joystick)
		{
			byte* ret = JoystickPathNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickPathS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(JoystickPathNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickPath(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = JoystickPathNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickPathS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(JoystickPathNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetPlayerIndexNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[502])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[502])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetPlayerIndex(SDLJoystick* joystick)
		{
			int ret = JoystickGetPlayerIndexNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetPlayerIndex(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickGetPlayerIndexNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickSetPlayerIndexNative(SDLJoystick* joystick, int playerIndex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLJoystick*, int, void>)funcTable[503])(joystick, playerIndex);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[503])((nint)joystick, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickSetPlayerIndex(SDLJoystick* joystick, int playerIndex)
		{
			JoystickSetPlayerIndexNative(joystick, playerIndex);
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickSetPlayerIndex(ref SDLJoystick joystick, int playerIndex)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				JoystickSetPlayerIndexNative((SDLJoystick*)pjoystick, playerIndex);
			}
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Guid JoystickGetGUIDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, Guid>)funcTable[504])(joystick);
			#else
			return (Guid)((delegate* unmanaged[Cdecl]<nint, Guid>)funcTable[504])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUID(SDLJoystick* joystick)
		{
			Guid ret = JoystickGetGUIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUID(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				Guid ret = JoystickGetGUIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetVendorNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[505])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[505])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetVendor(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetVendorNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetVendor(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetVendorNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetProductNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[506])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[506])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProduct(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetProductNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProduct(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetProductNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetProductVersionNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[507])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[507])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProductVersion(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetProductVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProductVersion(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetProductVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetFirmwareVersionNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[508])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[508])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetFirmwareVersion(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetFirmwareVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetFirmwareVersion(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetFirmwareVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickGetSerialNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[509])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[509])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickGetSerial(SDLJoystick* joystick)
		{
			byte* ret = JoystickGetSerialNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickGetSerialS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(JoystickGetSerialNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickGetSerial(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = JoystickGetSerialNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickGetSerialS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(JoystickGetSerialNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType JoystickGetTypeNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickType>)funcTable[510])(joystick);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<nint, SDLJoystickType>)funcTable[510])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType JoystickGetType(SDLJoystick* joystick)
		{
			SDLJoystickType ret = JoystickGetTypeNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType JoystickGetType(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickType ret = JoystickGetTypeNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickGetGUIDStringNative(Guid guid, byte* pszGUID, int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Guid, byte*, int, void>)funcTable[511])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<Guid, nint, int, void>)funcTable[511])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickGetGUIDString(Guid guid, byte* pszGUID, int cbGUID)
		{
			JoystickGetGUIDStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickGetGUIDString(Guid guid, ref byte pszGUID, int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				JoystickGetGUIDStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickGetGUIDString(Guid guid, ref string pszGUID, int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			JoystickGetGUIDStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Guid JoystickGetGUIDFromStringNative(byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Guid>)funcTable[512])(pchGUID);
			#else
			return (Guid)((delegate* unmanaged[Cdecl]<nint, Guid>)funcTable[512])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(byte* pchGUID)
		{
			Guid ret = JoystickGetGUIDFromStringNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				Guid ret = JoystickGetGUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				Guid ret = JoystickGetGUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Guid ret = JoystickGetGUIDFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetJoystickGUIDInfoNative(Guid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Guid, ushort*, ushort*, ushort*, ushort*, void>)funcTable[513])(guid, vendor, product, version, crc16);
			#else
			((delegate* unmanaged[Cdecl]<Guid, nint, nint, nint, nint, void>)funcTable[513])(guid, (nint)vendor, (nint)product, (nint)version, (nint)crc16);
			#endif
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16)
		{
			GetJoystickGUIDInfoNative(guid, vendor, product, version, crc16);
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pversion = &version)
			{
				GetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, crc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pcrc16 = &crc16)
			{
				GetJoystickGUIDInfoNative(guid, vendor, product, version, (ushort*)pcrc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pversion = &version)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						fixed (ushort* pcrc16 = &crc16)
						{
							GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickGetAttachedNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[514])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[514])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAttached(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickGetAttachedNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAttached(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickGetAttachedNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickInstanceIDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[515])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[515])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickInstanceID(SDLJoystick* joystick)
		{
			int ret = JoystickInstanceIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickInstanceID(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickInstanceIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumAxesNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[516])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[516])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumAxes(SDLJoystick* joystick)
		{
			int ret = JoystickNumAxesNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumAxes(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumAxesNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumBallsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[517])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[517])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumBalls(SDLJoystick* joystick)
		{
			int ret = JoystickNumBallsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumBalls(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumBallsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumHatsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[518])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[518])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumHats(SDLJoystick* joystick)
		{
			int ret = JoystickNumHatsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumHats(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumHatsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumButtonsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[519])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[519])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumButtons(SDLJoystick* joystick)
		{
			int ret = JoystickNumButtonsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumButtons(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumButtonsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Update the current state of the open joysticks.<br/>
		/// This is called automatically by the event loop if any joystick events are<br/>
		/// enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickUpdateNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[520])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[520])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open joysticks.<br/>
		/// This is called automatically by the event loop if any joystick events are<br/>
		/// enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickUpdate()
		{
			JoystickUpdateNative();
		}

		/// <summary>
		/// Enable/disable joystick event polling.<br/>
		/// If joystick events are disabled, you must call SDL_JoystickUpdate()<br/>
		/// yourself and manually check the state of the joystick when you want<br/>
		/// joystick information.<br/>
		/// It is recommended that you leave joystick event handling enabled.<br/>
		/// **WARNING**: Calling this function may delete all events currently in SDL's<br/>
		/// event queue.<br/>
		/// While `param` is meant to be one of `SDL_QUERY`, `SDL_IGNORE`, or<br/>
		/// `SDL_ENABLE`, this function accepts any value, with any non-zero value that<br/>
		/// isn't `SDL_QUERY` being treated as `SDL_ENABLE`.<br/>
		/// If SDL was built with events disabled (extremely uncommon!), this will<br/>
		/// do nothing and always return `SDL_IGNORE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickEventStateNative(int state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[521])(state);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[521])(state);
			#endif
		}

		/// <summary>
		/// Enable/disable joystick event polling.<br/>
		/// If joystick events are disabled, you must call SDL_JoystickUpdate()<br/>
		/// yourself and manually check the state of the joystick when you want<br/>
		/// joystick information.<br/>
		/// It is recommended that you leave joystick event handling enabled.<br/>
		/// **WARNING**: Calling this function may delete all events currently in SDL's<br/>
		/// event queue.<br/>
		/// While `param` is meant to be one of `SDL_QUERY`, `SDL_IGNORE`, or<br/>
		/// `SDL_ENABLE`, this function accepts any value, with any non-zero value that<br/>
		/// isn't `SDL_QUERY` being treated as `SDL_ENABLE`.<br/>
		/// If SDL was built with events disabled (extremely uncommon!), this will<br/>
		/// do nothing and always return `SDL_IGNORE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickEventState(int state)
		{
			int ret = JoystickEventStateNative(state);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short JoystickGetAxisNative(SDLJoystick* joystick, int axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short>)funcTable[522])(joystick, axis);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)funcTable[522])((nint)joystick, axis);
			#endif
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short JoystickGetAxis(SDLJoystick* joystick, int axis)
		{
			short ret = JoystickGetAxisNative(joystick, axis);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short JoystickGetAxis(ref SDLJoystick joystick, int axis)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				short ret = JoystickGetAxisNative((SDLJoystick*)pjoystick, axis);
				return ret;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickGetAxisInitialStateNative(SDLJoystick* joystick, int axis, short* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short*, SDLBool>)funcTable[523])(joystick, axis, state);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, int, nint, SDLBool>)funcTable[523])((nint)joystick, axis, (nint)state);
			#endif
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(SDLJoystick* joystick, int axis, short* state)
		{
			SDLBool ret = JoystickGetAxisInitialStateNative(joystick, axis, state);
			return ret;
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(ref SDLJoystick joystick, int axis, short* state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickGetAxisInitialStateNative((SDLJoystick*)pjoystick, axis, state);
				return ret;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(SDLJoystick* joystick, int axis, ref short state)
		{
			fixed (short* pstate = &state)
			{
				SDLBool ret = JoystickGetAxisInitialStateNative(joystick, axis, (short*)pstate);
				return ret;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(ref SDLJoystick joystick, int axis, ref short state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (short* pstate = &state)
				{
					SDLBool ret = JoystickGetAxisInitialStateNative((SDLJoystick*)pjoystick, axis, (short*)pstate);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the following positions:<br/>
		/// - `SDL_HAT_CENTERED`<br/>
		/// - `SDL_HAT_UP`<br/>
		/// - `SDL_HAT_RIGHT`<br/>
		/// - `SDL_HAT_DOWN`<br/>
		/// - `SDL_HAT_LEFT`<br/>
		/// - `SDL_HAT_RIGHTUP`<br/>
		/// - `SDL_HAT_RIGHTDOWN`<br/>
		/// - `SDL_HAT_LEFTUP`<br/>
		/// - `SDL_HAT_LEFTDOWN`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JoystickGetHatNative(SDLJoystick* joystick, int hat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[524])(joystick, hat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[524])((nint)joystick, hat);
			#endif
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the following positions:<br/>
		/// - `SDL_HAT_CENTERED`<br/>
		/// - `SDL_HAT_UP`<br/>
		/// - `SDL_HAT_RIGHT`<br/>
		/// - `SDL_HAT_DOWN`<br/>
		/// - `SDL_HAT_LEFT`<br/>
		/// - `SDL_HAT_RIGHTUP`<br/>
		/// - `SDL_HAT_RIGHTDOWN`<br/>
		/// - `SDL_HAT_LEFTUP`<br/>
		/// - `SDL_HAT_LEFTDOWN`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetHat(SDLJoystick* joystick, int hat)
		{
			byte ret = JoystickGetHatNative(joystick, hat);
			return ret;
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the following positions:<br/>
		/// - `SDL_HAT_CENTERED`<br/>
		/// - `SDL_HAT_UP`<br/>
		/// - `SDL_HAT_RIGHT`<br/>
		/// - `SDL_HAT_DOWN`<br/>
		/// - `SDL_HAT_LEFT`<br/>
		/// - `SDL_HAT_RIGHTUP`<br/>
		/// - `SDL_HAT_RIGHTDOWN`<br/>
		/// - `SDL_HAT_LEFTUP`<br/>
		/// - `SDL_HAT_LEFTDOWN`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetHat(ref SDLJoystick joystick, int hat)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = JoystickGetHatNative((SDLJoystick*)pjoystick, hat);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetBallNative(SDLJoystick* joystick, int ball, int* dx, int* dy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, int*, int*, int>)funcTable[525])(joystick, ball, dx, dy);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int>)funcTable[525])((nint)joystick, ball, (nint)dx, (nint)dy);
			#endif
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, int* dx, int* dy)
		{
			int ret = JoystickGetBallNative(joystick, ball, dx, dy);
			return ret;
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, int* dx, int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, dx, dy);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, ref int dx, int* dy)
		{
			fixed (int* pdx = &dx)
			{
				int ret = JoystickGetBallNative(joystick, ball, (int*)pdx, dy);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, ref int dx, int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, dy);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, int* dx, ref int dy)
		{
			fixed (int* pdy = &dy)
			{
				int ret = JoystickGetBallNative(joystick, ball, dx, (int*)pdy);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, int* dx, ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdy = &dy)
				{
					int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, dx, (int*)pdy);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, ref int dx, ref int dy)
		{
			fixed (int* pdx = &dx)
			{
				fixed (int* pdy = &dy)
				{
					int ret = JoystickGetBallNative(joystick, ball, (int*)pdx, (int*)pdy);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, ref int dx, ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					fixed (int* pdy = &dy)
					{
						int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, (int*)pdy);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JoystickGetButtonNative(SDLJoystick* joystick, int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[526])(joystick, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[526])((nint)joystick, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetButton(SDLJoystick* joystick, int button)
		{
			byte ret = JoystickGetButtonNative(joystick, button);
			return ret;
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetButton(ref SDLJoystick joystick, int button)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = JoystickGetButtonNative((SDLJoystick*)pjoystick, button);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickRumbleNative(SDLJoystick* joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort, ushort, uint, int>)funcTable[527])(joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)funcTable[527])((nint)joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumble(SDLJoystick* joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			int ret = JoystickRumbleNative(joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumble(ref SDLJoystick joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickRumbleNative((SDLJoystick*)pjoystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickRumbleTriggersNative(SDLJoystick* joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort, ushort, uint, int>)funcTable[528])(joystick, leftRumble, rightRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)funcTable[528])((nint)joystick, leftRumble, rightRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumbleTriggers(SDLJoystick* joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			int ret = JoystickRumbleTriggersNative(joystick, leftRumble, rightRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumbleTriggers(ref SDLJoystick joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickRumbleTriggersNative((SDLJoystick*)pjoystick, leftRumble, rightRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has an LED.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickHasLEDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[529])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[529])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query whether a joystick has an LED.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasLED(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickHasLEDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Query whether a joystick has an LED.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasLED(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickHasLEDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickHasRumbleNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[530])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[530])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query whether a joystick has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumble(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickHasRumbleNative(joystick);
			return ret;
		}

		/// <summary>
		/// Query whether a joystick has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumble(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickHasRumbleNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickHasRumbleTriggersNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[531])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[531])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query whether a joystick has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumbleTriggers(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickHasRumbleTriggersNative(joystick);
			return ret;
		}

		/// <summary>
		/// Query whether a joystick has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumbleTriggers(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickHasRumbleTriggersNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetLEDNative(SDLJoystick* joystick, byte red, byte green, byte blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte, byte, byte, int>)funcTable[532])(joystick, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)funcTable[532])((nint)joystick, red, green, blue);
			#endif
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetLED(SDLJoystick* joystick, byte red, byte green, byte blue)
		{
			int ret = JoystickSetLEDNative(joystick, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetLED(ref SDLJoystick joystick, byte red, byte green, byte blue)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetLEDNative((SDLJoystick*)pjoystick, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSendEffectNative(SDLJoystick* joystick, void* data, int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, void*, int, int>)funcTable[533])(joystick, data, size);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[533])((nint)joystick, (nint)data, size);
			#endif
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSendEffect(SDLJoystick* joystick, void* data, int size)
		{
			int ret = JoystickSendEffectNative(joystick, data, size);
			return ret;
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSendEffect(ref SDLJoystick joystick, void* data, int size)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSendEffectNative((SDLJoystick*)pjoystick, data, size);
				return ret;
			}
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickCloseNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLJoystick*, void>)funcTable[534])(joystick);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[534])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickClose(SDLJoystick* joystick)
		{
			JoystickCloseNative(joystick);
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickClose(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				JoystickCloseNative((SDLJoystick*)pjoystick);
			}
		}

		/// <summary>
		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickPowerLevel JoystickCurrentPowerLevelNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickPowerLevel>)funcTable[535])(joystick);
			#else
			return (SDLJoystickPowerLevel)((delegate* unmanaged[Cdecl]<nint, SDLJoystickPowerLevel>)funcTable[535])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickPowerLevel JoystickCurrentPowerLevel(SDLJoystick* joystick)
		{
			SDLJoystickPowerLevel ret = JoystickCurrentPowerLevelNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickPowerLevel JoystickCurrentPowerLevel(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickPowerLevel ret = JoystickCurrentPowerLevelNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Locking for multi-threaded access to the sensor API<br/>
		/// If you are using the sensor API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the sensors.<br/>
		/// In particular, you are guaranteed that the sensor list won't change, so the<br/>
		/// API functions that take a sensor index will be valid, and sensor events<br/>
		/// will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[536])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[536])();
			#endif
		}

		/// <summary>
		/// Locking for multi-threaded access to the sensor API<br/>
		/// If you are using the sensor API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the sensors.<br/>
		/// In particular, you are guaranteed that the sensor list won't change, so the<br/>
		/// API functions that take a sensor index will be valid, and sensor events<br/>
		/// will not be delivered.<br/>
		/// <br/>
		/// </summary>
		public static void LockSensors()
		{
			LockSensorsNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[537])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[537])();
			#endif
		}

		public static void UnlockSensors()
		{
			UnlockSensorsNative();
		}

		/// <summary>
		/// Count the number of sensors attached to the system right now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int NumSensorsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[538])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[538])();
			#endif
		}

		/// <summary>
		/// Count the number of sensors attached to the system right now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int NumSensors()
		{
			int ret = NumSensorsNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* SensorGetDeviceNameNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[539])(deviceIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[539])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* SensorGetDeviceName(int deviceIndex)
		{
			byte* ret = SensorGetDeviceNameNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string SensorGetDeviceNameS(int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SensorGetDeviceNameNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType SensorGetDeviceTypeNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[540])(deviceIndex);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[540])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType SensorGetDeviceType(int deviceIndex)
		{
			SDLSensorType ret = SensorGetDeviceTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDeviceNonPortableTypeNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[541])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[541])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDeviceNonPortableType(int deviceIndex)
		{
			int ret = SensorGetDeviceNonPortableTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDeviceInstanceIDNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[542])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[542])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDeviceInstanceID(int deviceIndex)
		{
			int ret = SensorGetDeviceInstanceIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* SensorOpenNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[543])(deviceIndex);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[543])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensor* SensorOpen(int deviceIndex)
		{
			SDLSensor* ret = SensorOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* SensorFromInstanceIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[544])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[544])(instanceId);
			#endif
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensor* SensorFromInstanceID(int instanceId)
		{
			SDLSensor* ret = SensorFromInstanceIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* SensorGetNameNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, byte*>)funcTable[545])(sensor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[545])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* SensorGetName(SDLSensor* sensor)
		{
			byte* ret = SensorGetNameNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string SensorGetNameS(SDLSensor* sensor)
		{
			string ret = Utils.DecodeStringUTF8(SensorGetNameNative(sensor));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* SensorGetName(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte* ret = SensorGetNameNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string SensorGetNameS(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				string ret = Utils.DecodeStringUTF8(SensorGetNameNative((SDLSensor*)psensor));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType SensorGetTypeNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, SDLSensorType>)funcTable[546])(sensor);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<nint, SDLSensorType>)funcTable[546])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType SensorGetType(SDLSensor* sensor)
		{
			SDLSensorType ret = SensorGetTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType SensorGetType(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorType ret = SensorGetTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetNonPortableTypeNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[547])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[547])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetNonPortableType(SDLSensor* sensor)
		{
			int ret = SensorGetNonPortableTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetNonPortableType(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetNonPortableTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetInstanceIDNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[548])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[548])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetInstanceID(SDLSensor* sensor)
		{
			int ret = SensorGetInstanceIDNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetInstanceID(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetInstanceIDNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDataNative(SDLSensor* sensor, float* data, int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, float*, int, int>)funcTable[549])(sensor, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[549])((nint)sensor, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(SDLSensor* sensor, float* data, int numValues)
		{
			int ret = SensorGetDataNative(sensor, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(ref SDLSensor sensor, float* data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetDataNative((SDLSensor*)psensor, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(SDLSensor* sensor, ref float data, int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SensorGetDataNative(sensor, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(ref SDLSensor sensor, ref float data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					int ret = SensorGetDataNative((SDLSensor*)psensor, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDataWithTimestampNative(SDLSensor* sensor, ulong* timestamp, float* data, int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, ulong*, float*, int, int>)funcTable[550])(sensor, timestamp, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)funcTable[550])((nint)sensor, (nint)timestamp, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ulong* timestamp, float* data, int numValues)
		{
			int ret = SensorGetDataWithTimestampNative(sensor, timestamp, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ulong* timestamp, float* data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, timestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ref ulong timestamp, float* data, int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				int ret = SensorGetDataWithTimestampNative(sensor, (ulong*)ptimestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ref ulong timestamp, float* data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, (ulong*)ptimestamp, data, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ulong* timestamp, ref float data, int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SensorGetDataWithTimestampNative(sensor, timestamp, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ulong* timestamp, ref float data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, timestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ref ulong timestamp, ref float data, int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				fixed (float* pdata = &data)
				{
					int ret = SensorGetDataWithTimestampNative(sensor, (ulong*)ptimestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ref ulong timestamp, ref float data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					fixed (float* pdata = &data)
					{
						int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, (ulong*)ptimestamp, (float*)pdata, numValues);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_SensorOpen().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SensorCloseNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSensor*, void>)funcTable[551])(sensor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[551])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_SensorOpen().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SensorClose(SDLSensor* sensor)
		{
			SensorCloseNative(sensor);
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_SensorOpen().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SensorClose(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SensorCloseNative((SDLSensor*)psensor);
			}
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SensorUpdateNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[552])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[552])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		public static void SensorUpdate()
		{
			SensorUpdateNative();
		}

		/// <summary>
		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known controller GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerAddMappingsFromRWNative(SDLRWops* rw, int freerw)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, int>)funcTable[553])(rw, freerw);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[553])((nint)rw, freerw);
			#endif
		}

		/// <summary>
		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known controller GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMappingsFromRW(SDLRWops* rw, int freerw)
		{
			int ret = GameControllerAddMappingsFromRWNative(rw, freerw);
			return ret;
		}

		/// <summary>
		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known controller GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMappingsFromRW(ref SDLRWops rw, int freerw)
		{
			fixed (SDLRWops* prw = &rw)
			{
				int ret = GameControllerAddMappingsFromRWNative((SDLRWops*)prw, freerw);
				return ret;
			}
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerAddMappingNative(byte* mappingString)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[554])(mappingString);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[554])((nint)mappingString);
			#endif
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(byte* mappingString)
		{
			int ret = GameControllerAddMappingNative(mappingString);
			return ret;
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(ref byte mappingString)
		{
			fixed (byte* pmappingString = &mappingString)
			{
				int ret = GameControllerAddMappingNative((byte*)pmappingString);
				return ret;
			}
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(ReadOnlySpan<byte> mappingString)
		{
			fixed (byte* pmappingString = mappingString)
			{
				int ret = GameControllerAddMappingNative((byte*)pmappingString);
				return ret;
			}
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(string mappingString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mappingString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mappingString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mappingString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GameControllerAddMappingNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the number of mappings installed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerNumMappingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[555])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[555])();
			#endif
		}

		/// <summary>
		/// Get the number of mappings installed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerNumMappings()
		{
			int ret = GameControllerNumMappingsNative();
			return ret;
		}
	}
}
