// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, in ushort red, in ushort green, in ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						fixed (ushort* pblue = &blue)
						{
							int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowGammaRampNative(SDLWindow* window, ushort* red, ushort* green, ushort* blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, ushort*, ushort*, ushort*, int>)funcTable[417])(window, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[417])((nint)window, (nint)red, (nint)green, (nint)blue);
			#endif
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ushort* red, ushort* green, ushort* blue)
		{
			int ret = GetWindowGammaRampNative((SDLWindow*)window, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ref ushort red, ushort* green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				int ret = GetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ushort* red, ref ushort green, ushort* blue)
		{
			fixed (ushort* pgreen = &green)
			{
				int ret = GetWindowGammaRampNative((SDLWindow*)window, red, (ushort*)pgreen, blue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ref ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ref ushort red, ref ushort green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ref ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, blue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ushort* red, ushort* green, ref ushort blue)
		{
			fixed (ushort* pblue = &blue)
			{
				int ret = GetWindowGammaRampNative((SDLWindow*)window, red, green, (ushort*)pblue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ref ushort red, ushort* green, ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ushort* green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ushort* red, ref ushort green, ref ushort blue)
		{
			fixed (ushort* pgreen = &green)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)window, red, (ushort*)pgreen, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ref ushort green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindowPtr window, ref ushort red, ref ushort green, ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = GetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ref ushort green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						fixed (ushort* pblue = &blue)
						{
							int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowHitTestNative(SDLWindow* window, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, void* callbackData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>, void*, int>)funcTable[418])(window, callback, callbackData);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[418])((nint)window, (nint)callback, (nint)callbackData);
			#endif
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(SDLWindowPtr window, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, void* callbackData)
		{
			int ret = SetWindowHitTestNative((SDLWindow*)window, callback, callbackData);
			return ret;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(ref SDLWindow window, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowHitTestNative((SDLWindow*)pwindow, callback, callbackData);
				return ret;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(SDLWindowPtr window, SDLHitTest callback, void* callbackData)
		{
			int ret = SetWindowHitTestNative((SDLWindow*)window, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), callbackData);
			return ret;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(ref SDLWindow window, SDLHitTest callback, void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowHitTestNative((SDLWindow*)pwindow, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), callbackData);
				return ret;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(SDLWindowPtr window, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, nint callbackData)
		{
			int ret = SetWindowHitTestNative((SDLWindow*)window, callback, (void*)callbackData);
			return ret;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(ref SDLWindow window, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, nint callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowHitTestNative((SDLWindow*)pwindow, callback, (void*)callbackData);
				return ret;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(SDLWindowPtr window, SDLHitTest callback, nint callbackData)
		{
			int ret = SetWindowHitTestNative((SDLWindow*)window, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)callbackData);
			return ret;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(ref SDLWindow window, SDLHitTest callback, nint callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowHitTestNative((SDLWindow*)pwindow, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)callbackData);
				return ret;
			}
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FlashWindowNative(SDLWindow* window, SDLFlashOperation operation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLFlashOperation, int>)funcTable[419])(window, operation);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLFlashOperation, int>)funcTable[419])((nint)window, operation);
			#endif
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int FlashWindow(SDLWindowPtr window, SDLFlashOperation operation)
		{
			int ret = FlashWindowNative((SDLWindow*)window, operation);
			return ret;
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int FlashWindow(ref SDLWindow window, SDLFlashOperation operation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = FlashWindowNative((SDLWindow*)pwindow, operation);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[420])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[420])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyWindow(SDLWindowPtr window)
		{
			DestroyWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				DestroyWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsScreenSaverEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[421])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[421])();
			#endif
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsScreenSaverEnabled()
		{
			SDLBool ret = IsScreenSaverEnabledNative();
			return ret;
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[422])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[422])();
			#endif
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void EnableScreenSaver()
		{
			EnableScreenSaverNative();
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[423])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[423])();
			#endif
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DisableScreenSaver()
		{
			DisableScreenSaverNative();
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLLoadLibraryNative(byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[424])(path);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[424])((nint)path);
			#endif
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(byte* path)
		{
			int ret = GLLoadLibraryNative(path);
			return ret;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(in byte path)
		{
			fixed (byte* ppath = &path)
			{
				int ret = GLLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				int ret = GLLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GLLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GLGetProcAddressNative(byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*>)funcTable[425])(proc);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[425])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(byte* proc)
		{
			void* ret = GLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(in byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				void* ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				void* ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLUnloadLibraryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[426])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[426])();
			#endif
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLUnloadLibrary()
		{
			GLUnloadLibraryNative();
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GLExtensionSupportedNative(byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLBool>)funcTable[427])(extension);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[427])((nint)extension);
			#endif
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(byte* extension)
		{
			SDLBool ret = GLExtensionSupportedNative(extension);
			return ret;
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(in byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				SDLBool ret = GLExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				SDLBool ret = GLExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = GLExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLResetAttributesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[428])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[428])();
			#endif
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLResetAttributes()
		{
			GLResetAttributesNative();
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLSetAttributeNative(SDLGLattr attr, int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int, int>)funcTable[429])(attr, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLGLattr, int, int>)funcTable[429])(attr, value);
			#endif
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLSetAttribute(SDLGLattr attr, int value)
		{
			int ret = GLSetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLGetAttributeNative(SDLGLattr attr, int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int*, int>)funcTable[430])(attr, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLGLattr, nint, int>)funcTable[430])(attr, (nint)value);
			#endif
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLGetAttribute(SDLGLattr attr, int* value)
		{
			int ret = GLGetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLGetAttribute(SDLGLattr attr, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				int ret = GLGetAttributeNative(attr, (int*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GLCreateContextNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, void*>)funcTable[431])(window);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[431])((nint)window);
			#endif
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLCreateContext(SDLWindowPtr window)
		{
			void* ret = GLCreateContextNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLCreateContext(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = GLCreateContextNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLMakeCurrentNative(SDLWindow* window, void* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, void*, int>)funcTable[432])(window, context);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[432])((nint)window, (nint)context);
			#endif
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLMakeCurrent(SDLWindowPtr window, void* context)
		{
			int ret = GLMakeCurrentNative((SDLWindow*)window, context);
			return ret;
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLMakeCurrent(ref SDLWindow window, void* context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GLMakeCurrentNative((SDLWindow*)pwindow, context);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLMakeCurrent(SDLWindowPtr window, nint context)
		{
			int ret = GLMakeCurrentNative((SDLWindow*)window, (void*)context);
			return ret;
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLMakeCurrent(ref SDLWindow window, nint context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GLMakeCurrentNative((SDLWindow*)pwindow, (void*)context);
				return ret;
			}
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GLGetCurrentWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[433])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[433])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr GLGetCurrentWindow()
		{
			SDLWindowPtr ret = GLGetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GLGetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*>)funcTable[434])();
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint>)funcTable[434])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetCurrentContext()
		{
			void* ret = GLGetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLGetDrawableSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[435])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[435])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindowPtr window, int* w, int* h)
		{
			GLGetDrawableSizeNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GLGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindowPtr window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GLGetDrawableSizeNative((SDLWindow*)window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindowPtr window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GLGetDrawableSizeNative((SDLWindow*)window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GLGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindowPtr window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GLGetDrawableSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return -1. In such a case, you should probably<br/>
		/// retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLSetSwapIntervalNative(int interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[436])(interval);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[436])(interval);
			#endif
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return -1. In such a case, you should probably<br/>
		/// retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLSetSwapInterval(int interval)
		{
			int ret = GLSetSwapIntervalNative(interval);
			return ret;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will return 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLGetSwapIntervalNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[437])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[437])();
			#endif
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will return 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLGetSwapInterval()
		{
			int ret = GLGetSwapIntervalNative();
			return ret;
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLSwapWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[438])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[438])((nint)window);
			#endif
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLSwapWindow(SDLWindowPtr window)
		{
			GLSwapWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLSwapWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GLSwapWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLDeleteContextNative(void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[439])(context);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[439])((nint)context);
			#endif
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLDeleteContext(void* context)
		{
			GLDeleteContextNative(context);
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLDeleteContext(nint context)
		{
			GLDeleteContextNative((void*)context);
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetKeyboardFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[440])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[440])();
			#endif
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr GetKeyboardFocus()
		{
			SDLWindowPtr ret = GetKeyboardFocusNative();
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyboardStateNative(int* numkeys)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte*>)funcTable[441])(numkeys);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[441])((nint)numkeys);
			#endif
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetKeyboardState(int* numkeys)
		{
			byte* ret = GetKeyboardStateNative(numkeys);
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetKeyboardStateS(int* numkeys)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyboardStateNative(numkeys));
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetKeyboardState(ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				byte* ret = GetKeyboardStateNative((int*)pnumkeys);
				return ret;
			}
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetKeyboardStateS(ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				string ret = Utils.DecodeStringUTF8(GetKeyboardStateNative((int*)pnumkeys));
				return ret;
			}
		}

		/// <summary>
		/// Clear the state of the keyboard<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetKeyboardNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[442])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[442])();
			#endif
		}

		/// <summary>
		/// Clear the state of the keyboard<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ResetKeyboard()
		{
			ResetKeyboardNative();
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLKeymod GetModStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLKeymod>)funcTable[443])();
			#else
			return (SDLKeymod)((delegate* unmanaged[Cdecl]<SDLKeymod>)funcTable[443])();
			#endif
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLKeymod GetModState()
		{
			SDLKeymod ret = GetModStateNative();
			return ret;
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetModStateNative(SDLKeymod modstate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLKeymod, void>)funcTable[444])(modstate);
			#else
			((delegate* unmanaged[Cdecl]<SDLKeymod, void>)funcTable[444])(modstate);
			#endif
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetModState(SDLKeymod modstate)
		{
			SetModStateNative(modstate);
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromScancodeNative(SDLScancode scancode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, int>)funcTable[445])(scancode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLScancode, int>)funcTable[445])(scancode);
			#endif
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromScancode(SDLScancode scancode)
		{
			int ret = GetKeyFromScancodeNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Scancode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromKeyNative(int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLScancode>)funcTable[446])(key);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<int, SDLScancode>)funcTable[446])(key);
			#endif
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Scancode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromKey(int key)
		{
			SDLScancode ret = GetScancodeFromKeyNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetScancodeNameNative(SDLScancode scancode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, byte*>)funcTable[447])(scancode);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLScancode, nint>)funcTable[447])(scancode);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetScancodeName(SDLScancode scancode)
		{
			byte* ret = GetScancodeNameNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetScancodeNameS(SDLScancode scancode)
		{
			string ret = Utils.DecodeStringUTF8(GetScancodeNameNative(scancode));
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromNameNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLScancode>)funcTable[448])(name);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<nint, SDLScancode>)funcTable[448])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(byte* name)
		{
			SDLScancode ret = GetScancodeFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(in byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLScancode ret = GetScancodeFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyNameNative(int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[449])(key);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[449])(key);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetKeyName(int key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetKeyNameS(int key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromNameNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[450])(name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[450])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(byte* name)
		{
			int ret = GetKeyFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(in byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetKeyFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events.<br/>
		/// This function will start accepting Unicode text input events in the focused<br/>
		/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>
		/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>
		/// pair with SDL_StopTextInput().<br/>
		/// On some platforms using this function activates the screen keyboard.<br/>
		/// On desktop platforms, SDL_StartTextInput() is implicitly called on SDL<br/>
		/// video subsystem initialization which will cause SDL_TextInputEvent and<br/>
		/// SDL_TextEditingEvent to begin emitting.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StartTextInputNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[451])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[451])();
			#endif
		}

		/// <summary>
		/// Start accepting Unicode text input events.<br/>
		/// This function will start accepting Unicode text input events in the focused<br/>
		/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>
		/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>
		/// pair with SDL_StopTextInput().<br/>
		/// On some platforms using this function activates the screen keyboard.<br/>
		/// On desktop platforms, SDL_StartTextInput() is implicitly called on SDL<br/>
		/// video subsystem initialization which will cause SDL_TextInputEvent and<br/>
		/// SDL_TextEditingEvent to begin emitting.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void StartTextInput()
		{
			StartTextInputNative();
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsTextInputActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[452])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[452])();
			#endif
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsTextInputActive()
		{
			SDLBool ret = IsTextInputActiveNative();
			return ret;
		}

		/// <summary>
		/// Stop receiving any text input events.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StopTextInputNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[453])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[453])();
			#endif
		}

		/// <summary>
		/// Stop receiving any text input events.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void StopTextInput()
		{
			StopTextInputNative();
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearCompositionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[454])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[454])();
			#endif
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ClearComposition()
		{
			ClearCompositionNative();
		}

		/// <summary>
		/// Returns if an IME Composite or Candidate window is currently shown.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsTextInputShownNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[455])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[455])();
			#endif
		}

		/// <summary>
		/// Returns if an IME Composite or Candidate window is currently shown.<br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsTextInputShown()
		{
			SDLBool ret = IsTextInputShownNative();
			return ret;
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs.<br/>
		/// Native input methods will place a window with word suggestions near it,<br/>
		/// without covering the text being inputted.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextInputRectNative(SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRect*, void>)funcTable[456])(rect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[456])((nint)rect);
			#endif
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs.<br/>
		/// Native input methods will place a window with word suggestions near it,<br/>
		/// without covering the text being inputted.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetTextInputRect(SDLRectPtr rect)
		{
			SetTextInputRectNative((SDLRect*)rect);
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs.<br/>
		/// Native input methods will place a window with word suggestions near it,<br/>
		/// without covering the text being inputted.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetTextInputRect(in SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SetTextInputRectNative((SDLRect*)prect);
			}
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasScreenKeyboardSupportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[457])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[457])();
			#endif
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasScreenKeyboardSupport()
		{
			SDLBool ret = HasScreenKeyboardSupportNative();
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsScreenKeyboardShownNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[458])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[458])((nint)window);
			#endif
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsScreenKeyboardShown(SDLWindowPtr window)
		{
			SDLBool ret = IsScreenKeyboardShownNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsScreenKeyboardShown(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = IsScreenKeyboardShownNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetMouseFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[459])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[459])();
			#endif
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr GetMouseFocus()
		{
			SDLWindowPtr ret = GetMouseFocusNative();
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetMouseStateNative(int* x, int* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)funcTable[460])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[460])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(int* x, int* y)
		{
			uint ret = GetMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = GetMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = GetMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = GetMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGlobalMouseStateNative(int* x, int* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)funcTable[461])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[461])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGlobalMouseState(int* x, int* y)
		{
			uint ret = GetGlobalMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGlobalMouseState(ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = GetGlobalMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGlobalMouseState(int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = GetGlobalMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGlobalMouseState(ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = GetGlobalMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetRelativeMouseStateNative(int* x, int* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)funcTable[462])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[462])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(int* x, int* y)
		{
			uint ret = GetRelativeMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = GetRelativeMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = GetRelativeMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetRelativeMouseState(ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = GetRelativeMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarpMouseInWindowNative(SDLWindow* window, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[463])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[463])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WarpMouseInWindow(SDLWindowPtr window, int x, int y)
		{
			WarpMouseInWindowNative((SDLWindow*)window, x, y);
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WarpMouseInWindow(ref SDLWindow window, int x, int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				WarpMouseInWindowNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WarpMouseGlobalNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[464])(x, y);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[464])(x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int WarpMouseGlobal(int x, int y)
		{
			int ret = WarpMouseGlobalNative(x, y);
			return ret;
		}

		/// <summary>
		/// Set relative mouse mode.<br/>
		/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>
		/// position is constrained to the window, and SDL will report continuous<br/>
		/// relative mouse motion even if the mouse is at the edge of the window.<br/>
		/// This function will flush any pending mouse motion.<br/>
		/// <br/>
		/// If relative mode is not supported, this returns -1.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetRelativeMouseModeNative(SDLBool enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[465])(enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[465])(enabled);
			#endif
		}

		/// <summary>
		/// Set relative mouse mode.<br/>
		/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>
		/// position is constrained to the window, and SDL will report continuous<br/>
		/// relative mouse motion even if the mouse is at the edge of the window.<br/>
		/// This function will flush any pending mouse motion.<br/>
		/// <br/>
		/// If relative mode is not supported, this returns -1.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetRelativeMouseMode(SDLBool enabled)
		{
			int ret = SetRelativeMouseModeNative(enabled);
			return ret;
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>
		/// on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>
		/// mouse while the user is pressing a button; this is to try and make mouse<br/>
		/// behavior more consistent between platforms, and deal with the common case<br/>
		/// of a user dragging the mouse outside of the window. This means that if you<br/>
		/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>
		/// longer have to (although it is safe to do so). If this causes problems for<br/>
		/// your app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CaptureMouseNative(SDLBool enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[466])(enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLBool, int>)funcTable[466])(enabled);
			#endif
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>
		/// on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>
		/// mouse while the user is pressing a button; this is to try and make mouse<br/>
		/// behavior more consistent between platforms, and deal with the common case<br/>
		/// of a user dragging the mouse outside of the window. This means that if you<br/>
		/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>
		/// longer have to (although it is safe to do so). If this causes problems for<br/>
		/// your app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CaptureMouse(SDLBool enabled)
		{
			int ret = CaptureMouseNative(enabled);
			return ret;
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetRelativeMouseModeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[467])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[467])();
			#endif
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetRelativeMouseMode()
		{
			SDLBool ret = GetRelativeMouseModeNative();
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateCursorNative(byte* data, byte* mask, int w, int h, int hotX, int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int, int, int, SDLCursor*>)funcTable[468])(data, mask, w, h, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int, nint>)funcTable[468])((nint)data, (nint)mask, w, h, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr CreateCursor(byte* data, byte* mask, int w, int h, int hotX, int hotY)
		{
			SDLCursorPtr ret = CreateCursorNative(data, mask, w, h, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr CreateCursor(in byte data, byte* mask, int w, int h, int hotX, int hotY)
		{
			fixed (byte* pdata = &data)
			{
				SDLCursorPtr ret = CreateCursorNative((byte*)pdata, mask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr CreateCursor(byte* data, in byte mask, int w, int h, int hotX, int hotY)
		{
			fixed (byte* pmask = &mask)
			{
				SDLCursorPtr ret = CreateCursorNative(data, (byte*)pmask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr CreateCursor(in byte data, in byte mask, int w, int h, int hotX, int hotY)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pmask = &mask)
				{
					SDLCursorPtr ret = CreateCursorNative((byte*)pdata, (byte*)pmask, w, h, hotX, hotY);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateColorCursorNative(SDLSurface* surface, int hotX, int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, SDLCursor*>)funcTable[469])(surface, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)funcTable[469])((nint)surface, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr CreateColorCursor(SDLSurfacePtr surface, int hotX, int hotY)
		{
			SDLCursorPtr ret = CreateColorCursorNative((SDLSurface*)surface, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr CreateColorCursor(ref SDLSurface surface, int hotX, int hotY)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLCursorPtr ret = CreateColorCursorNative((SDLSurface*)psurface, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateSystemCursorNative(SDLSystemCursor id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSystemCursor, SDLCursor*>)funcTable[470])(id);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<SDLSystemCursor, nint>)funcTable[470])(id);
			#endif
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr CreateSystemCursor(SDLSystemCursor id)
		{
			SDLCursorPtr ret = CreateSystemCursorNative(id);
			return ret;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCursorNative(SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)funcTable[471])(cursor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[471])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetCursor(SDLCursorPtr cursor)
		{
			SetCursorNative((SDLCursor*)cursor);
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetCursor(ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				SetCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[472])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[472])();
			#endif
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr GetCursor()
		{
			SDLCursorPtr ret = GetCursorNative();
			return ret;
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetDefaultCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[473])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[473])();
			#endif
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCursorPtr GetDefaultCursor()
		{
			SDLCursorPtr ret = GetDefaultCursorNative();
			return ret;
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeCursorNative(SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)funcTable[474])(cursor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[474])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeCursor(SDLCursorPtr cursor)
		{
			FreeCursorNative((SDLCursor*)cursor);
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeCursor(ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				FreeCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Toggle whether or not the cursor is shown.<br/>
		/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>
		/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>
		/// The current state of the mouse cursor can be queried by passing<br/>
		/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShowCursorNative(int toggle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[475])(toggle);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[475])(toggle);
			#endif
		}

		/// <summary>
		/// Toggle whether or not the cursor is shown.<br/>
		/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>
		/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>
		/// The current state of the mouse cursor can be queried by passing<br/>
		/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowCursor(int toggle)
		{
			int ret = ShowCursorNative(toggle);
			return ret;
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GUIDToStringNative(SdlGuid guid, byte* pszGUID, int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, byte*, int, void>)funcTable[476])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, int, void>)funcTable[476])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, byte* pszGUID, int cbGUID)
		{
			GUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, ref byte pszGUID, int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				GUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, ref string pszGUID, int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GUIDFromStringNative(byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SdlGuid>)funcTable[477])(pchGUID);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[477])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(byte* pchGUID)
		{
			SdlGuid ret = GUIDFromStringNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(in byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdlGuid ret = GUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				SdlGuid ret = GUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GUIDFromString(string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdlGuid ret = GUIDFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Locking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>
		/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>
		/// uninitialized state. However, all open joysticks will be closed and SDL<br/>
		/// functions called with them will fail.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[478])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[478])();
			#endif
		}

		/// <summary>
		/// Locking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>
		/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>
		/// uninitialized state. However, all open joysticks will be closed and SDL<br/>
		/// functions called with them will fail.<br/>
		/// <br/>
		/// </summary>
		public static void LockJoysticks()
		{
			LockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[479])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[479])();
			#endif
		}

		/// <summary>
		/// Unlocking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		public static void UnlockJoysticks()
		{
			UnlockJoysticksNative();
		}

		/// <summary>
		/// Count the number of joysticks attached to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int NumJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[480])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[480])();
			#endif
		}

		/// <summary>
		/// Count the number of joysticks attached to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int NumJoysticks()
		{
			int ret = NumJoysticksNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickNameForIndexNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[481])(deviceIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[481])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickNameForIndex(int deviceIndex)
		{
			byte* ret = JoystickNameForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickNameForIndexS(int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(JoystickNameForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickPathForIndexNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[482])(deviceIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[482])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickPathForIndex(int deviceIndex)
		{
			byte* ret = JoystickPathForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickPathForIndexS(int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(JoystickPathForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick, or -1 if it's not available This can be<br/>
		/// called before any joysticks are opened.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetDevicePlayerIndexNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[483])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[483])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the player index of a joystick, or -1 if it's not available This can be<br/>
		/// called before any joysticks are opened.<br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetDevicePlayerIndex(int deviceIndex)
		{
			int ret = JoystickGetDevicePlayerIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick at a given device<br/>
		/// index.<br/>
		/// This function can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Guid JoystickGetDeviceGUIDNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, Guid>)funcTable[484])(deviceIndex);
			#else
			return (Guid)((delegate* unmanaged[Cdecl]<int, Guid>)funcTable[484])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick at a given device<br/>
		/// index.<br/>
		/// This function can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetDeviceGUID(int deviceIndex)
		{
			Guid ret = JoystickGetDeviceGUIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetDeviceVendorNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[485])(deviceIndex);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[485])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetDeviceVendor(int deviceIndex)
		{
			ushort ret = JoystickGetDeviceVendorNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetDeviceProductNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[486])(deviceIndex);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[486])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetDeviceProduct(int deviceIndex)
		{
			ushort ret = JoystickGetDeviceProductNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetDeviceProductVersionNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[487])(deviceIndex);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[487])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetDeviceProductVersion(int deviceIndex)
		{
			ushort ret = JoystickGetDeviceProductVersionNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType JoystickGetDeviceTypeNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[488])(deviceIndex);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[488])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType JoystickGetDeviceType(int deviceIndex)
		{
			SDLJoystickType ret = JoystickGetDeviceTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetDeviceInstanceIDNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[489])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[489])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetDeviceInstanceID(int deviceIndex)
		{
			int ret = JoystickGetDeviceInstanceIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The `device_index` argument refers to the N'th joystick presently<br/>
		/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>
		/// used to identify the joystick in future events. See<br/>
		/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* JoystickOpenNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[490])(deviceIndex);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[490])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The `device_index` argument refers to the N'th joystick presently<br/>
		/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>
		/// used to identify the joystick in future events. See<br/>
		/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* JoystickOpen(int deviceIndex)
		{
			SDLJoystick* ret = JoystickOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* JoystickFromInstanceIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[491])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[491])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* JoystickFromInstanceID(int instanceId)
		{
			SDLJoystick* ret = JoystickFromInstanceIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* JoystickFromPlayerIndexNative(int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[492])(playerIndex);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[492])(playerIndex);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* JoystickFromPlayerIndex(int playerIndex)
		{
			SDLJoystick* ret = JoystickFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickAttachVirtualNative(SDLJoystickType type, int naxes, int nbuttons, int nhats)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystickType, int, int, int, int>)funcTable[493])(type, naxes, nbuttons, nhats);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLJoystickType, int, int, int, int>)funcTable[493])(type, naxes, nbuttons, nhats);
			#endif
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickAttachVirtual(SDLJoystickType type, int naxes, int nbuttons, int nhats)
		{
			int ret = JoystickAttachVirtualNative(type, naxes, nbuttons, nhats);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickAttachVirtualExNative(SDLVirtualJoystickDesc* desc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLVirtualJoystickDesc*, int>)funcTable[494])(desc);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[494])((nint)desc);
			#endif
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickAttachVirtualEx(SDLVirtualJoystickDescPtr desc)
		{
			int ret = JoystickAttachVirtualExNative((SDLVirtualJoystickDesc*)desc);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickAttachVirtualEx(in SDLVirtualJoystickDesc desc)
		{
			fixed (SDLVirtualJoystickDesc* pdesc = &desc)
			{
				int ret = JoystickAttachVirtualExNative((SDLVirtualJoystickDesc*)pdesc);
				return ret;
			}
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickDetachVirtualNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[495])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[495])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickDetachVirtual(int deviceIndex)
		{
			int ret = JoystickDetachVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Query whether or not the joystick at a given device index is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickIsVirtualNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[496])(deviceIndex);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[496])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Query whether or not the joystick at a given device index is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickIsVirtual(int deviceIndex)
		{
			SDLBool ret = JoystickIsVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetVirtualAxisNative(SDLJoystick* joystick, int axis, short value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, int>)funcTable[497])(joystick, axis, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, short, int>)funcTable[497])((nint)joystick, axis, value);
			#endif
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualAxis(SDLJoystick* joystick, int axis, short value)
		{
			int ret = JoystickSetVirtualAxisNative(joystick, axis, value);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualAxis(ref SDLJoystick joystick, int axis, short value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetVirtualAxisNative((SDLJoystick*)pjoystick, axis, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetVirtualButtonNative(SDLJoystick* joystick, int button, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)funcTable[498])(joystick, button, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, byte, int>)funcTable[498])((nint)joystick, button, value);
			#endif
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualButton(SDLJoystick* joystick, int button, byte value)
		{
			int ret = JoystickSetVirtualButtonNative(joystick, button, value);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualButton(ref SDLJoystick joystick, int button, byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetVirtualButtonNative((SDLJoystick*)pjoystick, button, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetVirtualHatNative(SDLJoystick* joystick, int hat, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)funcTable[499])(joystick, hat, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, byte, int>)funcTable[499])((nint)joystick, hat, value);
			#endif
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualHat(SDLJoystick* joystick, int hat, byte value)
		{
			int ret = JoystickSetVirtualHatNative(joystick, hat, value);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetVirtualHat(ref SDLJoystick joystick, int hat, byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetVirtualHatNative((SDLJoystick*)pjoystick, hat, value);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickNameNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[500])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[500])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickName(SDLJoystick* joystick)
		{
			byte* ret = JoystickNameNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickNameS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(JoystickNameNative(joystick));
			return ret;
		}
	}
}
