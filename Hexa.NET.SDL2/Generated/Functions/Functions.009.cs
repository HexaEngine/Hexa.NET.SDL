// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickName(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = JoystickNameNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickNameS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(JoystickNameNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickPathNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[501])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[501])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickPath(SDLJoystick* joystick)
		{
			byte* ret = JoystickPathNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickPathS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(JoystickPathNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickPath(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = JoystickPathNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickPathS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(JoystickPathNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetPlayerIndexNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[502])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[502])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetPlayerIndex(SDLJoystick* joystick)
		{
			int ret = JoystickGetPlayerIndexNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetPlayerIndex(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickGetPlayerIndexNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickSetPlayerIndexNative(SDLJoystick* joystick, int playerIndex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLJoystick*, int, void>)funcTable[503])(joystick, playerIndex);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[503])((nint)joystick, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickSetPlayerIndex(SDLJoystick* joystick, int playerIndex)
		{
			JoystickSetPlayerIndexNative(joystick, playerIndex);
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickSetPlayerIndex(ref SDLJoystick joystick, int playerIndex)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				JoystickSetPlayerIndexNative((SDLJoystick*)pjoystick, playerIndex);
			}
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Guid JoystickGetGUIDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, Guid>)funcTable[504])(joystick);
			#else
			return (Guid)((delegate* unmanaged[Cdecl]<nint, Guid>)funcTable[504])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUID(SDLJoystick* joystick)
		{
			Guid ret = JoystickGetGUIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUID(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				Guid ret = JoystickGetGUIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetVendorNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[505])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[505])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetVendor(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetVendorNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetVendor(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetVendorNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetProductNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[506])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[506])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProduct(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetProductNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProduct(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetProductNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetProductVersionNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[507])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[507])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProductVersion(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetProductVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetProductVersion(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetProductVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort JoystickGetFirmwareVersionNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[508])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[508])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetFirmwareVersion(SDLJoystick* joystick)
		{
			ushort ret = JoystickGetFirmwareVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort JoystickGetFirmwareVersion(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = JoystickGetFirmwareVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* JoystickGetSerialNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[509])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[509])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickGetSerial(SDLJoystick* joystick)
		{
			byte* ret = JoystickGetSerialNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickGetSerialS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(JoystickGetSerialNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* JoystickGetSerial(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = JoystickGetSerialNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string JoystickGetSerialS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(JoystickGetSerialNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType JoystickGetTypeNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickType>)funcTable[510])(joystick);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<nint, SDLJoystickType>)funcTable[510])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType JoystickGetType(SDLJoystick* joystick)
		{
			SDLJoystickType ret = JoystickGetTypeNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType JoystickGetType(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickType ret = JoystickGetTypeNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickGetGUIDStringNative(Guid guid, byte* pszGUID, int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Guid, byte*, int, void>)funcTable[511])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<Guid, nint, int, void>)funcTable[511])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickGetGUIDString(Guid guid, byte* pszGUID, int cbGUID)
		{
			JoystickGetGUIDStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickGetGUIDString(Guid guid, ref byte pszGUID, int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				JoystickGetGUIDStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickGetGUIDString(Guid guid, ref string pszGUID, int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			JoystickGetGUIDStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Guid JoystickGetGUIDFromStringNative(byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Guid>)funcTable[512])(pchGUID);
			#else
			return (Guid)((delegate* unmanaged[Cdecl]<nint, Guid>)funcTable[512])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(byte* pchGUID)
		{
			Guid ret = JoystickGetGUIDFromStringNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(in byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				Guid ret = JoystickGetGUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				Guid ret = JoystickGetGUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Guid JoystickGetGUIDFromString(string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Guid ret = JoystickGetGUIDFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetJoystickGUIDInfoNative(Guid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Guid, ushort*, ushort*, ushort*, ushort*, void>)funcTable[513])(guid, vendor, product, version, crc16);
			#else
			((delegate* unmanaged[Cdecl]<Guid, nint, nint, nint, nint, void>)funcTable[513])(guid, (nint)vendor, (nint)product, (nint)version, (nint)crc16);
			#endif
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16)
		{
			GetJoystickGUIDInfoNative(guid, vendor, product, version, crc16);
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pversion = &version)
			{
				GetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, crc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pcrc16 = &crc16)
			{
				GetJoystickGUIDInfoNative(guid, vendor, product, version, (ushort*)pcrc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pversion = &version)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ushort* product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ushort* vendor, ref ushort product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(Guid guid, ref ushort vendor, ref ushort product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						fixed (ushort* pcrc16 = &crc16)
						{
							GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickGetAttachedNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[514])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[514])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAttached(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickGetAttachedNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAttached(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickGetAttachedNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickInstanceIDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[515])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[515])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickInstanceID(SDLJoystick* joystick)
		{
			int ret = JoystickInstanceIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickInstanceID(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickInstanceIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumAxesNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[516])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[516])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumAxes(SDLJoystick* joystick)
		{
			int ret = JoystickNumAxesNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumAxes(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumAxesNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumBallsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[517])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[517])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumBalls(SDLJoystick* joystick)
		{
			int ret = JoystickNumBallsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumBalls(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumBallsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumHatsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[518])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[518])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumHats(SDLJoystick* joystick)
		{
			int ret = JoystickNumHatsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumHats(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumHatsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickNumButtonsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[519])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[519])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumButtons(SDLJoystick* joystick)
		{
			int ret = JoystickNumButtonsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickNumButtons(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickNumButtonsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Update the current state of the open joysticks.<br/>
		/// This is called automatically by the event loop if any joystick events are<br/>
		/// enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickUpdateNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[520])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[520])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open joysticks.<br/>
		/// This is called automatically by the event loop if any joystick events are<br/>
		/// enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickUpdate()
		{
			JoystickUpdateNative();
		}

		/// <summary>
		/// Enable/disable joystick event polling.<br/>
		/// If joystick events are disabled, you must call SDL_JoystickUpdate()<br/>
		/// yourself and manually check the state of the joystick when you want<br/>
		/// joystick information.<br/>
		/// It is recommended that you leave joystick event handling enabled.<br/>
		/// **WARNING**: Calling this function may delete all events currently in SDL's<br/>
		/// event queue.<br/>
		/// While `param` is meant to be one of `SDL_QUERY`, `SDL_IGNORE`, or<br/>
		/// `SDL_ENABLE`, this function accepts any value, with any non-zero value that<br/>
		/// isn't `SDL_QUERY` being treated as `SDL_ENABLE`.<br/>
		/// If SDL was built with events disabled (extremely uncommon!), this will do<br/>
		/// nothing and always return `SDL_IGNORE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickEventStateNative(int state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[521])(state);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[521])(state);
			#endif
		}

		/// <summary>
		/// Enable/disable joystick event polling.<br/>
		/// If joystick events are disabled, you must call SDL_JoystickUpdate()<br/>
		/// yourself and manually check the state of the joystick when you want<br/>
		/// joystick information.<br/>
		/// It is recommended that you leave joystick event handling enabled.<br/>
		/// **WARNING**: Calling this function may delete all events currently in SDL's<br/>
		/// event queue.<br/>
		/// While `param` is meant to be one of `SDL_QUERY`, `SDL_IGNORE`, or<br/>
		/// `SDL_ENABLE`, this function accepts any value, with any non-zero value that<br/>
		/// isn't `SDL_QUERY` being treated as `SDL_ENABLE`.<br/>
		/// If SDL was built with events disabled (extremely uncommon!), this will do<br/>
		/// nothing and always return `SDL_IGNORE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickEventState(int state)
		{
			int ret = JoystickEventStateNative(state);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short JoystickGetAxisNative(SDLJoystick* joystick, int axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short>)funcTable[522])(joystick, axis);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)funcTable[522])((nint)joystick, axis);
			#endif
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short JoystickGetAxis(SDLJoystick* joystick, int axis)
		{
			short ret = JoystickGetAxisNative(joystick, axis);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short JoystickGetAxis(ref SDLJoystick joystick, int axis)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				short ret = JoystickGetAxisNative((SDLJoystick*)pjoystick, axis);
				return ret;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickGetAxisInitialStateNative(SDLJoystick* joystick, int axis, short* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short*, SDLBool>)funcTable[523])(joystick, axis, state);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, int, nint, SDLBool>)funcTable[523])((nint)joystick, axis, (nint)state);
			#endif
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(SDLJoystick* joystick, int axis, short* state)
		{
			SDLBool ret = JoystickGetAxisInitialStateNative(joystick, axis, state);
			return ret;
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(ref SDLJoystick joystick, int axis, short* state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickGetAxisInitialStateNative((SDLJoystick*)pjoystick, axis, state);
				return ret;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(SDLJoystick* joystick, int axis, ref short state)
		{
			fixed (short* pstate = &state)
			{
				SDLBool ret = JoystickGetAxisInitialStateNative(joystick, axis, (short*)pstate);
				return ret;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickGetAxisInitialState(ref SDLJoystick joystick, int axis, ref short state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (short* pstate = &state)
				{
					SDLBool ret = JoystickGetAxisInitialStateNative((SDLJoystick*)pjoystick, axis, (short*)pstate);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the following positions:<br/>
		/// - `SDL_HAT_CENTERED`<br/>
		/// - `SDL_HAT_UP`<br/>
		/// - `SDL_HAT_RIGHT`<br/>
		/// - `SDL_HAT_DOWN`<br/>
		/// - `SDL_HAT_LEFT`<br/>
		/// - `SDL_HAT_RIGHTUP`<br/>
		/// - `SDL_HAT_RIGHTDOWN`<br/>
		/// - `SDL_HAT_LEFTUP`<br/>
		/// - `SDL_HAT_LEFTDOWN`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JoystickGetHatNative(SDLJoystick* joystick, int hat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[524])(joystick, hat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[524])((nint)joystick, hat);
			#endif
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the following positions:<br/>
		/// - `SDL_HAT_CENTERED`<br/>
		/// - `SDL_HAT_UP`<br/>
		/// - `SDL_HAT_RIGHT`<br/>
		/// - `SDL_HAT_DOWN`<br/>
		/// - `SDL_HAT_LEFT`<br/>
		/// - `SDL_HAT_RIGHTUP`<br/>
		/// - `SDL_HAT_RIGHTDOWN`<br/>
		/// - `SDL_HAT_LEFTUP`<br/>
		/// - `SDL_HAT_LEFTDOWN`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetHat(SDLJoystick* joystick, int hat)
		{
			byte ret = JoystickGetHatNative(joystick, hat);
			return ret;
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the following positions:<br/>
		/// - `SDL_HAT_CENTERED`<br/>
		/// - `SDL_HAT_UP`<br/>
		/// - `SDL_HAT_RIGHT`<br/>
		/// - `SDL_HAT_DOWN`<br/>
		/// - `SDL_HAT_LEFT`<br/>
		/// - `SDL_HAT_RIGHTUP`<br/>
		/// - `SDL_HAT_RIGHTDOWN`<br/>
		/// - `SDL_HAT_LEFTUP`<br/>
		/// - `SDL_HAT_LEFTDOWN`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetHat(ref SDLJoystick joystick, int hat)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = JoystickGetHatNative((SDLJoystick*)pjoystick, hat);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickGetBallNative(SDLJoystick* joystick, int ball, int* dx, int* dy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, int*, int*, int>)funcTable[525])(joystick, ball, dx, dy);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int>)funcTable[525])((nint)joystick, ball, (nint)dx, (nint)dy);
			#endif
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, int* dx, int* dy)
		{
			int ret = JoystickGetBallNative(joystick, ball, dx, dy);
			return ret;
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, int* dx, int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, dx, dy);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, ref int dx, int* dy)
		{
			fixed (int* pdx = &dx)
			{
				int ret = JoystickGetBallNative(joystick, ball, (int*)pdx, dy);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, ref int dx, int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, dy);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, int* dx, ref int dy)
		{
			fixed (int* pdy = &dy)
			{
				int ret = JoystickGetBallNative(joystick, ball, dx, (int*)pdy);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, int* dx, ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdy = &dy)
				{
					int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, dx, (int*)pdy);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(SDLJoystick* joystick, int ball, ref int dx, ref int dy)
		{
			fixed (int* pdx = &dx)
			{
				fixed (int* pdy = &dy)
				{
					int ret = JoystickGetBallNative(joystick, ball, (int*)pdx, (int*)pdy);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickGetBall(ref SDLJoystick joystick, int ball, ref int dx, ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					fixed (int* pdy = &dy)
					{
						int ret = JoystickGetBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, (int*)pdy);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JoystickGetButtonNative(SDLJoystick* joystick, int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[526])(joystick, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[526])((nint)joystick, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetButton(SDLJoystick* joystick, int button)
		{
			byte ret = JoystickGetButtonNative(joystick, button);
			return ret;
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte JoystickGetButton(ref SDLJoystick joystick, int button)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = JoystickGetButtonNative((SDLJoystick*)pjoystick, button);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickRumbleNative(SDLJoystick* joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort, ushort, uint, int>)funcTable[527])(joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)funcTable[527])((nint)joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumble(SDLJoystick* joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			int ret = JoystickRumbleNative(joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumble(ref SDLJoystick joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickRumbleNative((SDLJoystick*)pjoystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickRumbleTriggersNative(SDLJoystick* joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort, ushort, uint, int>)funcTable[528])(joystick, leftRumble, rightRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)funcTable[528])((nint)joystick, leftRumble, rightRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumbleTriggers(SDLJoystick* joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			int ret = JoystickRumbleTriggersNative(joystick, leftRumble, rightRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickRumbleTriggers(ref SDLJoystick joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickRumbleTriggersNative((SDLJoystick*)pjoystick, leftRumble, rightRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has an LED.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickHasLEDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[529])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[529])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query whether a joystick has an LED.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasLED(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickHasLEDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Query whether a joystick has an LED.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasLED(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickHasLEDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickHasRumbleNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[530])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[530])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query whether a joystick has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumble(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickHasRumbleNative(joystick);
			return ret;
		}

		/// <summary>
		/// Query whether a joystick has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumble(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickHasRumbleNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool JoystickHasRumbleTriggersNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLBool>)funcTable[531])(joystick);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[531])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query whether a joystick has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumbleTriggers(SDLJoystick* joystick)
		{
			SDLBool ret = JoystickHasRumbleTriggersNative(joystick);
			return ret;
		}

		/// <summary>
		/// Query whether a joystick has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool JoystickHasRumbleTriggers(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = JoystickHasRumbleTriggersNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSetLEDNative(SDLJoystick* joystick, byte red, byte green, byte blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte, byte, byte, int>)funcTable[532])(joystick, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)funcTable[532])((nint)joystick, red, green, blue);
			#endif
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetLED(SDLJoystick* joystick, byte red, byte green, byte blue)
		{
			int ret = JoystickSetLEDNative(joystick, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSetLED(ref SDLJoystick joystick, byte red, byte green, byte blue)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSetLEDNative((SDLJoystick*)pjoystick, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickSendEffectNative(SDLJoystick* joystick, void* data, int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, void*, int, int>)funcTable[533])(joystick, data, size);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[533])((nint)joystick, (nint)data, size);
			#endif
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSendEffect(SDLJoystick* joystick, void* data, int size)
		{
			int ret = JoystickSendEffectNative(joystick, data, size);
			return ret;
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSendEffect(ref SDLJoystick joystick, void* data, int size)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSendEffectNative((SDLJoystick*)pjoystick, data, size);
				return ret;
			}
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSendEffect(SDLJoystick* joystick, nint data, int size)
		{
			int ret = JoystickSendEffectNative(joystick, (void*)data, size);
			return ret;
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickSendEffect(ref SDLJoystick joystick, nint data, int size)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = JoystickSendEffectNative((SDLJoystick*)pjoystick, (void*)data, size);
				return ret;
			}
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JoystickCloseNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLJoystick*, void>)funcTable[534])(joystick);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[534])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickClose(SDLJoystick* joystick)
		{
			JoystickCloseNative(joystick);
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void JoystickClose(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				JoystickCloseNative((SDLJoystick*)pjoystick);
			}
		}

		/// <summary>
		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickPowerLevel JoystickCurrentPowerLevelNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickPowerLevel>)funcTable[535])(joystick);
			#else
			return (SDLJoystickPowerLevel)((delegate* unmanaged[Cdecl]<nint, SDLJoystickPowerLevel>)funcTable[535])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickPowerLevel JoystickCurrentPowerLevel(SDLJoystick* joystick)
		{
			SDLJoystickPowerLevel ret = JoystickCurrentPowerLevelNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickPowerLevel JoystickCurrentPowerLevel(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickPowerLevel ret = JoystickCurrentPowerLevelNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Locking for multi-threaded access to the sensor API<br/>
		/// If you are using the sensor API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the sensors.<br/>
		/// In particular, you are guaranteed that the sensor list won't change, so the<br/>
		/// API functions that take a sensor index will be valid, and sensor events<br/>
		/// will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[536])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[536])();
			#endif
		}

		/// <summary>
		/// Locking for multi-threaded access to the sensor API<br/>
		/// If you are using the sensor API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the sensors.<br/>
		/// In particular, you are guaranteed that the sensor list won't change, so the<br/>
		/// API functions that take a sensor index will be valid, and sensor events<br/>
		/// will not be delivered.<br/>
		/// <br/>
		/// </summary>
		public static void LockSensors()
		{
			LockSensorsNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[537])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[537])();
			#endif
		}

		public static void UnlockSensors()
		{
			UnlockSensorsNative();
		}

		/// <summary>
		/// Count the number of sensors attached to the system right now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int NumSensorsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[538])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[538])();
			#endif
		}

		/// <summary>
		/// Count the number of sensors attached to the system right now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int NumSensors()
		{
			int ret = NumSensorsNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* SensorGetDeviceNameNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[539])(deviceIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[539])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* SensorGetDeviceName(int deviceIndex)
		{
			byte* ret = SensorGetDeviceNameNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string SensorGetDeviceNameS(int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SensorGetDeviceNameNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType SensorGetDeviceTypeNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[540])(deviceIndex);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[540])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType SensorGetDeviceType(int deviceIndex)
		{
			SDLSensorType ret = SensorGetDeviceTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDeviceNonPortableTypeNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[541])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[541])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDeviceNonPortableType(int deviceIndex)
		{
			int ret = SensorGetDeviceNonPortableTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDeviceInstanceIDNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[542])(deviceIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[542])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDeviceInstanceID(int deviceIndex)
		{
			int ret = SensorGetDeviceInstanceIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* SensorOpenNative(int deviceIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[543])(deviceIndex);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[543])(deviceIndex);
			#endif
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensor* SensorOpen(int deviceIndex)
		{
			SDLSensor* ret = SensorOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* SensorFromInstanceIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[544])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[544])(instanceId);
			#endif
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensor* SensorFromInstanceID(int instanceId)
		{
			SDLSensor* ret = SensorFromInstanceIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* SensorGetNameNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, byte*>)funcTable[545])(sensor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[545])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* SensorGetName(SDLSensor* sensor)
		{
			byte* ret = SensorGetNameNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string SensorGetNameS(SDLSensor* sensor)
		{
			string ret = Utils.DecodeStringUTF8(SensorGetNameNative(sensor));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* SensorGetName(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte* ret = SensorGetNameNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string SensorGetNameS(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				string ret = Utils.DecodeStringUTF8(SensorGetNameNative((SDLSensor*)psensor));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType SensorGetTypeNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, SDLSensorType>)funcTable[546])(sensor);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<nint, SDLSensorType>)funcTable[546])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType SensorGetType(SDLSensor* sensor)
		{
			SDLSensorType ret = SensorGetTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType SensorGetType(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorType ret = SensorGetTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetNonPortableTypeNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[547])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[547])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetNonPortableType(SDLSensor* sensor)
		{
			int ret = SensorGetNonPortableTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetNonPortableType(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetNonPortableTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetInstanceIDNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[548])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[548])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetInstanceID(SDLSensor* sensor)
		{
			int ret = SensorGetInstanceIDNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetInstanceID(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetInstanceIDNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDataNative(SDLSensor* sensor, float* data, int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, float*, int, int>)funcTable[549])(sensor, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[549])((nint)sensor, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(SDLSensor* sensor, float* data, int numValues)
		{
			int ret = SensorGetDataNative(sensor, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(ref SDLSensor sensor, float* data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetDataNative((SDLSensor*)psensor, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(SDLSensor* sensor, ref float data, int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SensorGetDataNative(sensor, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetData(ref SDLSensor sensor, ref float data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					int ret = SensorGetDataNative((SDLSensor*)psensor, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SensorGetDataWithTimestampNative(SDLSensor* sensor, ulong* timestamp, float* data, int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, ulong*, float*, int, int>)funcTable[550])(sensor, timestamp, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)funcTable[550])((nint)sensor, (nint)timestamp, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ulong* timestamp, float* data, int numValues)
		{
			int ret = SensorGetDataWithTimestampNative(sensor, timestamp, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ulong* timestamp, float* data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, timestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ref ulong timestamp, float* data, int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				int ret = SensorGetDataWithTimestampNative(sensor, (ulong*)ptimestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ref ulong timestamp, float* data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, (ulong*)ptimestamp, data, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ulong* timestamp, ref float data, int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SensorGetDataWithTimestampNative(sensor, timestamp, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ulong* timestamp, ref float data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, timestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(SDLSensor* sensor, ref ulong timestamp, ref float data, int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				fixed (float* pdata = &data)
				{
					int ret = SensorGetDataWithTimestampNative(sensor, (ulong*)ptimestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SensorGetDataWithTimestamp(ref SDLSensor sensor, ref ulong timestamp, ref float data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					fixed (float* pdata = &data)
					{
						int ret = SensorGetDataWithTimestampNative((SDLSensor*)psensor, (ulong*)ptimestamp, (float*)pdata, numValues);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_SensorOpen().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SensorCloseNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSensor*, void>)funcTable[551])(sensor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[551])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_SensorOpen().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SensorClose(SDLSensor* sensor)
		{
			SensorCloseNative(sensor);
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_SensorOpen().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SensorClose(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SensorCloseNative((SDLSensor*)psensor);
			}
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SensorUpdateNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[552])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[552])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		public static void SensorUpdate()
		{
			SensorUpdateNative();
		}

		/// <summary>
		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known controller GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerAddMappingsFromRWNative(SDLRWops* rw, int freerw)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, int>)funcTable[553])(rw, freerw);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[553])((nint)rw, freerw);
			#endif
		}

		/// <summary>
		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known controller GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMappingsFromRW(SDLRWopsPtr rw, int freerw)
		{
			int ret = GameControllerAddMappingsFromRWNative((SDLRWops*)rw, freerw);
			return ret;
		}

		/// <summary>
		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known controller GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMappingsFromRW(ref SDLRWops rw, int freerw)
		{
			fixed (SDLRWops* prw = &rw)
			{
				int ret = GameControllerAddMappingsFromRWNative((SDLRWops*)prw, freerw);
				return ret;
			}
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerAddMappingNative(byte* mappingString)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[554])(mappingString);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[554])((nint)mappingString);
			#endif
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(byte* mappingString)
		{
			int ret = GameControllerAddMappingNative(mappingString);
			return ret;
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(in byte mappingString)
		{
			fixed (byte* pmappingString = &mappingString)
			{
				int ret = GameControllerAddMappingNative((byte*)pmappingString);
				return ret;
			}
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(ReadOnlySpan<byte> mappingString)
		{
			fixed (byte* pmappingString = mappingString)
			{
				int ret = GameControllerAddMappingNative((byte*)pmappingString);
				return ret;
			}
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// If this function is called before SDL_Init, SDL will generate an<br/>
		/// SDL_CONTROLLERDEVICEADDED event for matching controllers that are plugged<br/>
		/// in at the time that SDL_Init is called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerAddMapping(string mappingString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mappingString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mappingString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mappingString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GameControllerAddMappingNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the number of mappings installed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerNumMappingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[555])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[555])();
			#endif
		}

		/// <summary>
		/// Get the number of mappings installed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerNumMappings()
		{
			int ret = GameControllerNumMappingsNative();
			return ret;
		}

		/// <summary>
		/// Get the mapping at a particular index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerMappingForIndexNative(int mappingIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[556])(mappingIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[556])(mappingIndex);
			#endif
		}

		/// <summary>
		/// Get the mapping at a particular index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerMappingForIndex(int mappingIndex)
		{
			byte* ret = GameControllerMappingForIndexNative(mappingIndex);
			return ret;
		}

		/// <summary>
		/// Get the mapping at a particular index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerMappingForIndexS(int mappingIndex)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerMappingForIndexNative(mappingIndex));
			return ret;
		}

		/// <summary>
		/// Get the game controller mapping string for a given GUID.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerMappingForGUIDNative(Guid guid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Guid, byte*>)funcTable[557])(guid);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<Guid, nint>)funcTable[557])(guid);
			#endif
		}

		/// <summary>
		/// Get the game controller mapping string for a given GUID.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerMappingForGUID(Guid guid)
		{
			byte* ret = GameControllerMappingForGUIDNative(guid);
			return ret;
		}

		/// <summary>
		/// Get the game controller mapping string for a given GUID.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerMappingForGUIDS(Guid guid)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerMappingForGUIDNative(guid));
			return ret;
		}

		/// <summary>
		/// Get the current mapping of a Game Controller.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerMappingNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, byte*>)funcTable[558])(gamecontroller);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[558])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the current mapping of a Game Controller.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerMapping(SDLGameController* gamecontroller)
		{
			byte* ret = GameControllerMappingNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the current mapping of a Game Controller.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerMappingS(SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerMappingNative(gamecontroller));
			return ret;
		}

		/// <summary>
		/// Get the current mapping of a Game Controller.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerMapping(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = GameControllerMappingNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the current mapping of a Game Controller.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerMappingS(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(GameControllerMappingNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Check if the given joystick is supported by the game controller interface.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsGameControllerNative(int joystickIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[559])(joystickIndex);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[559])(joystickIndex);
			#endif
		}

		/// <summary>
		/// Check if the given joystick is supported by the game controller interface.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsGameController(int joystickIndex)
		{
			SDLBool ret = IsGameControllerNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerNameForIndexNative(int joystickIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[560])(joystickIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[560])(joystickIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerNameForIndex(int joystickIndex)
		{
			byte* ret = GameControllerNameForIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerNameForIndexS(int joystickIndex)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerNameForIndexNative(joystickIndex));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerPathForIndexNative(int joystickIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[561])(joystickIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[561])(joystickIndex);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerPathForIndex(int joystickIndex)
		{
			byte* ret = GameControllerPathForIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerPathForIndexS(int joystickIndex)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerPathForIndexNative(joystickIndex));
			return ret;
		}

		/// <summary>
		/// Get the type of a game controller.<br/>
		/// This can be called before any controllers are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameControllerType GameControllerTypeForIndexNative(int joystickIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGameControllerType>)funcTable[562])(joystickIndex);
			#else
			return (SDLGameControllerType)((delegate* unmanaged[Cdecl]<int, SDLGameControllerType>)funcTable[562])(joystickIndex);
			#endif
		}

		/// <summary>
		/// Get the type of a game controller.<br/>
		/// This can be called before any controllers are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerType GameControllerTypeForIndex(int joystickIndex)
		{
			SDLGameControllerType ret = GameControllerTypeForIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the mapping of a game controller.<br/>
		/// This can be called before any controllers are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerMappingForDeviceIndexNative(int joystickIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[563])(joystickIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[563])(joystickIndex);
			#endif
		}

		/// <summary>
		/// Get the mapping of a game controller.<br/>
		/// This can be called before any controllers are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerMappingForDeviceIndex(int joystickIndex)
		{
			byte* ret = GameControllerMappingForDeviceIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the mapping of a game controller.<br/>
		/// This can be called before any controllers are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerMappingForDeviceIndexS(int joystickIndex)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerMappingForDeviceIndexNative(joystickIndex));
			return ret;
		}

		/// <summary>
		/// Open a game controller for use.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// The index passed as an argument refers to the N'th game controller on the<br/>
		/// system. This index is not the value which will identify this controller in<br/>
		/// future controller events. The joystick's instance id (SDL_JoystickID) will<br/>
		/// be used there instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameController* GameControllerOpenNative(int joystickIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGameController*>)funcTable[564])(joystickIndex);
			#else
			return (SDLGameController*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[564])(joystickIndex);
			#endif
		}

		/// <summary>
		/// Open a game controller for use.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// The index passed as an argument refers to the N'th game controller on the<br/>
		/// system. This index is not the value which will identify this controller in<br/>
		/// future controller events. The joystick's instance id (SDL_JoystickID) will<br/>
		/// be used there instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameController* GameControllerOpen(int joystickIndex)
		{
			SDLGameController* ret = GameControllerOpenNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the SDL_GameController associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameController* GameControllerFromInstanceIDNative(int joyid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGameController*>)funcTable[565])(joyid);
			#else
			return (SDLGameController*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[565])(joyid);
			#endif
		}

		/// <summary>
		/// Get the SDL_GameController associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameController* GameControllerFromInstanceID(int joyid)
		{
			SDLGameController* ret = GameControllerFromInstanceIDNative(joyid);
			return ret;
		}

		/// <summary>
		/// Get the SDL_GameController associated with a player index.<br/>
		/// Please note that the player index is _not_ the device index, nor is it the<br/>
		/// instance id!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameController* GameControllerFromPlayerIndexNative(int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGameController*>)funcTable[566])(playerIndex);
			#else
			return (SDLGameController*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[566])(playerIndex);
			#endif
		}

		/// <summary>
		/// Get the SDL_GameController associated with a player index.<br/>
		/// Please note that the player index is _not_ the device index, nor is it the<br/>
		/// instance id!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameController* GameControllerFromPlayerIndex(int playerIndex)
		{
			SDLGameController* ret = GameControllerFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened game controller.<br/>
		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerNameNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, byte*>)funcTable[567])(gamecontroller);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[567])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened game controller.<br/>
		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerName(SDLGameController* gamecontroller)
		{
			byte* ret = GameControllerNameNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened game controller.<br/>
		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerNameS(SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerNameNative(gamecontroller));
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened game controller.<br/>
		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerName(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = GameControllerNameNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened game controller.<br/>
		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerNameS(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(GameControllerNameNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened game controller.<br/>
		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerPathNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, byte*>)funcTable[568])(gamecontroller);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[568])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened game controller.<br/>
		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerPath(SDLGameController* gamecontroller)
		{
			byte* ret = GameControllerPathNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened game controller.<br/>
		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerPathS(SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerPathNative(gamecontroller));
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened game controller.<br/>
		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerPath(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = GameControllerPathNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened game controller.<br/>
		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerPathS(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(GameControllerPathNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of this currently opened controller<br/>
		/// This is the same name as returned by SDL_GameControllerTypeForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameControllerType GameControllerGetTypeNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerType>)funcTable[569])(gamecontroller);
			#else
			return (SDLGameControllerType)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerType>)funcTable[569])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the type of this currently opened controller<br/>
		/// This is the same name as returned by SDL_GameControllerTypeForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerType GameControllerGetType(SDLGameController* gamecontroller)
		{
			SDLGameControllerType ret = GameControllerGetTypeNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the type of this currently opened controller<br/>
		/// This is the same name as returned by SDL_GameControllerTypeForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerType GameControllerGetType(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerType ret = GameControllerGetTypeNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened game controller.<br/>
		/// For XInput controllers this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerGetPlayerIndexNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, int>)funcTable[570])(gamecontroller);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[570])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened game controller.<br/>
		/// For XInput controllers this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerGetPlayerIndex(SDLGameController* gamecontroller)
		{
			int ret = GameControllerGetPlayerIndexNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened game controller.<br/>
		/// For XInput controllers this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerGetPlayerIndex(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = GameControllerGetPlayerIndexNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GameControllerSetPlayerIndexNative(SDLGameController* gamecontroller, int playerIndex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGameController*, int, void>)funcTable[571])(gamecontroller, playerIndex);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[571])((nint)gamecontroller, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GameControllerSetPlayerIndex(SDLGameController* gamecontroller, int playerIndex)
		{
			GameControllerSetPlayerIndexNative(gamecontroller, playerIndex);
		}

		/// <summary>
		/// Set the player index of an opened game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GameControllerSetPlayerIndex(ref SDLGameController gamecontroller, int playerIndex)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				GameControllerSetPlayerIndexNative((SDLGameController*)pgamecontroller, playerIndex);
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened controller, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GameControllerGetVendorNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, ushort>)funcTable[572])(gamecontroller);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[572])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened controller, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetVendor(SDLGameController* gamecontroller)
		{
			ushort ret = GameControllerGetVendorNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened controller, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetVendor(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = GameControllerGetVendorNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened controller, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GameControllerGetProductNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, ushort>)funcTable[573])(gamecontroller);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[573])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened controller, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetProduct(SDLGameController* gamecontroller)
		{
			ushort ret = GameControllerGetProductNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened controller, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetProduct(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = GameControllerGetProductNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened controller, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GameControllerGetProductVersionNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, ushort>)funcTable[574])(gamecontroller);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[574])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened controller, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetProductVersion(SDLGameController* gamecontroller)
		{
			ushort ret = GameControllerGetProductVersionNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened controller, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetProductVersion(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = GameControllerGetProductVersionNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened controller, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GameControllerGetFirmwareVersionNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, ushort>)funcTable[575])(gamecontroller);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[575])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened controller, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetFirmwareVersion(SDLGameController* gamecontroller)
		{
			ushort ret = GameControllerGetFirmwareVersionNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened controller, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GameControllerGetFirmwareVersion(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = GameControllerGetFirmwareVersionNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened controller, if available.<br/>
		/// Returns the serial number of the controller, or NULL if it is not<br/>
		/// available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerGetSerialNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, byte*>)funcTable[576])(gamecontroller);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[576])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened controller, if available.<br/>
		/// Returns the serial number of the controller, or NULL if it is not<br/>
		/// available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerGetSerial(SDLGameController* gamecontroller)
		{
			byte* ret = GameControllerGetSerialNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened controller, if available.<br/>
		/// Returns the serial number of the controller, or NULL if it is not<br/>
		/// available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerGetSerialS(SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerGetSerialNative(gamecontroller));
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened controller, if available.<br/>
		/// Returns the serial number of the controller, or NULL if it is not<br/>
		/// available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerGetSerial(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = GameControllerGetSerialNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened controller, if available.<br/>
		/// Returns the serial number of the controller, or NULL if it is not<br/>
		/// available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerGetSerialS(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(GameControllerGetSerialNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Get the Steam Input handle of an opened controller, if available.<br/>
		/// Returns an InputHandle_t for the controller that can be used with Steam<br/>
		/// Input API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GameControllerGetSteamHandleNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, ulong>)funcTable[577])(gamecontroller);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[577])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the Steam Input handle of an opened controller, if available.<br/>
		/// Returns an InputHandle_t for the controller that can be used with Steam<br/>
		/// Input API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GameControllerGetSteamHandle(SDLGameController* gamecontroller)
		{
			ulong ret = GameControllerGetSteamHandleNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the Steam Input handle of an opened controller, if available.<br/>
		/// Returns an InputHandle_t for the controller that can be used with Steam<br/>
		/// Input API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GameControllerGetSteamHandle(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ulong ret = GameControllerGetSteamHandleNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Check if a controller has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GameControllerGetAttachedNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLBool>)funcTable[578])(gamecontroller);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[578])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Check if a controller has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GameControllerGetAttached(SDLGameController* gamecontroller)
		{
			SDLBool ret = GameControllerGetAttachedNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Check if a controller has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GameControllerGetAttached(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = GameControllerGetAttachedNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the Joystick ID from a Game Controller.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_GameController object. This would be<br/>
		/// useful for getting a joystick's position at any given time, even if it<br/>
		/// hasn't moved (moving it would produce an event, which would have the axis'<br/>
		/// value).<br/>
		/// The pointer returned is owned by the SDL_GameController. You should not<br/>
		/// call SDL_JoystickClose() on it, for example, since doing so will likely<br/>
		/// cause SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GameControllerGetJoystickNative(SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLJoystick*>)funcTable[579])(gamecontroller);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[579])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the Joystick ID from a Game Controller.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_GameController object. This would be<br/>
		/// useful for getting a joystick's position at any given time, even if it<br/>
		/// hasn't moved (moving it would produce an event, which would have the axis'<br/>
		/// value).<br/>
		/// The pointer returned is owned by the SDL_GameController. You should not<br/>
		/// call SDL_JoystickClose() on it, for example, since doing so will likely<br/>
		/// cause SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* GameControllerGetJoystick(SDLGameController* gamecontroller)
		{
			SDLJoystick* ret = GameControllerGetJoystickNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the Joystick ID from a Game Controller.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_GameController object. This would be<br/>
		/// useful for getting a joystick's position at any given time, even if it<br/>
		/// hasn't moved (moving it would produce an event, which would have the axis'<br/>
		/// value).<br/>
		/// The pointer returned is owned by the SDL_GameController. You should not<br/>
		/// call SDL_JoystickClose() on it, for example, since doing so will likely<br/>
		/// cause SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* GameControllerGetJoystick(ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLJoystick* ret = GameControllerGetJoystickNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Query or change current state of Game Controller events.<br/>
		/// If controller events are disabled, you must call SDL_GameControllerUpdate()<br/>
		/// yourself and check the state of the controller when you want controller<br/>
		/// information.<br/>
		/// Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,<br/>
		/// and 1 will have any effect. Other numbers will just be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GameControllerEventStateNative(int state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[580])(state);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[580])(state);
			#endif
		}

		/// <summary>
		/// Query or change current state of Game Controller events.<br/>
		/// If controller events are disabled, you must call SDL_GameControllerUpdate()<br/>
		/// yourself and check the state of the controller when you want controller<br/>
		/// information.<br/>
		/// Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,<br/>
		/// and 1 will have any effect. Other numbers will just be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GameControllerEventState(int state)
		{
			int ret = GameControllerEventStateNative(state);
			return ret;
		}

		/// <summary>
		/// Manually pump game controller updates if not using the loop.<br/>
		/// This function is called automatically by the event loop if events are<br/>
		/// enabled. Under such circumstances, it will not be necessary to call this<br/>
		/// function.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GameControllerUpdateNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[581])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[581])();
			#endif
		}

		/// <summary>
		/// Manually pump game controller updates if not using the loop.<br/>
		/// This function is called automatically by the event loop if events are<br/>
		/// enabled. Under such circumstances, it will not be necessary to call this<br/>
		/// function.<br/>
		/// <br/>
		/// </summary>
		public static void GameControllerUpdate()
		{
			GameControllerUpdateNative();
		}

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameControllerAxis GameControllerGetAxisFromStringNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGameControllerAxis>)funcTable[582])(str);
			#else
			return (SDLGameControllerAxis)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis>)funcTable[582])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerAxis GameControllerGetAxisFromString(byte* str)
		{
			SDLGameControllerAxis ret = GameControllerGetAxisFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerAxis GameControllerGetAxisFromString(in byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGameControllerAxis ret = GameControllerGetAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerAxis GameControllerGetAxisFromString(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGameControllerAxis ret = GameControllerGetAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerAxis GameControllerGetAxisFromString(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGameControllerAxis ret = GameControllerGetAxisFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerGetStringForAxisNative(SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameControllerAxis, byte*>)funcTable[583])(axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGameControllerAxis, nint>)funcTable[583])(axis);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerGetStringForAxis(SDLGameControllerAxis axis)
		{
			byte* ret = GameControllerGetStringForAxisNative(axis);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerGetStringForAxisS(SDLGameControllerAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerGetStringForAxisNative(axis));
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameControllerButtonBind GameControllerGetBindForAxisNative(SDLGameController* gamecontroller, SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerAxis, SDLGameControllerButtonBind>)funcTable[584])(gamecontroller, axis);
			#else
			return (SDLGameControllerButtonBind)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis, SDLGameControllerButtonBind>)funcTable[584])((nint)gamecontroller, axis);
			#endif
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButtonBind GameControllerGetBindForAxis(SDLGameController* gamecontroller, SDLGameControllerAxis axis)
		{
			SDLGameControllerButtonBind ret = GameControllerGetBindForAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButtonBind GameControllerGetBindForAxis(ref SDLGameController gamecontroller, SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerButtonBind ret = GameControllerGetBindForAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has a given axis.<br/>
		/// This merely reports whether the controller's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GameControllerHasAxisNative(SDLGameController* gamecontroller, SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerAxis, SDLBool>)funcTable[585])(gamecontroller, axis);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis, SDLBool>)funcTable[585])((nint)gamecontroller, axis);
			#endif
		}

		/// <summary>
		/// Query whether a game controller has a given axis.<br/>
		/// This merely reports whether the controller's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GameControllerHasAxis(SDLGameController* gamecontroller, SDLGameControllerAxis axis)
		{
			SDLBool ret = GameControllerHasAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>
		/// Query whether a game controller has a given axis.<br/>
		/// This merely reports whether the controller's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GameControllerHasAxis(ref SDLGameController gamecontroller, SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = GameControllerHasAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an axis control on a game controller.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_JoystickGetAxis(), which normally uses the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short GameControllerGetAxisNative(SDLGameController* gamecontroller, SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerAxis, short>)funcTable[586])(gamecontroller, axis);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis, short>)funcTable[586])((nint)gamecontroller, axis);
			#endif
		}

		/// <summary>
		/// Get the current state of an axis control on a game controller.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_JoystickGetAxis(), which normally uses the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short GameControllerGetAxis(SDLGameController* gamecontroller, SDLGameControllerAxis axis)
		{
			short ret = GameControllerGetAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a game controller.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_JoystickGetAxis(), which normally uses the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short GameControllerGetAxis(ref SDLGameController gamecontroller, SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				short ret = GameControllerGetAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameControllerButton GameControllerGetButtonFromStringNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGameControllerButton>)funcTable[587])(str);
			#else
			return (SDLGameControllerButton)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton>)funcTable[587])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButton GameControllerGetButtonFromString(byte* str)
		{
			SDLGameControllerButton ret = GameControllerGetButtonFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButton GameControllerGetButtonFromString(in byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGameControllerButton ret = GameControllerGetButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButton GameControllerGetButtonFromString(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGameControllerButton ret = GameControllerGetButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButton GameControllerGetButtonFromString(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGameControllerButton ret = GameControllerGetButtonFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerButton enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GameControllerGetStringForButtonNative(SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameControllerButton, byte*>)funcTable[588])(button);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGameControllerButton, nint>)funcTable[588])(button);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GameControllerButton enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GameControllerGetStringForButton(SDLGameControllerButton button)
		{
			byte* ret = GameControllerGetStringForButtonNative(button);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerButton enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GameControllerGetStringForButtonS(SDLGameControllerButton button)
		{
			string ret = Utils.DecodeStringUTF8(GameControllerGetStringForButtonNative(button));
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller button mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGameControllerButtonBind GameControllerGetBindForButtonNative(SDLGameController* gamecontroller, SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerButton, SDLGameControllerButtonBind>)funcTable[589])(gamecontroller, button);
			#else
			return (SDLGameControllerButtonBind)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton, SDLGameControllerButtonBind>)funcTable[589])((nint)gamecontroller, button);
			#endif
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller button mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButtonBind GameControllerGetBindForButton(SDLGameController* gamecontroller, SDLGameControllerButton button)
		{
			SDLGameControllerButtonBind ret = GameControllerGetBindForButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller button mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGameControllerButtonBind GameControllerGetBindForButton(ref SDLGameController gamecontroller, SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerButtonBind ret = GameControllerGetBindForButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has a given button.<br/>
		/// This merely reports whether the controller's mapping defined this button,<br/>
		/// as that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GameControllerHasButtonNative(SDLGameController* gamecontroller, SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerButton, SDLBool>)funcTable[590])(gamecontroller, button);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton, SDLBool>)funcTable[590])((nint)gamecontroller, button);
			#endif
		}

		/// <summary>
		/// Query whether a game controller has a given button.<br/>
		/// This merely reports whether the controller's mapping defined this button,<br/>
		/// as that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GameControllerHasButton(SDLGameController* gamecontroller, SDLGameControllerButton button)
		{
			SDLBool ret = GameControllerHasButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>
		/// Query whether a game controller has a given button.<br/>
		/// This merely reports whether the controller's mapping defined this button,<br/>
		/// as that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GameControllerHasButton(ref SDLGameController gamecontroller, SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = GameControllerHasButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a button on a game controller.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GameControllerGetButtonNative(SDLGameController* gamecontroller, SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerButton, byte>)funcTable[591])(gamecontroller, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton, byte>)funcTable[591])((nint)gamecontroller, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a game controller.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte GameControllerGetButton(SDLGameController* gamecontroller, SDLGameControllerButton button)
		{
			byte ret = GameControllerGetButtonNative(gamecontroller, button);
			return ret;
		}
	}
}
