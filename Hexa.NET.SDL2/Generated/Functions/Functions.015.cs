// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(SDLWindowPtr window, SDLWindowShapeModePtr shapeMode)
		{
			int ret = GetShapedWindowModeNative((SDLWindow*)window, (SDLWindowShapeMode*)shapeMode);
			return ret;
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(ref SDLWindow window, SDLWindowShapeModePtr shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetShapedWindowModeNative((SDLWindow*)pwindow, (SDLWindowShapeMode*)shapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(SDLWindowPtr window, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
			{
				int ret = GetShapedWindowModeNative((SDLWindow*)window, (SDLWindowShapeMode*)pshapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetShapedWindowMode(ref SDLWindow window, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = GetShapedWindowModeNative((SDLWindow*)pwindow, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowsMessageHookNative(delegate*<void*, void*, uint, ulong, long, void> callback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, void*, uint, ulong, long, void>, void*, void>)funcTable[808])(callback, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[808])((nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowsMessageHook(delegate*<void*, void*, uint, ulong, long, void> callback, void* userdata)
		{
			SetWindowsMessageHookNative(callback, userdata);
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowsMessageHook(SDLWindowsMessageHook callback, void* userdata)
		{
			SetWindowsMessageHookNative((delegate*<void*, void*, uint, ulong, long, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowsMessageHook(delegate*<void*, void*, uint, ulong, long, void> callback, nint userdata)
		{
			SetWindowsMessageHookNative(callback, (void*)userdata);
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowsMessageHook(SDLWindowsMessageHook callback, nint userdata)
		{
			SetWindowsMessageHookNative((delegate*<void*, void*, uint, ulong, long, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
		}

		/// <summary>
		/// Get the D3D9 adapter index that matches the specified display index.<br/>
		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
		/// controls on which monitor a full screen application will appear.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Direct3D9GetAdapterIndexNative(int displayIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[809])(displayIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[809])(displayIndex);
			#endif
		}

		/// <summary>
		/// Get the D3D9 adapter index that matches the specified display index.<br/>
		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
		/// controls on which monitor a full screen application will appear.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Direct3D9GetAdapterIndex(int displayIndex)
		{
			int ret = Direct3D9GetAdapterIndexNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get the D3D9 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IDirect3DDevice9* RenderGetD3D9DeviceNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, IDirect3DDevice9*>)funcTable[810])(renderer);
			#else
			return (IDirect3DDevice9*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[810])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the D3D9 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static IDirect3DDevice9Ptr RenderGetD3D9Device(SDLRendererPtr renderer)
		{
			IDirect3DDevice9Ptr ret = RenderGetD3D9DeviceNative((SDLRenderer*)renderer);
			return ret;
		}

		/// <summary>
		/// Get the D3D9 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static IDirect3DDevice9Ptr RenderGetD3D9Device(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				IDirect3DDevice9Ptr ret = RenderGetD3D9DeviceNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the D3D11 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ID3D11Device* RenderGetD3D11DeviceNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, ID3D11Device*>)funcTable[811])(renderer);
			#else
			return (ID3D11Device*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[811])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the D3D11 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ID3D11DevicePtr RenderGetD3D11Device(SDLRendererPtr renderer)
		{
			ID3D11DevicePtr ret = RenderGetD3D11DeviceNative((SDLRenderer*)renderer);
			return ret;
		}

		/// <summary>
		/// Get the D3D11 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ID3D11DevicePtr RenderGetD3D11Device(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				ID3D11DevicePtr ret = RenderGetD3D11DeviceNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the D3D12 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ID3D12Device* RenderGetD3D12DeviceNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, ID3D12Device*>)funcTable[812])(renderer);
			#else
			return (ID3D12Device*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[812])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the D3D12 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ID3D12DevicePtr RenderGetD3D12Device(SDLRendererPtr renderer)
		{
			ID3D12DevicePtr ret = RenderGetD3D12DeviceNative((SDLRenderer*)renderer);
			return ret;
		}

		/// <summary>
		/// Get the D3D12 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ID3D12DevicePtr RenderGetD3D12Device(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				ID3D12DevicePtr ret = RenderGetD3D12DeviceNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>
		/// returns an SDL_bool.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool DXGIGetOutputInfoNative(int displayIndex, int* adapterIndex, int* outputIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int*, int*, SDLBool>)funcTable[813])(displayIndex, adapterIndex, outputIndex);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<int, nint, nint, SDLBool>)funcTable[813])(displayIndex, (nint)adapterIndex, (nint)outputIndex);
			#endif
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>
		/// returns an SDL_bool.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool DXGIGetOutputInfo(int displayIndex, int* adapterIndex, int* outputIndex)
		{
			SDLBool ret = DXGIGetOutputInfoNative(displayIndex, adapterIndex, outputIndex);
			return ret;
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>
		/// returns an SDL_bool.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool DXGIGetOutputInfo(int displayIndex, ref int adapterIndex, int* outputIndex)
		{
			fixed (int* padapterIndex = &adapterIndex)
			{
				SDLBool ret = DXGIGetOutputInfoNative(displayIndex, (int*)padapterIndex, outputIndex);
				return ret;
			}
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>
		/// returns an SDL_bool.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool DXGIGetOutputInfo(int displayIndex, int* adapterIndex, ref int outputIndex)
		{
			fixed (int* poutputIndex = &outputIndex)
			{
				SDLBool ret = DXGIGetOutputInfoNative(displayIndex, adapterIndex, (int*)poutputIndex);
				return ret;
			}
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>
		/// returns an SDL_bool.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool DXGIGetOutputInfo(int displayIndex, ref int adapterIndex, ref int outputIndex)
		{
			fixed (int* padapterIndex = &adapterIndex)
			{
				fixed (int* poutputIndex = &outputIndex)
				{
					SDLBool ret = DXGIGetOutputInfoNative(displayIndex, (int*)padapterIndex, (int*)poutputIndex);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query if the current device is a tablet.<br/>
		/// If SDL can't determine this, it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsTabletNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[814])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[814])();
			#endif
		}

		/// <summary>
		/// Query if the current device is a tablet.<br/>
		/// If SDL can't determine this, it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsTablet()
		{
			SDLBool ret = IsTabletNative();
			return ret;
		}

		/// <summary>
		/// Functions used by iOS application delegates to notify SDL about state changes <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationWillTerminateNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[815])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[815])();
			#endif
		}

		/// <summary>
		/// Functions used by iOS application delegates to notify SDL about state changes <br/>
		/// </summary>
		public static void OnApplicationWillTerminate()
		{
			OnApplicationWillTerminateNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationDidReceiveMemoryWarningNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[816])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[816])();
			#endif
		}

		public static void OnApplicationDidReceiveMemoryWarning()
		{
			OnApplicationDidReceiveMemoryWarningNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationWillResignActiveNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[817])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[817])();
			#endif
		}

		public static void OnApplicationWillResignActive()
		{
			OnApplicationWillResignActiveNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationDidEnterBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[818])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[818])();
			#endif
		}

		public static void OnApplicationDidEnterBackground()
		{
			OnApplicationDidEnterBackgroundNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationWillEnterForegroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[819])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[819])();
			#endif
		}

		public static void OnApplicationWillEnterForeground()
		{
			OnApplicationWillEnterForegroundNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationDidBecomeActiveNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[820])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[820])();
			#endif
		}

		public static void OnApplicationDidBecomeActive()
		{
			OnApplicationDidBecomeActiveNative();
		}

		/// <summary>
		/// Get the number of milliseconds since SDL library initialization.<br/>
		/// This value wraps if the program runs for more than ~49 days.<br/>
		/// This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()<br/>
		/// instead, where the value doesn't wrap every ~49 days. There are places in<br/>
		/// SDL where we provide a 32-bit timestamp that can not change without<br/>
		/// breaking binary compatibility, though, so this function isn't officially<br/>
		/// deprecated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetTicksNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[821])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[821])();
			#endif
		}

		/// <summary>
		/// Get the number of milliseconds since SDL library initialization.<br/>
		/// This value wraps if the program runs for more than ~49 days.<br/>
		/// This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()<br/>
		/// instead, where the value doesn't wrap every ~49 days. There are places in<br/>
		/// SDL where we provide a 32-bit timestamp that can not change without<br/>
		/// breaking binary compatibility, though, so this function isn't officially<br/>
		/// deprecated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetTicks()
		{
			uint ret = GetTicksNative();
			return ret;
		}

		/// <summary>
		/// Get the number of milliseconds since SDL library initialization.<br/>
		/// Note that you should not use the SDL_TICKS_PASSED macro with values<br/>
		/// returned by this function, as that macro does clever math to compensate for<br/>
		/// the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit<br/>
		/// values from this function can be safely compared directly.<br/>
		/// For example, if you want to wait 100 ms, you could do this:<br/>
		/// ```c<br/>
		/// const Uint64 timeout = SDL_GetTicks64() + 100;<br/>
		/// while (SDL_GetTicks64() <br/>
		/// <<br/>
		/// timeout) {<br/>
		/// // ... do work until timeout has elapsed<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTicks64Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[822])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[822])();
			#endif
		}

		/// <summary>
		/// Get the number of milliseconds since SDL library initialization.<br/>
		/// Note that you should not use the SDL_TICKS_PASSED macro with values<br/>
		/// returned by this function, as that macro does clever math to compensate for<br/>
		/// the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit<br/>
		/// values from this function can be safely compared directly.<br/>
		/// For example, if you want to wait 100 ms, you could do this:<br/>
		/// ```c<br/>
		/// const Uint64 timeout = SDL_GetTicks64() + 100;<br/>
		/// while (SDL_GetTicks64() <br/>
		/// <<br/>
		/// timeout) {<br/>
		/// // ... do work until timeout has elapsed<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetTicks64()
		{
			ulong ret = GetTicks64Native();
			return ret;
		}

		/// <summary>
		/// Get the current value of the high resolution counter.<br/>
		/// This function is typically used for profiling.<br/>
		/// The counter values are only meaningful relative to each other. Differences<br/>
		/// between values can be converted to times by using<br/>
		/// SDL_GetPerformanceFrequency().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetPerformanceCounterNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[823])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[823])();
			#endif
		}

		/// <summary>
		/// Get the current value of the high resolution counter.<br/>
		/// This function is typically used for profiling.<br/>
		/// The counter values are only meaningful relative to each other. Differences<br/>
		/// between values can be converted to times by using<br/>
		/// SDL_GetPerformanceFrequency().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetPerformanceCounter()
		{
			ulong ret = GetPerformanceCounterNative();
			return ret;
		}

		/// <summary>
		/// Get the count per second of the high resolution counter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetPerformanceFrequencyNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[824])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[824])();
			#endif
		}

		/// <summary>
		/// Get the count per second of the high resolution counter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetPerformanceFrequency()
		{
			ulong ret = GetPerformanceFrequencyNative();
			return ret;
		}

		/// <summary>
		/// Wait a specified number of milliseconds before returning.<br/>
		/// This function waits a specified number of milliseconds before returning. It<br/>
		/// waits at least the specified time, but possibly longer due to OS<br/>
		/// scheduling.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DelayNative(uint ms)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[825])(ms);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[825])(ms);
			#endif
		}

		/// <summary>
		/// Wait a specified number of milliseconds before returning.<br/>
		/// This function waits a specified number of milliseconds before returning. It<br/>
		/// waits at least the specified time, but possibly longer due to OS<br/>
		/// scheduling.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void Delay(uint ms)
		{
			DelayNative(ms);
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled.<br/>
		/// The callback is run on a separate thread.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddTimerNative(uint interval, delegate*<uint, void*, uint> callback, void* param)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<uint, void*, uint>, void*, int>)funcTable[826])(interval, callback, param);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, int>)funcTable[826])(interval, (nint)callback, (nint)param);
			#endif
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled.<br/>
		/// The callback is run on a separate thread.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddTimer(uint interval, delegate*<uint, void*, uint> callback, void* param)
		{
			int ret = AddTimerNative(interval, callback, param);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled.<br/>
		/// The callback is run on a separate thread.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddTimer(uint interval, SDLTimerCallback callback, void* param)
		{
			int ret = AddTimerNative(interval, (delegate*<uint, void*, uint>)Utils.GetFunctionPointerForDelegate(callback), param);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled.<br/>
		/// The callback is run on a separate thread.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddTimer(uint interval, delegate*<uint, void*, uint> callback, nint param)
		{
			int ret = AddTimerNative(interval, callback, (void*)param);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled.<br/>
		/// The callback is run on a separate thread.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddTimer(uint interval, SDLTimerCallback callback, nint param)
		{
			int ret = AddTimerNative(interval, (delegate*<uint, void*, uint>)Utils.GetFunctionPointerForDelegate(callback), (void*)param);
			return ret;
		}

		/// <summary>
		/// Remove a timer created with SDL_AddTimer().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool RemoveTimerNative(int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[827])(id);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<int, SDLBool>)funcTable[827])(id);
			#endif
		}

		/// <summary>
		/// Remove a timer created with SDL_AddTimer().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool RemoveTimer(int id)
		{
			SDLBool ret = RemoveTimerNative(id);
			return ret;
		}

		/// <summary>
		/// Get the version of SDL that is linked against your program.<br/>
		/// If you are linking to SDL dynamically, then it is possible that the current<br/>
		/// version will be different than the version you compiled against. This<br/>
		/// function returns the current version, while SDL_VERSION() is a macro that<br/>
		/// tells you what version you compiled with.<br/>
		/// This function may be called safely at any time, even before SDL_Init().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVersionNative(SDLVersion* ver)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLVersion*, void>)funcTable[828])(ver);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[828])((nint)ver);
			#endif
		}

		/// <summary>
		/// Get the version of SDL that is linked against your program.<br/>
		/// If you are linking to SDL dynamically, then it is possible that the current<br/>
		/// version will be different than the version you compiled against. This<br/>
		/// function returns the current version, while SDL_VERSION() is a macro that<br/>
		/// tells you what version you compiled with.<br/>
		/// This function may be called safely at any time, even before SDL_Init().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetVersion(SDLVersionPtr ver)
		{
			GetVersionNative((SDLVersion*)ver);
		}

		/// <summary>
		/// Get the version of SDL that is linked against your program.<br/>
		/// If you are linking to SDL dynamically, then it is possible that the current<br/>
		/// version will be different than the version you compiled against. This<br/>
		/// function returns the current version, while SDL_VERSION() is a macro that<br/>
		/// tells you what version you compiled with.<br/>
		/// This function may be called safely at any time, even before SDL_Init().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetVersion(ref SDLVersion ver)
		{
			fixed (SDLVersion* pver = &ver)
			{
				GetVersionNative((SDLVersion*)pver);
			}
		}

		/// <summary>
		/// Get the code revision of SDL that is linked against your program.<br/>
		/// This value is the revision of the code you are linked with and may be<br/>
		/// different from the code you are compiling with, which is found in the<br/>
		/// constant SDL_REVISION.<br/>
		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
		/// exact revision of the SDL library in use, and is only useful in comparing<br/>
		/// against other revisions. It is NOT an incrementing number.<br/>
		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
		/// will return an empty string.<br/>
		/// Prior to SDL 2.0.16, before development moved to GitHub, this returned a<br/>
		/// hash for a Mercurial repository.<br/>
		/// You shouldn't use this function for anything but logging it for debugging<br/>
		/// purposes. The string is not intended to be reliable in any way.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetRevisionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[829])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[829])();
			#endif
		}

		/// <summary>
		/// Get the code revision of SDL that is linked against your program.<br/>
		/// This value is the revision of the code you are linked with and may be<br/>
		/// different from the code you are compiling with, which is found in the<br/>
		/// constant SDL_REVISION.<br/>
		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
		/// exact revision of the SDL library in use, and is only useful in comparing<br/>
		/// against other revisions. It is NOT an incrementing number.<br/>
		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
		/// will return an empty string.<br/>
		/// Prior to SDL 2.0.16, before development moved to GitHub, this returned a<br/>
		/// hash for a Mercurial repository.<br/>
		/// You shouldn't use this function for anything but logging it for debugging<br/>
		/// purposes. The string is not intended to be reliable in any way.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetRevision()
		{
			byte* ret = GetRevisionNative();
			return ret;
		}

		/// <summary>
		/// Get the code revision of SDL that is linked against your program.<br/>
		/// This value is the revision of the code you are linked with and may be<br/>
		/// different from the code you are compiling with, which is found in the<br/>
		/// constant SDL_REVISION.<br/>
		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
		/// exact revision of the SDL library in use, and is only useful in comparing<br/>
		/// against other revisions. It is NOT an incrementing number.<br/>
		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
		/// will return an empty string.<br/>
		/// Prior to SDL 2.0.16, before development moved to GitHub, this returned a<br/>
		/// hash for a Mercurial repository.<br/>
		/// You shouldn't use this function for anything but logging it for debugging<br/>
		/// purposes. The string is not intended to be reliable in any way.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetRevisionS()
		{
			string ret = Utils.DecodeStringUTF8(GetRevisionNative());
			return ret;
		}

		/// <summary>
		/// Obsolete function, do not use.<br/>
		/// When SDL was hosted in a Mercurial repository, and was built carefully,<br/>
		/// this would return the revision number that the build was created from. This<br/>
		/// number was not reliable for several reasons, but more importantly, SDL is<br/>
		/// now hosted in a git repository, which does not offer numbers at all, only<br/>
		/// hashes. This function only ever returns zero now. Don't use it.<br/>
		/// Before SDL 2.0.16, this might have returned an unreliable, but non-zero<br/>
		/// number.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRevisionNumberNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[830])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[830])();
			#endif
		}

		/// <summary>
		/// Obsolete function, do not use.<br/>
		/// When SDL was hosted in a Mercurial repository, and was built carefully,<br/>
		/// this would return the revision number that the build was created from. This<br/>
		/// number was not reliable for several reasons, but more importantly, SDL is<br/>
		/// now hosted in a git repository, which does not offer numbers at all, only<br/>
		/// hashes. This function only ever returns zero now. Don't use it.<br/>
		/// Before SDL 2.0.16, this might have returned an unreliable, but non-zero<br/>
		/// number.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRevisionNumber()
		{
			int ret = GetRevisionNumberNative();
			return ret;
		}

		/// <summary>
		/// Report the user's preferred locale.<br/>
		/// This returns an array of SDL_Locale structs, the final item zeroed out.<br/>
		/// When the caller is done with this array, it should call SDL_free() on the<br/>
		/// returned value; all the memory involved is allocated in a single block, so<br/>
		/// a single SDL_free() will suffice.<br/>
		/// Returned language strings are in the format xx, where 'xx' is an ISO-639<br/>
		/// language specifier (such as "en" for English, "de" for German, etc).<br/>
		/// Country strings are in the format YY, where "YY" is an ISO-3166 country<br/>
		/// code (such as "US" for the United States, "CA" for Canada, etc). Country<br/>
		/// might be NULL if there's no specific guidance on them (so you might get {<br/>
		/// "en", "US" } for American English, but { "en", NULL } means "English<br/>
		/// language, generically"). Language strings are never NULL, except to<br/>
		/// terminate the array.<br/>
		/// Please note that not all of these strings are 2 characters; some are three<br/>
		/// or more.<br/>
		/// The returned list of locales are in the order of the user's preference. For<br/>
		/// example, a German citizen that is fluent in US English and knows enough<br/>
		/// Japanese to navigate around Tokyo might have a list like: { "de", "en_US",<br/>
		/// "jp", NULL }. Someone from England might prefer British English (where<br/>
		/// "color" is spelled "colour", etc), but will settle for anything like it: {<br/>
		/// "en_GB", "en", NULL }.<br/>
		/// This function returns NULL on error, including when the platform does not<br/>
		/// supply this information at all.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, this list can<br/>
		/// change, usually because the user has changed a system preference outside of<br/>
		/// your program; SDL will send an SDL_LOCALECHANGED event in this case, if<br/>
		/// possible, and you can call this function again to get an updated copy of<br/>
		/// preferred locales.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLLocale* GetPreferredLocalesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLLocale*>)funcTable[831])();
			#else
			return (SDLLocale*)((delegate* unmanaged[Cdecl]<nint>)funcTable[831])();
			#endif
		}

		/// <summary>
		/// Report the user's preferred locale.<br/>
		/// This returns an array of SDL_Locale structs, the final item zeroed out.<br/>
		/// When the caller is done with this array, it should call SDL_free() on the<br/>
		/// returned value; all the memory involved is allocated in a single block, so<br/>
		/// a single SDL_free() will suffice.<br/>
		/// Returned language strings are in the format xx, where 'xx' is an ISO-639<br/>
		/// language specifier (such as "en" for English, "de" for German, etc).<br/>
		/// Country strings are in the format YY, where "YY" is an ISO-3166 country<br/>
		/// code (such as "US" for the United States, "CA" for Canada, etc). Country<br/>
		/// might be NULL if there's no specific guidance on them (so you might get {<br/>
		/// "en", "US" } for American English, but { "en", NULL } means "English<br/>
		/// language, generically"). Language strings are never NULL, except to<br/>
		/// terminate the array.<br/>
		/// Please note that not all of these strings are 2 characters; some are three<br/>
		/// or more.<br/>
		/// The returned list of locales are in the order of the user's preference. For<br/>
		/// example, a German citizen that is fluent in US English and knows enough<br/>
		/// Japanese to navigate around Tokyo might have a list like: { "de", "en_US",<br/>
		/// "jp", NULL }. Someone from England might prefer British English (where<br/>
		/// "color" is spelled "colour", etc), but will settle for anything like it: {<br/>
		/// "en_GB", "en", NULL }.<br/>
		/// This function returns NULL on error, including when the platform does not<br/>
		/// supply this information at all.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, this list can<br/>
		/// change, usually because the user has changed a system preference outside of<br/>
		/// your program; SDL will send an SDL_LOCALECHANGED event in this case, if<br/>
		/// possible, and you can call this function again to get an updated copy of<br/>
		/// preferred locales.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLLocalePtr GetPreferredLocales()
		{
			SDLLocalePtr ret = GetPreferredLocalesNative();
			return ret;
		}

		/// <summary>
		/// Open a URL/URI in the browser or other appropriate external application.<br/>
		/// Open a URL in a separate, system-provided application. How this works will<br/>
		/// vary wildly depending on the platform. This will likely launch what makes<br/>
		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>
		/// etc), but it might also be able to launch file managers for directories and<br/>
		/// other things.<br/>
		/// What happens when you open a URL varies wildly as well: your game window<br/>
		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>
		/// or grabbing input at the time). On mobile devices, your app will likely<br/>
		/// move to the background or your process might be paused. Any given platform<br/>
		/// may or may not handle a given URL.<br/>
		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>
		/// fail with an error. A successful result does not mean the URL loaded, just<br/>
		/// that we launched _something_ to handle it (or at least believe we did).<br/>
		/// All this to say: this function can be useful, but you should definitely<br/>
		/// test it on every platform you target.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OpenURLNative(byte* url)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[832])(url);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[832])((nint)url);
			#endif
		}

		/// <summary>
		/// Open a URL/URI in the browser or other appropriate external application.<br/>
		/// Open a URL in a separate, system-provided application. How this works will<br/>
		/// vary wildly depending on the platform. This will likely launch what makes<br/>
		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>
		/// etc), but it might also be able to launch file managers for directories and<br/>
		/// other things.<br/>
		/// What happens when you open a URL varies wildly as well: your game window<br/>
		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>
		/// or grabbing input at the time). On mobile devices, your app will likely<br/>
		/// move to the background or your process might be paused. Any given platform<br/>
		/// may or may not handle a given URL.<br/>
		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>
		/// fail with an error. A successful result does not mean the URL loaded, just<br/>
		/// that we launched _something_ to handle it (or at least believe we did).<br/>
		/// All this to say: this function can be useful, but you should definitely<br/>
		/// test it on every platform you target.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenURL(byte* url)
		{
			int ret = OpenURLNative(url);
			return ret;
		}

		/// <summary>
		/// Open a URL/URI in the browser or other appropriate external application.<br/>
		/// Open a URL in a separate, system-provided application. How this works will<br/>
		/// vary wildly depending on the platform. This will likely launch what makes<br/>
		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>
		/// etc), but it might also be able to launch file managers for directories and<br/>
		/// other things.<br/>
		/// What happens when you open a URL varies wildly as well: your game window<br/>
		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>
		/// or grabbing input at the time). On mobile devices, your app will likely<br/>
		/// move to the background or your process might be paused. Any given platform<br/>
		/// may or may not handle a given URL.<br/>
		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>
		/// fail with an error. A successful result does not mean the URL loaded, just<br/>
		/// that we launched _something_ to handle it (or at least believe we did).<br/>
		/// All this to say: this function can be useful, but you should definitely<br/>
		/// test it on every platform you target.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenURL(in byte url)
		{
			fixed (byte* purl = &url)
			{
				int ret = OpenURLNative((byte*)purl);
				return ret;
			}
		}

		/// <summary>
		/// Open a URL/URI in the browser or other appropriate external application.<br/>
		/// Open a URL in a separate, system-provided application. How this works will<br/>
		/// vary wildly depending on the platform. This will likely launch what makes<br/>
		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>
		/// etc), but it might also be able to launch file managers for directories and<br/>
		/// other things.<br/>
		/// What happens when you open a URL varies wildly as well: your game window<br/>
		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>
		/// or grabbing input at the time). On mobile devices, your app will likely<br/>
		/// move to the background or your process might be paused. Any given platform<br/>
		/// may or may not handle a given URL.<br/>
		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>
		/// fail with an error. A successful result does not mean the URL loaded, just<br/>
		/// that we launched _something_ to handle it (or at least believe we did).<br/>
		/// All this to say: this function can be useful, but you should definitely<br/>
		/// test it on every platform you target.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenURL(ReadOnlySpan<byte> url)
		{
			fixed (byte* purl = url)
			{
				int ret = OpenURLNative((byte*)purl);
				return ret;
			}
		}

		/// <summary>
		/// Open a URL/URI in the browser or other appropriate external application.<br/>
		/// Open a URL in a separate, system-provided application. How this works will<br/>
		/// vary wildly depending on the platform. This will likely launch what makes<br/>
		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>
		/// etc), but it might also be able to launch file managers for directories and<br/>
		/// other things.<br/>
		/// What happens when you open a URL varies wildly as well: your game window<br/>
		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>
		/// or grabbing input at the time). On mobile devices, your app will likely<br/>
		/// move to the background or your process might be paused. Any given platform<br/>
		/// may or may not handle a given URL.<br/>
		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>
		/// fail with an error. A successful result does not mean the URL loaded, just<br/>
		/// that we launched _something_ to handle it (or at least believe we did).<br/>
		/// All this to say: this function can be useful, but you should definitely<br/>
		/// test it on every platform you target.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int OpenURL(string url)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (url != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(url);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(url, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = OpenURLNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Initialize the SDL library.<br/>
		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
		/// two may be used interchangeably. Though for readability of your code<br/>
		/// SDL_InitSubSystem() might be preferred.<br/>
		/// The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)<br/>
		/// subsystems are initialized by default. Message boxes<br/>
		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
		/// use them in your application.<br/>
		/// Logging (such as SDL_Log) works without initialization, too.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_INIT_TIMER`: timer subsystem<br/>
		/// - `SDL_INIT_AUDIO`: audio subsystem<br/>
		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
		/// events subsystem<br/>
		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
		/// - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically<br/>
		/// initializes the joystick subsystem<br/>
		/// - `SDL_INIT_EVENTS`: events subsystem<br/>
		/// - `SDL_INIT_EVERYTHING`: all of the above subsystems<br/>
		/// - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored<br/>
		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
		/// this call will increase the ref-count and return.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InitNative(uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int>)funcTable[833])(flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, int>)funcTable[833])(flags);
			#endif
		}

		/// <summary>
		/// Initialize the SDL library.<br/>
		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
		/// two may be used interchangeably. Though for readability of your code<br/>
		/// SDL_InitSubSystem() might be preferred.<br/>
		/// The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)<br/>
		/// subsystems are initialized by default. Message boxes<br/>
		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
		/// use them in your application.<br/>
		/// Logging (such as SDL_Log) works without initialization, too.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_INIT_TIMER`: timer subsystem<br/>
		/// - `SDL_INIT_AUDIO`: audio subsystem<br/>
		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
		/// events subsystem<br/>
		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
		/// - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically<br/>
		/// initializes the joystick subsystem<br/>
		/// - `SDL_INIT_EVENTS`: events subsystem<br/>
		/// - `SDL_INIT_EVERYTHING`: all of the above subsystems<br/>
		/// - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored<br/>
		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
		/// this call will increase the ref-count and return.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Init(uint flags)
		{
			int ret = InitNative(flags);
			return ret;
		}

		/// <summary>
		/// Compatibility function to initialize the SDL library.<br/>
		/// In SDL2, this function and SDL_Init() are interchangeable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InitSubSystemNative(uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int>)funcTable[834])(flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, int>)funcTable[834])(flags);
			#endif
		}

		/// <summary>
		/// Compatibility function to initialize the SDL library.<br/>
		/// In SDL2, this function and SDL_Init() are interchangeable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int InitSubSystem(uint flags)
		{
			int ret = InitSubSystemNative(flags);
			return ret;
		}

		/// <summary>
		/// Shut down specific SDL subsystems.<br/>
		/// If you start a subsystem using a call to that subsystem's init function<br/>
		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>
		/// SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use<br/>
		/// that subsystem's quit function (SDL_VideoQuit()) directly instead. But<br/>
		/// generally, you should not be using those functions directly anyhow; use<br/>
		/// SDL_Init() instead.<br/>
		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
		/// with SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuitSubSystemNative(uint flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[835])(flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[835])(flags);
			#endif
		}

		/// <summary>
		/// Shut down specific SDL subsystems.<br/>
		/// If you start a subsystem using a call to that subsystem's init function<br/>
		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>
		/// SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use<br/>
		/// that subsystem's quit function (SDL_VideoQuit()) directly instead. But<br/>
		/// generally, you should not be using those functions directly anyhow; use<br/>
		/// SDL_Init() instead.<br/>
		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
		/// with SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void QuitSubSystem(uint flags)
		{
			QuitSubSystemNative(flags);
		}

		/// <summary>
		/// Get a mask of the specified subsystems which are currently initialized.<br/>
		/// <br/>
		/// The return value does not include SDL_INIT_NOPARACHUTE.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint WasInitNative(uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[836])(flags);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[836])(flags);
			#endif
		}

		/// <summary>
		/// Get a mask of the specified subsystems which are currently initialized.<br/>
		/// <br/>
		/// The return value does not include SDL_INIT_NOPARACHUTE.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint WasInit(uint flags)
		{
			uint ret = WasInitNative(flags);
			return ret;
		}

		/// <summary>
		/// Clean up all initialized subsystems.<br/>
		/// You should call this function even if you have already shutdown each<br/>
		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
		/// function even in the case of errors in initialization.<br/>
		/// If you start a subsystem using a call to that subsystem's init function<br/>
		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>
		/// then you must use that subsystem's quit function (SDL_VideoQuit()) to shut<br/>
		/// it down before calling SDL_Quit(). But generally, you should not be using<br/>
		/// those functions directly anyhow; use SDL_Init() instead.<br/>
		/// You can use this function with atexit() to ensure that it is run when your<br/>
		/// application is shutdown, but it is not wise to do this from a library or<br/>
		/// other dynamically loaded code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[837])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[837])();
			#endif
		}

		/// <summary>
		/// Clean up all initialized subsystems.<br/>
		/// You should call this function even if you have already shutdown each<br/>
		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
		/// function even in the case of errors in initialization.<br/>
		/// If you start a subsystem using a call to that subsystem's init function<br/>
		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>
		/// then you must use that subsystem's quit function (SDL_VideoQuit()) to shut<br/>
		/// it down before calling SDL_Quit(). But generally, you should not be using<br/>
		/// those functions directly anyhow; use SDL_Init() instead.<br/>
		/// You can use this function with atexit() to ensure that it is run when your<br/>
		/// application is shutdown, but it is not wise to do this from a library or<br/>
		/// other dynamically loaded code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void Quit()
		{
			QuitNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglChooseConfigNative(void* dpy, int* attribList, void** configs, int configSize, int* numConfig)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int*, void**, int, int*, uint>)funcTable[838])(dpy, attribList, configs, configSize, numConfig);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, uint>)funcTable[838])((nint)dpy, (nint)attribList, (nint)configs, configSize, (nint)numConfig);
			#endif
		}

		public static uint EglChooseConfig(void* dpy, int* attribList, void** configs, int configSize, int* numConfig)
		{
			uint ret = EglChooseConfigNative(dpy, attribList, configs, configSize, numConfig);
			return ret;
		}

		public static uint EglChooseConfig(nint dpy, int* attribList, void** configs, int configSize, int* numConfig)
		{
			uint ret = EglChooseConfigNative((void*)dpy, attribList, configs, configSize, numConfig);
			return ret;
		}

		public static uint EglChooseConfig(void* dpy, in int attribList, void** configs, int configSize, int* numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				uint ret = EglChooseConfigNative(dpy, (int*)pattribList, configs, configSize, numConfig);
				return ret;
			}
		}

		public static uint EglChooseConfig(nint dpy, in int attribList, void** configs, int configSize, int* numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				uint ret = EglChooseConfigNative((void*)dpy, (int*)pattribList, configs, configSize, numConfig);
				return ret;
			}
		}

		public static uint EglChooseConfig(void* dpy, int* attribList, ref nint configs, int configSize, int* numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				uint ret = EglChooseConfigNative(dpy, attribList, (void**)pconfigs, configSize, numConfig);
				return ret;
			}
		}

		public static uint EglChooseConfig(nint dpy, int* attribList, ref nint configs, int configSize, int* numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				uint ret = EglChooseConfigNative((void*)dpy, attribList, (void**)pconfigs, configSize, numConfig);
				return ret;
			}
		}

		public static uint EglChooseConfig(void* dpy, in int attribList, ref nint configs, int configSize, int* numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (nint* pconfigs = &configs)
				{
					uint ret = EglChooseConfigNative(dpy, (int*)pattribList, (void**)pconfigs, configSize, numConfig);
					return ret;
				}
			}
		}

		public static uint EglChooseConfig(nint dpy, in int attribList, ref nint configs, int configSize, int* numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (nint* pconfigs = &configs)
				{
					uint ret = EglChooseConfigNative((void*)dpy, (int*)pattribList, (void**)pconfigs, configSize, numConfig);
					return ret;
				}
			}
		}

		public static uint EglChooseConfig(void* dpy, int* attribList, void** configs, int configSize, ref int numConfig)
		{
			fixed (int* pnumConfig = &numConfig)
			{
				uint ret = EglChooseConfigNative(dpy, attribList, configs, configSize, (int*)pnumConfig);
				return ret;
			}
		}

		public static uint EglChooseConfig(nint dpy, int* attribList, void** configs, int configSize, ref int numConfig)
		{
			fixed (int* pnumConfig = &numConfig)
			{
				uint ret = EglChooseConfigNative((void*)dpy, attribList, configs, configSize, (int*)pnumConfig);
				return ret;
			}
		}

		public static uint EglChooseConfig(void* dpy, in int attribList, void** configs, int configSize, ref int numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglChooseConfigNative(dpy, (int*)pattribList, configs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		public static uint EglChooseConfig(nint dpy, in int attribList, void** configs, int configSize, ref int numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglChooseConfigNative((void*)dpy, (int*)pattribList, configs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		public static uint EglChooseConfig(void* dpy, int* attribList, ref nint configs, int configSize, ref int numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglChooseConfigNative(dpy, attribList, (void**)pconfigs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		public static uint EglChooseConfig(nint dpy, int* attribList, ref nint configs, int configSize, ref int numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglChooseConfigNative((void*)dpy, attribList, (void**)pconfigs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		public static uint EglChooseConfig(void* dpy, in int attribList, ref nint configs, int configSize, ref int numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (nint* pconfigs = &configs)
				{
					fixed (int* pnumConfig = &numConfig)
					{
						uint ret = EglChooseConfigNative(dpy, (int*)pattribList, (void**)pconfigs, configSize, (int*)pnumConfig);
						return ret;
					}
				}
			}
		}

		public static uint EglChooseConfig(nint dpy, in int attribList, ref nint configs, int configSize, ref int numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (nint* pconfigs = &configs)
				{
					fixed (int* pnumConfig = &numConfig)
					{
						uint ret = EglChooseConfigNative((void*)dpy, (int*)pattribList, (void**)pconfigs, configSize, (int*)pnumConfig);
						return ret;
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglCopyBuffersNative(void* dpy, void* surface, nint target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nint, uint>)funcTable[839])(dpy, surface, target);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[839])((nint)dpy, (nint)surface, target);
			#endif
		}

		public static uint EglCopyBuffers(void* dpy, void* surface, nint target)
		{
			uint ret = EglCopyBuffersNative(dpy, surface, target);
			return ret;
		}

		public static uint EglCopyBuffers(nint dpy, void* surface, nint target)
		{
			uint ret = EglCopyBuffersNative((void*)dpy, surface, target);
			return ret;
		}

		public static uint EglCopyBuffers(void* dpy, nint surface, nint target)
		{
			uint ret = EglCopyBuffersNative(dpy, (void*)surface, target);
			return ret;
		}

		public static uint EglCopyBuffers(nint dpy, nint surface, nint target)
		{
			uint ret = EglCopyBuffersNative((void*)dpy, (void*)surface, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreateContextNative(void* dpy, void* config, void* shareContext, int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, void*, int*, void*>)funcTable[840])(dpy, config, shareContext, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint>)funcTable[840])((nint)dpy, (nint)config, (nint)shareContext, (nint)attribList);
			#endif
		}

		public static void* EglCreateContext(void* dpy, void* config, void* shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative(dpy, config, shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(nint dpy, void* config, void* shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative((void*)dpy, config, shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(void* dpy, nint config, void* shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative(dpy, (void*)config, shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(nint dpy, nint config, void* shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative((void*)dpy, (void*)config, shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(void* dpy, void* config, nint shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative(dpy, config, (void*)shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(nint dpy, void* config, nint shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative((void*)dpy, config, (void*)shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(void* dpy, nint config, nint shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative(dpy, (void*)config, (void*)shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(nint dpy, nint config, nint shareContext, int* attribList)
		{
			void* ret = EglCreateContextNative((void*)dpy, (void*)config, (void*)shareContext, attribList);
			return ret;
		}

		public static void* EglCreateContext(void* dpy, void* config, void* shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative(dpy, config, shareContext, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateContext(nint dpy, void* config, void* shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative((void*)dpy, config, shareContext, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateContext(void* dpy, nint config, void* shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative(dpy, (void*)config, shareContext, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateContext(nint dpy, nint config, void* shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative((void*)dpy, (void*)config, shareContext, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateContext(void* dpy, void* config, nint shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative(dpy, config, (void*)shareContext, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateContext(nint dpy, void* config, nint shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative((void*)dpy, config, (void*)shareContext, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateContext(void* dpy, nint config, nint shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative(dpy, (void*)config, (void*)shareContext, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateContext(nint dpy, nint config, nint shareContext, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateContextNative((void*)dpy, (void*)config, (void*)shareContext, (int*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreatePbufferSurfaceNative(void* dpy, void* config, int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int*, void*>)funcTable[841])(dpy, config, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)funcTable[841])((nint)dpy, (nint)config, (nint)attribList);
			#endif
		}

		public static void* EglCreatePbufferSurface(void* dpy, void* config, int* attribList)
		{
			void* ret = EglCreatePbufferSurfaceNative(dpy, config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferSurface(nint dpy, void* config, int* attribList)
		{
			void* ret = EglCreatePbufferSurfaceNative((void*)dpy, config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferSurface(void* dpy, nint config, int* attribList)
		{
			void* ret = EglCreatePbufferSurfaceNative(dpy, (void*)config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferSurface(nint dpy, nint config, int* attribList)
		{
			void* ret = EglCreatePbufferSurfaceNative((void*)dpy, (void*)config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferSurface(void* dpy, void* config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferSurfaceNative(dpy, config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferSurface(nint dpy, void* config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferSurfaceNative((void*)dpy, config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferSurface(void* dpy, nint config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferSurfaceNative(dpy, (void*)config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferSurface(nint dpy, nint config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferSurfaceNative((void*)dpy, (void*)config, (int*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreatePixmapSurfaceNative(void* dpy, void* config, nint pixmap, int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nint, int*, void*>)funcTable[842])(dpy, config, pixmap, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint>)funcTable[842])((nint)dpy, (nint)config, pixmap, (nint)attribList);
			#endif
		}

		public static void* EglCreatePixmapSurface(void* dpy, void* config, nint pixmap, int* attribList)
		{
			void* ret = EglCreatePixmapSurfaceNative(dpy, config, pixmap, attribList);
			return ret;
		}

		public static void* EglCreatePixmapSurface(nint dpy, void* config, nint pixmap, int* attribList)
		{
			void* ret = EglCreatePixmapSurfaceNative((void*)dpy, config, pixmap, attribList);
			return ret;
		}

		public static void* EglCreatePixmapSurface(void* dpy, nint config, nint pixmap, int* attribList)
		{
			void* ret = EglCreatePixmapSurfaceNative(dpy, (void*)config, pixmap, attribList);
			return ret;
		}

		public static void* EglCreatePixmapSurface(nint dpy, nint config, nint pixmap, int* attribList)
		{
			void* ret = EglCreatePixmapSurfaceNative((void*)dpy, (void*)config, pixmap, attribList);
			return ret;
		}

		public static void* EglCreatePixmapSurface(void* dpy, void* config, nint pixmap, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePixmapSurfaceNative(dpy, config, pixmap, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePixmapSurface(nint dpy, void* config, nint pixmap, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePixmapSurfaceNative((void*)dpy, config, pixmap, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePixmapSurface(void* dpy, nint config, nint pixmap, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePixmapSurfaceNative(dpy, (void*)config, pixmap, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePixmapSurface(nint dpy, nint config, nint pixmap, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePixmapSurfaceNative((void*)dpy, (void*)config, pixmap, (int*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreateWindowSurfaceNative(void* dpy, void* config, nint win, int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nint, int*, void*>)funcTable[843])(dpy, config, win, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint>)funcTable[843])((nint)dpy, (nint)config, win, (nint)attribList);
			#endif
		}

		public static void* EglCreateWindowSurface(void* dpy, void* config, nint win, int* attribList)
		{
			void* ret = EglCreateWindowSurfaceNative(dpy, config, win, attribList);
			return ret;
		}

		public static void* EglCreateWindowSurface(nint dpy, void* config, nint win, int* attribList)
		{
			void* ret = EglCreateWindowSurfaceNative((void*)dpy, config, win, attribList);
			return ret;
		}

		public static void* EglCreateWindowSurface(void* dpy, nint config, nint win, int* attribList)
		{
			void* ret = EglCreateWindowSurfaceNative(dpy, (void*)config, win, attribList);
			return ret;
		}

		public static void* EglCreateWindowSurface(nint dpy, nint config, nint win, int* attribList)
		{
			void* ret = EglCreateWindowSurfaceNative((void*)dpy, (void*)config, win, attribList);
			return ret;
		}

		public static void* EglCreateWindowSurface(void* dpy, void* config, nint win, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateWindowSurfaceNative(dpy, config, win, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateWindowSurface(nint dpy, void* config, nint win, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateWindowSurfaceNative((void*)dpy, config, win, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateWindowSurface(void* dpy, nint config, nint win, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateWindowSurfaceNative(dpy, (void*)config, win, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateWindowSurface(nint dpy, nint config, nint win, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreateWindowSurfaceNative((void*)dpy, (void*)config, win, (int*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroyContextNative(void* dpy, void* ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, uint>)funcTable[844])(dpy, ctx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[844])((nint)dpy, (nint)ctx);
			#endif
		}

		public static uint EglDestroyContext(void* dpy, void* ctx)
		{
			uint ret = EglDestroyContextNative(dpy, ctx);
			return ret;
		}

		public static uint EglDestroyContext(nint dpy, void* ctx)
		{
			uint ret = EglDestroyContextNative((void*)dpy, ctx);
			return ret;
		}

		public static uint EglDestroyContext(void* dpy, nint ctx)
		{
			uint ret = EglDestroyContextNative(dpy, (void*)ctx);
			return ret;
		}

		public static uint EglDestroyContext(nint dpy, nint ctx)
		{
			uint ret = EglDestroyContextNative((void*)dpy, (void*)ctx);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroySurfaceNative(void* dpy, void* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, uint>)funcTable[845])(dpy, surface);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[845])((nint)dpy, (nint)surface);
			#endif
		}

		public static uint EglDestroySurface(void* dpy, void* surface)
		{
			uint ret = EglDestroySurfaceNative(dpy, surface);
			return ret;
		}

		public static uint EglDestroySurface(nint dpy, void* surface)
		{
			uint ret = EglDestroySurfaceNative((void*)dpy, surface);
			return ret;
		}

		public static uint EglDestroySurface(void* dpy, nint surface)
		{
			uint ret = EglDestroySurfaceNative(dpy, (void*)surface);
			return ret;
		}

		public static uint EglDestroySurface(nint dpy, nint surface)
		{
			uint ret = EglDestroySurfaceNative((void*)dpy, (void*)surface);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglGetConfigAttribNative(void* dpy, void* config, int attribute, int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, int*, uint>)funcTable[846])(dpy, config, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, uint>)funcTable[846])((nint)dpy, (nint)config, attribute, (nint)value);
			#endif
		}

		public static uint EglGetConfigAttrib(void* dpy, void* config, int attribute, int* value)
		{
			uint ret = EglGetConfigAttribNative(dpy, config, attribute, value);
			return ret;
		}

		public static uint EglGetConfigAttrib(nint dpy, void* config, int attribute, int* value)
		{
			uint ret = EglGetConfigAttribNative((void*)dpy, config, attribute, value);
			return ret;
		}

		public static uint EglGetConfigAttrib(void* dpy, nint config, int attribute, int* value)
		{
			uint ret = EglGetConfigAttribNative(dpy, (void*)config, attribute, value);
			return ret;
		}

		public static uint EglGetConfigAttrib(nint dpy, nint config, int attribute, int* value)
		{
			uint ret = EglGetConfigAttribNative((void*)dpy, (void*)config, attribute, value);
			return ret;
		}

		public static uint EglGetConfigAttrib(void* dpy, void* config, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglGetConfigAttribNative(dpy, config, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglGetConfigAttrib(nint dpy, void* config, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglGetConfigAttribNative((void*)dpy, config, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglGetConfigAttrib(void* dpy, nint config, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglGetConfigAttribNative(dpy, (void*)config, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglGetConfigAttrib(nint dpy, nint config, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglGetConfigAttribNative((void*)dpy, (void*)config, attribute, (int*)pvalue);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglGetConfigsNative(void* dpy, void** configs, int configSize, int* numConfig)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void**, int, int*, uint>)funcTable[847])(dpy, configs, configSize, numConfig);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, uint>)funcTable[847])((nint)dpy, (nint)configs, configSize, (nint)numConfig);
			#endif
		}

		public static uint EglGetConfigs(void* dpy, void** configs, int configSize, int* numConfig)
		{
			uint ret = EglGetConfigsNative(dpy, configs, configSize, numConfig);
			return ret;
		}

		public static uint EglGetConfigs(nint dpy, void** configs, int configSize, int* numConfig)
		{
			uint ret = EglGetConfigsNative((void*)dpy, configs, configSize, numConfig);
			return ret;
		}

		public static uint EglGetConfigs(void* dpy, ref nint configs, int configSize, int* numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				uint ret = EglGetConfigsNative(dpy, (void**)pconfigs, configSize, numConfig);
				return ret;
			}
		}

		public static uint EglGetConfigs(nint dpy, ref nint configs, int configSize, int* numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				uint ret = EglGetConfigsNative((void*)dpy, (void**)pconfigs, configSize, numConfig);
				return ret;
			}
		}

		public static uint EglGetConfigs(void* dpy, void** configs, int configSize, ref int numConfig)
		{
			fixed (int* pnumConfig = &numConfig)
			{
				uint ret = EglGetConfigsNative(dpy, configs, configSize, (int*)pnumConfig);
				return ret;
			}
		}

		public static uint EglGetConfigs(nint dpy, void** configs, int configSize, ref int numConfig)
		{
			fixed (int* pnumConfig = &numConfig)
			{
				uint ret = EglGetConfigsNative((void*)dpy, configs, configSize, (int*)pnumConfig);
				return ret;
			}
		}

		public static uint EglGetConfigs(void* dpy, ref nint configs, int configSize, ref int numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglGetConfigsNative(dpy, (void**)pconfigs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		public static uint EglGetConfigs(nint dpy, ref nint configs, int configSize, ref int numConfig)
		{
			fixed (nint* pconfigs = &configs)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglGetConfigsNative((void*)dpy, (void**)pconfigs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglGetCurrentDisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*>)funcTable[848])();
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint>)funcTable[848])();
			#endif
		}

		public static void* EglGetCurrentDisplay()
		{
			void* ret = EglGetCurrentDisplayNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglGetCurrentSurfaceNative(int readdraw)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, void*>)funcTable[849])(readdraw);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[849])(readdraw);
			#endif
		}

		public static void* EglGetCurrentSurface(int readdraw)
		{
			void* ret = EglGetCurrentSurfaceNative(readdraw);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglGetDisplayNative(nint displayId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nint, void*>)funcTable[850])(displayId);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[850])(displayId);
			#endif
		}

		public static void* EglGetDisplay(nint displayId)
		{
			void* ret = EglGetDisplayNative(displayId);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EglGetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[851])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[851])();
			#endif
		}

		public static int EglGetError()
		{
			int ret = EglGetErrorNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> EglGetProcAddressNative(byte* procname)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[852])(procname);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[852])((nint)procname);
			#endif
		}

		public static delegate*<void> EglGetProcAddress(byte* procname)
		{
			delegate*<void> ret = EglGetProcAddressNative(procname);
			return ret;
		}

		public static delegate*<void> EglGetProcAddress(in byte procname)
		{
			fixed (byte* pprocname = &procname)
			{
				delegate*<void> ret = EglGetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		public static delegate*<void> EglGetProcAddress(ReadOnlySpan<byte> procname)
		{
			fixed (byte* pprocname = procname)
			{
				delegate*<void> ret = EglGetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		public static delegate*<void> EglGetProcAddress(string procname)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (procname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(procname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(procname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = EglGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglInitializeNative(void* dpy, int* major, int* minor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int*, int*, uint>)funcTable[853])(dpy, major, minor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[853])((nint)dpy, (nint)major, (nint)minor);
			#endif
		}

		public static uint EglInitialize(void* dpy, int* major, int* minor)
		{
			uint ret = EglInitializeNative(dpy, major, minor);
			return ret;
		}

		public static uint EglInitialize(nint dpy, int* major, int* minor)
		{
			uint ret = EglInitializeNative((void*)dpy, major, minor);
			return ret;
		}

		public static uint EglInitialize(void* dpy, ref int major, int* minor)
		{
			fixed (int* pmajor = &major)
			{
				uint ret = EglInitializeNative(dpy, (int*)pmajor, minor);
				return ret;
			}
		}

		public static uint EglInitialize(nint dpy, ref int major, int* minor)
		{
			fixed (int* pmajor = &major)
			{
				uint ret = EglInitializeNative((void*)dpy, (int*)pmajor, minor);
				return ret;
			}
		}

		public static uint EglInitialize(void* dpy, int* major, ref int minor)
		{
			fixed (int* pminor = &minor)
			{
				uint ret = EglInitializeNative(dpy, major, (int*)pminor);
				return ret;
			}
		}

		public static uint EglInitialize(nint dpy, int* major, ref int minor)
		{
			fixed (int* pminor = &minor)
			{
				uint ret = EglInitializeNative((void*)dpy, major, (int*)pminor);
				return ret;
			}
		}

		public static uint EglInitialize(void* dpy, ref int major, ref int minor)
		{
			fixed (int* pmajor = &major)
			{
				fixed (int* pminor = &minor)
				{
					uint ret = EglInitializeNative(dpy, (int*)pmajor, (int*)pminor);
					return ret;
				}
			}
		}

		public static uint EglInitialize(nint dpy, ref int major, ref int minor)
		{
			fixed (int* pmajor = &major)
			{
				fixed (int* pminor = &minor)
				{
					uint ret = EglInitializeNative((void*)dpy, (int*)pmajor, (int*)pminor);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglMakeCurrentNative(void* dpy, void* draw, void* read, void* ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, void*, void*, uint>)funcTable[854])(dpy, draw, read, ctx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, uint>)funcTable[854])((nint)dpy, (nint)draw, (nint)read, (nint)ctx);
			#endif
		}

		public static uint EglMakeCurrent(void* dpy, void* draw, void* read, void* ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, draw, read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, void* draw, void* read, void* ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, draw, read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(void* dpy, nint draw, void* read, void* ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, (void*)draw, read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, nint draw, void* read, void* ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, (void*)draw, read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(void* dpy, void* draw, nint read, void* ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, draw, (void*)read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, void* draw, nint read, void* ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, draw, (void*)read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(void* dpy, nint draw, nint read, void* ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, (void*)draw, (void*)read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, nint draw, nint read, void* ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, (void*)draw, (void*)read, ctx);
			return ret;
		}

		public static uint EglMakeCurrent(void* dpy, void* draw, void* read, nint ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, draw, read, (void*)ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, void* draw, void* read, nint ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, draw, read, (void*)ctx);
			return ret;
		}

		public static uint EglMakeCurrent(void* dpy, nint draw, void* read, nint ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, (void*)draw, read, (void*)ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, nint draw, void* read, nint ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, (void*)draw, read, (void*)ctx);
			return ret;
		}

		public static uint EglMakeCurrent(void* dpy, void* draw, nint read, nint ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, draw, (void*)read, (void*)ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, void* draw, nint read, nint ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, draw, (void*)read, (void*)ctx);
			return ret;
		}

		public static uint EglMakeCurrent(void* dpy, nint draw, nint read, nint ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, (void*)draw, (void*)read, (void*)ctx);
			return ret;
		}

		public static uint EglMakeCurrent(nint dpy, nint draw, nint read, nint ctx)
		{
			uint ret = EglMakeCurrentNative((void*)dpy, (void*)draw, (void*)read, (void*)ctx);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglQueryContextNative(void* dpy, void* ctx, int attribute, int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, int*, uint>)funcTable[855])(dpy, ctx, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, uint>)funcTable[855])((nint)dpy, (nint)ctx, attribute, (nint)value);
			#endif
		}

		public static uint EglQueryContext(void* dpy, void* ctx, int attribute, int* value)
		{
			uint ret = EglQueryContextNative(dpy, ctx, attribute, value);
			return ret;
		}

		public static uint EglQueryContext(nint dpy, void* ctx, int attribute, int* value)
		{
			uint ret = EglQueryContextNative((void*)dpy, ctx, attribute, value);
			return ret;
		}

		public static uint EglQueryContext(void* dpy, nint ctx, int attribute, int* value)
		{
			uint ret = EglQueryContextNative(dpy, (void*)ctx, attribute, value);
			return ret;
		}

		public static uint EglQueryContext(nint dpy, nint ctx, int attribute, int* value)
		{
			uint ret = EglQueryContextNative((void*)dpy, (void*)ctx, attribute, value);
			return ret;
		}

		public static uint EglQueryContext(void* dpy, void* ctx, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQueryContextNative(dpy, ctx, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglQueryContext(nint dpy, void* ctx, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQueryContextNative((void*)dpy, ctx, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglQueryContext(void* dpy, nint ctx, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQueryContextNative(dpy, (void*)ctx, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglQueryContext(nint dpy, nint ctx, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQueryContextNative((void*)dpy, (void*)ctx, attribute, (int*)pvalue);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* EglQueryStringNative(void* dpy, int name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, byte*>)funcTable[856])(dpy, name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[856])((nint)dpy, name);
			#endif
		}

		public static byte* EglQueryString(void* dpy, int name)
		{
			byte* ret = EglQueryStringNative(dpy, name);
			return ret;
		}

		public static string EglQueryStringS(void* dpy, int name)
		{
			string ret = Utils.DecodeStringUTF8(EglQueryStringNative(dpy, name));
			return ret;
		}

		public static byte* EglQueryString(nint dpy, int name)
		{
			byte* ret = EglQueryStringNative((void*)dpy, name);
			return ret;
		}

		public static string EglQueryStringS(nint dpy, int name)
		{
			string ret = Utils.DecodeStringUTF8(EglQueryStringNative((void*)dpy, name));
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglQuerySurfaceNative(void* dpy, void* surface, int attribute, int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, int*, uint>)funcTable[857])(dpy, surface, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, uint>)funcTable[857])((nint)dpy, (nint)surface, attribute, (nint)value);
			#endif
		}

		public static uint EglQuerySurface(void* dpy, void* surface, int attribute, int* value)
		{
			uint ret = EglQuerySurfaceNative(dpy, surface, attribute, value);
			return ret;
		}

		public static uint EglQuerySurface(nint dpy, void* surface, int attribute, int* value)
		{
			uint ret = EglQuerySurfaceNative((void*)dpy, surface, attribute, value);
			return ret;
		}

		public static uint EglQuerySurface(void* dpy, nint surface, int attribute, int* value)
		{
			uint ret = EglQuerySurfaceNative(dpy, (void*)surface, attribute, value);
			return ret;
		}

		public static uint EglQuerySurface(nint dpy, nint surface, int attribute, int* value)
		{
			uint ret = EglQuerySurfaceNative((void*)dpy, (void*)surface, attribute, value);
			return ret;
		}

		public static uint EglQuerySurface(void* dpy, void* surface, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQuerySurfaceNative(dpy, surface, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglQuerySurface(nint dpy, void* surface, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQuerySurfaceNative((void*)dpy, surface, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglQuerySurface(void* dpy, nint surface, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQuerySurfaceNative(dpy, (void*)surface, attribute, (int*)pvalue);
				return ret;
			}
		}

		public static uint EglQuerySurface(nint dpy, nint surface, int attribute, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQuerySurfaceNative((void*)dpy, (void*)surface, attribute, (int*)pvalue);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglSwapBuffersNative(void* dpy, void* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, uint>)funcTable[858])(dpy, surface);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[858])((nint)dpy, (nint)surface);
			#endif
		}

		public static uint EglSwapBuffers(void* dpy, void* surface)
		{
			uint ret = EglSwapBuffersNative(dpy, surface);
			return ret;
		}

		public static uint EglSwapBuffers(nint dpy, void* surface)
		{
			uint ret = EglSwapBuffersNative((void*)dpy, surface);
			return ret;
		}

		public static uint EglSwapBuffers(void* dpy, nint surface)
		{
			uint ret = EglSwapBuffersNative(dpy, (void*)surface);
			return ret;
		}

		public static uint EglSwapBuffers(nint dpy, nint surface)
		{
			uint ret = EglSwapBuffersNative((void*)dpy, (void*)surface);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglTerminateNative(void* dpy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, uint>)funcTable[859])(dpy);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[859])((nint)dpy);
			#endif
		}

		public static uint EglTerminate(void* dpy)
		{
			uint ret = EglTerminateNative(dpy);
			return ret;
		}

		public static uint EglTerminate(nint dpy)
		{
			uint ret = EglTerminateNative((void*)dpy);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitGLNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[860])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[860])();
			#endif
		}

		public static uint EglWaitGL()
		{
			uint ret = EglWaitGLNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitNativeNative(int engine)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[861])(engine);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[861])(engine);
			#endif
		}

		public static uint EglWaitNative(int engine)
		{
			uint ret = EglWaitNativeNative(engine);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglBindTexImageNative(void* dpy, void* surface, int buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, uint>)funcTable[862])(dpy, surface, buffer);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, uint>)funcTable[862])((nint)dpy, (nint)surface, buffer);
			#endif
		}

		public static uint EglBindTexImage(void* dpy, void* surface, int buffer)
		{
			uint ret = EglBindTexImageNative(dpy, surface, buffer);
			return ret;
		}

		public static uint EglBindTexImage(nint dpy, void* surface, int buffer)
		{
			uint ret = EglBindTexImageNative((void*)dpy, surface, buffer);
			return ret;
		}

		public static uint EglBindTexImage(void* dpy, nint surface, int buffer)
		{
			uint ret = EglBindTexImageNative(dpy, (void*)surface, buffer);
			return ret;
		}

		public static uint EglBindTexImage(nint dpy, nint surface, int buffer)
		{
			uint ret = EglBindTexImageNative((void*)dpy, (void*)surface, buffer);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglReleaseTexImageNative(void* dpy, void* surface, int buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, uint>)funcTable[863])(dpy, surface, buffer);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, uint>)funcTable[863])((nint)dpy, (nint)surface, buffer);
			#endif
		}

		public static uint EglReleaseTexImage(void* dpy, void* surface, int buffer)
		{
			uint ret = EglReleaseTexImageNative(dpy, surface, buffer);
			return ret;
		}

		public static uint EglReleaseTexImage(nint dpy, void* surface, int buffer)
		{
			uint ret = EglReleaseTexImageNative((void*)dpy, surface, buffer);
			return ret;
		}

		public static uint EglReleaseTexImage(void* dpy, nint surface, int buffer)
		{
			uint ret = EglReleaseTexImageNative(dpy, (void*)surface, buffer);
			return ret;
		}

		public static uint EglReleaseTexImage(nint dpy, nint surface, int buffer)
		{
			uint ret = EglReleaseTexImageNative((void*)dpy, (void*)surface, buffer);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglSurfaceAttribNative(void* dpy, void* surface, int attribute, int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, int, uint>)funcTable[864])(dpy, surface, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, int, uint>)funcTable[864])((nint)dpy, (nint)surface, attribute, value);
			#endif
		}

		public static uint EglSurfaceAttrib(void* dpy, void* surface, int attribute, int value)
		{
			uint ret = EglSurfaceAttribNative(dpy, surface, attribute, value);
			return ret;
		}

		public static uint EglSurfaceAttrib(nint dpy, void* surface, int attribute, int value)
		{
			uint ret = EglSurfaceAttribNative((void*)dpy, surface, attribute, value);
			return ret;
		}

		public static uint EglSurfaceAttrib(void* dpy, nint surface, int attribute, int value)
		{
			uint ret = EglSurfaceAttribNative(dpy, (void*)surface, attribute, value);
			return ret;
		}

		public static uint EglSurfaceAttrib(nint dpy, nint surface, int attribute, int value)
		{
			uint ret = EglSurfaceAttribNative((void*)dpy, (void*)surface, attribute, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglSwapIntervalNative(void* dpy, int interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, uint>)funcTable[865])(dpy, interval);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[865])((nint)dpy, interval);
			#endif
		}

		public static uint EglSwapInterval(void* dpy, int interval)
		{
			uint ret = EglSwapIntervalNative(dpy, interval);
			return ret;
		}

		public static uint EglSwapInterval(nint dpy, int interval)
		{
			uint ret = EglSwapIntervalNative((void*)dpy, interval);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglBindAPINative(uint api)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[866])(api);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[866])(api);
			#endif
		}

		public static uint EglBindAPI(uint api)
		{
			uint ret = EglBindAPINative(api);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglQueryAPINative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[867])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[867])();
			#endif
		}

		public static uint EglQueryAPI()
		{
			uint ret = EglQueryAPINative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreatePbufferFromClientBufferNative(void* dpy, uint buftype, void* buffer, void* config, int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, uint, void*, void*, int*, void*>)funcTable[868])(dpy, buftype, buffer, config, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, uint, nint, nint, nint, nint>)funcTable[868])((nint)dpy, buftype, (nint)buffer, (nint)config, (nint)attribList);
			#endif
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, void* buffer, void* config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, buffer, config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, void* buffer, void* config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, buffer, config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, nint buffer, void* config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, (void*)buffer, config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, nint buffer, void* config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, (void*)buffer, config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, void* buffer, nint config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, buffer, (void*)config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, void* buffer, nint config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, buffer, (void*)config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, nint buffer, nint config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, (void*)buffer, (void*)config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, nint buffer, nint config, int* attribList)
		{
			void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, (void*)buffer, (void*)config, attribList);
			return ret;
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, void* buffer, void* config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, buffer, config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, void* buffer, void* config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, buffer, config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, nint buffer, void* config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, (void*)buffer, config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, nint buffer, void* config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, (void*)buffer, config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, void* buffer, nint config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, buffer, (void*)config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, void* buffer, nint config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, buffer, (void*)config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferFromClientBuffer(void* dpy, uint buftype, nint buffer, nint config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, (void*)buffer, (void*)config, (int*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePbufferFromClientBuffer(nint dpy, uint buftype, nint buffer, nint config, in int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				void* ret = EglCreatePbufferFromClientBufferNative((void*)dpy, buftype, (void*)buffer, (void*)config, (int*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglReleaseThreadNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[869])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[869])();
			#endif
		}

		public static uint EglReleaseThread()
		{
			uint ret = EglReleaseThreadNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitClientNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[870])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[870])();
			#endif
		}

		public static uint EglWaitClient()
		{
			uint ret = EglWaitClientNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglGetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*>)funcTable[871])();
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint>)funcTable[871])();
			#endif
		}

		public static void* EglGetCurrentContext()
		{
			void* ret = EglGetCurrentContextNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreateSyncNative(void* dpy, uint type, nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, uint, nint*, void*>)funcTable[872])(dpy, type, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, uint, nint, nint>)funcTable[872])((nint)dpy, type, (nint)attribList);
			#endif
		}

		public static void* EglCreateSync(void* dpy, uint type, nint* attribList)
		{
			void* ret = EglCreateSyncNative(dpy, type, attribList);
			return ret;
		}

		public static void* EglCreateSync(nint dpy, uint type, nint* attribList)
		{
			void* ret = EglCreateSyncNative((void*)dpy, type, attribList);
			return ret;
		}

		public static void* EglCreateSync(void* dpy, uint type, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateSyncNative(dpy, type, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateSync(nint dpy, uint type, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateSyncNative((void*)dpy, type, (nint*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroySyncNative(void* dpy, void* sync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, uint>)funcTable[873])(dpy, sync);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[873])((nint)dpy, (nint)sync);
			#endif
		}

		public static uint EglDestroySync(void* dpy, void* sync)
		{
			uint ret = EglDestroySyncNative(dpy, sync);
			return ret;
		}

		public static uint EglDestroySync(nint dpy, void* sync)
		{
			uint ret = EglDestroySyncNative((void*)dpy, sync);
			return ret;
		}

		public static uint EglDestroySync(void* dpy, nint sync)
		{
			uint ret = EglDestroySyncNative(dpy, (void*)sync);
			return ret;
		}

		public static uint EglDestroySync(nint dpy, nint sync)
		{
			uint ret = EglDestroySyncNative((void*)dpy, (void*)sync);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EglClientWaitSyncNative(void* dpy, void* sync, int flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, ulong, int>)funcTable[874])(dpy, sync, flags, timeout);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, ulong, int>)funcTable[874])((nint)dpy, (nint)sync, flags, timeout);
			#endif
		}

		public static int EglClientWaitSync(void* dpy, void* sync, int flags, ulong timeout)
		{
			int ret = EglClientWaitSyncNative(dpy, sync, flags, timeout);
			return ret;
		}

		public static int EglClientWaitSync(nint dpy, void* sync, int flags, ulong timeout)
		{
			int ret = EglClientWaitSyncNative((void*)dpy, sync, flags, timeout);
			return ret;
		}

		public static int EglClientWaitSync(void* dpy, nint sync, int flags, ulong timeout)
		{
			int ret = EglClientWaitSyncNative(dpy, (void*)sync, flags, timeout);
			return ret;
		}

		public static int EglClientWaitSync(nint dpy, nint sync, int flags, ulong timeout)
		{
			int ret = EglClientWaitSyncNative((void*)dpy, (void*)sync, flags, timeout);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglGetSyncAttribNative(void* dpy, void* sync, int attribute, nint* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, nint*, uint>)funcTable[875])(dpy, sync, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, uint>)funcTable[875])((nint)dpy, (nint)sync, attribute, (nint)value);
			#endif
		}

		public static uint EglGetSyncAttrib(void* dpy, void* sync, int attribute, nint* value)
		{
			uint ret = EglGetSyncAttribNative(dpy, sync, attribute, value);
			return ret;
		}

		public static uint EglGetSyncAttrib(nint dpy, void* sync, int attribute, nint* value)
		{
			uint ret = EglGetSyncAttribNative((void*)dpy, sync, attribute, value);
			return ret;
		}

		public static uint EglGetSyncAttrib(void* dpy, nint sync, int attribute, nint* value)
		{
			uint ret = EglGetSyncAttribNative(dpy, (void*)sync, attribute, value);
			return ret;
		}

		public static uint EglGetSyncAttrib(nint dpy, nint sync, int attribute, nint* value)
		{
			uint ret = EglGetSyncAttribNative((void*)dpy, (void*)sync, attribute, value);
			return ret;
		}

		public static uint EglGetSyncAttrib(void* dpy, void* sync, int attribute, ref nint value)
		{
			fixed (nint* pvalue = &value)
			{
				uint ret = EglGetSyncAttribNative(dpy, sync, attribute, (nint*)pvalue);
				return ret;
			}
		}

		public static uint EglGetSyncAttrib(nint dpy, void* sync, int attribute, ref nint value)
		{
			fixed (nint* pvalue = &value)
			{
				uint ret = EglGetSyncAttribNative((void*)dpy, sync, attribute, (nint*)pvalue);
				return ret;
			}
		}

		public static uint EglGetSyncAttrib(void* dpy, nint sync, int attribute, ref nint value)
		{
			fixed (nint* pvalue = &value)
			{
				uint ret = EglGetSyncAttribNative(dpy, (void*)sync, attribute, (nint*)pvalue);
				return ret;
			}
		}

		public static uint EglGetSyncAttrib(nint dpy, nint sync, int attribute, ref nint value)
		{
			fixed (nint* pvalue = &value)
			{
				uint ret = EglGetSyncAttribNative((void*)dpy, (void*)sync, attribute, (nint*)pvalue);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreateImageNative(void* dpy, void* ctx, uint target, void* buffer, nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, uint, void*, nint*, void*>)funcTable[876])(dpy, ctx, target, buffer, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, nint, nint>)funcTable[876])((nint)dpy, (nint)ctx, target, (nint)buffer, (nint)attribList);
			#endif
		}

		public static void* EglCreateImage(void* dpy, void* ctx, uint target, void* buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative(dpy, ctx, target, buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(nint dpy, void* ctx, uint target, void* buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative((void*)dpy, ctx, target, buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(void* dpy, nint ctx, uint target, void* buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative(dpy, (void*)ctx, target, buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(nint dpy, nint ctx, uint target, void* buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative((void*)dpy, (void*)ctx, target, buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(void* dpy, void* ctx, uint target, nint buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative(dpy, ctx, target, (void*)buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(nint dpy, void* ctx, uint target, nint buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative((void*)dpy, ctx, target, (void*)buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(void* dpy, nint ctx, uint target, nint buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative(dpy, (void*)ctx, target, (void*)buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(nint dpy, nint ctx, uint target, nint buffer, nint* attribList)
		{
			void* ret = EglCreateImageNative((void*)dpy, (void*)ctx, target, (void*)buffer, attribList);
			return ret;
		}

		public static void* EglCreateImage(void* dpy, void* ctx, uint target, void* buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative(dpy, ctx, target, buffer, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateImage(nint dpy, void* ctx, uint target, void* buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative((void*)dpy, ctx, target, buffer, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateImage(void* dpy, nint ctx, uint target, void* buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative(dpy, (void*)ctx, target, buffer, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateImage(nint dpy, nint ctx, uint target, void* buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative((void*)dpy, (void*)ctx, target, buffer, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateImage(void* dpy, void* ctx, uint target, nint buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative(dpy, ctx, target, (void*)buffer, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateImage(nint dpy, void* ctx, uint target, nint buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative((void*)dpy, ctx, target, (void*)buffer, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateImage(void* dpy, nint ctx, uint target, nint buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative(dpy, (void*)ctx, target, (void*)buffer, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreateImage(nint dpy, nint ctx, uint target, nint buffer, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreateImageNative((void*)dpy, (void*)ctx, target, (void*)buffer, (nint*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroyImageNative(void* dpy, void* image)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, uint>)funcTable[877])(dpy, image);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[877])((nint)dpy, (nint)image);
			#endif
		}

		public static uint EglDestroyImage(void* dpy, void* image)
		{
			uint ret = EglDestroyImageNative(dpy, image);
			return ret;
		}

		public static uint EglDestroyImage(nint dpy, void* image)
		{
			uint ret = EglDestroyImageNative((void*)dpy, image);
			return ret;
		}

		public static uint EglDestroyImage(void* dpy, nint image)
		{
			uint ret = EglDestroyImageNative(dpy, (void*)image);
			return ret;
		}

		public static uint EglDestroyImage(nint dpy, nint image)
		{
			uint ret = EglDestroyImageNative((void*)dpy, (void*)image);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglGetPlatformDisplayNative(uint platform, void* nativeDisplay, nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*, nint*, void*>)funcTable[878])(platform, nativeDisplay, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[878])(platform, (nint)nativeDisplay, (nint)attribList);
			#endif
		}

		public static void* EglGetPlatformDisplay(uint platform, void* nativeDisplay, nint* attribList)
		{
			void* ret = EglGetPlatformDisplayNative(platform, nativeDisplay, attribList);
			return ret;
		}

		public static void* EglGetPlatformDisplay(uint platform, nint nativeDisplay, nint* attribList)
		{
			void* ret = EglGetPlatformDisplayNative(platform, (void*)nativeDisplay, attribList);
			return ret;
		}

		public static void* EglGetPlatformDisplay(uint platform, void* nativeDisplay, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglGetPlatformDisplayNative(platform, nativeDisplay, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglGetPlatformDisplay(uint platform, nint nativeDisplay, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglGetPlatformDisplayNative(platform, (void*)nativeDisplay, (nint*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreatePlatformWindowSurfaceNative(void* dpy, void* config, void* nativeWindow, nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, void*, nint*, void*>)funcTable[879])(dpy, config, nativeWindow, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint>)funcTable[879])((nint)dpy, (nint)config, (nint)nativeWindow, (nint)attribList);
			#endif
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, void* config, void* nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative(dpy, config, nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, void* config, void* nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, config, nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, nint config, void* nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative(dpy, (void*)config, nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, nint config, void* nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, (void*)config, nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, void* config, nint nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative(dpy, config, (void*)nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, void* config, nint nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, config, (void*)nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, nint config, nint nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative(dpy, (void*)config, (void*)nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, nint config, nint nativeWindow, nint* attribList)
		{
			void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, (void*)config, (void*)nativeWindow, attribList);
			return ret;
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, void* config, void* nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative(dpy, config, nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, void* config, void* nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, config, nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, nint config, void* nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative(dpy, (void*)config, nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, nint config, void* nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, (void*)config, nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, void* config, nint nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative(dpy, config, (void*)nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, void* config, nint nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, config, (void*)nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformWindowSurface(void* dpy, nint config, nint nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative(dpy, (void*)config, (void*)nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformWindowSurface(nint dpy, nint config, nint nativeWindow, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformWindowSurfaceNative((void*)dpy, (void*)config, (void*)nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EglCreatePlatformPixmapSurfaceNative(void* dpy, void* config, void* nativePixmap, nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, void*, nint*, void*>)funcTable[880])(dpy, config, nativePixmap, attribList);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint>)funcTable[880])((nint)dpy, (nint)config, (nint)nativePixmap, (nint)attribList);
			#endif
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, void* config, void* nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, config, nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, void* config, void* nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, config, nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, nint config, void* nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, (void*)config, nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, nint config, void* nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, (void*)config, nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, void* config, nint nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, config, (void*)nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, void* config, nint nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, config, (void*)nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, nint config, nint nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, (void*)config, (void*)nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, nint config, nint nativePixmap, nint* attribList)
		{
			void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, (void*)config, (void*)nativePixmap, attribList);
			return ret;
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, void* config, void* nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, config, nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, void* config, void* nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, config, nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, nint config, void* nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, (void*)config, nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, nint config, void* nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, (void*)config, nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, void* config, nint nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, config, (void*)nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, void* config, nint nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, config, (void*)nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformPixmapSurface(void* dpy, nint config, nint nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative(dpy, (void*)config, (void*)nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		public static void* EglCreatePlatformPixmapSurface(nint dpy, nint config, nint nativePixmap, in nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				void* ret = EglCreatePlatformPixmapSurfaceNative((void*)dpy, (void*)config, (void*)nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitSyncNative(void* dpy, void* sync, int flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, int, uint>)funcTable[881])(dpy, sync, flags);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, uint>)funcTable[881])((nint)dpy, (nint)sync, flags);
			#endif
		}

		public static uint EglWaitSync(void* dpy, void* sync, int flags)
		{
			uint ret = EglWaitSyncNative(dpy, sync, flags);
			return ret;
		}

		public static uint EglWaitSync(nint dpy, void* sync, int flags)
		{
			uint ret = EglWaitSyncNative((void*)dpy, sync, flags);
			return ret;
		}

		public static uint EglWaitSync(void* dpy, nint sync, int flags)
		{
			uint ret = EglWaitSyncNative(dpy, (void*)sync, flags);
			return ret;
		}

		public static uint EglWaitSync(nint dpy, nint sync, int flags)
		{
			uint ret = EglWaitSyncNative((void*)dpy, (void*)sync, flags);
			return ret;
		}

		/// <summary>
		/// Miscellaneous<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlClearIndexNative(float c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[882])(c);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[882])(c);
			#endif
		}

		/// <summary>
		/// Miscellaneous<br/>
		/// </summary>
		public static void GlClearIndex(float c)
		{
			GlClearIndexNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlClearColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[883])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[883])(red, green, blue, alpha);
			#endif
		}

		public static void GlClearColor(float red, float green, float blue, float alpha)
		{
			GlClearColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlClearNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[884])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[884])(mask);
			#endif
		}

		public static void GlClear(uint mask)
		{
			GlClearNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlIndexMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[885])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[885])(mask);
			#endif
		}

		public static void GlIndexMask(uint mask)
		{
			GlIndexMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlColorMaskNative(byte red, byte green, byte blue, byte alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[886])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[886])(red, green, blue, alpha);
			#endif
		}

		public static void GlColorMask(byte red, byte green, byte blue, byte alpha)
		{
			GlColorMaskNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlAlphaFuncNative(uint func, float reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[887])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[887])(func, reference);
			#endif
		}

		public static void GlAlphaFunc(uint func, float reference)
		{
			GlAlphaFuncNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlBlendFuncNative(uint sfactor, uint dfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[888])(sfactor, dfactor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[888])(sfactor, dfactor);
			#endif
		}

		public static void GlBlendFunc(uint sfactor, uint dfactor)
		{
			GlBlendFuncNative(sfactor, dfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlLogicOpNative(uint opcode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[889])(opcode);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[889])(opcode);
			#endif
		}

		public static void GlLogicOp(uint opcode)
		{
			GlLogicOpNative(opcode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlCullFaceNative(uint mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[890])(mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[890])(mode);
			#endif
		}

		public static void GlCullFace(uint mode)
		{
			GlCullFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlFrontFaceNative(uint mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[891])(mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[891])(mode);
			#endif
		}

		public static void GlFrontFace(uint mode)
		{
			GlFrontFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPointSizeNative(float size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[892])(size);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[892])(size);
			#endif
		}

		public static void GlPointSize(float size)
		{
			GlPointSizeNative(size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlLineWidthNative(float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[893])(width);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[893])(width);
			#endif
		}

		public static void GlLineWidth(float width)
		{
			GlLineWidthNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlLineStippleNative(int factor, ushort pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[894])(factor, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[894])(factor, pattern);
			#endif
		}

		public static void GlLineStipple(int factor, ushort pattern)
		{
			GlLineStippleNative(factor, pattern);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPolygonModeNative(uint face, uint mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[895])(face, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[895])(face, mode);
			#endif
		}

		public static void GlPolygonMode(uint face, uint mode)
		{
			GlPolygonModeNative(face, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPolygonOffsetNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[896])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[896])(factor, units);
			#endif
		}

		public static void GlPolygonOffset(float factor, float units)
		{
			GlPolygonOffsetNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPolygonStippleNative(byte* mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[897])(mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[897])((nint)mask);
			#endif
		}

		public static void GlPolygonStipple(byte* mask)
		{
			GlPolygonStippleNative(mask);
		}

		public static void GlPolygonStipple(in byte mask)
		{
			fixed (byte* pmask = &mask)
			{
				GlPolygonStippleNative((byte*)pmask);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlGetPolygonStippleNative(byte* mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[898])(mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[898])((nint)mask);
			#endif
		}

		public static void GlGetPolygonStipple(byte* mask)
		{
			GlGetPolygonStippleNative(mask);
		}

		public static void GlGetPolygonStipple(ref byte mask)
		{
			fixed (byte* pmask = &mask)
			{
				GlGetPolygonStippleNative((byte*)pmask);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlEdgeFlagNative(byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[899])(flag);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[899])(flag);
			#endif
		}

		public static void GlEdgeFlag(byte flag)
		{
			GlEdgeFlagNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlEdgeFlagvNative(byte* flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[900])(flag);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[900])((nint)flag);
			#endif
		}

		public static void GlEdgeFlagv(byte* flag)
		{
			GlEdgeFlagvNative(flag);
		}

		public static void GlEdgeFlagv(in byte flag)
		{
			fixed (byte* pflag = &flag)
			{
				GlEdgeFlagvNative((byte*)pflag);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlScissorNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[901])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[901])(x, y, width, height);
			#endif
		}

		public static void GlScissor(int x, int y, int width, int height)
		{
			GlScissorNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlClipPlaneNative(uint plane, double* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[902])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[902])(plane, (nint)equation);
			#endif
		}

		public static void GlClipPlane(uint plane, double* equation)
		{
			GlClipPlaneNative(plane, equation);
		}

		public static void GlClipPlane(uint plane, in double equation)
		{
			fixed (double* pequation = &equation)
			{
				GlClipPlaneNative(plane, (double*)pequation);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlGetClipPlaneNative(uint plane, double* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[903])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[903])(plane, (nint)equation);
			#endif
		}

		public static void GlGetClipPlane(uint plane, double* equation)
		{
			GlGetClipPlaneNative(plane, equation);
		}

		public static void GlGetClipPlane(uint plane, ref double equation)
		{
			fixed (double* pequation = &equation)
			{
				GlGetClipPlaneNative(plane, (double*)pequation);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlDrawBufferNative(uint mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[904])(mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[904])(mode);
			#endif
		}

		public static void GlDrawBuffer(uint mode)
		{
			GlDrawBufferNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlReadBufferNative(uint mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[905])(mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[905])(mode);
			#endif
		}

		public static void GlReadBuffer(uint mode)
		{
			GlReadBufferNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlEnableNative(uint cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[906])(cap);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[906])(cap);
			#endif
		}

		public static void GlEnable(uint cap)
		{
			GlEnableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlDisableNative(uint cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[907])(cap);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[907])(cap);
			#endif
		}

		public static void GlDisable(uint cap)
		{
			GlDisableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GlIsEnabledNative(uint cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[908])(cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[908])(cap);
			#endif
		}

		public static byte GlIsEnabled(uint cap)
		{
			byte ret = GlIsEnabledNative(cap);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlEnableClientStateNative(uint cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[909])(cap);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[909])(cap);
			#endif
		}

		public static void GlEnableClientState(uint cap)
		{
			GlEnableClientStateNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlDisableClientStateNative(uint cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[910])(cap);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[910])(cap);
			#endif
		}

		public static void GlDisableClientState(uint cap)
		{
			GlDisableClientStateNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlGetBooleanvNative(uint pname, byte* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[911])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[911])(pname, (nint)@params);
			#endif
		}

		public static void GlGetBooleanv(uint pname, byte* @params)
		{
			GlGetBooleanvNative(pname, @params);
		}

		public static void GlGetBooleanv(uint pname, ref byte @params)
		{
			fixed (byte* pparams = &@params)
			{
				GlGetBooleanvNative(pname, (byte*)pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlGetDoublevNative(uint pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[912])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[912])(pname, (nint)@params);
			#endif
		}

		public static void GlGetDoublev(uint pname, double* @params)
		{
			GlGetDoublevNative(pname, @params);
		}

		public static void GlGetDoublev(uint pname, ref double @params)
		{
			fixed (double* pparams = &@params)
			{
				GlGetDoublevNative(pname, (double*)pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlGetFloatvNative(uint pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[913])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[913])(pname, (nint)@params);
			#endif
		}

		public static void GlGetFloatv(uint pname, float* @params)
		{
			GlGetFloatvNative(pname, @params);
		}

		public static void GlGetFloatv(uint pname, ref float @params)
		{
			fixed (float* pparams = &@params)
			{
				GlGetFloatvNative(pname, (float*)pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlGetIntegervNative(uint pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[914])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[914])(pname, (nint)@params);
			#endif
		}

		public static void GlGetIntegerv(uint pname, int* @params)
		{
			GlGetIntegervNative(pname, @params);
		}

		public static void GlGetIntegerv(uint pname, ref int @params)
		{
			fixed (int* pparams = &@params)
			{
				GlGetIntegervNative(pname, (int*)pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPushAttribNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[915])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[915])(mask);
			#endif
		}

		public static void GlPushAttrib(uint mask)
		{
			GlPushAttribNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPopAttribNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[916])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[916])();
			#endif
		}

		public static void GlPopAttrib()
		{
			GlPopAttribNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPushClientAttribNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[917])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[917])(mask);
			#endif
		}

		public static void GlPushClientAttrib(uint mask)
		{
			GlPushClientAttribNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPopClientAttribNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[918])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[918])();
			#endif
		}

		public static void GlPopClientAttrib()
		{
			GlPopClientAttribNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GlRenderModeNative(uint mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int>)funcTable[919])(mode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, int>)funcTable[919])(mode);
			#endif
		}

		public static int GlRenderMode(uint mode)
		{
			int ret = GlRenderModeNative(mode);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GlGetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[920])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[920])();
			#endif
		}

		public static uint GlGetError()
		{
			uint ret = GlGetErrorNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GlGetStringNative(uint name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[921])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[921])(name);
			#endif
		}

		public static byte* GlGetString(uint name)
		{
			byte* ret = GlGetStringNative(name);
			return ret;
		}

		public static string GlGetStringS(uint name)
		{
			string ret = Utils.DecodeStringUTF8(GlGetStringNative(name));
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlFinishNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[922])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[922])();
			#endif
		}

		public static void GlFinish()
		{
			GlFinishNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlFlushNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[923])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[923])();
			#endif
		}

		public static void GlFlush()
		{
			GlFlushNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlHintNative(uint target, uint mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[924])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[924])(target, mode);
			#endif
		}

		public static void GlHint(uint target, uint mode)
		{
			GlHintNative(target, mode);
		}

		/// <summary>
		/// Depth Buffer<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlClearDepthNative(double depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[925])(depth);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[925])(depth);
			#endif
		}

		/// <summary>
		/// Depth Buffer<br/>
		/// </summary>
		public static void GlClearDepth(double depth)
		{
			GlClearDepthNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlDepthFuncNative(uint func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[926])(func);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[926])(func);
			#endif
		}

		public static void GlDepthFunc(uint func)
		{
			GlDepthFuncNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlDepthMaskNative(byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[927])(flag);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[927])(flag);
			#endif
		}

		public static void GlDepthMask(byte flag)
		{
			GlDepthMaskNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlDepthRangeNative(double nearVal, double farVal)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[928])(nearVal, farVal);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[928])(nearVal, farVal);
			#endif
		}

		public static void GlDepthRange(double nearVal, double farVal)
		{
			GlDepthRangeNative(nearVal, farVal);
		}

		/// <summary>
		/// Accumulation Buffer<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlClearAccumNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[929])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[929])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// Accumulation Buffer<br/>
		/// </summary>
		public static void GlClearAccum(float red, float green, float blue, float alpha)
		{
			GlClearAccumNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlAccumNative(uint op, float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[930])(op, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[930])(op, value);
			#endif
		}

		public static void GlAccum(uint op, float value)
		{
			GlAccumNative(op, value);
		}

		/// <summary>
		/// Transformation<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlMatrixModeNative(uint mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[931])(mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[931])(mode);
			#endif
		}

		/// <summary>
		/// Transformation<br/>
		/// </summary>
		public static void GlMatrixMode(uint mode)
		{
			GlMatrixModeNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlOrthoNative(double left, double right, double bottom, double top, double nearVal, double farVal)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[932])(left, right, bottom, top, nearVal, farVal);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[932])(left, right, bottom, top, nearVal, farVal);
			#endif
		}

		public static void GlOrtho(double left, double right, double bottom, double top, double nearVal, double farVal)
		{
			GlOrthoNative(left, right, bottom, top, nearVal, farVal);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlFrustumNative(double left, double right, double bottom, double top, double nearVal, double farVal)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[933])(left, right, bottom, top, nearVal, farVal);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[933])(left, right, bottom, top, nearVal, farVal);
			#endif
		}

		public static void GlFrustum(double left, double right, double bottom, double top, double nearVal, double farVal)
		{
			GlFrustumNative(left, right, bottom, top, nearVal, farVal);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlViewportNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[934])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[934])(x, y, width, height);
			#endif
		}

		public static void GlViewport(int x, int y, int width, int height)
		{
			GlViewportNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPushMatrixNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[935])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[935])();
			#endif
		}

		public static void GlPushMatrix()
		{
			GlPushMatrixNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlPopMatrixNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[936])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[936])();
			#endif
		}

		public static void GlPopMatrix()
		{
			GlPopMatrixNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlLoadIdentityNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[937])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[937])();
			#endif
		}

		public static void GlLoadIdentity()
		{
			GlLoadIdentityNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlLoadMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[938])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[938])((nint)m);
			#endif
		}

		public static void GlLoadMatrixd(double* m)
		{
			GlLoadMatrixdNative(m);
		}

		public static void GlLoadMatrixd(in double m)
		{
			fixed (double* pm = &m)
			{
				GlLoadMatrixdNative((double*)pm);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlLoadMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[939])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[939])((nint)m);
			#endif
		}

		public static void GlLoadMatrixf(float* m)
		{
			GlLoadMatrixfNative(m);
		}

		public static void GlLoadMatrixf(in float m)
		{
			fixed (float* pm = &m)
			{
				GlLoadMatrixfNative((float*)pm);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlMultMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[940])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[940])((nint)m);
			#endif
		}

		public static void GlMultMatrixd(double* m)
		{
			GlMultMatrixdNative(m);
		}

		public static void GlMultMatrixd(in double m)
		{
			fixed (double* pm = &m)
			{
				GlMultMatrixdNative((double*)pm);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlMultMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[941])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[941])((nint)m);
			#endif
		}

		public static void GlMultMatrixf(float* m)
		{
			GlMultMatrixfNative(m);
		}

		public static void GlMultMatrixf(in float m)
		{
			fixed (float* pm = &m)
			{
				GlMultMatrixfNative((float*)pm);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlRotatedNative(double angle, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[942])(angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[942])(angle, x, y, z);
			#endif
		}

		public static void GlRotated(double angle, double x, double y, double z)
		{
			GlRotatedNative(angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlRotatefNative(float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[943])(angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[943])(angle, x, y, z);
			#endif
		}

		public static void GlRotatef(float angle, float x, float y, float z)
		{
			GlRotatefNative(angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlScaledNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[944])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[944])(x, y, z);
			#endif
		}

		public static void GlScaled(double x, double y, double z)
		{
			GlScaledNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlScalefNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[945])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[945])(x, y, z);
			#endif
		}

		public static void GlScalef(float x, float y, float z)
		{
			GlScalefNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlTranslatedNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[946])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[946])(x, y, z);
			#endif
		}

		public static void GlTranslated(double x, double y, double z)
		{
			GlTranslatedNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlTranslatefNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[947])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[947])(x, y, z);
			#endif
		}

		public static void GlTranslatef(float x, float y, float z)
		{
			GlTranslatefNative(x, y, z);
		}

		/// <summary>
		/// Display Lists<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GlIsListNative(uint list)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[948])(list);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[948])(list);
			#endif
		}

		/// <summary>
		/// Display Lists<br/>
		/// </summary>
		public static byte GlIsList(uint list)
		{
			byte ret = GlIsListNative(list);
			return ret;
		}
	}
}
