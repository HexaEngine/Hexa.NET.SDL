// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pa = &a)
			{
				GetRGBANative(pixel, format, r, g, b, (byte*)pa);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, (byte*)pr, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, r, (byte*)pg, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, (byte*)pr, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, b, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, r, g, (byte*)pb, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, (byte*)pr, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, r, (byte*)pg, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGammaRamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateGammaRampNative([NativeName(NativeNameType.Param, "gamma")] [NativeName(NativeNameType.Type, "float")] float gamma, [NativeName(NativeNameType.Param, "ramp")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* ramp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, ushort*, void>)funcTable[292])(gamma, ramp);
			#else
			((delegate* unmanaged[Cdecl]<float, nint, void>)funcTable[292])(gamma, (nint)ramp);
			#endif
		}

		/// <summary>
		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGammaRamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateGammaRamp([NativeName(NativeNameType.Param, "gamma")] [NativeName(NativeNameType.Type, "float")] float gamma, [NativeName(NativeNameType.Param, "ramp")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* ramp)
		{
			CalculateGammaRampNative(gamma, ramp);
		}

		/// <summary>
		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGammaRamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateGammaRamp([NativeName(NativeNameType.Param, "gamma")] [NativeName(NativeNameType.Type, "float")] float gamma, [NativeName(NativeNameType.Param, "ramp")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort ramp)
		{
			fixed (ushort* pramp = &ramp)
			{
				CalculateGammaRampNative(gamma, (ushort*)pramp);
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasIntersectionNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLBool>)funcTable[293])(a, b);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, SDLBool>)funcTable[293])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b)
		{
			SDLBool ret = HasIntersectionNative(a, b);
			return ret;
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b)
		{
			fixed (SDLRect* pa = &a)
			{
				SDLBool ret = HasIntersectionNative((SDLRect*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = HasIntersectionNative(a, (SDLRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					SDLBool ret = HasIntersectionNative((SDLRect*)pa, (SDLRect*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IntersectRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLRect*, SDLBool>)funcTable[294])(a, b, result);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, SDLBool>)funcTable[294])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLBool ret = IntersectRectNative(a, b, result);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				SDLBool ret = IntersectRectNative((SDLRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = IntersectRectNative(a, (SDLRect*)pb, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					SDLBool ret = IntersectRectNative((SDLRect*)pa, (SDLRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = IntersectRectNative(a, b, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = IntersectRectNative((SDLRect*)pa, b, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = IntersectRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						SDLBool ret = IntersectRectNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnionRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLRect*, void>)funcTable[295])(a, b, result);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[295])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			UnionRectNative(a, b, result);
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				UnionRectNative((SDLRect*)pa, b, result);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				UnionRectNative(a, (SDLRect*)pb, result);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					UnionRectNative((SDLRect*)pa, (SDLRect*)pb, result);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				UnionRectNative(a, b, (SDLRect*)presult);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					UnionRectNative((SDLRect*)pa, b, (SDLRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					UnionRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						UnionRectNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool EnclosePointsNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPoint*, int, SDLRect*, SDLRect*, SDLBool>)funcTable[296])(points, count, clip, result);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, SDLBool>)funcTable[296])((nint)points, count, (nint)clip, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLBool ret = EnclosePointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, clip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				SDLBool ret = EnclosePointsNative(points, count, (SDLRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = EnclosePointsNative(points, count, clip, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, clip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = EnclosePointsNative(points, count, (SDLRect*)pclip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					fixed (SDLRect* presult = &result)
					{
						SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IntersectRectAndLineNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, int*, int*, int*, int*, SDLBool>)funcTable[297])(rect, x1, y1, x2, y2);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, SDLBool>)funcTable[297])((nint)rect, (nint)x1, (nint)y1, (nint)x2, (nint)y2);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px2 = &x2)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, (int*)px2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, y2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py2 = &y2)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, x2, (int*)py2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px2 = &x2)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, (int*)px2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							fixed (int* py2 = &y2)
							{
								SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasIntersectionFNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLBool>)funcTable[298])(a, b);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, SDLBool>)funcTable[298])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b)
		{
			SDLBool ret = HasIntersectionFNative(a, b);
			return ret;
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b)
		{
			fixed (SDLFRect* pa = &a)
			{
				SDLBool ret = HasIntersectionFNative((SDLFRect*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLBool ret = HasIntersectionFNative(a, (SDLFRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					SDLBool ret = HasIntersectionFNative((SDLFRect*)pa, (SDLFRect*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IntersectFRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLFRect*, SDLBool>)funcTable[299])(a, b, result);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, SDLBool>)funcTable[299])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLBool ret = IntersectFRectNative(a, b, result);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				SDLBool ret = IntersectFRectNative((SDLFRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLBool ret = IntersectFRectNative(a, (SDLFRect*)pb, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					SDLBool ret = IntersectFRectNative((SDLFRect*)pa, (SDLFRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLBool ret = IntersectFRectNative(a, b, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = IntersectFRectNative((SDLFRect*)pa, b, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = IntersectFRectNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						SDLBool ret = IntersectFRectNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnionFRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLFRect*, void>)funcTable[300])(a, b, result);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[300])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			UnionFRectNative(a, b, result);
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				UnionFRectNative((SDLFRect*)pa, b, result);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				UnionFRectNative(a, (SDLFRect*)pb, result);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					UnionFRectNative((SDLFRect*)pa, (SDLFRect*)pb, result);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				UnionFRectNative(a, b, (SDLFRect*)presult);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					UnionFRectNative((SDLFRect*)pa, b, (SDLFRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					UnionFRectNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						UnionFRectNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool EncloseFPointsNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFPoint*, int, SDLFRect*, SDLFRect*, SDLBool>)funcTable[301])(points, count, clip, result);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, SDLBool>)funcTable[301])((nint)points, count, (nint)clip, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLBool ret = EncloseFPointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				SDLBool ret = EncloseFPointsNative((SDLFPoint*)ppoints, count, clip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				SDLBool ret = EncloseFPointsNative(points, count, (SDLFRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					SDLBool ret = EncloseFPointsNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLBool ret = EncloseFPointsNative(points, count, clip, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = EncloseFPointsNative((SDLFPoint*)ppoints, count, clip, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = EncloseFPointsNative(points, count, (SDLFRect*)pclip, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool EncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					fixed (SDLFRect* presult = &result)
					{
						SDLBool ret = EncloseFPointsNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, (SDLFRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IntersectFRectAndLineNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, float*, float*, float*, float*, SDLBool>)funcTable[302])(rect, x1, y1, x2, y2);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, SDLBool>)funcTable[302])((nint)rect, (nint)x1, (nint)y1, (nint)x2, (nint)y2);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			SDLBool ret = IntersectFRectAndLineNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				SDLBool ret = IntersectFRectAndLineNative(rect, x1, (float*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px2 = &x2)
			{
				SDLBool ret = IntersectFRectAndLineNative(rect, x1, y1, (float*)px2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, y1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = IntersectFRectAndLineNative(rect, x1, (float*)py1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, y2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py2 = &y2)
			{
				SDLBool ret = IntersectFRectAndLineNative(rect, x1, y1, x2, (float*)py2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, y1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = IntersectFRectAndLineNative(rect, x1, (float*)py1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px2 = &x2)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = IntersectFRectAndLineNative(rect, x1, y1, (float*)px2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, y1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = IntersectFRectAndLineNative(rect, x1, (float*)py1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = IntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool IntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							fixed (float* py2 = &y2)
							{
								SDLBool ret = IntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer in<br/>
		/// SDL 2.0.6. All renderers support the four blend modes listed in the<br/>
		/// SDL_BlendMode enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL<br/>
		/// 2.0.6.<br/>
		/// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. Color and alpha factors need to be the same. OpenGL ES 1<br/>
		/// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`<br/>
		/// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha<br/>
		/// operations being different from each other. May support color and alpha<br/>
		/// factors being different from each other.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBlendMode ComposeCustomBlendModeNative([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendMode>)funcTable[303])(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			#else
			return (SDLBlendMode)((delegate* unmanaged[Cdecl]<SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendMode>)funcTable[303])(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			#endif
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer in<br/>
		/// SDL 2.0.6. All renderers support the four blend modes listed in the<br/>
		/// SDL_BlendMode enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL<br/>
		/// 2.0.6.<br/>
		/// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. Color and alpha factors need to be the same. OpenGL ES 1<br/>
		/// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`<br/>
		/// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha<br/>
		/// operations being different from each other. May support color and alpha<br/>
		/// factors being different from each other.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		public static SDLBlendMode ComposeCustomBlendMode([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation)
		{
			SDLBlendMode ret = ComposeCustomBlendModeNative(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface.<br/>
		/// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.<br/>
		/// If `depth` is greater than 8 bits, the pixel format is set using the<br/>
		/// [RGBA]mask parameters.<br/>
		/// The [RGBA]mask parameters are the bitmasks used to extract that color from<br/>
		/// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is<br/>
		/// stored in the most significant byte. Using zeros for the RGB masks sets a<br/>
		/// default value, based on the depth. For example:<br/>
		/// ```c++<br/>
		/// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);<br/>
		/// ```<br/>
		/// However, using zero for the Amask results in an Amask of 0.<br/>
		/// By default surfaces with an alpha mask are set up for blending as with:<br/>
		/// ```c++<br/>
		/// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)<br/>
		/// ```<br/>
		/// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a<br/>
		/// different `blendMode`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateRGBSurfaceNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, int, uint, uint, uint, uint, SDLSurface*>)funcTable[304])(flags, width, height, depth, rmask, gmask, bmask, amask);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<uint, int, int, int, uint, uint, uint, uint, nint>)funcTable[304])(flags, width, height, depth, rmask, gmask, bmask, amask);
			#endif
		}

		/// <summary>
		/// Allocate a new RGB surface.<br/>
		/// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.<br/>
		/// If `depth` is greater than 8 bits, the pixel format is set using the<br/>
		/// [RGBA]mask parameters.<br/>
		/// The [RGBA]mask parameters are the bitmasks used to extract that color from<br/>
		/// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is<br/>
		/// stored in the most significant byte. Using zeros for the RGB masks sets a<br/>
		/// default value, based on the depth. For example:<br/>
		/// ```c++<br/>
		/// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);<br/>
		/// ```<br/>
		/// However, using zero for the Amask results in an Amask of 0.<br/>
		/// By default surfaces with an alpha mask are set up for blending as with:<br/>
		/// ```c++<br/>
		/// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)<br/>
		/// ```<br/>
		/// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a<br/>
		/// different `blendMode`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* CreateRGBSurface([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			SDLSurface* ret = CreateRGBSurfaceNative(flags, width, height, depth, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with a specific pixel format.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except instead<br/>
		/// of providing pixel color masks, you provide it with a predefined format<br/>
		/// from SDL_PixelFormatEnum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateRGBSurfaceWithFormatNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, int, uint, SDLSurface*>)funcTable[305])(flags, width, height, depth, format);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<uint, int, int, int, uint, nint>)funcTable[305])(flags, width, height, depth, format);
			#endif
		}

		/// <summary>
		/// Allocate a new RGB surface with a specific pixel format.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except instead<br/>
		/// of providing pixel color masks, you provide it with a predefined format<br/>
		/// from SDL_PixelFormatEnum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* CreateRGBSurfaceWithFormat([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			SDLSurface* ret = CreateRGBSurfaceWithFormatNative(flags, width, height, depth, format);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with existing pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except it does<br/>
		/// not allocate memory for the pixel data, instead the caller provides an<br/>
		/// existing buffer of data for the surface to use.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateRGBSurfaceFromNative([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, int, int, int, uint, uint, uint, uint, SDLSurface*>)funcTable[306])(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, int, int, int, uint, uint, uint, uint, nint>)funcTable[306])((nint)pixels, width, height, depth, pitch, rmask, gmask, bmask, amask);
			#endif
		}

		/// <summary>
		/// Allocate a new RGB surface with existing pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except it does<br/>
		/// not allocate memory for the pixel data, instead the caller provides an<br/>
		/// existing buffer of data for the surface to use.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* CreateRGBSurfaceFrom([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			SDLSurface* ret = CreateRGBSurfaceFromNative(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with with a specific pixel format and existing<br/>
		/// pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except<br/>
		/// instead of providing pixel color masks, you provide it with a predefined<br/>
		/// format from SDL_PixelFormatEnum.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormatFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateRGBSurfaceWithFormatFromNative([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, int, int, int, uint, SDLSurface*>)funcTable[307])(pixels, width, height, depth, pitch, format);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, int, int, int, uint, nint>)funcTable[307])((nint)pixels, width, height, depth, pitch, format);
			#endif
		}

		/// <summary>
		/// Allocate a new RGB surface with with a specific pixel format and existing<br/>
		/// pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except<br/>
		/// instead of providing pixel color masks, you provide it with a predefined<br/>
		/// format from SDL_PixelFormatEnum.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormatFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* CreateRGBSurfaceWithFormatFrom([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			SDLSurface* ret = CreateRGBSurfaceWithFormatFromNative(pixels, width, height, depth, pitch, format);
			return ret;
		}

		/// <summary>
		/// Free an RGB surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[308])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[308])((nint)surface);
			#endif
		}

		/// <summary>
		/// Free an RGB surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			FreeSurfaceNative(surface);
		}

		/// <summary>
		/// Free an RGB surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				FreeSurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPalette*, int>)funcTable[309])(surface, palette);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[309])((nint)surface, (nint)palette);
			#endif
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			int ret = SetSurfacePaletteNative(surface, palette);
			return ret;
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SetSurfacePaletteNative((SDLSurface*)psurface, palette);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SetSurfacePaletteNative(surface, (SDLPalette*)ppalette);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					int ret = SetSurfacePaletteNative((SDLSurface*)psurface, (SDLPalette*)ppalette);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int>)funcTable[310])(surface);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[310])((nint)surface);
			#endif
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			int ret = LockSurfaceNative(surface);
			return ret;
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = LockSurfaceNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[311])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[311])((nint)surface);
			#endif
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			UnlockSurfaceNative(surface);
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				UnlockSurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>
		/// result in a memory leak.<br/>
		/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>
		/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>
		/// from a file, convert it to an SDL_Surface and then close the file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadBMPRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, SDLSurface*>)funcTable[312])(src, freesrc);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[312])((nint)src, freesrc);
			#endif
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>
		/// result in a memory leak.<br/>
		/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>
		/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>
		/// from a file, convert it to an SDL_Surface and then close the file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* LoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			SDLSurface* ret = LoadBMPRWNative(src, freesrc);
			return ret;
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>
		/// result in a memory leak.<br/>
		/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>
		/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>
		/// from a file, convert it to an SDL_Surface and then close the file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* LoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadBMPRWNative((SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SaveBMPRWNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRWops*, int, int>)funcTable[313])(surface, dst, freedst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[313])((nint)surface, (nint)dst, freedst);
			#endif
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			int ret = SaveBMPRWNative(surface, dst, freedst);
			return ret;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SaveBMPRWNative((SDLSurface*)psurface, dst, freedst);
				return ret;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SaveBMPRWNative(surface, (SDLRWops*)pdst, freedst);
				return ret;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRWops* pdst = &dst)
				{
					int ret = SaveBMPRWNative((SDLSurface*)psurface, (SDLRWops*)pdst, freedst);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int>)funcTable[314])(surface, flag);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[314])((nint)surface, flag);
			#endif
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag)
		{
			int ret = SetSurfaceRLENative(surface, flag);
			return ret;
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SetSurfaceRLENative((SDLSurface*)psurface, flag);
				return ret;
			}
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLBool>)funcTable[315])(surface);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[315])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLBool ret = HasSurfaceRLENative(surface);
			return ret;
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLBool ret = HasSurfaceRLENative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// RLE acceleration can substantially speed up blitting of images with large<br/>
		/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, uint, int>)funcTable[316])(surface, flag, key);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, uint, int>)funcTable[316])((nint)surface, flag, key);
			#endif
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// RLE acceleration can substantially speed up blitting of images with large<br/>
		/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			int ret = SetColorKeyNative(surface, flag, key);
			return ret;
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// RLE acceleration can substantially speed up blitting of images with large<br/>
		/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SetColorKeyNative((SDLSurface*)psurface, flag, key);
				return ret;
			}
		}

		/// <summary>
		/// Returns whether the surface has a color key<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLBool>)funcTable[317])(surface);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[317])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface has a color key<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLBool ret = HasColorKeyNative(surface);
			return ret;
		}

		/// <summary>
		/// Returns whether the surface has a color key<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool HasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLBool ret = HasColorKeyNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint*, int>)funcTable[318])(surface, key);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[318])((nint)surface, (nint)key);
			#endif
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key)
		{
			int ret = GetColorKeyNative(surface, key);
			return ret;
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = GetColorKeyNative((SDLSurface*)psurface, key);
				return ret;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint key)
		{
			fixed (uint* pkey = &key)
			{
				int ret = GetColorKeyNative(surface, (uint*)pkey);
				return ret;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (uint* pkey = &key)
				{
					int ret = GetColorKeyNative((SDLSurface*)psurface, (uint*)pkey);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte, byte, int>)funcTable[319])(surface, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)funcTable[319])((nint)surface, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			int ret = SetSurfaceColorModNative(surface, r, g, b);
			return ret;
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte*, byte*, int>)funcTable[320])(surface, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[320])((nint)surface, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			int ret = GetSurfaceColorModNative(surface, r, g, b);
			return ret;
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = GetSurfaceColorModNative(surface, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					int ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = GetSurfaceColorModNative(surface, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, b);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = GetSurfaceColorModNative(surface, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetSurfaceColorModNative(surface, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetSurfaceColorModNative(surface, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, int>)funcTable[321])(surface, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)funcTable[321])((nint)surface, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			int ret = SetSurfaceAlphaModNative(surface, alpha);
			return ret;
		}
	}
}
