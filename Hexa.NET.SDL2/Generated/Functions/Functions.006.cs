// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		public static int BlitScaled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect) => UpperBlitScaled(ref src, srcrect, dst, ref dstrect);

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpperBlitScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = UpperBlitScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		public static int BlitScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect) => UpperBlitScaled(src, ref srcrect, dst, ref dstrect);

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpperBlitScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = UpperBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		public static int BlitScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect) => UpperBlitScaled(ref src, ref srcrect, dst, ref dstrect);

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpperBlitScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = UpperBlitScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		public static int BlitScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect) => UpperBlitScaled(src, srcrect, ref dst, ref dstrect);

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpperBlitScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = UpperBlitScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		public static int BlitScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect) => UpperBlitScaled(ref src, srcrect, ref dst, ref dstrect);

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpperBlitScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = UpperBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		public static int BlitScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect) => UpperBlitScaled(src, ref srcrect, ref dst, ref dstrect);

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpperBlitScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = UpperBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		public static int BlitScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect) => UpperBlitScaled(ref src, ref srcrect, ref dst, ref dstrect);

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LowerBlitScaledNative(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, int>)funcTable[339])(src, srcrect, dst, dstrect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[339])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			int ret = LowerBlitScaledNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				int ret = LowerBlitScaledNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = LowerBlitScaledNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = LowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = LowerBlitScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = LowerBlitScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = LowerBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						int ret = LowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = LowerBlitScaledNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = LowerBlitScaledNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = LowerBlitScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = LowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = LowerBlitScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = LowerBlitScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = LowerBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LowerBlitScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = LowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetYUVConversionModeNative(SdlYuvConversionMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlYuvConversionMode, void>)funcTable[340])(mode);
			#else
			((delegate* unmanaged[Cdecl]<SdlYuvConversionMode, void>)funcTable[340])(mode);
			#endif
		}

		/// <summary>
		/// Set the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		public static void SetYUVConversionMode(SdlYuvConversionMode mode)
		{
			SetYUVConversionModeNative(mode);
		}

		/// <summary>
		/// Get the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlYuvConversionMode GetYUVConversionModeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SdlYuvConversionMode>)funcTable[341])();
			#else
			return (SdlYuvConversionMode)((delegate* unmanaged[Cdecl]<SdlYuvConversionMode>)funcTable[341])();
			#endif
		}

		/// <summary>
		/// Get the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		public static SdlYuvConversionMode GetYUVConversionMode()
		{
			SdlYuvConversionMode ret = GetYUVConversionModeNative();
			return ret;
		}

		/// <summary>
		/// Get the YUV conversion mode, returning the correct mode for the resolution<br/>
		/// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlYuvConversionMode GetYUVConversionModeForResolutionNative(int width, int height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SdlYuvConversionMode>)funcTable[342])(width, height);
			#else
			return (SdlYuvConversionMode)((delegate* unmanaged[Cdecl]<int, int, SdlYuvConversionMode>)funcTable[342])(width, height);
			#endif
		}

		/// <summary>
		/// Get the YUV conversion mode, returning the correct mode for the resolution<br/>
		/// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC<br/>
		/// <br/>
		/// </summary>
		public static SdlYuvConversionMode GetYUVConversionModeForResolution(int width, int height)
		{
			SdlYuvConversionMode ret = GetYUVConversionModeForResolutionNative(width, height);
			return ret;
		}

		/// <summary>
		/// Get the number of video drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumVideoDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[343])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[343])();
			#endif
		}

		/// <summary>
		/// Get the number of video drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumVideoDrivers()
		{
			int ret = GetNumVideoDriversNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a built in video driver.<br/>
		/// The video drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetVideoDriverNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[344])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[344])(index);
			#endif
		}

		/// <summary>
		/// Get the name of a built in video driver.<br/>
		/// The video drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetVideoDriver(int index)
		{
			byte* ret = GetVideoDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Get the name of a built in video driver.<br/>
		/// The video drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetVideoDriverS(int index)
		{
			string ret = Utils.DecodeStringUTF8(GetVideoDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Initialize the video subsystem, optionally specifying a video driver.<br/>
		/// This function initializes the video subsystem, setting up a connection to<br/>
		/// the window manager, etc, and determines the available display modes and<br/>
		/// pixel formats, but does not initialize a window or graphics mode.<br/>
		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>
		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>
		/// before calling SDL_Quit().<br/>
		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>
		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>
		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>
		/// specific `driver_name`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VideoInitNative(byte* driverName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[345])(driverName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[345])((nint)driverName);
			#endif
		}

		/// <summary>
		/// Initialize the video subsystem, optionally specifying a video driver.<br/>
		/// This function initializes the video subsystem, setting up a connection to<br/>
		/// the window manager, etc, and determines the available display modes and<br/>
		/// pixel formats, but does not initialize a window or graphics mode.<br/>
		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>
		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>
		/// before calling SDL_Quit().<br/>
		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>
		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>
		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>
		/// specific `driver_name`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VideoInit(byte* driverName)
		{
			int ret = VideoInitNative(driverName);
			return ret;
		}

		/// <summary>
		/// Initialize the video subsystem, optionally specifying a video driver.<br/>
		/// This function initializes the video subsystem, setting up a connection to<br/>
		/// the window manager, etc, and determines the available display modes and<br/>
		/// pixel formats, but does not initialize a window or graphics mode.<br/>
		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>
		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>
		/// before calling SDL_Quit().<br/>
		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>
		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>
		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>
		/// specific `driver_name`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VideoInit(ref byte driverName)
		{
			fixed (byte* pdriverName = &driverName)
			{
				int ret = VideoInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Initialize the video subsystem, optionally specifying a video driver.<br/>
		/// This function initializes the video subsystem, setting up a connection to<br/>
		/// the window manager, etc, and determines the available display modes and<br/>
		/// pixel formats, but does not initialize a window or graphics mode.<br/>
		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>
		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>
		/// before calling SDL_Quit().<br/>
		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>
		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>
		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>
		/// specific `driver_name`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VideoInit(ReadOnlySpan<byte> driverName)
		{
			fixed (byte* pdriverName = driverName)
			{
				int ret = VideoInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Initialize the video subsystem, optionally specifying a video driver.<br/>
		/// This function initializes the video subsystem, setting up a connection to<br/>
		/// the window manager, etc, and determines the available display modes and<br/>
		/// pixel formats, but does not initialize a window or graphics mode.<br/>
		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>
		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>
		/// before calling SDL_Quit().<br/>
		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>
		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>
		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>
		/// specific `driver_name`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VideoInit(string driverName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (driverName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(driverName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(driverName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = VideoInitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Shut down the video subsystem, if initialized with SDL_VideoInit().<br/>
		/// This function closes all windows, and restores the original video mode.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VideoQuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[346])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[346])();
			#endif
		}

		/// <summary>
		/// Shut down the video subsystem, if initialized with SDL_VideoInit().<br/>
		/// This function closes all windows, and restores the original video mode.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VideoQuit()
		{
			VideoQuitNative();
		}

		/// <summary>
		/// Get the name of the currently initialized video driver.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCurrentVideoDriverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[347])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[347])();
			#endif
		}

		/// <summary>
		/// Get the name of the currently initialized video driver.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetCurrentVideoDriver()
		{
			byte* ret = GetCurrentVideoDriverNative();
			return ret;
		}

		/// <summary>
		/// Get the name of the currently initialized video driver.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetCurrentVideoDriverS()
		{
			string ret = Utils.DecodeStringUTF8(GetCurrentVideoDriverNative());
			return ret;
		}

		/// <summary>
		/// Get the number of available video displays.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumVideoDisplaysNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[348])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[348])();
			#endif
		}

		/// <summary>
		/// Get the number of available video displays.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumVideoDisplays()
		{
			int ret = GetNumVideoDisplaysNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a display in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetDisplayNameNative(int displayIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[349])(displayIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[349])(displayIndex);
			#endif
		}

		/// <summary>
		/// Get the name of a display in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetDisplayName(int displayIndex)
		{
			byte* ret = GetDisplayNameNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get the name of a display in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetDisplayNameS(int displayIndex)
		{
			string ret = Utils.DecodeStringUTF8(GetDisplayNameNative(displayIndex));
			return ret;
		}

		/// <summary>
		/// Get the desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDisplayBoundsNative(int displayIndex, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLRect*, int>)funcTable[350])(displayIndex, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[350])(displayIndex, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayBounds(int displayIndex, SDLRect* rect)
		{
			int ret = GetDisplayBoundsNative(displayIndex, rect);
			return ret;
		}

		/// <summary>
		/// Get the desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayBounds(int displayIndex, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = GetDisplayBoundsNative(displayIndex, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the usable desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>
		/// reserved by the system removed. For example, on Apple's macOS, this<br/>
		/// subtracts the area occupied by the menu bar and dock.<br/>
		/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>
		/// so these are good guidelines for the maximum space available to a<br/>
		/// non-fullscreen window.<br/>
		/// The parameter `rect` is ignored if it is NULL.<br/>
		/// This function also returns -1 if the parameter `displayIndex` is out of<br/>
		/// range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDisplayUsableBoundsNative(int displayIndex, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLRect*, int>)funcTable[351])(displayIndex, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[351])(displayIndex, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the usable desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>
		/// reserved by the system removed. For example, on Apple's macOS, this<br/>
		/// subtracts the area occupied by the menu bar and dock.<br/>
		/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>
		/// so these are good guidelines for the maximum space available to a<br/>
		/// non-fullscreen window.<br/>
		/// The parameter `rect` is ignored if it is NULL.<br/>
		/// This function also returns -1 if the parameter `displayIndex` is out of<br/>
		/// range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayUsableBounds(int displayIndex, SDLRect* rect)
		{
			int ret = GetDisplayUsableBoundsNative(displayIndex, rect);
			return ret;
		}

		/// <summary>
		/// Get the usable desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>
		/// reserved by the system removed. For example, on Apple's macOS, this<br/>
		/// subtracts the area occupied by the menu bar and dock.<br/>
		/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>
		/// so these are good guidelines for the maximum space available to a<br/>
		/// non-fullscreen window.<br/>
		/// The parameter `rect` is ignored if it is NULL.<br/>
		/// This function also returns -1 if the parameter `displayIndex` is out of<br/>
		/// range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayUsableBounds(int displayIndex, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = GetDisplayUsableBoundsNative(displayIndex, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDisplayDPINative(int displayIndex, float* ddpi, float* hdpi, float* vdpi)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, float*, float*, float*, int>)funcTable[352])(displayIndex, ddpi, hdpi, vdpi);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, nint, nint, int>)funcTable[352])(displayIndex, (nint)ddpi, (nint)hdpi, (nint)vdpi);
			#endif
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, float* ddpi, float* hdpi, float* vdpi)
		{
			int ret = GetDisplayDPINative(displayIndex, ddpi, hdpi, vdpi);
			return ret;
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, ref float ddpi, float* hdpi, float* vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				int ret = GetDisplayDPINative(displayIndex, (float*)pddpi, hdpi, vdpi);
				return ret;
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, float* ddpi, ref float hdpi, float* vdpi)
		{
			fixed (float* phdpi = &hdpi)
			{
				int ret = GetDisplayDPINative(displayIndex, ddpi, (float*)phdpi, vdpi);
				return ret;
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, ref float ddpi, ref float hdpi, float* vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* phdpi = &hdpi)
				{
					int ret = GetDisplayDPINative(displayIndex, (float*)pddpi, (float*)phdpi, vdpi);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, float* ddpi, float* hdpi, ref float vdpi)
		{
			fixed (float* pvdpi = &vdpi)
			{
				int ret = GetDisplayDPINative(displayIndex, ddpi, hdpi, (float*)pvdpi);
				return ret;
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, ref float ddpi, float* hdpi, ref float vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* pvdpi = &vdpi)
				{
					int ret = GetDisplayDPINative(displayIndex, (float*)pddpi, hdpi, (float*)pvdpi);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, float* ddpi, ref float hdpi, ref float vdpi)
		{
			fixed (float* phdpi = &hdpi)
			{
				fixed (float* pvdpi = &vdpi)
				{
					int ret = GetDisplayDPINative(displayIndex, ddpi, (float*)phdpi, (float*)pvdpi);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayDPI(int displayIndex, ref float ddpi, ref float hdpi, ref float vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* phdpi = &hdpi)
				{
					fixed (float* pvdpi = &vdpi)
					{
						int ret = GetDisplayDPINative(displayIndex, (float*)pddpi, (float*)phdpi, (float*)pvdpi);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the orientation of a display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLDisplayOrientation GetDisplayOrientationNative(int displayIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLDisplayOrientation>)funcTable[353])(displayIndex);
			#else
			return (SDLDisplayOrientation)((delegate* unmanaged[Cdecl]<int, SDLDisplayOrientation>)funcTable[353])(displayIndex);
			#endif
		}

		/// <summary>
		/// Get the orientation of a display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLDisplayOrientation GetDisplayOrientation(int displayIndex)
		{
			SDLDisplayOrientation ret = GetDisplayOrientationNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get the number of available display modes.<br/>
		/// The `displayIndex` needs to be in the range from 0 to<br/>
		/// SDL_GetNumVideoDisplays() - 1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumDisplayModesNative(int displayIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[354])(displayIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[354])(displayIndex);
			#endif
		}

		/// <summary>
		/// Get the number of available display modes.<br/>
		/// The `displayIndex` needs to be in the range from 0 to<br/>
		/// SDL_GetNumVideoDisplays() - 1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumDisplayModes(int displayIndex)
		{
			int ret = GetNumDisplayModesNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get information about a specific display mode.<br/>
		/// The display modes are sorted in this priority:<br/>
		/// - width -> largest to smallest<br/>
		/// - height -> largest to smallest<br/>
		/// - bits per pixel -> more colors to fewer colors<br/>
		/// - packed pixel layout -> largest to smallest<br/>
		/// - refresh rate -> highest to lowest<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDisplayModeNative(int displayIndex, int modeIndex, SDLDisplayMode* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLDisplayMode*, int>)funcTable[355])(displayIndex, modeIndex, mode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, nint, int>)funcTable[355])(displayIndex, modeIndex, (nint)mode);
			#endif
		}

		/// <summary>
		/// Get information about a specific display mode.<br/>
		/// The display modes are sorted in this priority:<br/>
		/// - width -> largest to smallest<br/>
		/// - height -> largest to smallest<br/>
		/// - bits per pixel -> more colors to fewer colors<br/>
		/// - packed pixel layout -> largest to smallest<br/>
		/// - refresh rate -> highest to lowest<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayMode(int displayIndex, int modeIndex, SDLDisplayMode* mode)
		{
			int ret = GetDisplayModeNative(displayIndex, modeIndex, mode);
			return ret;
		}

		/// <summary>
		/// Get information about a specific display mode.<br/>
		/// The display modes are sorted in this priority:<br/>
		/// - width -> largest to smallest<br/>
		/// - height -> largest to smallest<br/>
		/// - bits per pixel -> more colors to fewer colors<br/>
		/// - packed pixel layout -> largest to smallest<br/>
		/// - refresh rate -> highest to lowest<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDisplayMode(int displayIndex, int modeIndex, ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = GetDisplayModeNative(displayIndex, modeIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get information about the desktop's display mode.<br/>
		/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the previous native display mode, and not the current<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDesktopDisplayModeNative(int displayIndex, SDLDisplayMode* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLDisplayMode*, int>)funcTable[356])(displayIndex, mode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[356])(displayIndex, (nint)mode);
			#endif
		}

		/// <summary>
		/// Get information about the desktop's display mode.<br/>
		/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the previous native display mode, and not the current<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDesktopDisplayMode(int displayIndex, SDLDisplayMode* mode)
		{
			int ret = GetDesktopDisplayModeNative(displayIndex, mode);
			return ret;
		}

		/// <summary>
		/// Get information about the desktop's display mode.<br/>
		/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the previous native display mode, and not the current<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetDesktopDisplayMode(int displayIndex, ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = GetDesktopDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get information about the current display mode.<br/>
		/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the current display mode, and not the previous native<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCurrentDisplayModeNative(int displayIndex, SDLDisplayMode* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLDisplayMode*, int>)funcTable[357])(displayIndex, mode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[357])(displayIndex, (nint)mode);
			#endif
		}

		/// <summary>
		/// Get information about the current display mode.<br/>
		/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the current display mode, and not the previous native<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetCurrentDisplayMode(int displayIndex, SDLDisplayMode* mode)
		{
			int ret = GetCurrentDisplayModeNative(displayIndex, mode);
			return ret;
		}

		/// <summary>
		/// Get information about the current display mode.<br/>
		/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the current display mode, and not the previous native<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetCurrentDisplayMode(int displayIndex, ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = GetCurrentDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get the closest match to the requested display mode.<br/>
		/// The available display modes are scanned and `closest` is filled in with the<br/>
		/// closest mode matching the requested mode and returned. The mode format and<br/>
		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
		/// are scanned with size being first priority, format being second priority,<br/>
		/// and finally checking the refresh rate. If all the available modes are too<br/>
		/// small, then NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLDisplayMode* GetClosestDisplayModeNative(int displayIndex, SDLDisplayMode* mode, SDLDisplayMode* closest)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLDisplayMode*, SDLDisplayMode*, SDLDisplayMode*>)funcTable[358])(displayIndex, mode, closest);
			#else
			return (SDLDisplayMode*)((delegate* unmanaged[Cdecl]<int, nint, nint, nint>)funcTable[358])(displayIndex, (nint)mode, (nint)closest);
			#endif
		}

		/// <summary>
		/// Get the closest match to the requested display mode.<br/>
		/// The available display modes are scanned and `closest` is filled in with the<br/>
		/// closest mode matching the requested mode and returned. The mode format and<br/>
		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
		/// are scanned with size being first priority, format being second priority,<br/>
		/// and finally checking the refresh rate. If all the available modes are too<br/>
		/// small, then NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLDisplayMode* GetClosestDisplayMode(int displayIndex, SDLDisplayMode* mode, SDLDisplayMode* closest)
		{
			SDLDisplayMode* ret = GetClosestDisplayModeNative(displayIndex, mode, closest);
			return ret;
		}

		/// <summary>
		/// Get the closest match to the requested display mode.<br/>
		/// The available display modes are scanned and `closest` is filled in with the<br/>
		/// closest mode matching the requested mode and returned. The mode format and<br/>
		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
		/// are scanned with size being first priority, format being second priority,<br/>
		/// and finally checking the refresh rate. If all the available modes are too<br/>
		/// small, then NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLDisplayMode* GetClosestDisplayMode(int displayIndex, ref SDLDisplayMode mode, SDLDisplayMode* closest)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				SDLDisplayMode* ret = GetClosestDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode, closest);
				return ret;
			}
		}

		/// <summary>
		/// Get the closest match to the requested display mode.<br/>
		/// The available display modes are scanned and `closest` is filled in with the<br/>
		/// closest mode matching the requested mode and returned. The mode format and<br/>
		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
		/// are scanned with size being first priority, format being second priority,<br/>
		/// and finally checking the refresh rate. If all the available modes are too<br/>
		/// small, then NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLDisplayMode* GetClosestDisplayMode(int displayIndex, SDLDisplayMode* mode, ref SDLDisplayMode closest)
		{
			fixed (SDLDisplayMode* pclosest = &closest)
			{
				SDLDisplayMode* ret = GetClosestDisplayModeNative(displayIndex, mode, (SDLDisplayMode*)pclosest);
				return ret;
			}
		}

		/// <summary>
		/// Get the closest match to the requested display mode.<br/>
		/// The available display modes are scanned and `closest` is filled in with the<br/>
		/// closest mode matching the requested mode and returned. The mode format and<br/>
		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
		/// are scanned with size being first priority, format being second priority,<br/>
		/// and finally checking the refresh rate. If all the available modes are too<br/>
		/// small, then NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLDisplayMode* GetClosestDisplayMode(int displayIndex, ref SDLDisplayMode mode, ref SDLDisplayMode closest)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				fixed (SDLDisplayMode* pclosest = &closest)
				{
					SDLDisplayMode* ret = GetClosestDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode, (SDLDisplayMode*)pclosest);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the index of the display containing a point<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetPointDisplayIndexNative(SDLPoint* point)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPoint*, int>)funcTable[359])(point);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[359])((nint)point);
			#endif
		}

		/// <summary>
		/// Get the index of the display containing a point<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetPointDisplayIndex(SDLPoint* point)
		{
			int ret = GetPointDisplayIndexNative(point);
			return ret;
		}

		/// <summary>
		/// Get the index of the display containing a point<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetPointDisplayIndex(ref SDLPoint point)
		{
			fixed (SDLPoint* ppoint = &point)
			{
				int ret = GetPointDisplayIndexNative((SDLPoint*)ppoint);
				return ret;
			}
		}

		/// <summary>
		/// Get the index of the display primarily containing a rect<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectDisplayIndexNative(SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, int>)funcTable[360])(rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[360])((nint)rect);
			#endif
		}

		/// <summary>
		/// Get the index of the display primarily containing a rect<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRectDisplayIndex(SDLRect* rect)
		{
			int ret = GetRectDisplayIndexNative(rect);
			return ret;
		}

		/// <summary>
		/// Get the index of the display primarily containing a rect<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRectDisplayIndex(ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = GetRectDisplayIndexNative((SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the index of the display associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowDisplayIndexNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[361])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[361])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the index of the display associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowDisplayIndex(SDLWindow* window)
		{
			int ret = GetWindowDisplayIndexNative(window);
			return ret;
		}

		/// <summary>
		/// Get the index of the display associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowDisplayIndex(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowDisplayIndexNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the display mode to use when a window is visible at fullscreen.<br/>
		/// This only affects the display mode used when the window is fullscreen. To<br/>
		/// change the window size when the window is not fullscreen, use<br/>
		/// SDL_SetWindowSize().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowDisplayModeNative(SDLWindow* window, SDLDisplayMode* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLDisplayMode*, int>)funcTable[362])(window, mode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[362])((nint)window, (nint)mode);
			#endif
		}

		/// <summary>
		/// Set the display mode to use when a window is visible at fullscreen.<br/>
		/// This only affects the display mode used when the window is fullscreen. To<br/>
		/// change the window size when the window is not fullscreen, use<br/>
		/// SDL_SetWindowSize().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowDisplayMode(SDLWindow* window, SDLDisplayMode* mode)
		{
			int ret = SetWindowDisplayModeNative(window, mode);
			return ret;
		}

		/// <summary>
		/// Set the display mode to use when a window is visible at fullscreen.<br/>
		/// This only affects the display mode used when the window is fullscreen. To<br/>
		/// change the window size when the window is not fullscreen, use<br/>
		/// SDL_SetWindowSize().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowDisplayMode(ref SDLWindow window, SDLDisplayMode* mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowDisplayModeNative((SDLWindow*)pwindow, mode);
				return ret;
			}
		}

		/// <summary>
		/// Set the display mode to use when a window is visible at fullscreen.<br/>
		/// This only affects the display mode used when the window is fullscreen. To<br/>
		/// change the window size when the window is not fullscreen, use<br/>
		/// SDL_SetWindowSize().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowDisplayMode(SDLWindow* window, ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SetWindowDisplayModeNative(window, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Set the display mode to use when a window is visible at fullscreen.<br/>
		/// This only affects the display mode used when the window is fullscreen. To<br/>
		/// change the window size when the window is not fullscreen, use<br/>
		/// SDL_SetWindowSize().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowDisplayMode(ref SDLWindow window, ref SDLDisplayMode mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDisplayMode* pmode = &mode)
				{
					int ret = SetWindowDisplayModeNative((SDLWindow*)pwindow, (SDLDisplayMode*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the display mode to use when a window is visible at fullscreen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowDisplayModeNative(SDLWindow* window, SDLDisplayMode* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLDisplayMode*, int>)funcTable[363])(window, mode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[363])((nint)window, (nint)mode);
			#endif
		}

		/// <summary>
		/// Query the display mode to use when a window is visible at fullscreen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowDisplayMode(SDLWindow* window, SDLDisplayMode* mode)
		{
			int ret = GetWindowDisplayModeNative(window, mode);
			return ret;
		}

		/// <summary>
		/// Query the display mode to use when a window is visible at fullscreen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowDisplayMode(ref SDLWindow window, SDLDisplayMode* mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowDisplayModeNative((SDLWindow*)pwindow, mode);
				return ret;
			}
		}

		/// <summary>
		/// Query the display mode to use when a window is visible at fullscreen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowDisplayMode(SDLWindow* window, ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = GetWindowDisplayModeNative(window, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Query the display mode to use when a window is visible at fullscreen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowDisplayMode(ref SDLWindow window, ref SDLDisplayMode mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDisplayMode* pmode = &mode)
				{
					int ret = GetWindowDisplayModeNative((SDLWindow*)pwindow, (SDLDisplayMode*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the raw ICC profile data for the screen the window is currently on.<br/>
		/// Data returned should be freed with SDL_free.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetWindowICCProfileNative(SDLWindow* window, nuint* size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, nuint*, void*>)funcTable[364])(window, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[364])((nint)window, (nint)size);
			#endif
		}

		/// <summary>
		/// Get the raw ICC profile data for the screen the window is currently on.<br/>
		/// Data returned should be freed with SDL_free.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowICCProfile(SDLWindow* window, nuint* size)
		{
			void* ret = GetWindowICCProfileNative(window, size);
			return ret;
		}

		/// <summary>
		/// Get the raw ICC profile data for the screen the window is currently on.<br/>
		/// Data returned should be freed with SDL_free.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowICCProfile(ref SDLWindow window, nuint* size)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = GetWindowICCProfileNative((SDLWindow*)pwindow, size);
				return ret;
			}
		}

		/// <summary>
		/// Get the raw ICC profile data for the screen the window is currently on.<br/>
		/// Data returned should be freed with SDL_free.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowICCProfile(SDLWindow* window, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				void* ret = GetWindowICCProfileNative(window, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// Get the raw ICC profile data for the screen the window is currently on.<br/>
		/// Data returned should be freed with SDL_free.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowICCProfile(ref SDLWindow window, ref nuint size)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (nuint* psize = &size)
				{
					void* ret = GetWindowICCProfileNative((SDLWindow*)pwindow, (nuint*)psize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the pixel format associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetWindowPixelFormatNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint>)funcTable[365])(window);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[365])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the pixel format associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowPixelFormat(SDLWindow* window)
		{
			uint ret = GetWindowPixelFormatNative(window);
			return ret;
		}

		/// <summary>
		/// Get the pixel format associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowPixelFormat(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = GetWindowPixelFormatNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Create a window with the specified position, dimensions, and flags.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>
		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>
		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>
		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>
		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>
		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>
		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>
		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>
		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>
		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>
		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>
		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>
		/// supported (>= SDL 2.0.1)<br/>
		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>
		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>
		/// queried later using SDL_GetWindowFlags().<br/>
		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>
		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>
		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>
		/// in pixels may differ from its size in screen coordinates on platforms with<br/>
		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>
		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>
		/// when this flag is set, the drawable size can vary after the window is<br/>
		/// created and should be queried after major window events such as when the<br/>
		/// window is resized or moved between displays.<br/>
		/// If the window is set fullscreen, the width and height parameters `w` and<br/>
		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>
		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>
		/// platforms at window creation.<br/>
		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>
		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>
		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>
		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>
		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>
		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>
		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>
		/// SDL_CreateWindow() will fail.<br/>
		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>
		/// loader or link to a dynamic library version. This limitation may be removed<br/>
		/// in a future version of SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* CreateWindowNative(byte* title, int x, int y, int w, int h, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int, int, int, uint, SDLWindow*>)funcTable[366])(title, x, y, w, h, flags);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, int, int, int, int, uint, nint>)funcTable[366])((nint)title, x, y, w, h, flags);
			#endif
		}

		/// <summary>
		/// Create a window with the specified position, dimensions, and flags.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>
		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>
		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>
		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>
		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>
		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>
		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>
		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>
		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>
		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>
		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>
		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>
		/// supported (>= SDL 2.0.1)<br/>
		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>
		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>
		/// queried later using SDL_GetWindowFlags().<br/>
		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>
		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>
		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>
		/// in pixels may differ from its size in screen coordinates on platforms with<br/>
		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>
		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>
		/// when this flag is set, the drawable size can vary after the window is<br/>
		/// created and should be queried after major window events such as when the<br/>
		/// window is resized or moved between displays.<br/>
		/// If the window is set fullscreen, the width and height parameters `w` and<br/>
		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>
		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>
		/// platforms at window creation.<br/>
		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>
		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>
		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>
		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>
		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>
		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>
		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>
		/// SDL_CreateWindow() will fail.<br/>
		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>
		/// loader or link to a dynamic library version. This limitation may be removed<br/>
		/// in a future version of SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateWindow(byte* title, int x, int y, int w, int h, uint flags)
		{
			SDLWindow* ret = CreateWindowNative(title, x, y, w, h, flags);
			return ret;
		}

		/// <summary>
		/// Create a window with the specified position, dimensions, and flags.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>
		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>
		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>
		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>
		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>
		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>
		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>
		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>
		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>
		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>
		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>
		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>
		/// supported (>= SDL 2.0.1)<br/>
		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>
		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>
		/// queried later using SDL_GetWindowFlags().<br/>
		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>
		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>
		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>
		/// in pixels may differ from its size in screen coordinates on platforms with<br/>
		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>
		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>
		/// when this flag is set, the drawable size can vary after the window is<br/>
		/// created and should be queried after major window events such as when the<br/>
		/// window is resized or moved between displays.<br/>
		/// If the window is set fullscreen, the width and height parameters `w` and<br/>
		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>
		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>
		/// platforms at window creation.<br/>
		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>
		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>
		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>
		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>
		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>
		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>
		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>
		/// SDL_CreateWindow() will fail.<br/>
		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>
		/// loader or link to a dynamic library version. This limitation may be removed<br/>
		/// in a future version of SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateWindow(ref byte title, int x, int y, int w, int h, uint flags)
		{
			fixed (byte* ptitle = &title)
			{
				SDLWindow* ret = CreateWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a window with the specified position, dimensions, and flags.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>
		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>
		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>
		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>
		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>
		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>
		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>
		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>
		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>
		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>
		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>
		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>
		/// supported (>= SDL 2.0.1)<br/>
		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>
		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>
		/// queried later using SDL_GetWindowFlags().<br/>
		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>
		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>
		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>
		/// in pixels may differ from its size in screen coordinates on platforms with<br/>
		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>
		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>
		/// when this flag is set, the drawable size can vary after the window is<br/>
		/// created and should be queried after major window events such as when the<br/>
		/// window is resized or moved between displays.<br/>
		/// If the window is set fullscreen, the width and height parameters `w` and<br/>
		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>
		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>
		/// platforms at window creation.<br/>
		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>
		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>
		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>
		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>
		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>
		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>
		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>
		/// SDL_CreateWindow() will fail.<br/>
		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>
		/// loader or link to a dynamic library version. This limitation may be removed<br/>
		/// in a future version of SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateWindow(ReadOnlySpan<byte> title, int x, int y, int w, int h, uint flags)
		{
			fixed (byte* ptitle = title)
			{
				SDLWindow* ret = CreateWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a window with the specified position, dimensions, and flags.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>
		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>
		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>
		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>
		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>
		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>
		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>
		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>
		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>
		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>
		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>
		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>
		/// supported (>= SDL 2.0.1)<br/>
		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>
		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>
		/// queried later using SDL_GetWindowFlags().<br/>
		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>
		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>
		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>
		/// in pixels may differ from its size in screen coordinates on platforms with<br/>
		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>
		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>
		/// when this flag is set, the drawable size can vary after the window is<br/>
		/// created and should be queried after major window events such as when the<br/>
		/// window is resized or moved between displays.<br/>
		/// If the window is set fullscreen, the width and height parameters `w` and<br/>
		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>
		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>
		/// platforms at window creation.<br/>
		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>
		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>
		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>
		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>
		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>
		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>
		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>
		/// SDL_CreateWindow() will fail.<br/>
		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>
		/// loader or link to a dynamic library version. This limitation may be removed<br/>
		/// in a future version of SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateWindow(string title, int x, int y, int w, int h, uint flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLWindow* ret = CreateWindowNative(pStr0, x, y, w, h, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Create an SDL window from an existing native window.<br/>
		/// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)<br/>
		/// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured<br/>
		/// before using SDL_CreateWindowFrom().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* CreateWindowFromNative(void* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, SDLWindow*>)funcTable[367])(data);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[367])((nint)data);
			#endif
		}

		/// <summary>
		/// Create an SDL window from an existing native window.<br/>
		/// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)<br/>
		/// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured<br/>
		/// before using SDL_CreateWindowFrom().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* CreateWindowFrom(void* data)
		{
			SDLWindow* ret = CreateWindowFromNative(data);
			return ret;
		}

		/// <summary>
		/// Get the numeric ID of a window.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetWindowIDNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint>)funcTable[368])(window);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[368])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the numeric ID of a window.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowID(SDLWindow* window)
		{
			uint ret = GetWindowIDNative(window);
			return ret;
		}

		/// <summary>
		/// Get the numeric ID of a window.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowID(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = GetWindowIDNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window from a stored ID.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetWindowFromIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLWindow*>)funcTable[369])(id);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[369])(id);
			#endif
		}

		/// <summary>
		/// Get a window from a stored ID.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GetWindowFromID(uint id)
		{
			SDLWindow* ret = GetWindowFromIDNative(id);
			return ret;
		}

		/// <summary>
		/// Get the window flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetWindowFlagsNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint>)funcTable[370])(window);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[370])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the window flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowFlags(SDLWindow* window)
		{
			uint ret = GetWindowFlagsNative(window);
			return ret;
		}

		/// <summary>
		/// Get the window flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowFlags(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = GetWindowFlagsNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowTitleNative(SDLWindow* window, byte* title)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, byte*, void>)funcTable[371])(window, title);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[371])((nint)window, (nint)title);
			#endif
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindow* window, byte* title)
		{
			SetWindowTitleNative(window, title);
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, byte* title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowTitleNative((SDLWindow*)pwindow, title);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindow* window, ref byte title)
		{
			fixed (byte* ptitle = &title)
			{
				SetWindowTitleNative(window, (byte*)ptitle);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindow* window, ReadOnlySpan<byte> title)
		{
			fixed (byte* ptitle = title)
			{
				SetWindowTitleNative(window, (byte*)ptitle);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindow* window, string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowTitleNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, ref byte title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* ptitle = &title)
				{
					SetWindowTitleNative((SDLWindow*)pwindow, (byte*)ptitle);
				}
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, ReadOnlySpan<byte> title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* ptitle = title)
				{
					SetWindowTitleNative((SDLWindow*)pwindow, (byte*)ptitle);
				}
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, string title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (title != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(title);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetWindowTitleNative((SDLWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetWindowTitleNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte*>)funcTable[372])(window);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[372])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWindowTitle(SDLWindow* window)
		{
			byte* ret = GetWindowTitleNative(window);
			return ret;
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWindowTitleS(SDLWindow* window)
		{
			string ret = Utils.DecodeStringUTF8(GetWindowTitleNative(window));
			return ret;
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWindowTitle(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* ret = GetWindowTitleNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWindowTitleS(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				string ret = Utils.DecodeStringUTF8(GetWindowTitleNative((SDLWindow*)pwindow));
				return ret;
			}
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowIconNative(SDLWindow* window, SDLSurface* icon)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*, void>)funcTable[373])(window, icon);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[373])((nint)window, (nint)icon);
			#endif
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(SDLWindow* window, SDLSurface* icon)
		{
			SetWindowIconNative(window, icon);
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(ref SDLWindow window, SDLSurface* icon)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowIconNative((SDLWindow*)pwindow, icon);
			}
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(SDLWindow* window, ref SDLSurface icon)
		{
			fixed (SDLSurface* picon = &icon)
			{
				SetWindowIconNative(window, (SDLSurface*)picon);
			}
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(ref SDLWindow window, ref SDLSurface icon)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* picon = &icon)
				{
					SetWindowIconNative((SDLWindow*)pwindow, (SDLSurface*)picon);
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SetWindowDataNative(SDLWindow* window, byte* name, void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte*, void*, void*>)funcTable[374])(window, name, userdata);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)funcTable[374])((nint)window, (nint)name, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindow* window, byte* name, void* userdata)
		{
			void* ret = SetWindowDataNative(window, name, userdata);
			return ret;
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, byte* name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = SetWindowDataNative((SDLWindow*)pwindow, name, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindow* window, ref byte name, void* userdata)
		{
			fixed (byte* pname = &name)
			{
				void* ret = SetWindowDataNative(window, (byte*)pname, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindow* window, ReadOnlySpan<byte> name, void* userdata)
		{
			fixed (byte* pname = name)
			{
				void* ret = SetWindowDataNative(window, (byte*)pname, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindow* window, string name, void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SetWindowDataNative(window, pStr0, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, ref byte name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					void* ret = SetWindowDataNative((SDLWindow*)pwindow, (byte*)pname, userdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, ReadOnlySpan<byte> name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = name)
				{
					void* ret = SetWindowDataNative((SDLWindow*)pwindow, (byte*)pname, userdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, string name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = SetWindowDataNative((SDLWindow*)pwindow, pStr0, userdata);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetWindowDataNative(SDLWindow* window, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte*, void*>)funcTable[375])(window, name);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[375])((nint)window, (nint)name);
			#endif
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindow* window, byte* name)
		{
			void* ret = GetWindowDataNative(window, name);
			return ret;
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, byte* name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = GetWindowDataNative((SDLWindow*)pwindow, name);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindow* window, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				void* ret = GetWindowDataNative(window, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindow* window, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				void* ret = GetWindowDataNative(window, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindow* window, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetWindowDataNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, ref byte name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					void* ret = GetWindowDataNative((SDLWindow*)pwindow, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, ReadOnlySpan<byte> name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = name)
				{
					void* ret = GetWindowDataNative((SDLWindow*)pwindow, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, string name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = GetWindowDataNative((SDLWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Set the position of a window.<br/>
		/// The window coordinate origin is the upper left of the display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowPositionNative(SDLWindow* window, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[376])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[376])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Set the position of a window.<br/>
		/// The window coordinate origin is the upper left of the display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowPosition(SDLWindow* window, int x, int y)
		{
			SetWindowPositionNative(window, x, y);
		}

		/// <summary>
		/// Set the position of a window.<br/>
		/// The window coordinate origin is the upper left of the display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowPosition(ref SDLWindow window, int x, int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowPositionNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowPositionNative(SDLWindow* window, int* x, int* y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[377])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[377])((nint)window, (nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindow* window, int* x, int* y)
		{
			GetWindowPositionNative(window, x, y);
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, int* x, int* y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowPositionNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindow* window, ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				GetWindowPositionNative(window, (int*)px, y);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, ref int x, int* y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* px = &x)
				{
					GetWindowPositionNative((SDLWindow*)pwindow, (int*)px, y);
				}
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindow* window, int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				GetWindowPositionNative(window, x, (int*)py);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, int* x, ref int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* py = &y)
				{
					GetWindowPositionNative((SDLWindow*)pwindow, x, (int*)py);
				}
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindow* window, ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					GetWindowPositionNative(window, (int*)px, (int*)py);
				}
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, ref int x, ref int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* px = &x)
				{
					fixed (int* py = &y)
					{
						GetWindowPositionNative((SDLWindow*)pwindow, (int*)px, (int*)py);
					}
				}
			}
		}

		/// <summary>
		/// Set the size of a window's client area.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>
		/// Fullscreen windows automatically match the size of the display mode, and<br/>
		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowSizeNative(SDLWindow* window, int w, int h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[378])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[378])((nint)window, w, h);
			#endif
		}

		/// <summary>
		/// Set the size of a window's client area.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>
		/// Fullscreen windows automatically match the size of the display mode, and<br/>
		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowSize(SDLWindow* window, int w, int h)
		{
			SetWindowSizeNative(window, w, h);
		}

		/// <summary>
		/// Set the size of a window's client area.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>
		/// Fullscreen windows automatically match the size of the display mode, and<br/>
		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowSize(ref SDLWindow window, int w, int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[379])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[379])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindow* window, int* w, int* h)
		{
			GetWindowSizeNative(window, w, h);
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowBordersSizeNative(SDLWindow* window, int* top, int* left, int* bottom, int* right)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, int*, int*, int>)funcTable[380])(window, top, left, bottom, right);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[380])((nint)window, (nint)top, (nint)left, (nint)bottom, (nint)right);
			#endif
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, int* left, int* bottom, int* right)
		{
			int ret = GetWindowBordersSizeNative(window, top, left, bottom, right);
			return ret;
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, int* left, int* bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				int ret = GetWindowBordersSizeNative(window, (int*)ptop, left, bottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, ref int left, int* bottom, int* right)
		{
			fixed (int* pleft = &left)
			{
				int ret = GetWindowBordersSizeNative(window, top, (int*)pleft, bottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, ref int left, int* bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					int ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, int* left, ref int bottom, int* right)
		{
			fixed (int* pbottom = &bottom)
			{
				int ret = GetWindowBordersSizeNative(window, top, left, (int*)pbottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, int* left, ref int bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = GetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, ref int left, ref int bottom, int* right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = GetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, ref int left, ref int bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, right);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, int* left, int* bottom, ref int right)
		{
			fixed (int* pright = &right)
			{
				int ret = GetWindowBordersSizeNative(window, top, left, bottom, (int*)pright);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, int* left, int* bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative(window, (int*)ptop, left, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, ref int left, int* bottom, ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative(window, top, (int*)pleft, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, ref int left, int* bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, int* left, ref int bottom, ref int right)
		{
			fixed (int* pbottom = &bottom)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative(window, top, left, (int*)pbottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, int* left, ref int bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, int* top, ref int left, ref int bottom, ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindow* window, ref int top, ref int left, ref int bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							fixed (int* pright = &right)
							{
								int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowSizeInPixelsNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[381])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[381])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindow* window, int* w, int* h)
		{
			GetWindowSizeInPixelsNative(window, w, h);
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowSizeInPixelsNative(window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowSizeInPixelsNative(window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeInPixelsNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMinimumSizeNative(SDLWindow* window, int minW, int minH)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[382])(window, minW, minH);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[382])((nint)window, minW, minH);
			#endif
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMinimumSize(SDLWindow* window, int minW, int minH)
		{
			SetWindowMinimumSizeNative(window, minW, minH);
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMinimumSize(ref SDLWindow window, int minW, int minH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowMinimumSizeNative((SDLWindow*)pwindow, minW, minH);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowMinimumSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[383])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[383])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindow* window, int* w, int* h)
		{
			GetWindowMinimumSizeNative(window, w, h);
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowMinimumSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowMinimumSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowMinimumSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMaximumSizeNative(SDLWindow* window, int maxW, int maxH)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[384])(window, maxW, maxH);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[384])((nint)window, maxW, maxH);
			#endif
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMaximumSize(SDLWindow* window, int maxW, int maxH)
		{
			SetWindowMaximumSizeNative(window, maxW, maxH);
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMaximumSize(ref SDLWindow window, int maxW, int maxH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowMaximumSizeNative((SDLWindow*)pwindow, maxW, maxH);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowMaximumSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[385])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[385])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindow* window, int* w, int* h)
		{
			GetWindowMaximumSizeNative(window, w, h);
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, h);
			}
		}
	}
}
