// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, byte* fmt)
		{
			LogWarnNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogWarnNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogWarnNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogWarnNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogErrorNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[710])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[710])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, byte* fmt)
		{
			LogErrorNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogErrorNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogErrorNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogErrorNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogCriticalNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[711])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[711])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, byte* fmt)
		{
			LogCriticalNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogCriticalNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogCriticalNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogCriticalNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogMessageNative(int category, SDLLogPriority priority, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, byte*, void>)funcTable[712])(category, priority, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, nint, void>)funcTable[712])(category, priority, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, byte* fmt)
		{
			LogMessageNative(category, priority, fmt);
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogMessageNative(category, priority, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogMessageNative(category, priority, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogMessageNative(category, priority, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogMessageVNative(int category, SDLLogPriority priority, byte* fmt, nint ap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, byte*, nint, void>)funcTable[713])(category, priority, fmt, ap);
			#else
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, nint, nint, void>)funcTable[713])(category, priority, (nint)fmt, ap);
			#endif
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, byte* fmt, nint ap)
		{
			LogMessageVNative(category, priority, fmt, ap);
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, in byte fmt, nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogMessageVNative(category, priority, (byte*)pfmt, ap);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				LogMessageVNative(category, priority, (byte*)pfmt, ap);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, string fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogMessageVNative(category, priority, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Get the current log output function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogGetOutputFunctionNative(delegate*<void*, int, SDLLogPriority, byte*, void>* callback, void** userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, int, SDLLogPriority, byte*, void>*, void**, void>)funcTable[714])(callback, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[714])((nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Get the current log output function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogGetOutputFunction(delegate*<void*, int, SDLLogPriority, byte*, void>* callback, void** userdata)
		{
			LogGetOutputFunctionNative(callback, userdata);
		}

		/// <summary>
		/// Get the current log output function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogGetOutputFunction(delegate*<void*, int, SDLLogPriority, byte*, void>* callback, ref nint userdata)
		{
			fixed (nint* puserdata = &userdata)
			{
				LogGetOutputFunctionNative(callback, (void**)puserdata);
			}
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogSetOutputFunctionNative(delegate*<void*, int, SDLLogPriority, byte*, void> callback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, int, SDLLogPriority, byte*, void>, void*, void>)funcTable[715])(callback, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[715])((nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogSetOutputFunction(delegate*<void*, int, SDLLogPriority, byte*, void> callback, void* userdata)
		{
			LogSetOutputFunctionNative(callback, userdata);
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogSetOutputFunction(SDLLogOutputFunction callback, void* userdata)
		{
			LogSetOutputFunctionNative((delegate*<void*, int, SDLLogPriority, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogSetOutputFunction(delegate*<void*, int, SDLLogPriority, byte*, void> callback, nint userdata)
		{
			LogSetOutputFunctionNative(callback, (void*)userdata);
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogSetOutputFunction(SDLLogOutputFunction callback, nint userdata)
		{
			LogSetOutputFunctionNative((delegate*<void*, int, SDLLogPriority, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShowMessageBoxNative(SDLMessageBoxData* messageboxdata, int* buttonid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMessageBoxData*, int*, int>)funcTable[716])(messageboxdata, buttonid);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[716])((nint)messageboxdata, (nint)buttonid);
			#endif
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(SDLMessageBoxDataPtr messageboxdata, int* buttonid)
		{
			int ret = ShowMessageBoxNative((SDLMessageBoxData*)messageboxdata, buttonid);
			return ret;
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(in SDLMessageBoxData messageboxdata, int* buttonid)
		{
			fixed (SDLMessageBoxData* pmessageboxdata = &messageboxdata)
			{
				int ret = ShowMessageBoxNative((SDLMessageBoxData*)pmessageboxdata, buttonid);
				return ret;
			}
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(SDLMessageBoxDataPtr messageboxdata, ref int buttonid)
		{
			fixed (int* pbuttonid = &buttonid)
			{
				int ret = ShowMessageBoxNative((SDLMessageBoxData*)messageboxdata, (int*)pbuttonid);
				return ret;
			}
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(in SDLMessageBoxData messageboxdata, ref int buttonid)
		{
			fixed (SDLMessageBoxData* pmessageboxdata = &messageboxdata)
			{
				fixed (int* pbuttonid = &buttonid)
				{
					int ret = ShowMessageBoxNative((SDLMessageBoxData*)pmessageboxdata, (int*)pbuttonid);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShowSimpleMessageBoxNative(uint flags, byte* title, byte* message, SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, SDLWindow*, int>)funcTable[717])(flags, title, message, window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, int>)funcTable[717])(flags, (nint)title, (nint)message, (nint)window);
			#endif
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, byte* message, SDLWindowPtr window)
		{
			int ret = ShowSimpleMessageBoxNative(flags, title, message, (SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, in byte title, byte* message, SDLWindowPtr window)
		{
			fixed (byte* ptitle = &title)
			{
				int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, (SDLWindow*)window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, byte* message, SDLWindowPtr window)
		{
			fixed (byte* ptitle = title)
			{
				int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, (SDLWindow*)window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, byte* message, SDLWindowPtr window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ShowSimpleMessageBoxNative(flags, pStr0, message, (SDLWindow*)window);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, in byte message, SDLWindowPtr window)
		{
			fixed (byte* pmessage = &message)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, (SDLWindow*)window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, ReadOnlySpan<byte> message, SDLWindowPtr window)
		{
			fixed (byte* pmessage = message)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, (SDLWindow*)window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, string message, SDLWindowPtr window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ShowSimpleMessageBoxNative(flags, title, pStr0, (SDLWindow*)window);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, in byte title, in byte message, SDLWindowPtr window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (byte* pmessage = &message)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, (SDLWindow*)window);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, ReadOnlySpan<byte> message, SDLWindowPtr window)
		{
			fixed (byte* ptitle = title)
			{
				fixed (byte* pmessage = message)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, (SDLWindow*)window);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, string message, SDLWindowPtr window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (message != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(message);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(message, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ShowSimpleMessageBoxNative(flags, pStr0, pStr1, (SDLWindow*)window);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, byte* message, ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, message, (SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, in byte title, byte* message, ref SDLWindow window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, byte* message, ref SDLWindow window)
		{
			fixed (byte* ptitle = title)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, byte* message, ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, pStr0, message, (SDLWindow*)pwindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, in byte message, ref SDLWindow window)
		{
			fixed (byte* pmessage = &message)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, ReadOnlySpan<byte> message, ref SDLWindow window)
		{
			fixed (byte* pmessage = message)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, string message, ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, pStr0, (SDLWindow*)pwindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, in byte title, in byte message, ref SDLWindow window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (byte* pmessage = &message)
				{
					fixed (SDLWindow* pwindow = &window)
					{
						int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, (SDLWindow*)pwindow);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, ReadOnlySpan<byte> message, ref SDLWindow window)
		{
			fixed (byte* ptitle = title)
			{
				fixed (byte* pmessage = message)
				{
					fixed (SDLWindow* pwindow = &window)
					{
						int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, (SDLWindow*)pwindow);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, string message, ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (message != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(message);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(message, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, pStr0, pStr1, (SDLWindow*)pwindow);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
		/// window.<br/>
		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
		/// its own. It is up to user code to do that.<br/>
		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MetalCreateViewNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, void*>)funcTable[718])(window);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[718])((nint)window);
			#endif
		}

		/// <summary>
		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
		/// window.<br/>
		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
		/// its own. It is up to user code to do that.<br/>
		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* MetalCreateView(SDLWindowPtr window)
		{
			void* ret = MetalCreateViewNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
		/// window.<br/>
		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
		/// its own. It is up to user code to do that.<br/>
		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* MetalCreateView(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = MetalCreateViewNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Destroy an existing SDL_MetalView object.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>
		/// called after SDL_CreateWindow.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MetalDestroyViewNative(void* view)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[719])(view);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[719])((nint)view);
			#endif
		}

		/// <summary>
		/// Destroy an existing SDL_MetalView object.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>
		/// called after SDL_CreateWindow.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalDestroyView(void* view)
		{
			MetalDestroyViewNative(view);
		}

		/// <summary>
		/// Destroy an existing SDL_MetalView object.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>
		/// called after SDL_CreateWindow.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalDestroyView(nint view)
		{
			MetalDestroyViewNative((void*)view);
		}

		/// <summary>
		/// Get a pointer to the backing CAMetalLayer for the given view.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MetalGetLayerNative(void* view)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*>)funcTable[720])(view);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[720])((nint)view);
			#endif
		}

		/// <summary>
		/// Get a pointer to the backing CAMetalLayer for the given view.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* MetalGetLayer(void* view)
		{
			void* ret = MetalGetLayerNative(view);
			return ret;
		}

		/// <summary>
		/// Get a pointer to the backing CAMetalLayer for the given view.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* MetalGetLayer(nint view)
		{
			void* ret = MetalGetLayerNative((void*)view);
			return ret;
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MetalGetDrawableSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[721])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[721])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindowPtr window, int* w, int* h)
		{
			MetalGetDrawableSizeNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				MetalGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindowPtr window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				MetalGetDrawableSizeNative((SDLWindow*)window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					MetalGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindowPtr window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				MetalGetDrawableSizeNative((SDLWindow*)window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					MetalGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindowPtr window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					MetalGetDrawableSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						MetalGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetPowerInfoNative(int* seconds, int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, SDLPowerState>)funcTable[722])(seconds, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[722])((nint)seconds, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(int* seconds, int* percent)
		{
			SDLPowerState ret = GetPowerInfoNative(seconds, percent);
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(ref int seconds, int* percent)
		{
			fixed (int* pseconds = &seconds)
			{
				SDLPowerState ret = GetPowerInfoNative((int*)pseconds, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(int* seconds, ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetPowerInfoNative(seconds, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(ref int seconds, ref int percent)
		{
			fixed (int* pseconds = &seconds)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetPowerInfoNative((int*)pseconds, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of 2D rendering drivers available for the current display.<br/>
		/// A render driver is a set of code that handles rendering and texture<br/>
		/// management on a particular display. Normally there is only one, but some<br/>
		/// drivers may have several available with different capabilities.<br/>
		/// There may be none if SDL was compiled without render support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumRenderDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[723])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[723])();
			#endif
		}

		/// <summary>
		/// Get the number of 2D rendering drivers available for the current display.<br/>
		/// A render driver is a set of code that handles rendering and texture<br/>
		/// management on a particular display. Normally there is only one, but some<br/>
		/// drivers may have several available with different capabilities.<br/>
		/// There may be none if SDL was compiled without render support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumRenderDrivers()
		{
			int ret = GetNumRenderDriversNative();
			return ret;
		}

		/// <summary>
		/// Get info about a specific 2D rendering driver for the current display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRenderDriverInfoNative(int index, SDLRendererInfo* info)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLRendererInfo*, int>)funcTable[724])(index, info);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[724])(index, (nint)info);
			#endif
		}

		/// <summary>
		/// Get info about a specific 2D rendering driver for the current display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRenderDriverInfo(int index, SDLRendererInfoPtr info)
		{
			int ret = GetRenderDriverInfoNative(index, (SDLRendererInfo*)info);
			return ret;
		}

		/// <summary>
		/// Get info about a specific 2D rendering driver for the current display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRenderDriverInfo(int index, ref SDLRendererInfo info)
		{
			fixed (SDLRendererInfo* pinfo = &info)
			{
				int ret = GetRenderDriverInfoNative(index, (SDLRendererInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateWindowAndRendererNative(int width, int height, uint windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, uint, SDLWindow**, SDLRenderer**, int>)funcTable[725])(width, height, windowFlags, window, renderer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, uint, nint, nint, int>)funcTable[725])(width, height, windowFlags, (nint)window, (nint)renderer);
			#endif
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, SDLWindowPtrPtr window, SDLRendererPtrPtr renderer)
		{
			int ret = CreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)window, (SDLRenderer**)renderer);
			return ret;
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, ref SDLWindow* window, SDLRendererPtrPtr renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				int ret = CreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)renderer);
				return ret;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, SDLWindowPtrPtr window, ref SDLRenderer* renderer)
		{
			fixed (SDLRenderer** prenderer = &renderer)
			{
				int ret = CreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)window, (SDLRenderer**)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, ref SDLWindow* window, ref SDLRenderer* renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				fixed (SDLRenderer** prenderer = &renderer)
				{
					int ret = CreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)prenderer);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* CreateRendererNative(SDLWindow* window, int index, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, uint, SDLRenderer*>)funcTable[726])(window, index, flags);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, int, uint, nint>)funcTable[726])((nint)window, index, flags);
			#endif
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRendererPtr CreateRenderer(SDLWindowPtr window, int index, uint flags)
		{
			SDLRendererPtr ret = CreateRendererNative((SDLWindow*)window, index, flags);
			return ret;
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRendererPtr CreateRenderer(ref SDLWindow window, int index, uint flags)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRendererPtr ret = CreateRendererNative((SDLWindow*)pwindow, index, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* CreateSoftwareRendererNative(SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRenderer*>)funcTable[727])(surface);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[727])((nint)surface);
			#endif
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRendererPtr CreateSoftwareRenderer(SDLSurfacePtr surface)
		{
			SDLRendererPtr ret = CreateSoftwareRendererNative((SDLSurface*)surface);
			return ret;
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRendererPtr CreateSoftwareRenderer(ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLRendererPtr ret = CreateSoftwareRendererNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* GetRendererNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRenderer*>)funcTable[728])(window);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[728])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRendererPtr GetRenderer(SDLWindowPtr window)
		{
			SDLRendererPtr ret = GetRendererNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRendererPtr GetRenderer(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRendererPtr ret = GetRendererNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* RenderGetWindowNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLWindow*>)funcTable[729])(renderer);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[729])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr RenderGetWindow(SDLRendererPtr renderer)
		{
			SDLWindowPtr ret = RenderGetWindowNative((SDLRenderer*)renderer);
			return ret;
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr RenderGetWindow(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLWindowPtr ret = RenderGetWindowNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRendererInfoNative(SDLRenderer* renderer, SDLRendererInfo* info)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRendererInfo*, int>)funcTable[730])(renderer, info);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[730])((nint)renderer, (nint)info);
			#endif
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(SDLRendererPtr renderer, SDLRendererInfoPtr info)
		{
			int ret = GetRendererInfoNative((SDLRenderer*)renderer, (SDLRendererInfo*)info);
			return ret;
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(ref SDLRenderer renderer, SDLRendererInfoPtr info)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = GetRendererInfoNative((SDLRenderer*)prenderer, (SDLRendererInfo*)info);
				return ret;
			}
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(SDLRendererPtr renderer, ref SDLRendererInfo info)
		{
			fixed (SDLRendererInfo* pinfo = &info)
			{
				int ret = GetRendererInfoNative((SDLRenderer*)renderer, (SDLRendererInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(ref SDLRenderer renderer, ref SDLRendererInfo info)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRendererInfo* pinfo = &info)
				{
					int ret = GetRendererInfoNative((SDLRenderer*)prenderer, (SDLRendererInfo*)pinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRendererOutputSizeNative(SDLRenderer* renderer, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int*, int*, int>)funcTable[731])(renderer, w, h);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[731])((nint)renderer, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRendererPtr renderer, int* w, int* h)
		{
			int ret = GetRendererOutputSizeNative((SDLRenderer*)renderer, w, h);
			return ret;
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, int* w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRendererPtr renderer, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				int ret = GetRendererOutputSizeNative((SDLRenderer*)renderer, (int*)pw, h);
				return ret;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, ref int w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRendererPtr renderer, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				int ret = GetRendererOutputSizeNative((SDLRenderer*)renderer, w, (int*)ph);
				return ret;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, int* w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRendererPtr renderer, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					int ret = GetRendererOutputSizeNative((SDLRenderer*)renderer, (int*)pw, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, ref int w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// You can set the texture scaling method by setting<br/>
		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* CreateTextureNative(SDLRenderer* renderer, uint format, int access, int w, int h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, uint, int, int, int, SDLTexture*>)funcTable[732])(renderer, format, access, w, h);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, uint, int, int, int, nint>)funcTable[732])((nint)renderer, format, access, w, h);
			#endif
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// You can set the texture scaling method by setting<br/>
		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexturePtr CreateTexture(SDLRendererPtr renderer, uint format, int access, int w, int h)
		{
			SDLTexturePtr ret = CreateTextureNative((SDLRenderer*)renderer, format, access, w, h);
			return ret;
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// You can set the texture scaling method by setting<br/>
		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexturePtr CreateTexture(ref SDLRenderer renderer, uint format, int access, int w, int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexturePtr ret = CreateTextureNative((SDLRenderer*)prenderer, format, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* CreateTextureFromSurfaceNative(SDLRenderer* renderer, SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLSurface*, SDLTexture*>)funcTable[733])(renderer, surface);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[733])((nint)renderer, (nint)surface);
			#endif
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexturePtr CreateTextureFromSurface(SDLRendererPtr renderer, SDLSurfacePtr surface)
		{
			SDLTexturePtr ret = CreateTextureFromSurfaceNative((SDLRenderer*)renderer, (SDLSurface*)surface);
			return ret;
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexturePtr CreateTextureFromSurface(ref SDLRenderer renderer, SDLSurfacePtr surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexturePtr ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, (SDLSurface*)surface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexturePtr CreateTextureFromSurface(SDLRendererPtr renderer, ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLTexturePtr ret = CreateTextureFromSurfaceNative((SDLRenderer*)renderer, (SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexturePtr CreateTextureFromSurface(ref SDLRenderer renderer, ref SDLSurface surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLSurface* psurface = &surface)
				{
					SDLTexturePtr ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, (SDLSurface*)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int QueryTextureNative(SDLTexture* texture, uint* format, int* access, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, uint*, int*, int*, int*, int>)funcTable[734])(texture, format, access, w, h);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[734])((nint)texture, (nint)format, (nint)access, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, int* access, int* w, int* h)
		{
			int ret = QueryTextureNative((SDLTexture*)texture, format, access, w, h);
			return ret;
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, int* access, int* w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, ref int access, int* w, int* h)
		{
			fixed (int* paccess = &access)
			{
				int ret = QueryTextureNative((SDLTexture*)texture, format, (int*)paccess, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, ref int access, int* w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, int* access, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				int ret = QueryTextureNative((SDLTexture*)texture, format, access, (int*)pw, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, int* access, ref int w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, ref int access, ref int w, int* h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative((SDLTexture*)texture, format, (int*)paccess, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, ref int access, ref int w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, h);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, int* access, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				int ret = QueryTextureNative((SDLTexture*)texture, format, access, w, (int*)ph);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, int* access, int* w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, ref int access, int* w, ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative((SDLTexture*)texture, format, (int*)paccess, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, ref int access, int* w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, int* access, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative((SDLTexture*)texture, format, access, (int*)pw, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, int* access, ref int w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, uint* format, ref int access, ref int w, ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)texture, format, (int*)paccess, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexturePtr texture, ref uint format, ref int access, ref int w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)texture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							fixed (int* ph = &h)
							{
								int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureColorModNative(SDLTexture* texture, byte r, byte g, byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, byte, byte, int>)funcTable[735])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)funcTable[735])((nint)texture, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureColorMod(SDLTexturePtr texture, byte r, byte g, byte b)
		{
			int ret = SetTextureColorModNative((SDLTexture*)texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureColorMod(ref SDLTexture texture, byte r, byte g, byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureColorModNative(SDLTexture* texture, byte* r, byte* g, byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, byte*, byte*, int>)funcTable[736])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[736])((nint)texture, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, byte* r, byte* g, byte* b)
		{
			int ret = GetTextureColorModNative((SDLTexture*)texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, byte* g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, ref byte r, byte* g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = GetTextureColorModNative((SDLTexture*)texture, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, byte* g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, byte* r, ref byte g, byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = GetTextureColorModNative((SDLTexture*)texture, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, ref byte g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, ref byte r, ref byte g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetTextureColorModNative((SDLTexture*)texture, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, b);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, byte* r, byte* g, ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = GetTextureColorModNative((SDLTexture*)texture, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, byte* g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, ref byte r, byte* g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative((SDLTexture*)texture, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, byte* r, ref byte g, ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative((SDLTexture*)texture, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexturePtr texture, ref byte r, ref byte g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative((SDLTexture*)texture, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureAlphaModNative(SDLTexture* texture, byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, int>)funcTable[737])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)funcTable[737])((nint)texture, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureAlphaMod(SDLTexturePtr texture, byte alpha)
		{
			int ret = SetTextureAlphaModNative((SDLTexture*)texture, alpha);
			return ret;
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureAlphaMod(ref SDLTexture texture, byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureAlphaModNative(SDLTexture* texture, byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, int>)funcTable[738])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[738])((nint)texture, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(SDLTexturePtr texture, byte* alpha)
		{
			int ret = GetTextureAlphaModNative((SDLTexture*)texture, alpha);
			return ret;
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(ref SDLTexture texture, byte* alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(SDLTexturePtr texture, ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				int ret = GetTextureAlphaModNative((SDLTexture*)texture, (byte*)palpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(ref SDLTexture texture, ref byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* palpha = &alpha)
				{
					int ret = GetTextureAlphaModNative((SDLTexture*)ptexture, (byte*)palpha);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureBlendModeNative(SDLTexture* texture, SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode, int>)funcTable[739])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, int>)funcTable[739])((nint)texture, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureBlendMode(SDLTexturePtr texture, SDLBlendMode blendMode)
		{
			int ret = SetTextureBlendModeNative((SDLTexture*)texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureBlendMode(ref SDLTexture texture, SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureBlendModeNative(SDLTexture* texture, SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode*, int>)funcTable[740])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[740])((nint)texture, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(SDLTexturePtr texture, SDLBlendMode* blendMode)
		{
			int ret = GetTextureBlendModeNative((SDLTexture*)texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(ref SDLTexture texture, SDLBlendMode* blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(SDLTexturePtr texture, ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = GetTextureBlendModeNative((SDLTexture*)texture, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(ref SDLTexture texture, ref SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					int ret = GetTextureBlendModeNative((SDLTexture*)ptexture, (SDLBlendMode*)pblendMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureScaleModeNative(SDLTexture* texture, SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode, int>)funcTable[741])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLScaleMode, int>)funcTable[741])((nint)texture, scaleMode);
			#endif
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureScaleMode(SDLTexturePtr texture, SDLScaleMode scaleMode)
		{
			int ret = SetTextureScaleModeNative((SDLTexture*)texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureScaleMode(ref SDLTexture texture, SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureScaleModeNative(SDLTexture* texture, SDLScaleMode* scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode*, int>)funcTable[742])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[742])((nint)texture, (nint)scaleMode);
			#endif
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(SDLTexturePtr texture, SDLScaleMode* scaleMode)
		{
			int ret = GetTextureScaleModeNative((SDLTexture*)texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(ref SDLTexture texture, SDLScaleMode* scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(SDLTexturePtr texture, ref SDLScaleMode scaleMode)
		{
			fixed (SDLScaleMode* pscaleMode = &scaleMode)
			{
				int ret = GetTextureScaleModeNative((SDLTexture*)texture, (SDLScaleMode*)pscaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(ref SDLTexture texture, ref SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLScaleMode* pscaleMode = &scaleMode)
				{
					int ret = GetTextureScaleModeNative((SDLTexture*)ptexture, (SDLScaleMode*)pscaleMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureUserDataNative(SDLTexture* texture, void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, void*, int>)funcTable[743])(texture, userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[743])((nint)texture, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureUserData(SDLTexturePtr texture, void* userdata)
		{
			int ret = SetTextureUserDataNative((SDLTexture*)texture, userdata);
			return ret;
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureUserData(ref SDLTexture texture, void* userdata)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureUserDataNative((SDLTexture*)ptexture, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureUserData(SDLTexturePtr texture, nint userdata)
		{
			int ret = SetTextureUserDataNative((SDLTexture*)texture, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureUserData(ref SDLTexture texture, nint userdata)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureUserDataNative((SDLTexture*)ptexture, (void*)userdata);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetTextureUserDataNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, void*>)funcTable[744])(texture);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[744])((nint)texture);
			#endif
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetTextureUserData(SDLTexturePtr texture)
		{
			void* ret = GetTextureUserDataNative((SDLTexture*)texture);
			return ret;
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetTextureUserData(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				void* ret = GetTextureUserDataNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateTextureNative(SDLTexture* texture, SDLRect* rect, void* pixels, int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, void*, int, int>)funcTable[745])(texture, rect, pixels, pitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)funcTable[745])((nint)texture, (nint)rect, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(SDLTexturePtr texture, SDLRectPtr rect, void* pixels, int pitch)
		{
			int ret = UpdateTextureNative((SDLTexture*)texture, (SDLRect*)rect, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(ref SDLTexture texture, SDLRectPtr rect, void* pixels, int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = UpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(SDLTexturePtr texture, in SDLRect rect, void* pixels, int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = UpdateTextureNative((SDLTexture*)texture, (SDLRect*)prect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(ref SDLTexture texture, in SDLRect rect, void* pixels, int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = UpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(SDLTexturePtr texture, SDLRectPtr rect, nint pixels, int pitch)
		{
			int ret = UpdateTextureNative((SDLTexture*)texture, (SDLRect*)rect, (void*)pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(ref SDLTexture texture, SDLRectPtr rect, nint pixels, int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = UpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, (void*)pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(SDLTexturePtr texture, in SDLRect rect, nint pixels, int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = UpdateTextureNative((SDLTexture*)texture, (SDLRect*)prect, (void*)pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateTexture(ref SDLTexture texture, in SDLRect rect, nint pixels, int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = UpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (void*)pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateYUVTextureNative(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, byte*, int, byte*, int, byte*, int, int>)funcTable[746])(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int, int>)funcTable[746])((nint)texture, (nint)rect, (nint)yplane, ypitch, (nint)uplane, upitch, (nint)vplane, vpitch);
			#endif
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, SDLRectPtr rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			return ret;
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, SDLRectPtr rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, in SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, in SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, SDLRectPtr rect, in byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, SDLRectPtr rect, in byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, in SDLRect rect, in byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, in SDLRect rect, in byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, SDLRectPtr rect, byte* yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, SDLRectPtr rect, byte* yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, in SDLRect rect, byte* yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, in SDLRect rect, byte* yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, SDLRectPtr rect, in byte yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, SDLRectPtr rect, in byte yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, in SDLRect rect, in byte yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, in SDLRect rect, in byte yplane, int ypitch, in byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, SDLRectPtr rect, byte* yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (byte* pvplane = &vplane)
			{
				int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, SDLRectPtr rect, byte* yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, in SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, in SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, SDLRectPtr rect, in byte yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, SDLRectPtr rect, in byte yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(SDLTexturePtr texture, in SDLRect rect, in byte yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateYUVTexture(ref SDLTexture texture, in SDLRect rect, in byte yplane, int ypitch, byte* uplane, int upitch, in byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}
	}
}
