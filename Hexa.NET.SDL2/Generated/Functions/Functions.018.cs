// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTestTextWindowPtr TestTextWindowCreate(int x, int y, int w, int h)
		{
			SDLTestTextWindowPtr ret = TestTextWindowCreateNative(x, y, w, h);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowDisplayNative(SDLTestTextWindow* textwin, SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, SDLRenderer*, void>)funcTable[1373])(textwin, renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1373])((nint)textwin, (nint)renderer);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowDisplay(SDLTestTextWindowPtr textwin, SDLRendererPtr renderer)
		{
			TestTextWindowDisplayNative((SDLTestTextWindow*)textwin, (SDLRenderer*)renderer);
		}

		/// <summary>
		/// <br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowDisplay(ref SDLTestTextWindow textwin, SDLRendererPtr renderer)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowDisplayNative((SDLTestTextWindow*)ptextwin, (SDLRenderer*)renderer);
			}
		}

		/// <summary>
		/// <br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowDisplay(SDLTestTextWindowPtr textwin, ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				TestTextWindowDisplayNative((SDLTestTextWindow*)textwin, (SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// <br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowDisplay(ref SDLTestTextWindow textwin, ref SDLRenderer renderer)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (SDLRenderer* prenderer = &renderer)
				{
					TestTextWindowDisplayNative((SDLTestTextWindow*)ptextwin, (SDLRenderer*)prenderer);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowAddTextNative(SDLTestTextWindow* textwin, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, byte*, void>)funcTable[1374])(textwin, fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1374])((nint)textwin, (nint)fmt);
			#endif
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(SDLTestTextWindowPtr textwin, byte* fmt)
		{
			TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, fmt);
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(ref SDLTestTextWindow textwin, byte* fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, fmt);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(SDLTestTextWindowPtr textwin, in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, (byte*)pfmt);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(SDLTestTextWindowPtr textwin, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, (byte*)pfmt);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(SDLTestTextWindowPtr textwin, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(ref SDLTestTextWindow textwin, in byte fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* pfmt = &fmt)
				{
					TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(ref SDLTestTextWindow textwin, ReadOnlySpan<byte> fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* pfmt = fmt)
				{
					TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddText(ref SDLTestTextWindow textwin, string fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowAddTextWithLengthNative(SDLTestTextWindow* textwin, byte* text, nuint len)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, byte*, nuint, void>)funcTable[1375])(textwin, text, len);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[1375])((nint)textwin, (nint)text, len);
			#endif
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(SDLTestTextWindowPtr textwin, byte* text, nuint len)
		{
			TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, text, len);
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(ref SDLTestTextWindow textwin, byte* text, nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, text, len);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(SDLTestTextWindowPtr textwin, in byte text, nuint len)
		{
			fixed (byte* ptext = &text)
			{
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, (byte*)ptext, len);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(SDLTestTextWindowPtr textwin, ReadOnlySpan<byte> text, nuint len)
		{
			fixed (byte* ptext = text)
			{
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, (byte*)ptext, len);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(SDLTestTextWindowPtr textwin, string text, nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, pStr0, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(ref SDLTestTextWindow textwin, in byte text, nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* ptext = &text)
				{
					TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, (byte*)ptext, len);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(ref SDLTestTextWindow textwin, ReadOnlySpan<byte> text, nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* ptext = text)
				{
					TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, (byte*)ptext, len);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowAddTextWithLength(ref SDLTestTextWindow textwin, string text, nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, pStr0, len);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowClearNative(SDLTestTextWindow* textwin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, void>)funcTable[1376])(textwin);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1376])((nint)textwin);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowClear(SDLTestTextWindowPtr textwin)
		{
			TestTextWindowClearNative((SDLTestTextWindow*)textwin);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowClear(ref SDLTestTextWindow textwin)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowClearNative((SDLTestTextWindow*)ptextwin);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowDestroyNative(SDLTestTextWindow* textwin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, void>)funcTable[1377])(textwin);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1377])((nint)textwin);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowDestroy(SDLTestTextWindowPtr textwin)
		{
			TestTextWindowDestroyNative((SDLTestTextWindow*)textwin);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestTextWindowDestroy(ref SDLTestTextWindow textwin)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowDestroyNative((SDLTestTextWindow*)ptextwin);
			}
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCleanupTextDrawingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1378])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1378])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// </summary>
		public static void TestCleanupTextDrawing()
		{
			TestCleanupTextDrawingNative();
		}

		/// <summary>
		/// Initializes the fuzzer for a test<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestFuzzerInitNative(ulong execKey)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1379])(execKey);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1379])(execKey);
			#endif
		}

		/// <summary>
		/// Initializes the fuzzer for a test<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestFuzzerInit(ulong execKey)
		{
			TestFuzzerInitNative(execKey);
		}

		/// <summary>
		/// Returns a random Uint8<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestRandomUint8Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1380])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1380])();
			#endif
		}

		/// <summary>
		/// Returns a random Uint8<br/>
		/// <br/>
		/// </summary>
		public static byte TestRandomUint8()
		{
			byte ret = TestRandomUint8Native();
			return ret;
		}

		/// <summary>
		/// Returns a random Sint8<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte TestRandomSint8Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte>)funcTable[1381])();
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<sbyte>)funcTable[1381])();
			#endif
		}

		/// <summary>
		/// Returns a random Sint8<br/>
		/// <br/>
		/// </summary>
		public static sbyte TestRandomSint8()
		{
			sbyte ret = TestRandomSint8Native();
			return ret;
		}

		/// <summary>
		/// Returns a random Uint16<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort TestRandomUint16Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort>)funcTable[1382])();
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort>)funcTable[1382])();
			#endif
		}

		/// <summary>
		/// Returns a random Uint16<br/>
		/// <br/>
		/// </summary>
		public static ushort TestRandomUint16()
		{
			ushort ret = TestRandomUint16Native();
			return ret;
		}

		/// <summary>
		/// Returns a random Sint16<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short TestRandomSint16Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short>)funcTable[1383])();
			#else
			return (short)((delegate* unmanaged[Cdecl]<short>)funcTable[1383])();
			#endif
		}

		/// <summary>
		/// Returns a random Sint16<br/>
		/// <br/>
		/// </summary>
		public static short TestRandomSint16()
		{
			short ret = TestRandomSint16Native();
			return ret;
		}

		/// <summary>
		/// Returns a random integer<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestRandomSint32Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1384])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1384])();
			#endif
		}

		/// <summary>
		/// Returns a random integer<br/>
		/// <br/>
		/// </summary>
		public static int TestRandomSint32()
		{
			int ret = TestRandomSint32Native();
			return ret;
		}

		/// <summary>
		/// Returns a random positive integer<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TestRandomUint32Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1385])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1385])();
			#endif
		}

		/// <summary>
		/// Returns a random positive integer<br/>
		/// <br/>
		/// </summary>
		public static uint TestRandomUint32()
		{
			uint ret = TestRandomUint32Native();
			return ret;
		}

		/// <summary>
		/// Returns random Uint64.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong TestRandomUint64Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[1386])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[1386])();
			#endif
		}

		/// <summary>
		/// Returns random Uint64.<br/>
		/// <br/>
		/// </summary>
		public static ulong TestRandomUint64()
		{
			ulong ret = TestRandomUint64Native();
			return ret;
		}

		/// <summary>
		/// Returns random Sint64.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long TestRandomSint64Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long>)funcTable[1387])();
			#else
			return (long)((delegate* unmanaged[Cdecl]<long>)funcTable[1387])();
			#endif
		}

		/// <summary>
		/// Returns random Sint64.<br/>
		/// <br/>
		/// </summary>
		public static long TestRandomSint64()
		{
			long ret = TestRandomSint64Native();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TestRandomUnitFloatNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[1388])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[1388])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// </summary>
		public static float TestRandomUnitFloat()
		{
			float ret = TestRandomUnitFloatNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TestRandomUnitDoubleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)funcTable[1389])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)funcTable[1389])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// </summary>
		public static double TestRandomUnitDouble()
		{
			double ret = TestRandomUnitDoubleNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TestRandomFloatNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[1390])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[1390])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float TestRandomFloat()
		{
			float ret = TestRandomFloatNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TestRandomDoubleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)funcTable[1391])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)funcTable[1391])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static double TestRandomDouble()
		{
			double ret = TestRandomDoubleNative();
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint8BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint8BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint8BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint8BoundaryValue(0, 255, SDL_FALSE) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestRandomUint8BoundaryValueNative(byte boundary1, byte boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, SDLBool, byte>)funcTable[1392])(boundary1, boundary2, validDomain);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, SDLBool, byte>)funcTable[1392])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint8BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint8BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint8BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint8BoundaryValue(0, 255, SDL_FALSE) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte TestRandomUint8BoundaryValue(byte boundary1, byte boundary2, SDLBool validDomain)
		{
			byte ret = TestRandomUint8BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint16BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint16BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint16BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint16BoundaryValue(0, 0xFFFF, SDL_FALSE) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort TestRandomUint16BoundaryValueNative(ushort boundary1, ushort boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, SDLBool, ushort>)funcTable[1393])(boundary1, boundary2, validDomain);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, ushort, SDLBool, ushort>)funcTable[1393])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint16BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint16BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint16BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint16BoundaryValue(0, 0xFFFF, SDL_FALSE) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort TestRandomUint16BoundaryValue(ushort boundary1, ushort boundary2, SDLBool validDomain)
		{
			ushort ret = TestRandomUint16BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint32BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint32BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint32BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint32BoundaryValue(0, 0xFFFFFFFF, SDL_FALSE) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TestRandomUint32BoundaryValueNative(uint boundary1, uint boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, SDLBool, uint>)funcTable[1394])(boundary1, boundary2, validDomain);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, SDLBool, uint>)funcTable[1394])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint32BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint32BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint32BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint32BoundaryValue(0, 0xFFFFFFFF, SDL_FALSE) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint TestRandomUint32BoundaryValue(uint boundary1, uint boundary2, SDLBool validDomain)
		{
			uint ret = TestRandomUint32BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint64BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint64BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint64BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint64BoundaryValue(0, 0xFFFFFFFFFFFFFFFF, SDL_FALSE) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong TestRandomUint64BoundaryValueNative(ulong boundary1, ulong boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, ulong, SDLBool, ulong>)funcTable[1395])(boundary1, boundary2, validDomain);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong, ulong, SDLBool, ulong>)funcTable[1395])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint64BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20<br/>
		/// RandomUint64BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21<br/>
		/// RandomUint64BoundaryValue(0, 99, SDL_FALSE) returns 100<br/>
		/// RandomUint64BoundaryValue(0, 0xFFFFFFFFFFFFFFFF, SDL_FALSE) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong TestRandomUint64BoundaryValue(ulong boundary1, ulong boundary2, SDLBool validDomain)
		{
			ulong ret = TestRandomUint64BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint8BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint8BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, SINT8_MAX, SDL_FALSE) returns SINT8_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte TestRandomSint8BoundaryValueNative(sbyte boundary1, sbyte boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte, sbyte, SDLBool, sbyte>)funcTable[1396])(boundary1, boundary2, validDomain);
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<sbyte, sbyte, SDLBool, sbyte>)funcTable[1396])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint8BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint8BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, SINT8_MAX, SDL_FALSE) returns SINT8_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static sbyte TestRandomSint8BoundaryValue(sbyte boundary1, sbyte boundary2, SDLBool validDomain)
		{
			sbyte ret = TestRandomSint8BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint16BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint16BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, SINT16_MAX, SDL_FALSE) returns SINT16_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short TestRandomSint16BoundaryValueNative(short boundary1, short boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, SDLBool, short>)funcTable[1397])(boundary1, boundary2, validDomain);
			#else
			return (short)((delegate* unmanaged[Cdecl]<short, short, SDLBool, short>)funcTable[1397])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint16BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint16BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, SINT16_MAX, SDL_FALSE) returns SINT16_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short TestRandomSint16BoundaryValue(short boundary1, short boundary2, SDLBool validDomain)
		{
			short ret = TestRandomSint16BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint32BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint32BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, SINT32_MAX, SDL_FALSE) returns SINT32_MIN (== error value)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestRandomSint32BoundaryValueNative(int boundary1, int boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLBool, int>)funcTable[1398])(boundary1, boundary2, validDomain);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, SDLBool, int>)funcTable[1398])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint32BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint32BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, SINT32_MAX, SDL_FALSE) returns SINT32_MIN (== error value)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRandomSint32BoundaryValue(int boundary1, int boundary2, SDLBool validDomain)
		{
			int ret = TestRandomSint32BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint64BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint64BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, SINT64_MAX, SDL_FALSE) returns SINT64_MIN (== error value) and error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long TestRandomSint64BoundaryValueNative(long boundary1, long boundary2, SDLBool validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, long, SDLBool, long>)funcTable[1399])(boundary1, boundary2, validDomain);
			#else
			return (long)((delegate* unmanaged[Cdecl]<long, long, SDLBool, long>)funcTable[1399])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint64BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20<br/>
		/// RandomSint64BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, 99, SDL_FALSE) returns 100<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, SINT64_MAX, SDL_FALSE) returns SINT64_MIN (== error value) and error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long TestRandomSint64BoundaryValue(long boundary1, long boundary2, SDLBool validDomain)
		{
			long ret = TestRandomSint64BoundaryValueNative(boundary1, boundary2, validDomain);
			return ret;
		}

		/// <summary>
		/// Returns integer in range [min, max] (inclusive).<br/>
		/// Min and max values can be negative values.<br/>
		/// If Max in smaller than min, then the values are swapped.<br/>
		/// Min and max are the same value, that value will be returned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestRandomIntegerInRangeNative(int min, int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[1400])(min, max);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[1400])(min, max);
			#endif
		}

		/// <summary>
		/// Returns integer in range [min, max] (inclusive).<br/>
		/// Min and max values can be negative values.<br/>
		/// If Max in smaller than min, then the values are swapped.<br/>
		/// Min and max are the same value, that value will be returned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRandomIntegerInRange(int min, int max)
		{
			int ret = TestRandomIntegerInRangeNative(min, max);
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The minimum length for<br/>
		/// the string is 1 character, maximum length for the string is 255<br/>
		/// characters and it can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestRandomAsciiStringNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[1401])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1401])();
			#endif
		}

		/// <summary>
		/// Generates random null-terminated string. The minimum length for<br/>
		/// the string is 1 character, maximum length for the string is 255<br/>
		/// characters and it can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// </summary>
		public static byte* TestRandomAsciiString()
		{
			byte* ret = TestRandomAsciiStringNative();
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The minimum length for<br/>
		/// the string is 1 character, maximum length for the string is 255<br/>
		/// characters and it can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// </summary>
		public static string TestRandomAsciiStringS()
		{
			string ret = Utils.DecodeStringUTF8(TestRandomAsciiStringNative());
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The maximum length for<br/>
		/// the string is defined by the maxLength parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestRandomAsciiStringWithMaximumLengthNative(int maxLength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[1402])(maxLength);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[1402])(maxLength);
			#endif
		}

		/// <summary>
		/// Generates random null-terminated string. The maximum length for<br/>
		/// the string is defined by the maxLength parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* TestRandomAsciiStringWithMaximumLength(int maxLength)
		{
			byte* ret = TestRandomAsciiStringWithMaximumLengthNative(maxLength);
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The maximum length for<br/>
		/// the string is defined by the maxLength parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string TestRandomAsciiStringWithMaximumLengthS(int maxLength)
		{
			string ret = Utils.DecodeStringUTF8(TestRandomAsciiStringWithMaximumLengthNative(maxLength));
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The length for<br/>
		/// the string is defined by the size parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestRandomAsciiStringOfSizeNative(int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[1403])(size);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[1403])(size);
			#endif
		}

		/// <summary>
		/// Generates random null-terminated string. The length for<br/>
		/// the string is defined by the size parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* TestRandomAsciiStringOfSize(int size)
		{
			byte* ret = TestRandomAsciiStringOfSizeNative(size);
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The length for<br/>
		/// the string is defined by the size parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string TestRandomAsciiStringOfSizeS(int size)
		{
			string ret = Utils.DecodeStringUTF8(TestRandomAsciiStringOfSizeNative(size));
			return ret;
		}

		/// <summary>
		/// Get the invocation count for the fuzzer since last ...FuzzerInit.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestGetFuzzerInvocationCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1404])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1404])();
			#endif
		}

		/// <summary>
		/// Get the invocation count for the fuzzer since last ...FuzzerInit.<br/>
		/// <br/>
		/// </summary>
		public static int TestGetFuzzerInvocationCount()
		{
			int ret = TestGetFuzzerInvocationCountNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Note: The returned string needs to be deallocated by the caller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestGenerateRunSeedNative(int length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[1405])(length);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[1405])(length);
			#endif
		}

		/// <summary>
		/// <br/>
		/// Note: The returned string needs to be deallocated by the caller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* TestGenerateRunSeed(int length)
		{
			byte* ret = TestGenerateRunSeedNative(length);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Note: The returned string needs to be deallocated by the caller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string TestGenerateRunSeedS(int length)
		{
			string ret = Utils.DecodeStringUTF8(TestGenerateRunSeedNative(length));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestRunSuitesNative(SDLTestTestSuiteReference** testSuites, byte* userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestTestSuiteReference**, byte*, ulong, byte*, int, int>)funcTable[1406])(testSuites, userRunSeed, userExecKey, filter, testIterations);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, ulong, nint, int, int>)funcTable[1406])((nint)testSuites, (nint)userRunSeed, userExecKey, (nint)filter, testIterations);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, byte* userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			int ret = TestRunSuitesNative(testSuites, userRunSeed, userExecKey, filter, testIterations);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, byte* userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, userRunSeed, userExecKey, filter, testIterations);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, in byte userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			fixed (byte* puserRunSeed = &userRunSeed)
			{
				int ret = TestRunSuitesNative(testSuites, (byte*)puserRunSeed, userExecKey, filter, testIterations);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, ReadOnlySpan<byte> userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			fixed (byte* puserRunSeed = userRunSeed)
			{
				int ret = TestRunSuitesNative(testSuites, (byte*)puserRunSeed, userExecKey, filter, testIterations);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, string userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userRunSeed != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userRunSeed);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userRunSeed, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TestRunSuitesNative(testSuites, pStr0, userExecKey, filter, testIterations);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, in byte userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				fixed (byte* puserRunSeed = &userRunSeed)
				{
					int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, (byte*)puserRunSeed, userExecKey, filter, testIterations);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, ReadOnlySpan<byte> userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				fixed (byte* puserRunSeed = userRunSeed)
				{
					int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, (byte*)puserRunSeed, userExecKey, filter, testIterations);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, string userRunSeed, ulong userExecKey, byte* filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (userRunSeed != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(userRunSeed);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(userRunSeed, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, pStr0, userExecKey, filter, testIterations);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, byte* userRunSeed, ulong userExecKey, in byte filter, int testIterations)
		{
			fixed (byte* pfilter = &filter)
			{
				int ret = TestRunSuitesNative(testSuites, userRunSeed, userExecKey, (byte*)pfilter, testIterations);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, byte* userRunSeed, ulong userExecKey, ReadOnlySpan<byte> filter, int testIterations)
		{
			fixed (byte* pfilter = filter)
			{
				int ret = TestRunSuitesNative(testSuites, userRunSeed, userExecKey, (byte*)pfilter, testIterations);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, byte* userRunSeed, ulong userExecKey, string filter, int testIterations)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TestRunSuitesNative(testSuites, userRunSeed, userExecKey, pStr0, testIterations);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, byte* userRunSeed, ulong userExecKey, in byte filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				fixed (byte* pfilter = &filter)
				{
					int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, userRunSeed, userExecKey, (byte*)pfilter, testIterations);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, byte* userRunSeed, ulong userExecKey, ReadOnlySpan<byte> filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				fixed (byte* pfilter = filter)
				{
					int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, userRunSeed, userExecKey, (byte*)pfilter, testIterations);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, byte* userRunSeed, ulong userExecKey, string filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filter != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filter);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filter, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, userRunSeed, userExecKey, pStr0, testIterations);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, in byte userRunSeed, ulong userExecKey, in byte filter, int testIterations)
		{
			fixed (byte* puserRunSeed = &userRunSeed)
			{
				fixed (byte* pfilter = &filter)
				{
					int ret = TestRunSuitesNative(testSuites, (byte*)puserRunSeed, userExecKey, (byte*)pfilter, testIterations);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, ReadOnlySpan<byte> userRunSeed, ulong userExecKey, ReadOnlySpan<byte> filter, int testIterations)
		{
			fixed (byte* puserRunSeed = userRunSeed)
			{
				fixed (byte* pfilter = filter)
				{
					int ret = TestRunSuitesNative(testSuites, (byte*)puserRunSeed, userExecKey, (byte*)pfilter, testIterations);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(SDLTestTestSuiteReference** testSuites, string userRunSeed, ulong userExecKey, string filter, int testIterations)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userRunSeed != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userRunSeed);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userRunSeed, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (filter != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(filter);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(filter, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = TestRunSuitesNative(testSuites, pStr0, userExecKey, pStr1, testIterations);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, in byte userRunSeed, ulong userExecKey, in byte filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				fixed (byte* puserRunSeed = &userRunSeed)
				{
					fixed (byte* pfilter = &filter)
					{
						int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, (byte*)puserRunSeed, userExecKey, (byte*)pfilter, testIterations);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, ReadOnlySpan<byte> userRunSeed, ulong userExecKey, ReadOnlySpan<byte> filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				fixed (byte* puserRunSeed = userRunSeed)
				{
					fixed (byte* pfilter = filter)
					{
						int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, (byte*)puserRunSeed, userExecKey, (byte*)pfilter, testIterations);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestRunSuites(ref SDLTestTestSuiteReference* testSuites, string userRunSeed, ulong userExecKey, string filter, int testIterations)
		{
			fixed (SDLTestTestSuiteReference** ptestSuites = &testSuites)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (userRunSeed != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(userRunSeed);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(userRunSeed, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (filter != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(filter);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(filter, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = TestRunSuitesNative((SDLTestTestSuiteReference**)ptestSuites, pStr0, userExecKey, pStr1, testIterations);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1407])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1407])((nint)fmt);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLog(byte* fmt)
		{
			TestLogNative(fmt);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLog(in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TestLogNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLog(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TestLogNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLog(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestLogNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogErrorNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1408])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1408])((nint)fmt);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLogError(byte* fmt)
		{
			TestLogErrorNative(fmt);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLogError(in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TestLogErrorNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLogError(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TestLogErrorNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLogError(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestLogErrorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function initializes the message-digest context<br/>
		/// mdContext. Call before each new use of the context -<br/>
		/// all fields are set to zero.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestMd5InitNative(SDLTestMd5Context* mdContext)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestMd5Context*, void>)funcTable[1409])(mdContext);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1409])((nint)mdContext);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function initializes the message-digest context<br/>
		/// mdContext. Call before each new use of the context -<br/>
		/// all fields are set to zero.<br/>
		/// </summary>
		public static void TestMd5Init(SDLTestMd5ContextPtr mdContext)
		{
			TestMd5InitNative((SDLTestMd5Context*)mdContext);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function initializes the message-digest context<br/>
		/// mdContext. Call before each new use of the context -<br/>
		/// all fields are set to zero.<br/>
		/// </summary>
		public static void TestMd5Init(ref SDLTestMd5Context mdContext)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				TestMd5InitNative((SDLTestMd5Context*)pmdContext);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestMd5UpdateNative(SDLTestMd5Context* mdContext, byte* inBuf, uint inLen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestMd5Context*, byte*, uint, void>)funcTable[1410])(mdContext, inBuf, inLen);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[1410])((nint)mdContext, (nint)inBuf, inLen);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		public static void TestMd5Update(SDLTestMd5ContextPtr mdContext, byte* inBuf, uint inLen)
		{
			TestMd5UpdateNative((SDLTestMd5Context*)mdContext, inBuf, inLen);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		public static void TestMd5Update(ref SDLTestMd5Context mdContext, byte* inBuf, uint inLen)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				TestMd5UpdateNative((SDLTestMd5Context*)pmdContext, inBuf, inLen);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		public static void TestMd5Update(SDLTestMd5ContextPtr mdContext, ref byte inBuf, uint inLen)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				TestMd5UpdateNative((SDLTestMd5Context*)mdContext, (byte*)pinBuf, inLen);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		public static void TestMd5Update(ref SDLTestMd5Context mdContext, ref byte inBuf, uint inLen)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					TestMd5UpdateNative((SDLTestMd5Context*)pmdContext, (byte*)pinBuf, inLen);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function terminates the message-digest computation and<br/>
		/// ends with the desired message digest in mdContext.digest[0..15].<br/>
		/// Always call before using the digest[] variable.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestMd5FinalNative(SDLTestMd5Context* mdContext)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestMd5Context*, void>)funcTable[1411])(mdContext);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1411])((nint)mdContext);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function terminates the message-digest computation and<br/>
		/// ends with the desired message digest in mdContext.digest[0..15].<br/>
		/// Always call before using the digest[] variable.<br/>
		/// </summary>
		public static void TestMd5Final(SDLTestMd5ContextPtr mdContext)
		{
			TestMd5FinalNative((SDLTestMd5Context*)mdContext);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// Note: The function terminates the message-digest computation and<br/>
		/// ends with the desired message digest in mdContext.digest[0..15].<br/>
		/// Always call before using the digest[] variable.<br/>
		/// </summary>
		public static void TestMd5Final(ref SDLTestMd5Context mdContext)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				TestMd5FinalNative((SDLTestMd5Context*)pmdContext);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestTrackAllocationsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1412])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1412])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TestTrackAllocations()
		{
			int ret = TestTrackAllocationsNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogAllocationsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1413])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1413])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestLogAllocations()
		{
			TestLogAllocationsNative();
		}

		/// <summary>
		/// <br/>
		/// Note: The random sequence of numbers returned by ...Random() is the<br/>
		/// same for the same two integers and has a period of 2^31.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestRandomInitNative(SDLTestRandomContext* rndContext, uint xi, uint ci)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestRandomContext*, uint, uint, void>)funcTable[1414])(rndContext, xi, ci);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, void>)funcTable[1414])((nint)rndContext, xi, ci);
			#endif
		}

		/// <summary>
		/// <br/>
		/// Note: The random sequence of numbers returned by ...Random() is the<br/>
		/// same for the same two integers and has a period of 2^31.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestRandomInit(SDLTestRandomContextPtr rndContext, uint xi, uint ci)
		{
			TestRandomInitNative((SDLTestRandomContext*)rndContext, xi, ci);
		}

		/// <summary>
		/// <br/>
		/// Note: The random sequence of numbers returned by ...Random() is the<br/>
		/// same for the same two integers and has a period of 2^31.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestRandomInit(ref SDLTestRandomContext rndContext, uint xi, uint ci)
		{
			fixed (SDLTestRandomContext* prndContext = &rndContext)
			{
				TestRandomInitNative((SDLTestRandomContext*)prndContext, xi, ci);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestRandomInitTimeNative(SDLTestRandomContext* rndContext)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestRandomContext*, void>)funcTable[1415])(rndContext);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1415])((nint)rndContext);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestRandomInitTime(SDLTestRandomContextPtr rndContext)
		{
			TestRandomInitTimeNative((SDLTestRandomContext*)rndContext);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void TestRandomInitTime(ref SDLTestRandomContext rndContext)
		{
			fixed (SDLTestRandomContext* prndContext = &rndContext)
			{
				TestRandomInitTimeNative((SDLTestRandomContext*)prndContext);
			}
		}

		/// <summary>
		/// <br/>
		/// Note: ...RandomInit() or ...RandomInitTime() must have been called<br/>
		/// before using this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TestRandomNative(SDLTestRandomContext* rndContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestRandomContext*, uint>)funcTable[1416])(rndContext);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[1416])((nint)rndContext);
			#endif
		}

		/// <summary>
		/// <br/>
		/// Note: ...RandomInit() or ...RandomInitTime() must have been called<br/>
		/// before using this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint TestRandom(SDLTestRandomContextPtr rndContext)
		{
			uint ret = TestRandomNative((SDLTestRandomContext*)rndContext);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Note: ...RandomInit() or ...RandomInitTime() must have been called<br/>
		/// before using this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint TestRandom(ref SDLTestRandomContext rndContext)
		{
			fixed (SDLTestRandomContext* prndContext = &rndContext)
			{
				uint ret = TestRandomNative((SDLTestRandomContext*)prndContext);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VulkanLoadLibraryNative(byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[1417])(path);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[1417])((nint)path);
			#endif
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VulkanLoadLibrary(byte* path)
		{
			int ret = VulkanLoadLibraryNative(path);
			return ret;
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VulkanLoadLibrary(in byte path)
		{
			fixed (byte* ppath = &path)
			{
				int ret = VulkanLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VulkanLoadLibrary(ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				int ret = VulkanLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VulkanLoadLibrary(string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = VulkanLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the address of the `vkGetInstanceProcAddr` function.<br/>
		/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
		/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* VulkanGetVkGetInstanceProcAddrNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*>)funcTable[1418])();
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1418])();
			#endif
		}

		/// <summary>
		/// Get the address of the `vkGetInstanceProcAddr` function.<br/>
		/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
		/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* VulkanGetVkGetInstanceProcAddr()
		{
			void* ret = VulkanGetVkGetInstanceProcAddrNative();
			return ret;
		}

		/// <summary>
		/// Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary()<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VulkanUnloadLibraryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1419])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1419])();
			#endif
		}

		/// <summary>
		/// Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary()<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanUnloadLibrary()
		{
			VulkanUnloadLibraryNative();
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool VulkanGetInstanceExtensionsNative(SDLWindow* window, uint* pCount, byte** pNames)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint*, byte**, SDLBool>)funcTable[1420])(window, pCount, pNames);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, SDLBool>)funcTable[1420])((nint)window, (nint)pCount, (nint)pNames);
			#endif
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(SDLWindowPtr window, uint* pCount, byte** pNames)
		{
			SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)window, pCount, pNames);
			return ret;
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(ref SDLWindow window, uint* pCount, byte** pNames)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)pwindow, pCount, pNames);
				return ret;
			}
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(SDLWindowPtr window, ref uint pCount, byte** pNames)
		{
			fixed (uint* ppCount = &pCount)
			{
				SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)window, (uint*)ppCount, pNames);
				return ret;
			}
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(ref SDLWindow window, ref uint pCount, byte** pNames)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* ppCount = &pCount)
				{
					SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)pwindow, (uint*)ppCount, pNames);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(SDLWindowPtr window, uint* pCount, ref byte* pNames)
		{
			fixed (byte** ppNames = &pNames)
			{
				SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)window, pCount, (byte**)ppNames);
				return ret;
			}
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(ref SDLWindow window, uint* pCount, ref byte* pNames)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte** ppNames = &pNames)
				{
					SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)pwindow, pCount, (byte**)ppNames);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(SDLWindowPtr window, ref uint pCount, ref byte* pNames)
		{
			fixed (uint* ppCount = &pCount)
			{
				fixed (byte** ppNames = &pNames)
				{
					SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)window, (uint*)ppCount, (byte**)ppNames);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the names of the Vulkan instance extensions needed to create a surface<br/>
		/// with SDL_Vulkan_CreateSurface.<br/>
		/// If `pNames` is NULL, then the number of required Vulkan instance extensions<br/>
		/// is returned in `pCount`. Otherwise, `pCount` must point to a variable set<br/>
		/// to the number of elements in the `pNames` array, and on return the variable<br/>
		/// is overwritten with the number of names actually written to `pNames`. If<br/>
		/// `pCount` is less than the number of required extensions, at most `pCount`<br/>
		/// structures will be written. If `pCount` is smaller than the number of<br/>
		/// required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to<br/>
		/// indicate that not all the required extensions were returned.<br/>
		/// The `window` parameter is currently needed to be valid as of SDL 2.0.8,<br/>
		/// however, this parameter will likely be removed in future releases<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanGetInstanceExtensions(ref SDLWindow window, ref uint pCount, ref byte* pNames)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* ppCount = &pCount)
				{
					fixed (byte** ppNames = &pNames)
					{
						SDLBool ret = VulkanGetInstanceExtensionsNative((SDLWindow*)pwindow, (uint*)ppCount, (byte**)ppNames);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool VulkanCreateSurfaceNative(SDLWindow* window, VkInstance instance, VkSurfaceKHR* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, VkInstance, VkSurfaceKHR*, SDLBool>)funcTable[1421])(window, instance, surface);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, VkInstance, nint, SDLBool>)funcTable[1421])((nint)window, instance, (nint)surface);
			#endif
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanCreateSurface(SDLWindowPtr window, VkInstance instance, VkSurfaceKHR* surface)
		{
			SDLBool ret = VulkanCreateSurfaceNative((SDLWindow*)window, instance, surface);
			return ret;
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanCreateSurface(ref SDLWindow window, VkInstance instance, VkSurfaceKHR* surface)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = VulkanCreateSurfaceNative((SDLWindow*)pwindow, instance, surface);
				return ret;
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanCreateSurface(SDLWindowPtr window, VkInstance instance, ref VkSurfaceKHR surface)
		{
			fixed (VkSurfaceKHR* psurface = &surface)
			{
				SDLBool ret = VulkanCreateSurfaceNative((SDLWindow*)window, instance, (VkSurfaceKHR*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool VulkanCreateSurface(ref SDLWindow window, VkInstance instance, ref VkSurfaceKHR surface)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (VkSurfaceKHR* psurface = &surface)
				{
					SDLBool ret = VulkanCreateSurfaceNative((SDLWindow*)pwindow, instance, (VkSurfaceKHR*)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VulkanGetDrawableSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[1422])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1422])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(SDLWindowPtr window, int* w, int* h)
		{
			VulkanGetDrawableSizeNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				VulkanGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(SDLWindowPtr window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				VulkanGetDrawableSizeNative((SDLWindow*)window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					VulkanGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(SDLWindowPtr window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				VulkanGetDrawableSizeNative((SDLWindow*)window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					VulkanGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(SDLWindowPtr window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					VulkanGetDrawableSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of the window's underlying drawable dimensions in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void VulkanGetDrawableSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						VulkanGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

	}
}
