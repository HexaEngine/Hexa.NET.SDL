// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{
		/// <summary>
		/// Get the name of the platform.<br/>
		/// Here are the names returned for some (but not all) supported platforms:<br/>
		/// - "Windows"<br/>
		/// - "Mac OS X"<br/>
		/// - "Linux"<br/>
		/// - "iOS"<br/>
		/// - "Android"<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPlatformNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[0])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[0])();
			#endif
		}

		/// <summary>
		/// Get the name of the platform.<br/>
		/// Here are the names returned for some (but not all) supported platforms:<br/>
		/// - "Windows"<br/>
		/// - "Mac OS X"<br/>
		/// - "Linux"<br/>
		/// - "iOS"<br/>
		/// - "Android"<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetPlatform()
		{
			byte* ret = GetPlatformNative();
			return ret;
		}

		/// <summary>
		/// Get the name of the platform.<br/>
		/// Here are the names returned for some (but not all) supported platforms:<br/>
		/// - "Windows"<br/>
		/// - "Mac OS X"<br/>
		/// - "Linux"<br/>
		/// - "iOS"<br/>
		/// - "Android"<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetPlatformS()
		{
			string ret = Utils.DecodeStringUTF8(GetPlatformNative());
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MallocNative(nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, void*>)funcTable[1])(size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nint>)funcTable[1])(size);
			#endif
		}

		public static void* Malloc(nuint size)
		{
			void* ret = MallocNative(size);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* CallocNative(nuint nmemb, nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, nuint, void*>)funcTable[2])(nmemb, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nuint, nint>)funcTable[2])(nmemb, size);
			#endif
		}

		public static void* Calloc(nuint nmemb, nuint size)
		{
			void* ret = CallocNative(nmemb, size);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* ReallocNative(void* mem, nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, void*>)funcTable[3])(mem, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[3])((nint)mem, size);
			#endif
		}

		public static void* Realloc(void* mem, nuint size)
		{
			void* ret = ReallocNative(mem, size);
			return ret;
		}

		public static void* Realloc(nint mem, nuint size)
		{
			void* ret = ReallocNative((void*)mem, size);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeNative(void* mem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[4])(mem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[4])((nint)mem);
			#endif
		}

		public static void Free(void* mem)
		{
			FreeNative(mem);
		}

		public static void Free(nint mem)
		{
			FreeNative((void*)mem);
		}

		/// <summary>
		/// Get the original set of SDL memory functions<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetOriginalMemoryFunctionsNative(delegate*<nuint, void*>* mallocFunc, delegate*<nuint, nuint, void*>* callocFunc, delegate*<void*, nuint, void*>* reallocFunc, delegate*<void*, void>* freeFunc)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*>*, delegate*<nuint, nuint, void*>*, delegate*<void*, nuint, void*>*, delegate*<void*, void>*, void>)funcTable[5])(mallocFunc, callocFunc, reallocFunc, freeFunc);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[5])((nint)mallocFunc, (nint)callocFunc, (nint)reallocFunc, (nint)freeFunc);
			#endif
		}

		/// <summary>
		/// Get the original set of SDL memory functions<br/>
		/// <br/>
		/// </summary>
		public static void GetOriginalMemoryFunctions(delegate*<nuint, void*>* mallocFunc, delegate*<nuint, nuint, void*>* callocFunc, delegate*<void*, nuint, void*>* reallocFunc, delegate*<void*, void>* freeFunc)
		{
			GetOriginalMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
		}

		/// <summary>
		/// Get the current set of SDL memory functions<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMemoryFunctionsNative(delegate*<nuint, void*>* mallocFunc, delegate*<nuint, nuint, void*>* callocFunc, delegate*<void*, nuint, void*>* reallocFunc, delegate*<void*, void>* freeFunc)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*>*, delegate*<nuint, nuint, void*>*, delegate*<void*, nuint, void*>*, delegate*<void*, void>*, void>)funcTable[6])(mallocFunc, callocFunc, reallocFunc, freeFunc);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[6])((nint)mallocFunc, (nint)callocFunc, (nint)reallocFunc, (nint)freeFunc);
			#endif
		}

		/// <summary>
		/// Get the current set of SDL memory functions<br/>
		/// <br/>
		/// </summary>
		public static void GetMemoryFunctions(delegate*<nuint, void*>* mallocFunc, delegate*<nuint, nuint, void*>* callocFunc, delegate*<void*, nuint, void*>* reallocFunc, delegate*<void*, void>* freeFunc)
		{
			GetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetMemoryFunctionsNative(delegate*<nuint, void*> mallocFunc, delegate*<nuint, nuint, void*> callocFunc, delegate*<void*, nuint, void*> reallocFunc, delegate*<void*, void> freeFunc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<nuint, void*>, delegate*<nuint, nuint, void*>, delegate*<void*, nuint, void*>, delegate*<void*, void>, int>)funcTable[7])(mallocFunc, callocFunc, reallocFunc, freeFunc);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[7])((nint)mallocFunc, (nint)callocFunc, (nint)reallocFunc, (nint)freeFunc);
			#endif
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, delegate*<nuint, nuint, void*> callocFunc, delegate*<void*, nuint, void*> reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, delegate*<nuint, nuint, void*> callocFunc, delegate*<void*, nuint, void*> reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, reallocFunc, freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, SDLCallocFunc callocFunc, delegate*<void*, nuint, void*> reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, SDLCallocFunc callocFunc, delegate*<void*, nuint, void*> reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, delegate*<nuint, nuint, void*> callocFunc, SDLReallocFunc reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, delegate*<nuint, nuint, void*> callocFunc, SDLReallocFunc reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, SDLCallocFunc callocFunc, SDLReallocFunc reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, SDLCallocFunc callocFunc, SDLReallocFunc reallocFunc, delegate*<void*, void> freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, delegate*<nuint, nuint, void*> callocFunc, delegate*<void*, nuint, void*> reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, delegate*<nuint, nuint, void*> callocFunc, delegate*<void*, nuint, void*> reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, SDLCallocFunc callocFunc, delegate*<void*, nuint, void*> reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, SDLCallocFunc callocFunc, delegate*<void*, nuint, void*> reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, delegate*<nuint, nuint, void*> callocFunc, SDLReallocFunc reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, delegate*<nuint, nuint, void*> callocFunc, SDLReallocFunc reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(delegate*<nuint, void*> mallocFunc, SDLCallocFunc callocFunc, SDLReallocFunc reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		public static int SetMemoryFunctions(SDLMallocFunc mallocFunc, SDLCallocFunc callocFunc, SDLReallocFunc reallocFunc, SDLFreeFunc freeFunc)
		{
			int ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret;
		}

		/// <summary>
		/// Get the number of outstanding (unfreed) allocations<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumAllocationsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[8])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[8])();
			#endif
		}

		/// <summary>
		/// Get the number of outstanding (unfreed) allocations<br/>
		/// <br/>
		/// </summary>
		public static int GetNumAllocations()
		{
			int ret = GetNumAllocationsNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetenvNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[9])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[9])((nint)name);
			#endif
		}

		public static byte* Getenv(byte* name)
		{
			byte* ret = GetenvNative(name);
			return ret;
		}

		public static string GetenvS(byte* name)
		{
			string ret = Utils.DecodeStringUTF8(GetenvNative(name));
			return ret;
		}

		public static byte* Getenv(in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetenvNative((byte*)pname);
				return ret;
			}
		}

		public static string GetenvS(in byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetenvNative((byte*)pname));
				return ret;
			}
		}

		public static byte* Getenv(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetenvNative((byte*)pname);
				return ret;
			}
		}

		public static string GetenvS(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetenvNative((byte*)pname));
				return ret;
			}
		}

		public static byte* Getenv(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetenvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string GetenvS(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetenvNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetenvNative(byte* name, byte* value, int overwrite)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int>)funcTable[10])(name, value, overwrite);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[10])((nint)name, (nint)value, overwrite);
			#endif
		}

		public static int Setenv(byte* name, byte* value, int overwrite)
		{
			int ret = SetenvNative(name, value, overwrite);
			return ret;
		}

		public static int Setenv(in byte name, byte* value, int overwrite)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetenvNative((byte*)pname, value, overwrite);
				return ret;
			}
		}

		public static int Setenv(ReadOnlySpan<byte> name, byte* value, int overwrite)
		{
			fixed (byte* pname = name)
			{
				int ret = SetenvNative((byte*)pname, value, overwrite);
				return ret;
			}
		}

		public static int Setenv(string name, byte* value, int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetenvNative(pStr0, value, overwrite);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Setenv(byte* name, in byte value, int overwrite)
		{
			fixed (byte* pvalue = &value)
			{
				int ret = SetenvNative(name, (byte*)pvalue, overwrite);
				return ret;
			}
		}

		public static int Setenv(byte* name, ReadOnlySpan<byte> value, int overwrite)
		{
			fixed (byte* pvalue = value)
			{
				int ret = SetenvNative(name, (byte*)pvalue, overwrite);
				return ret;
			}
		}

		public static int Setenv(byte* name, string value, int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetenvNative(name, pStr0, overwrite);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Setenv(in byte name, in byte value, int overwrite)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					int ret = SetenvNative((byte*)pname, (byte*)pvalue, overwrite);
					return ret;
				}
			}
		}

		public static int Setenv(ReadOnlySpan<byte> name, ReadOnlySpan<byte> value, int overwrite)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					int ret = SetenvNative((byte*)pname, (byte*)pvalue, overwrite);
					return ret;
				}
			}
		}

		public static int Setenv(string name, string value, int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SetenvNative(pStr0, pStr1, overwrite);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QsortNative(void* baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, nuint, nuint, delegate*<void*, void*, int>, void>)funcTable[11])(baseValue, nmemb, size, compare);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, nuint, nint, void>)funcTable[11])((nint)baseValue, nmemb, size, (nint)compare);
			#endif
		}

		public static void Qsort(void* baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			QsortNative(baseValue, nmemb, size, compare);
		}

		public static void Qsort(nint baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			QsortNative((void*)baseValue, nmemb, size, compare);
		}

		public static void Qsort(void* baseValue, nuint nmemb, nuint size, SDLCompareCallback compare)
		{
			QsortNative(baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
		}

		public static void Qsort(nint baseValue, nuint nmemb, nuint size, SDLCompareCallback compare)
		{
			QsortNative((void*)baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* BsearchNative(void* key, void* baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, nuint, delegate*<void*, void*, int>, void*>)funcTable[12])(key, baseValue, nmemb, size, compare);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint, nint, nint>)funcTable[12])((nint)key, (nint)baseValue, nmemb, size, (nint)compare);
			#endif
		}

		public static void* Bsearch(void* key, void* baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative(key, baseValue, nmemb, size, compare);
			return ret;
		}

		public static void* Bsearch(nint key, void* baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative((void*)key, baseValue, nmemb, size, compare);
			return ret;
		}

		public static void* Bsearch(void* key, nint baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative(key, (void*)baseValue, nmemb, size, compare);
			return ret;
		}

		public static void* Bsearch(nint key, nint baseValue, nuint nmemb, nuint size, delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative((void*)key, (void*)baseValue, nmemb, size, compare);
			return ret;
		}

		public static void* Bsearch(void* key, void* baseValue, nuint nmemb, nuint size, SDLCompareCallback compare)
		{
			void* ret = BsearchNative(key, baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		public static void* Bsearch(nint key, void* baseValue, nuint nmemb, nuint size, SDLCompareCallback compare)
		{
			void* ret = BsearchNative((void*)key, baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		public static void* Bsearch(void* key, nint baseValue, nuint nmemb, nuint size, SDLCompareCallback compare)
		{
			void* ret = BsearchNative(key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		public static void* Bsearch(nint key, nint baseValue, nuint nmemb, nuint size, SDLCompareCallback compare)
		{
			void* ret = BsearchNative((void*)key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AbsNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[13])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[13])(x);
			#endif
		}

		public static int Abs(int x)
		{
			int ret = AbsNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsalphaNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[14])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[14])(x);
			#endif
		}

		public static int Isalpha(int x)
		{
			int ret = IsalphaNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsalnumNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[15])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[15])(x);
			#endif
		}

		public static int Isalnum(int x)
		{
			int ret = IsalnumNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsblankNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[16])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[16])(x);
			#endif
		}

		public static int Isblank(int x)
		{
			int ret = IsblankNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IscntrlNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[17])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[17])(x);
			#endif
		}

		public static int Iscntrl(int x)
		{
			int ret = IscntrlNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsdigitNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[18])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[18])(x);
			#endif
		}

		public static int Isdigit(int x)
		{
			int ret = IsdigitNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsxdigitNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[19])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[19])(x);
			#endif
		}

		public static int Isxdigit(int x)
		{
			int ret = IsxdigitNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IspunctNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[20])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[20])(x);
			#endif
		}

		public static int Ispunct(int x)
		{
			int ret = IspunctNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsspaceNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[21])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[21])(x);
			#endif
		}

		public static int Isspace(int x)
		{
			int ret = IsspaceNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsupperNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[22])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[22])(x);
			#endif
		}

		public static int Isupper(int x)
		{
			int ret = IsupperNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IslowerNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[23])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[23])(x);
			#endif
		}

		public static int Islower(int x)
		{
			int ret = IslowerNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsprintNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[24])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[24])(x);
			#endif
		}

		public static int Isprint(int x)
		{
			int ret = IsprintNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsgraphNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[25])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[25])(x);
			#endif
		}

		public static int Isgraph(int x)
		{
			int ret = IsgraphNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ToupperNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[26])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[26])(x);
			#endif
		}

		public static int Toupper(int x)
		{
			int ret = ToupperNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TolowerNative(int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[27])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[27])(x);
			#endif
		}

		public static int Tolower(int x)
		{
			int ret = TolowerNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort Crc16Native(ushort crc, void* data, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, void*, nuint, ushort>)funcTable[28])(crc, data, len);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, nint, nuint, ushort>)funcTable[28])(crc, (nint)data, len);
			#endif
		}

		public static ushort Crc16(ushort crc, void* data, nuint len)
		{
			ushort ret = Crc16Native(crc, data, len);
			return ret;
		}

		public static ushort Crc16(ushort crc, nint data, nuint len)
		{
			ushort ret = Crc16Native(crc, (void*)data, len);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Crc32Native(uint crc, void* data, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*, nuint, uint>)funcTable[29])(crc, data, len);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, nuint, uint>)funcTable[29])(crc, (nint)data, len);
			#endif
		}

		public static uint Crc32(uint crc, void* data, nuint len)
		{
			uint ret = Crc32Native(crc, data, len);
			return ret;
		}

		public static uint Crc32(uint crc, nint data, nuint len)
		{
			uint ret = Crc32Native(crc, (void*)data, len);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemsetNative(void* dst, int c, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, nuint, void*>)funcTable[30])(dst, c, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, int, nuint, nint>)funcTable[30])((nint)dst, c, len);
			#endif
		}

		public static void* Memset(void* dst, int c, nuint len)
		{
			void* ret = MemsetNative(dst, c, len);
			return ret;
		}

		public static void* Memset(nint dst, int c, nuint len)
		{
			void* ret = MemsetNative((void*)dst, c, len);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemcpyNative(void* dst, void* src, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, void*>)funcTable[31])(dst, src, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[31])((nint)dst, (nint)src, len);
			#endif
		}

		public static void* Memcpy(void* dst, void* src, nuint len)
		{
			void* ret = MemcpyNative(dst, src, len);
			return ret;
		}

		public static void* Memcpy(nint dst, void* src, nuint len)
		{
			void* ret = MemcpyNative((void*)dst, src, len);
			return ret;
		}

		public static void* Memcpy(void* dst, nint src, nuint len)
		{
			void* ret = MemcpyNative(dst, (void*)src, len);
			return ret;
		}

		public static void* Memcpy(nint dst, nint src, nuint len)
		{
			void* ret = MemcpyNative((void*)dst, (void*)src, len);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemmoveNative(void* dst, void* src, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, void*>)funcTable[32])(dst, src, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[32])((nint)dst, (nint)src, len);
			#endif
		}

		public static void* Memmove(void* dst, void* src, nuint len)
		{
			void* ret = MemmoveNative(dst, src, len);
			return ret;
		}

		public static void* Memmove(nint dst, void* src, nuint len)
		{
			void* ret = MemmoveNative((void*)dst, src, len);
			return ret;
		}

		public static void* Memmove(void* dst, nint src, nuint len)
		{
			void* ret = MemmoveNative(dst, (void*)src, len);
			return ret;
		}

		public static void* Memmove(nint dst, nint src, nuint len)
		{
			void* ret = MemmoveNative((void*)dst, (void*)src, len);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MemcmpNative(void* s1, void* s2, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, int>)funcTable[33])(s1, s2, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[33])((nint)s1, (nint)s2, len);
			#endif
		}

		public static int Memcmp(void* s1, void* s2, nuint len)
		{
			int ret = MemcmpNative(s1, s2, len);
			return ret;
		}

		public static int Memcmp(nint s1, void* s2, nuint len)
		{
			int ret = MemcmpNative((void*)s1, s2, len);
			return ret;
		}

		public static int Memcmp(void* s1, nint s2, nuint len)
		{
			int ret = MemcmpNative(s1, (void*)s2, len);
			return ret;
		}

		public static int Memcmp(nint s1, nint s2, nuint len)
		{
			int ret = MemcmpNative((void*)s1, (void*)s2, len);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WcslenNative(char* wstr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, nuint>)funcTable[34])(wstr);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[34])((nint)wstr);
			#endif
		}

		public static nuint Wcslen(char* wstr)
		{
			nuint ret = WcslenNative(wstr);
			return ret;
		}

		public static nuint Wcslen(in char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				nuint ret = WcslenNative((char*)pwstr);
				return ret;
			}
		}

		public static nuint Wcslen(ReadOnlySpan<char> wstr)
		{
			fixed (char* pwstr = wstr)
			{
				nuint ret = WcslenNative((char*)pwstr);
				return ret;
			}
		}

		public static nuint Wcslen(string wstr)
		{
			fixed (char* pwstr = wstr)
			{
				nuint ret = WcslenNative(pwstr);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WcslcpyNative(char* dst, char* src, nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, nuint>)funcTable[35])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[35])((nint)dst, (nint)src, maxlen);
			#endif
		}

		public static nuint Wcslcpy(char* dst, char* src, nuint maxlen)
		{
			nuint ret = WcslcpyNative(dst, src, maxlen);
			return ret;
		}

		public static nuint Wcslcpy(ref char dst, char* src, nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				nuint ret = WcslcpyNative((char*)pdst, src, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcpy(ref string dst, char* src, nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = WcslcpyNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Wcslcpy(char* dst, in char src, nuint maxlen)
		{
			fixed (char* psrc = &src)
			{
				nuint ret = WcslcpyNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcpy(char* dst, ReadOnlySpan<char> src, nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcpyNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcpy(char* dst, string src, nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcpyNative(dst, psrc, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcpy(ref char dst, in char src, nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = &src)
				{
					nuint ret = WcslcpyNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Wcslcpy(ref char dst, ReadOnlySpan<char> src, nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = src)
				{
					nuint ret = WcslcpyNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Wcslcpy(ref string dst, string src, nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (char* psrc = src)
			{
				nuint ret = WcslcpyNative(pStr0, psrc, maxlen);
				dst = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WcslcatNative(char* dst, char* src, nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, nuint>)funcTable[36])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[36])((nint)dst, (nint)src, maxlen);
			#endif
		}

		public static nuint Wcslcat(char* dst, char* src, nuint maxlen)
		{
			nuint ret = WcslcatNative(dst, src, maxlen);
			return ret;
		}

		public static nuint Wcslcat(ref char dst, char* src, nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				nuint ret = WcslcatNative((char*)pdst, src, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcat(ref string dst, char* src, nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = WcslcatNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Wcslcat(char* dst, in char src, nuint maxlen)
		{
			fixed (char* psrc = &src)
			{
				nuint ret = WcslcatNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcat(char* dst, ReadOnlySpan<char> src, nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcatNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcat(char* dst, string src, nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcatNative(dst, psrc, maxlen);
				return ret;
			}
		}

		public static nuint Wcslcat(ref char dst, in char src, nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = &src)
				{
					nuint ret = WcslcatNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Wcslcat(ref char dst, ReadOnlySpan<char> src, nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = src)
				{
					nuint ret = WcslcatNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Wcslcat(ref string dst, string src, nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (char* psrc = src)
			{
				nuint ret = WcslcatNative(pStr0, psrc, maxlen);
				dst = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static char* WcsdupNative(char* wstr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*>)funcTable[37])(wstr);
			#else
			return (char*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[37])((nint)wstr);
			#endif
		}

		public static char* Wcsdup(char* wstr)
		{
			char* ret = WcsdupNative(wstr);
			return ret;
		}

		public static string WcsdupS(char* wstr)
		{
			string ret = Utils.DecodeStringUTF16(WcsdupNative(wstr));
			return ret;
		}

		public static char* Wcsdup(in char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				char* ret = WcsdupNative((char*)pwstr);
				return ret;
			}
		}

		public static string WcsdupS(in char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				string ret = Utils.DecodeStringUTF16(WcsdupNative((char*)pwstr));
				return ret;
			}
		}

		public static char* Wcsdup(ReadOnlySpan<char> wstr)
		{
			fixed (char* pwstr = wstr)
			{
				char* ret = WcsdupNative((char*)pwstr);
				return ret;
			}
		}

		public static string WcsdupS(ReadOnlySpan<char> wstr)
		{
			fixed (char* pwstr = wstr)
			{
				string ret = Utils.DecodeStringUTF16(WcsdupNative((char*)pwstr));
				return ret;
			}
		}

		public static char* Wcsdup(string wstr)
		{
			fixed (char* pwstr = wstr)
			{
				char* ret = WcsdupNative(pwstr);
				return ret;
			}
		}

		public static string WcsdupS(string wstr)
		{
			fixed (char* pwstr = wstr)
			{
				string ret = Utils.DecodeStringUTF16(WcsdupNative(pwstr));
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static char* WcsstrNative(char* haystack, char* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, char*>)funcTable[38])(haystack, needle);
			#else
			return (char*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[38])((nint)haystack, (nint)needle);
			#endif
		}

		public static char* Wcsstr(char* haystack, char* needle)
		{
			char* ret = WcsstrNative(haystack, needle);
			return ret;
		}

		public static string WcsstrS(char* haystack, char* needle)
		{
			string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, needle));
			return ret;
		}

		public static char* Wcsstr(in char haystack, char* needle)
		{
			fixed (char* phaystack = &haystack)
			{
				char* ret = WcsstrNative((char*)phaystack, needle);
				return ret;
			}
		}

		public static string WcsstrS(in char haystack, char* needle)
		{
			fixed (char* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, needle));
				return ret;
			}
		}

		public static char* Wcsstr(ReadOnlySpan<char> haystack, char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				char* ret = WcsstrNative((char*)phaystack, needle);
				return ret;
			}
		}

		public static string WcsstrS(ReadOnlySpan<char> haystack, char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, needle));
				return ret;
			}
		}

		public static char* Wcsstr(string haystack, char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				char* ret = WcsstrNative(phaystack, needle);
				return ret;
			}
		}

		public static string WcsstrS(string haystack, char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(phaystack, needle));
				return ret;
			}
		}

		public static char* Wcsstr(char* haystack, in char needle)
		{
			fixed (char* pneedle = &needle)
			{
				char* ret = WcsstrNative(haystack, (char*)pneedle);
				return ret;
			}
		}

		public static string WcsstrS(char* haystack, in char needle)
		{
			fixed (char* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, (char*)pneedle));
				return ret;
			}
		}

		public static char* Wcsstr(char* haystack, ReadOnlySpan<char> needle)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsstrNative(haystack, (char*)pneedle);
				return ret;
			}
		}

		public static string WcsstrS(char* haystack, ReadOnlySpan<char> needle)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, (char*)pneedle));
				return ret;
			}
		}

		public static char* Wcsstr(char* haystack, string needle)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsstrNative(haystack, pneedle);
				return ret;
			}
		}

		public static string WcsstrS(char* haystack, string needle)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, pneedle));
				return ret;
			}
		}

		public static char* Wcsstr(in char haystack, in char needle)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					char* ret = WcsstrNative((char*)phaystack, (char*)pneedle);
					return ret;
				}
			}
		}

		public static string WcsstrS(in char haystack, in char needle)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, (char*)pneedle));
					return ret;
				}
			}
		}

		public static char* Wcsstr(ReadOnlySpan<char> haystack, ReadOnlySpan<char> needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsstrNative((char*)phaystack, (char*)pneedle);
					return ret;
				}
			}
		}

		public static string WcsstrS(ReadOnlySpan<char> haystack, ReadOnlySpan<char> needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, (char*)pneedle));
					return ret;
				}
			}
		}

		public static char* Wcsstr(string haystack, string needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsstrNative(phaystack, pneedle);
					return ret;
				}
			}
		}

		public static string WcsstrS(string haystack, string needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsstrNative(phaystack, pneedle));
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcscmpNative(char* str1, char* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, int>)funcTable[39])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[39])((nint)str1, (nint)str2);
			#endif
		}

		public static int Wcscmp(char* str1, char* str2)
		{
			int ret = WcscmpNative(str1, str2);
			return ret;
		}

		public static int Wcscmp(in char str1, char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcscmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		public static int Wcscmp(ReadOnlySpan<char> str1, char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		public static int Wcscmp(string str1, char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscmpNative(pstr1, str2);
				return ret;
			}
		}

		public static int Wcscmp(char* str1, in char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcscmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		public static int Wcscmp(char* str1, ReadOnlySpan<char> str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		public static int Wcscmp(char* str1, string str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscmpNative(str1, pstr2);
				return ret;
			}
		}

		public static int Wcscmp(in char str1, in char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcscmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		public static int Wcscmp(ReadOnlySpan<char> str1, ReadOnlySpan<char> str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		public static int Wcscmp(string str1, string str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscmpNative(pstr1, pstr2);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcsncmpNative(char* str1, char* str2, nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, int>)funcTable[40])(str1, str2, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[40])((nint)str1, (nint)str2, maxlen);
			#endif
		}

		public static int Wcsncmp(char* str1, char* str2, nuint maxlen)
		{
			int ret = WcsncmpNative(str1, str2, maxlen);
			return ret;
		}

		public static int Wcsncmp(in char str1, char* str2, nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcsncmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		public static int Wcsncmp(ReadOnlySpan<char> str1, char* str2, nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		public static int Wcsncmp(string str1, char* str2, nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncmpNative(pstr1, str2, maxlen);
				return ret;
			}
		}

		public static int Wcsncmp(char* str1, in char str2, nuint maxlen)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcsncmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		public static int Wcsncmp(char* str1, ReadOnlySpan<char> str2, nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		public static int Wcsncmp(char* str1, string str2, nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncmpNative(str1, pstr2, maxlen);
				return ret;
			}
		}

		public static int Wcsncmp(in char str1, in char str2, nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcsncmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		public static int Wcsncmp(ReadOnlySpan<char> str1, ReadOnlySpan<char> str2, nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		public static int Wcsncmp(string str1, string str2, nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncmpNative(pstr1, pstr2, maxlen);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcscasecmpNative(char* str1, char* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, int>)funcTable[41])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[41])((nint)str1, (nint)str2);
			#endif
		}

		public static int Wcscasecmp(char* str1, char* str2)
		{
			int ret = WcscasecmpNative(str1, str2);
			return ret;
		}

		public static int Wcscasecmp(in char str1, char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcscasecmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		public static int Wcscasecmp(ReadOnlySpan<char> str1, char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscasecmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		public static int Wcscasecmp(string str1, char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscasecmpNative(pstr1, str2);
				return ret;
			}
		}

		public static int Wcscasecmp(char* str1, in char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcscasecmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		public static int Wcscasecmp(char* str1, ReadOnlySpan<char> str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscasecmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		public static int Wcscasecmp(char* str1, string str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscasecmpNative(str1, pstr2);
				return ret;
			}
		}

		public static int Wcscasecmp(in char str1, in char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcscasecmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		public static int Wcscasecmp(ReadOnlySpan<char> str1, ReadOnlySpan<char> str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscasecmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		public static int Wcscasecmp(string str1, string str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscasecmpNative(pstr1, pstr2);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcsncasecmpNative(char* str1, char* str2, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, int>)funcTable[42])(str1, str2, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[42])((nint)str1, (nint)str2, len);
			#endif
		}

		public static int Wcsncasecmp(char* str1, char* str2, nuint len)
		{
			int ret = WcsncasecmpNative(str1, str2, len);
			return ret;
		}

		public static int Wcsncasecmp(in char str1, char* str2, nuint len)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcsncasecmpNative((char*)pstr1, str2, len);
				return ret;
			}
		}

		public static int Wcsncasecmp(ReadOnlySpan<char> str1, char* str2, nuint len)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncasecmpNative((char*)pstr1, str2, len);
				return ret;
			}
		}

		public static int Wcsncasecmp(string str1, char* str2, nuint len)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncasecmpNative(pstr1, str2, len);
				return ret;
			}
		}

		public static int Wcsncasecmp(char* str1, in char str2, nuint len)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcsncasecmpNative(str1, (char*)pstr2, len);
				return ret;
			}
		}

		public static int Wcsncasecmp(char* str1, ReadOnlySpan<char> str2, nuint len)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncasecmpNative(str1, (char*)pstr2, len);
				return ret;
			}
		}

		public static int Wcsncasecmp(char* str1, string str2, nuint len)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncasecmpNative(str1, pstr2, len);
				return ret;
			}
		}

		public static int Wcsncasecmp(in char str1, in char str2, nuint len)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcsncasecmpNative((char*)pstr1, (char*)pstr2, len);
					return ret;
				}
			}
		}

		public static int Wcsncasecmp(ReadOnlySpan<char> str1, ReadOnlySpan<char> str2, nuint len)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncasecmpNative((char*)pstr1, (char*)pstr2, len);
					return ret;
				}
			}
		}

		public static int Wcsncasecmp(string str1, string str2, nuint len)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncasecmpNative(pstr1, pstr2, len);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrlenNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint>)funcTable[43])(str);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[43])((nint)str);
			#endif
		}

		public static nuint Strlen(byte* str)
		{
			nuint ret = StrlenNative(str);
			return ret;
		}

		public static nuint Strlen(in byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = StrlenNative((byte*)pstr);
				return ret;
			}
		}

		public static nuint Strlen(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = StrlenNative((byte*)pstr);
				return ret;
			}
		}

		public static nuint Strlen(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrlcpyNative(byte* dst, byte* src, nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, nuint>)funcTable[44])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[44])((nint)dst, (nint)src, maxlen);
			#endif
		}

		public static nuint Strlcpy(byte* dst, byte* src, nuint maxlen)
		{
			nuint ret = StrlcpyNative(dst, src, maxlen);
			return ret;
		}

		public static nuint Strlcpy(ref byte dst, byte* src, nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = StrlcpyNative((byte*)pdst, src, maxlen);
				return ret;
			}
		}

		public static nuint Strlcpy(ref string dst, byte* src, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcpyNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Strlcpy(byte* dst, in byte src, nuint maxlen)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = StrlcpyNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Strlcpy(byte* dst, ReadOnlySpan<byte> src, nuint maxlen)
		{
			fixed (byte* psrc = src)
			{
				nuint ret = StrlcpyNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Strlcpy(byte* dst, string src, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcpyNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Strlcpy(ref byte dst, in byte src, nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = StrlcpyNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Strlcpy(ref byte dst, ReadOnlySpan<byte> src, nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					nuint ret = StrlcpyNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Strlcpy(ref string dst, string src, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = StrlcpyNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrlcpyNative(byte* dst, byte* src, nuint dstBytes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, nuint>)funcTable[45])(dst, src, dstBytes);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[45])((nint)dst, (nint)src, dstBytes);
			#endif
		}

		public static nuint Utf8Strlcpy(byte* dst, byte* src, nuint dstBytes)
		{
			nuint ret = Utf8StrlcpyNative(dst, src, dstBytes);
			return ret;
		}

		public static nuint Utf8Strlcpy(ref byte dst, byte* src, nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = Utf8StrlcpyNative((byte*)pdst, src, dstBytes);
				return ret;
			}
		}

		public static nuint Utf8Strlcpy(ref string dst, byte* src, nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrlcpyNative(pStr0, src, dstBytes);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Utf8Strlcpy(byte* dst, in byte src, nuint dstBytes)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = Utf8StrlcpyNative(dst, (byte*)psrc, dstBytes);
				return ret;
			}
		}

		public static nuint Utf8Strlcpy(byte* dst, ReadOnlySpan<byte> src, nuint dstBytes)
		{
			fixed (byte* psrc = src)
			{
				nuint ret = Utf8StrlcpyNative(dst, (byte*)psrc, dstBytes);
				return ret;
			}
		}

		public static nuint Utf8Strlcpy(byte* dst, string src, nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrlcpyNative(dst, pStr0, dstBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Utf8Strlcpy(ref byte dst, in byte src, nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = Utf8StrlcpyNative((byte*)pdst, (byte*)psrc, dstBytes);
					return ret;
				}
			}
		}

		public static nuint Utf8Strlcpy(ref byte dst, ReadOnlySpan<byte> src, nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					nuint ret = Utf8StrlcpyNative((byte*)pdst, (byte*)psrc, dstBytes);
					return ret;
				}
			}
		}

		public static nuint Utf8Strlcpy(ref string dst, string src, nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = Utf8StrlcpyNative(pStr0, pStr1, dstBytes);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrlcatNative(byte* dst, byte* src, nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, nuint>)funcTable[46])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[46])((nint)dst, (nint)src, maxlen);
			#endif
		}

		public static nuint Strlcat(byte* dst, byte* src, nuint maxlen)
		{
			nuint ret = StrlcatNative(dst, src, maxlen);
			return ret;
		}

		public static nuint Strlcat(ref byte dst, byte* src, nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = StrlcatNative((byte*)pdst, src, maxlen);
				return ret;
			}
		}

		public static nuint Strlcat(ref string dst, byte* src, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcatNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Strlcat(byte* dst, in byte src, nuint maxlen)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = StrlcatNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Strlcat(byte* dst, ReadOnlySpan<byte> src, nuint maxlen)
		{
			fixed (byte* psrc = src)
			{
				nuint ret = StrlcatNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		public static nuint Strlcat(byte* dst, string src, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcatNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static nuint Strlcat(ref byte dst, in byte src, nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = StrlcatNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Strlcat(ref byte dst, ReadOnlySpan<byte> src, nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					nuint ret = StrlcatNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		public static nuint Strlcat(ref string dst, string src, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = StrlcatNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrdupNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[47])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[47])((nint)str);
			#endif
		}

		public static byte* Strdup(byte* str)
		{
			byte* ret = StrdupNative(str);
			return ret;
		}

		public static string StrdupS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrdupNative(str));
			return ret;
		}

		public static byte* Strdup(in byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrdupNative((byte*)pstr);
				return ret;
			}
		}

		public static string StrdupS(in byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrdupNative((byte*)pstr));
				return ret;
			}
		}

		public static byte* Strdup(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrdupNative((byte*)pstr);
				return ret;
			}
		}

		public static string StrdupS(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrdupNative((byte*)pstr));
				return ret;
			}
		}

		public static byte* Strdup(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrdupNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrdupS(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrdupNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrrevNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[48])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[48])((nint)str);
			#endif
		}

		public static byte* Strrev(byte* str)
		{
			byte* ret = StrrevNative(str);
			return ret;
		}

		public static string StrrevS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrrevNative(str));
			return ret;
		}

		public static byte* Strrev(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrrevNative((byte*)pstr);
				return ret;
			}
		}

		public static string StrrevS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrrevNative((byte*)pstr));
				return ret;
			}
		}

		public static byte* Strrev(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrrevNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrrevS(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrrevNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StruprNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[49])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[49])((nint)str);
			#endif
		}

		public static byte* Strupr(byte* str)
		{
			byte* ret = StruprNative(str);
			return ret;
		}

		public static string StruprS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StruprNative(str));
			return ret;
		}

		public static byte* Strupr(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StruprNative((byte*)pstr);
				return ret;
			}
		}

		public static string StruprS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StruprNative((byte*)pstr));
				return ret;
			}
		}

		public static byte* Strupr(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StruprNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StruprS(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StruprNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrlwrNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[50])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[50])((nint)str);
			#endif
		}

		public static byte* Strlwr(byte* str)
		{
			byte* ret = StrlwrNative(str);
			return ret;
		}

		public static string StrlwrS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrlwrNative(str));
			return ret;
		}

		public static byte* Strlwr(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrlwrNative((byte*)pstr);
				return ret;
			}
		}

		public static string StrlwrS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrlwrNative((byte*)pstr));
				return ret;
			}
		}

		public static byte* Strlwr(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrlwrNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrlwrS(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrlwrNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrchrNative(byte* str, int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[51])(str, c);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[51])((nint)str, c);
			#endif
		}

		public static byte* Strchr(byte* str, int c)
		{
			byte* ret = StrchrNative(str, c);
			return ret;
		}

		public static string StrchrS(byte* str, int c)
		{
			string ret = Utils.DecodeStringUTF8(StrchrNative(str, c));
			return ret;
		}

		public static byte* Strchr(in byte str, int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		public static string StrchrS(in byte str, int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		public static byte* Strchr(ReadOnlySpan<byte> str, int c)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		public static string StrchrS(ReadOnlySpan<byte> str, int c)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		public static byte* Strchr(string str, int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrchrS(string str, int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrrchrNative(byte* str, int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[52])(str, c);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[52])((nint)str, c);
			#endif
		}

		public static byte* Strrchr(byte* str, int c)
		{
			byte* ret = StrrchrNative(str, c);
			return ret;
		}

		public static string StrrchrS(byte* str, int c)
		{
			string ret = Utils.DecodeStringUTF8(StrrchrNative(str, c));
			return ret;
		}

		public static byte* Strrchr(in byte str, int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		public static string StrrchrS(in byte str, int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		public static byte* Strrchr(ReadOnlySpan<byte> str, int c)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		public static string StrrchrS(ReadOnlySpan<byte> str, int c)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		public static byte* Strrchr(string str, int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrrchrS(string str, int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrstrNative(byte* haystack, byte* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[53])(haystack, needle);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[53])((nint)haystack, (nint)needle);
			#endif
		}

		public static byte* Strstr(byte* haystack, byte* needle)
		{
			byte* ret = StrstrNative(haystack, needle);
			return ret;
		}

		public static string StrstrS(byte* haystack, byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, needle));
			return ret;
		}

		public static byte* Strstr(in byte haystack, byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrstrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		public static string StrstrS(in byte haystack, byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		public static byte* Strstr(ReadOnlySpan<byte> haystack, byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrstrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		public static string StrstrS(ReadOnlySpan<byte> haystack, byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		public static byte* Strstr(string haystack, byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrstrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrstrS(string haystack, byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* Strstr(byte* haystack, in byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrstrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		public static string StrstrS(byte* haystack, in byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		public static byte* Strstr(byte* haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrstrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		public static string StrstrS(byte* haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		public static byte* Strstr(byte* haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrstrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrstrS(byte* haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* Strstr(in byte haystack, in byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		public static string StrstrS(in byte haystack, in byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		public static byte* Strstr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		public static string StrstrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		public static byte* Strstr(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrstrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrstrS(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrcasestrNative(byte* haystack, byte* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[54])(haystack, needle);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[54])((nint)haystack, (nint)needle);
			#endif
		}

		public static byte* Strcasestr(byte* haystack, byte* needle)
		{
			byte* ret = StrcasestrNative(haystack, needle);
			return ret;
		}

		public static string StrcasestrS(byte* haystack, byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, needle));
			return ret;
		}

		public static byte* Strcasestr(in byte haystack, byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		public static string StrcasestrS(in byte haystack, byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		public static byte* Strcasestr(ReadOnlySpan<byte> haystack, byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		public static string StrcasestrS(ReadOnlySpan<byte> haystack, byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		public static byte* Strcasestr(string haystack, byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrcasestrS(string haystack, byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* Strcasestr(byte* haystack, in byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		public static string StrcasestrS(byte* haystack, in byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		public static byte* Strcasestr(byte* haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		public static string StrcasestrS(byte* haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		public static byte* Strcasestr(byte* haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrcasestrS(byte* haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* Strcasestr(in byte haystack, in byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		public static string StrcasestrS(in byte haystack, in byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		public static byte* Strcasestr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		public static string StrcasestrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		public static byte* Strcasestr(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrcasestrS(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrtokrNative(byte* s1, byte* s2, byte** saveptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte**, byte*>)funcTable[55])(s1, s2, saveptr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)funcTable[55])((nint)s1, (nint)s2, (nint)saveptr);
			#endif
		}

		public static byte* Strtokr(byte* s1, byte* s2, byte** saveptr)
		{
			byte* ret = StrtokrNative(s1, s2, saveptr);
			return ret;
		}

		public static string StrtokrS(byte* s1, byte* s2, byte** saveptr)
		{
			string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, s2, saveptr));
			return ret;
		}

		public static byte* Strtokr(ref byte s1, byte* s2, byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				byte* ret = StrtokrNative((byte*)ps1, s2, saveptr);
				return ret;
			}
		}

		public static string StrtokrS(ref byte s1, byte* s2, byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				string ret = Utils.DecodeStringUTF8(StrtokrNative((byte*)ps1, s2, saveptr));
				return ret;
			}
		}

		public static byte* Strtokr(ref string s1, byte* s2, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrtokrNative(pStr0, s2, saveptr);
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrtokrS(ref string s1, byte* s2, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokrNative(pStr0, s2, saveptr));
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* Strtokr(byte* s1, in byte s2, byte** saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				byte* ret = StrtokrNative(s1, (byte*)ps2, saveptr);
				return ret;
			}
		}

		public static string StrtokrS(byte* s1, in byte s2, byte** saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, (byte*)ps2, saveptr));
				return ret;
			}
		}

		public static byte* Strtokr(byte* s1, ReadOnlySpan<byte> s2, byte** saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				byte* ret = StrtokrNative(s1, (byte*)ps2, saveptr);
				return ret;
			}
		}

		public static string StrtokrS(byte* s1, ReadOnlySpan<byte> s2, byte** saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, (byte*)ps2, saveptr));
				return ret;
			}
		}

		public static byte* Strtokr(byte* s1, string s2, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrtokrNative(s1, pStr0, saveptr);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrtokrS(byte* s1, string s2, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, pStr0, saveptr));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* Strtokr(ref byte s1, in byte s2, byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					byte* ret = StrtokrNative((byte*)ps1, (byte*)ps2, saveptr);
					return ret;
				}
			}
		}

		public static string StrtokrS(ref byte s1, in byte s2, byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					string ret = Utils.DecodeStringUTF8(StrtokrNative((byte*)ps1, (byte*)ps2, saveptr));
					return ret;
				}
			}
		}

		public static byte* Strtokr(ref byte s1, ReadOnlySpan<byte> s2, byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					byte* ret = StrtokrNative((byte*)ps1, (byte*)ps2, saveptr);
					return ret;
				}
			}
		}

		public static string StrtokrS(ref byte s1, ReadOnlySpan<byte> s2, byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					string ret = Utils.DecodeStringUTF8(StrtokrNative((byte*)ps1, (byte*)ps2, saveptr));
					return ret;
				}
			}
		}

		public static byte* Strtokr(ref string s1, string s2, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrtokrNative(pStr0, pStr1, saveptr);
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string StrtokrS(ref string s1, string s2, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokrNative(pStr0, pStr1, saveptr));
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* Strtokr(byte* s1, byte* s2, ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokrNative(s1, s2, (byte**)psaveptr);
				return ret;
			}
		}

		public static string StrtokrS(byte* s1, byte* s2, ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, s2, (byte**)psaveptr));
				return ret;
			}
		}

		public static byte* Strtokr(ref byte s1, byte* s2, ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokrNative((byte*)ps1, s2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		public static string StrtokrS(ref byte s1, byte* s2, ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokrNative((byte*)ps1, s2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		public static byte* Strtokr(ref string s1, byte* s2, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokrNative(pStr0, s2, (byte**)psaveptr);
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string StrtokrS(ref string s1, byte* s2, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokrNative(pStr0, s2, (byte**)psaveptr));
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* Strtokr(byte* s1, in byte s2, ref byte* saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokrNative(s1, (byte*)ps2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		public static string StrtokrS(byte* s1, in byte s2, ref byte* saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, (byte*)ps2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		public static byte* Strtokr(byte* s1, ReadOnlySpan<byte> s2, ref byte* saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokrNative(s1, (byte*)ps2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		public static string StrtokrS(byte* s1, ReadOnlySpan<byte> s2, ref byte* saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, (byte*)ps2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		public static byte* Strtokr(byte* s1, string s2, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokrNative(s1, pStr0, (byte**)psaveptr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string StrtokrS(byte* s1, string s2, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokrNative(s1, pStr0, (byte**)psaveptr));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* Strtokr(ref byte s1, in byte s2, ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						byte* ret = StrtokrNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr);
						return ret;
					}
				}
			}
		}

		public static string StrtokrS(ref byte s1, in byte s2, ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						string ret = Utils.DecodeStringUTF8(StrtokrNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr));
						return ret;
					}
				}
			}
		}

		public static byte* Strtokr(ref byte s1, ReadOnlySpan<byte> s2, ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						byte* ret = StrtokrNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr);
						return ret;
					}
				}
			}
		}

		public static string StrtokrS(ref byte s1, ReadOnlySpan<byte> s2, ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						string ret = Utils.DecodeStringUTF8(StrtokrNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr));
						return ret;
					}
				}
			}
		}

		public static byte* Strtokr(ref string s1, string s2, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokrNative(pStr0, pStr1, (byte**)psaveptr);
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string StrtokrS(ref string s1, string s2, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokrNative(pStr0, pStr1, (byte**)psaveptr));
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrlenNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint>)funcTable[56])(str);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[56])((nint)str);
			#endif
		}

		public static nuint Utf8Strlen(byte* str)
		{
			nuint ret = Utf8StrlenNative(str);
			return ret;
		}

		public static nuint Utf8Strlen(in byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = Utf8StrlenNative((byte*)pstr);
				return ret;
			}
		}

		public static nuint Utf8Strlen(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = Utf8StrlenNative((byte*)pstr);
				return ret;
			}
		}

		public static nuint Utf8Strlen(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrnlenNative(byte* str, nuint bytes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, nuint>)funcTable[57])(str, bytes);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint, nuint>)funcTable[57])((nint)str, bytes);
			#endif
		}

		public static nuint Utf8Strnlen(byte* str, nuint bytes)
		{
			nuint ret = Utf8StrnlenNative(str, bytes);
			return ret;
		}

		public static nuint Utf8Strnlen(in byte str, nuint bytes)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = Utf8StrnlenNative((byte*)pstr, bytes);
				return ret;
			}
		}

		public static nuint Utf8Strnlen(ReadOnlySpan<byte> str, nuint bytes)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = Utf8StrnlenNative((byte*)pstr, bytes);
				return ret;
			}
		}

		public static nuint Utf8Strnlen(string str, nuint bytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrnlenNative(pStr0, bytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ItoaNative(int value, byte* str, int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, int, byte*>)funcTable[58])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint, int, nint>)funcTable[58])(value, (nint)str, radix);
			#endif
		}

		public static byte* Itoa(int value, byte* str, int radix)
		{
			byte* ret = ItoaNative(value, str, radix);
			return ret;
		}

		public static string ItoaS(int value, byte* str, int radix)
		{
			string ret = Utils.DecodeStringUTF8(ItoaNative(value, str, radix));
			return ret;
		}

		public static byte* Itoa(int value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ItoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		public static string ItoaS(int value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ItoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		public static byte* Itoa(int value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ItoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ItoaS(int value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ItoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* UitoaNative(uint value, byte* str, int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int, byte*>)funcTable[59])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint, int, nint>)funcTable[59])(value, (nint)str, radix);
			#endif
		}
	}
}
