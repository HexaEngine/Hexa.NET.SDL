// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		public static byte* Lltoa(long value, byte* str, int radix)
		{
			byte* ret = LltoaNative(value, str, radix);
			return ret;
		}

		public static string LltoaS(long value, byte* str, int radix)
		{
			string ret = Utils.DecodeStringUTF8(LltoaNative(value, str, radix));
			return ret;
		}

		public static byte* Lltoa(long value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = LltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		public static string LltoaS(long value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(LltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		public static byte* Lltoa(long value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = LltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string LltoaS(long value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(LltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* UlltoaNative(ulong value, byte* str, int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte*, int, byte*>)funcTable[63])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ulong, nint, int, nint>)funcTable[63])(value, (nint)str, radix);
			#endif
		}

		public static byte* Ulltoa(ulong value, byte* str, int radix)
		{
			byte* ret = UlltoaNative(value, str, radix);
			return ret;
		}

		public static string UlltoaS(ulong value, byte* str, int radix)
		{
			string ret = Utils.DecodeStringUTF8(UlltoaNative(value, str, radix));
			return ret;
		}

		public static byte* Ulltoa(ulong value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = UlltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		public static string UlltoaS(ulong value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(UlltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		public static byte* Ulltoa(ulong value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = UlltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string UlltoaS(ulong value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(UlltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AtoiNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[64])(str);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[64])((nint)str);
			#endif
		}

		public static int Atoi(byte* str)
		{
			int ret = AtoiNative(str);
			return ret;
		}

		public static int Atoi(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				int ret = AtoiNative((byte*)pstr);
				return ret;
			}
		}

		public static int Atoi(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				int ret = AtoiNative((byte*)pstr);
				return ret;
			}
		}

		public static int Atoi(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AtoiNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double AtofNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, double>)funcTable[65])(str);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[65])((nint)str);
			#endif
		}

		public static double Atof(byte* str)
		{
			double ret = AtofNative(str);
			return ret;
		}

		public static double Atof(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				double ret = AtofNative((byte*)pstr);
				return ret;
			}
		}

		public static double Atof(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				double ret = AtofNative((byte*)pstr);
				return ret;
			}
		}

		public static double Atof(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			double ret = AtofNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrtolNative(byte* str, byte** endp, int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, int>)funcTable[66])(str, endp, baseValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[66])((nint)str, (nint)endp, baseValue);
			#endif
		}

		public static int Strtol(byte* str, byte** endp, int baseValue)
		{
			int ret = StrtolNative(str, endp, baseValue);
			return ret;
		}

		public static int Strtol(ref byte str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				int ret = StrtolNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static int Strtol(ReadOnlySpan<byte> str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				int ret = StrtolNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static int Strtol(string str, byte** endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrtolNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strtol(byte* str, ref byte* endp, int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				int ret = StrtolNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		public static int Strtol(ref byte str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					int ret = StrtolNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static int Strtol(ReadOnlySpan<byte> str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					int ret = StrtolNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static int Strtol(string str, ref byte* endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				int ret = StrtolNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint StrtoulNative(byte* str, byte** endp, int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, uint>)funcTable[67])(str, endp, baseValue);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, uint>)funcTable[67])((nint)str, (nint)endp, baseValue);
			#endif
		}

		public static uint Strtoul(byte* str, byte** endp, int baseValue)
		{
			uint ret = StrtoulNative(str, endp, baseValue);
			return ret;
		}

		public static uint Strtoul(ref byte str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = StrtoulNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static uint Strtoul(ReadOnlySpan<byte> str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				uint ret = StrtoulNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static uint Strtoul(string str, byte** endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = StrtoulNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint Strtoul(byte* str, ref byte* endp, int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				uint ret = StrtoulNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		public static uint Strtoul(ref byte str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					uint ret = StrtoulNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static uint Strtoul(ReadOnlySpan<byte> str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					uint ret = StrtoulNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static uint Strtoul(string str, ref byte* endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				uint ret = StrtoulNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long StrtollNative(byte* str, byte** endp, int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, long>)funcTable[68])(str, endp, baseValue);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, nint, int, long>)funcTable[68])((nint)str, (nint)endp, baseValue);
			#endif
		}

		public static long Strtoll(byte* str, byte** endp, int baseValue)
		{
			long ret = StrtollNative(str, endp, baseValue);
			return ret;
		}

		public static long Strtoll(ref byte str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				long ret = StrtollNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static long Strtoll(ReadOnlySpan<byte> str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				long ret = StrtollNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static long Strtoll(string str, byte** endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = StrtollNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static long Strtoll(byte* str, ref byte* endp, int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				long ret = StrtollNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		public static long Strtoll(ref byte str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					long ret = StrtollNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static long Strtoll(ReadOnlySpan<byte> str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					long ret = StrtollNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static long Strtoll(string str, ref byte* endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				long ret = StrtollNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong StrtoullNative(byte* str, byte** endp, int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, ulong>)funcTable[69])(str, endp, baseValue);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, nint, int, ulong>)funcTable[69])((nint)str, (nint)endp, baseValue);
			#endif
		}

		public static ulong Strtoull(byte* str, byte** endp, int baseValue)
		{
			ulong ret = StrtoullNative(str, endp, baseValue);
			return ret;
		}

		public static ulong Strtoull(ref byte str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				ulong ret = StrtoullNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static ulong Strtoull(ReadOnlySpan<byte> str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				ulong ret = StrtoullNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		public static ulong Strtoull(string str, byte** endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ulong ret = StrtoullNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ulong Strtoull(byte* str, ref byte* endp, int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				ulong ret = StrtoullNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		public static ulong Strtoull(ref byte str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					ulong ret = StrtoullNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static ulong Strtoull(ReadOnlySpan<byte> str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					ulong ret = StrtoullNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		public static ulong Strtoull(string str, ref byte* endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				ulong ret = StrtoullNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double StrtodNative(byte* str, byte** endp)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, double>)funcTable[70])(str, endp);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, nint, double>)funcTable[70])((nint)str, (nint)endp);
			#endif
		}

		public static double Strtod(byte* str, byte** endp)
		{
			double ret = StrtodNative(str, endp);
			return ret;
		}

		public static double Strtod(ref byte str, byte** endp)
		{
			fixed (byte* pstr = &str)
			{
				double ret = StrtodNative((byte*)pstr, endp);
				return ret;
			}
		}

		public static double Strtod(ReadOnlySpan<byte> str, byte** endp)
		{
			fixed (byte* pstr = str)
			{
				double ret = StrtodNative((byte*)pstr, endp);
				return ret;
			}
		}

		public static double Strtod(string str, byte** endp)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			double ret = StrtodNative(pStr0, endp);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static double Strtod(byte* str, ref byte* endp)
		{
			fixed (byte** pendp = &endp)
			{
				double ret = StrtodNative(str, (byte**)pendp);
				return ret;
			}
		}

		public static double Strtod(ref byte str, ref byte* endp)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					double ret = StrtodNative((byte*)pstr, (byte**)pendp);
					return ret;
				}
			}
		}

		public static double Strtod(ReadOnlySpan<byte> str, ref byte* endp)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					double ret = StrtodNative((byte*)pstr, (byte**)pendp);
					return ret;
				}
			}
		}

		public static double Strtod(string str, ref byte* endp)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				double ret = StrtodNative(pStr0, (byte**)pendp);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrcmpNative(byte* str1, byte* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[71])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[71])((nint)str1, (nint)str2);
			#endif
		}

		public static int Strcmp(byte* str1, byte* str2)
		{
			int ret = StrcmpNative(str1, str2);
			return ret;
		}

		public static int Strcmp(ref byte str1, byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = StrcmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		public static int Strcmp(ReadOnlySpan<byte> str1, byte* str2)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = StrcmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		public static int Strcmp(string str1, byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrcmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strcmp(byte* str1, ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = StrcmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		public static int Strcmp(byte* str1, ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = StrcmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		public static int Strcmp(byte* str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrcmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strcmp(ref byte str1, ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = StrcmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		public static int Strcmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = StrcmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		public static int Strcmp(string str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = StrcmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrncmpNative(byte* str1, byte* str2, nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, int>)funcTable[72])(str1, str2, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[72])((nint)str1, (nint)str2, maxlen);
			#endif
		}

		public static int Strncmp(byte* str1, byte* str2, nuint maxlen)
		{
			int ret = StrncmpNative(str1, str2, maxlen);
			return ret;
		}

		public static int Strncmp(ref byte str1, byte* str2, nuint maxlen)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = StrncmpNative((byte*)pstr1, str2, maxlen);
				return ret;
			}
		}

		public static int Strncmp(ReadOnlySpan<byte> str1, byte* str2, nuint maxlen)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = StrncmpNative((byte*)pstr1, str2, maxlen);
				return ret;
			}
		}

		public static int Strncmp(string str1, byte* str2, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrncmpNative(pStr0, str2, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strncmp(byte* str1, ref byte str2, nuint maxlen)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = StrncmpNative(str1, (byte*)pstr2, maxlen);
				return ret;
			}
		}

		public static int Strncmp(byte* str1, ReadOnlySpan<byte> str2, nuint maxlen)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = StrncmpNative(str1, (byte*)pstr2, maxlen);
				return ret;
			}
		}

		public static int Strncmp(byte* str1, string str2, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrncmpNative(str1, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strncmp(ref byte str1, ref byte str2, nuint maxlen)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = StrncmpNative((byte*)pstr1, (byte*)pstr2, maxlen);
					return ret;
				}
			}
		}

		public static int Strncmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2, nuint maxlen)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = StrncmpNative((byte*)pstr1, (byte*)pstr2, maxlen);
					return ret;
				}
			}
		}

		public static int Strncmp(string str1, string str2, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = StrncmpNative(pStr0, pStr1, maxlen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrcasecmpNative(byte* str1, byte* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[73])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[73])((nint)str1, (nint)str2);
			#endif
		}

		public static int Strcasecmp(byte* str1, byte* str2)
		{
			int ret = StrcasecmpNative(str1, str2);
			return ret;
		}

		public static int Strcasecmp(ref byte str1, byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = StrcasecmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		public static int Strcasecmp(ReadOnlySpan<byte> str1, byte* str2)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = StrcasecmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		public static int Strcasecmp(string str1, byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrcasecmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strcasecmp(byte* str1, ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = StrcasecmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		public static int Strcasecmp(byte* str1, ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = StrcasecmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		public static int Strcasecmp(byte* str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrcasecmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strcasecmp(ref byte str1, ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = StrcasecmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		public static int Strcasecmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = StrcasecmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		public static int Strcasecmp(string str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = StrcasecmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrncasecmpNative(byte* str1, byte* str2, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, int>)funcTable[74])(str1, str2, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[74])((nint)str1, (nint)str2, len);
			#endif
		}

		public static int Strncasecmp(byte* str1, byte* str2, nuint len)
		{
			int ret = StrncasecmpNative(str1, str2, len);
			return ret;
		}

		public static int Strncasecmp(ref byte str1, byte* str2, nuint len)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = StrncasecmpNative((byte*)pstr1, str2, len);
				return ret;
			}
		}

		public static int Strncasecmp(ReadOnlySpan<byte> str1, byte* str2, nuint len)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = StrncasecmpNative((byte*)pstr1, str2, len);
				return ret;
			}
		}

		public static int Strncasecmp(string str1, byte* str2, nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrncasecmpNative(pStr0, str2, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strncasecmp(byte* str1, ref byte str2, nuint len)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = StrncasecmpNative(str1, (byte*)pstr2, len);
				return ret;
			}
		}

		public static int Strncasecmp(byte* str1, ReadOnlySpan<byte> str2, nuint len)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = StrncasecmpNative(str1, (byte*)pstr2, len);
				return ret;
			}
		}

		public static int Strncasecmp(byte* str1, string str2, nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrncasecmpNative(str1, pStr0, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Strncasecmp(ref byte str1, ref byte str2, nuint len)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = StrncasecmpNative((byte*)pstr1, (byte*)pstr2, len);
					return ret;
				}
			}
		}

		public static int Strncasecmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2, nuint len)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = StrncasecmpNative((byte*)pstr1, (byte*)pstr2, len);
					return ret;
				}
			}
		}

		public static int Strncasecmp(string str1, string str2, nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = StrncasecmpNative(pStr0, pStr1, len);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SscanfNative(byte* text, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[75])(text, fmt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[75])((nint)text, (nint)fmt);
			#endif
		}

		public static int Sscanf(byte* text, byte* fmt)
		{
			int ret = SscanfNative(text, fmt);
			return ret;
		}

		public static int Sscanf(ref byte text, byte* fmt)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SscanfNative((byte*)ptext, fmt);
				return ret;
			}
		}

		public static int Sscanf(ReadOnlySpan<byte> text, byte* fmt)
		{
			fixed (byte* ptext = text)
			{
				int ret = SscanfNative((byte*)ptext, fmt);
				return ret;
			}
		}

		public static int Sscanf(string text, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SscanfNative(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Sscanf(byte* text, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SscanfNative(text, (byte*)pfmt);
				return ret;
			}
		}

		public static int Sscanf(byte* text, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				int ret = SscanfNative(text, (byte*)pfmt);
				return ret;
			}
		}

		public static int Sscanf(byte* text, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SscanfNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Sscanf(ref byte text, ref byte fmt)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SscanfNative((byte*)ptext, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int Sscanf(ReadOnlySpan<byte> text, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pfmt = fmt)
				{
					int ret = SscanfNative((byte*)ptext, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int Sscanf(string text, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SscanfNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VsscanfNative(byte* text, byte* fmt, nint ap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nint, int>)funcTable[76])(text, fmt, ap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[76])((nint)text, (nint)fmt, ap);
			#endif
		}

		public static int Vsscanf(byte* text, byte* fmt, nint ap)
		{
			int ret = VsscanfNative(text, fmt, ap);
			return ret;
		}

		public static int Vsscanf(ref byte text, byte* fmt, nint ap)
		{
			fixed (byte* ptext = &text)
			{
				int ret = VsscanfNative((byte*)ptext, fmt, ap);
				return ret;
			}
		}

		public static int Vsscanf(ReadOnlySpan<byte> text, byte* fmt, nint ap)
		{
			fixed (byte* ptext = text)
			{
				int ret = VsscanfNative((byte*)ptext, fmt, ap);
				return ret;
			}
		}

		public static int Vsscanf(string text, byte* fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = VsscanfNative(pStr0, fmt, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Vsscanf(byte* text, ref byte fmt, nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = VsscanfNative(text, (byte*)pfmt, ap);
				return ret;
			}
		}

		public static int Vsscanf(byte* text, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				int ret = VsscanfNative(text, (byte*)pfmt, ap);
				return ret;
			}
		}

		public static int Vsscanf(byte* text, string fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = VsscanfNative(text, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Vsscanf(ref byte text, ref byte fmt, nint ap)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = VsscanfNative((byte*)ptext, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		public static int Vsscanf(ReadOnlySpan<byte> text, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pfmt = fmt)
				{
					int ret = VsscanfNative((byte*)ptext, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		public static int Vsscanf(string text, string fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = VsscanfNative(pStr0, pStr1, ap);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SnprintfNative(byte* text, nuint maxlen, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, byte*, int>)funcTable[77])(text, maxlen, fmt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nint, int>)funcTable[77])((nint)text, maxlen, (nint)fmt);
			#endif
		}

		public static int Snprintf(byte* text, nuint maxlen, byte* fmt)
		{
			int ret = SnprintfNative(text, maxlen, fmt);
			return ret;
		}

		public static int Snprintf(ref byte text, nuint maxlen, byte* fmt)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SnprintfNative((byte*)ptext, maxlen, fmt);
				return ret;
			}
		}

		public static int Snprintf(ref string text, nuint maxlen, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SnprintfNative(pStr0, maxlen, fmt);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Snprintf(byte* text, nuint maxlen, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SnprintfNative(text, maxlen, (byte*)pfmt);
				return ret;
			}
		}

		public static int Snprintf(byte* text, nuint maxlen, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				int ret = SnprintfNative(text, maxlen, (byte*)pfmt);
				return ret;
			}
		}

		public static int Snprintf(byte* text, nuint maxlen, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SnprintfNative(text, maxlen, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Snprintf(ref byte text, nuint maxlen, ref byte fmt)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SnprintfNative((byte*)ptext, maxlen, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int Snprintf(ref byte text, nuint maxlen, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = fmt)
				{
					int ret = SnprintfNative((byte*)ptext, maxlen, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int Snprintf(ref string text, nuint maxlen, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SnprintfNative(pStr0, maxlen, pStr1);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VsnprintfNative(byte* text, nuint maxlen, byte* fmt, nint ap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, byte*, nint, int>)funcTable[78])(text, maxlen, fmt, ap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, int>)funcTable[78])((nint)text, maxlen, (nint)fmt, ap);
			#endif
		}

		public static int Vsnprintf(byte* text, nuint maxlen, byte* fmt, nint ap)
		{
			int ret = VsnprintfNative(text, maxlen, fmt, ap);
			return ret;
		}

		public static int Vsnprintf(ref byte text, nuint maxlen, byte* fmt, nint ap)
		{
			fixed (byte* ptext = &text)
			{
				int ret = VsnprintfNative((byte*)ptext, maxlen, fmt, ap);
				return ret;
			}
		}

		public static int Vsnprintf(ref string text, nuint maxlen, byte* fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = VsnprintfNative(pStr0, maxlen, fmt, ap);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Vsnprintf(byte* text, nuint maxlen, ref byte fmt, nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = VsnprintfNative(text, maxlen, (byte*)pfmt, ap);
				return ret;
			}
		}

		public static int Vsnprintf(byte* text, nuint maxlen, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				int ret = VsnprintfNative(text, maxlen, (byte*)pfmt, ap);
				return ret;
			}
		}

		public static int Vsnprintf(byte* text, nuint maxlen, string fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = VsnprintfNative(text, maxlen, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Vsnprintf(ref byte text, nuint maxlen, ref byte fmt, nint ap)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = VsnprintfNative((byte*)ptext, maxlen, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		public static int Vsnprintf(ref byte text, nuint maxlen, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = fmt)
				{
					int ret = VsnprintfNative((byte*)ptext, maxlen, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		public static int Vsnprintf(ref string text, nuint maxlen, string fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = VsnprintfNative(pStr0, maxlen, pStr1, ap);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AsprintfNative(byte** strp, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, byte*, int>)funcTable[79])(strp, fmt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[79])((nint)strp, (nint)fmt);
			#endif
		}

		public static int Asprintf(byte** strp, byte* fmt)
		{
			int ret = AsprintfNative(strp, fmt);
			return ret;
		}

		public static int Asprintf(ref byte* strp, byte* fmt)
		{
			fixed (byte** pstrp = &strp)
			{
				int ret = AsprintfNative((byte**)pstrp, fmt);
				return ret;
			}
		}

		public static int Asprintf(byte** strp, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = AsprintfNative(strp, (byte*)pfmt);
				return ret;
			}
		}

		public static int Asprintf(byte** strp, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				int ret = AsprintfNative(strp, (byte*)pfmt);
				return ret;
			}
		}

		public static int Asprintf(byte** strp, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AsprintfNative(strp, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Asprintf(ref byte* strp, ref byte fmt)
		{
			fixed (byte** pstrp = &strp)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = AsprintfNative((byte**)pstrp, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int Asprintf(ref byte* strp, ReadOnlySpan<byte> fmt)
		{
			fixed (byte** pstrp = &strp)
			{
				fixed (byte* pfmt = fmt)
				{
					int ret = AsprintfNative((byte**)pstrp, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int Asprintf(ref byte* strp, string fmt)
		{
			fixed (byte** pstrp = &strp)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = AsprintfNative((byte**)pstrp, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VasprintfNative(byte** strp, byte* fmt, nint ap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, byte*, nint, int>)funcTable[80])(strp, fmt, ap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[80])((nint)strp, (nint)fmt, ap);
			#endif
		}

		public static int Vasprintf(byte** strp, byte* fmt, nint ap)
		{
			int ret = VasprintfNative(strp, fmt, ap);
			return ret;
		}

		public static int Vasprintf(ref byte* strp, byte* fmt, nint ap)
		{
			fixed (byte** pstrp = &strp)
			{
				int ret = VasprintfNative((byte**)pstrp, fmt, ap);
				return ret;
			}
		}

		public static int Vasprintf(byte** strp, ref byte fmt, nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = VasprintfNative(strp, (byte*)pfmt, ap);
				return ret;
			}
		}

		public static int Vasprintf(byte** strp, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				int ret = VasprintfNative(strp, (byte*)pfmt, ap);
				return ret;
			}
		}

		public static int Vasprintf(byte** strp, string fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = VasprintfNative(strp, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int Vasprintf(ref byte* strp, ref byte fmt, nint ap)
		{
			fixed (byte** pstrp = &strp)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = VasprintfNative((byte**)pstrp, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		public static int Vasprintf(ref byte* strp, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte** pstrp = &strp)
			{
				fixed (byte* pfmt = fmt)
				{
					int ret = VasprintfNative((byte**)pstrp, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		public static int Vasprintf(ref byte* strp, string fmt, nint ap)
		{
			fixed (byte** pstrp = &strp)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = VasprintfNative((byte**)pstrp, pStr0, ap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Use this function to compute arc cosine of `x`.<br/>
		/// The definition of `y = acos(x)` is `x = cos(y)`.<br/>
		/// Domain: `-1 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = 1`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi`<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double AcosNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[81])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[81])(x);
			#endif
		}

		/// <summary>
		/// Use this function to compute arc cosine of `x`.<br/>
		/// The definition of `y = acos(x)` is `x = cos(y)`.<br/>
		/// Domain: `-1 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = 1`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi`<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static double Acos(double x)
		{
			double ret = AcosNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float AcosfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[82])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[82])(x);
			#endif
		}

		public static float Acosf(float x)
		{
			float ret = AcosfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double AsinNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[83])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[83])(x);
			#endif
		}

		public static double Asin(double x)
		{
			double ret = AsinNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float AsinfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[84])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[84])(x);
			#endif
		}

		public static float Asinf(float x)
		{
			float ret = AsinfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double AtanNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[85])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[85])(x);
			#endif
		}

		public static double Atan(double x)
		{
			double ret = AtanNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float AtanfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[86])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[86])(x);
			#endif
		}

		public static float Atanf(float x)
		{
			float ret = AtanfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Atan2Native(double y, double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[87])(y, x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[87])(y, x);
			#endif
		}

		public static double Atan2(double y, double x)
		{
			double ret = Atan2Native(y, x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float Atan2FNative(float y, float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[88])(y, x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[88])(y, x);
			#endif
		}

		public static float Atan2F(float y, float x)
		{
			float ret = Atan2FNative(y, x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double CeilNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[89])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[89])(x);
			#endif
		}

		public static double Ceil(double x)
		{
			double ret = CeilNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CeilfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[90])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[90])(x);
			#endif
		}

		public static float Ceilf(float x)
		{
			float ret = CeilfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double CopysignNative(double x, double y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[91])(x, y);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[91])(x, y);
			#endif
		}

		public static double Copysign(double x, double y)
		{
			double ret = CopysignNative(x, y);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CopysignfNative(float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[92])(x, y);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[92])(x, y);
			#endif
		}

		public static float Copysignf(float x, float y)
		{
			float ret = CopysignfNative(x, y);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double CosNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[93])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[93])(x);
			#endif
		}

		public static double Cos(double x)
		{
			double ret = CosNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CosfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[94])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[94])(x);
			#endif
		}

		public static float Cosf(float x)
		{
			float ret = CosfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ExpNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[95])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[95])(x);
			#endif
		}

		public static double Exp(double x)
		{
			double ret = ExpNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ExpfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[96])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[96])(x);
			#endif
		}

		public static float Expf(float x)
		{
			float ret = ExpfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double FabsNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[97])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[97])(x);
			#endif
		}

		public static double Fabs(double x)
		{
			double ret = FabsNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float FabsfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[98])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[98])(x);
			#endif
		}

		public static float Fabsf(float x)
		{
			float ret = FabsfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double FloorNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[99])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[99])(x);
			#endif
		}

		public static double Floor(double x)
		{
			double ret = FloorNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float FloorfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[100])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[100])(x);
			#endif
		}

		public static float Floorf(float x)
		{
			float ret = FloorfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TruncNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[101])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[101])(x);
			#endif
		}

		public static double Trunc(double x)
		{
			double ret = TruncNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TruncfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[102])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[102])(x);
			#endif
		}

		public static float Truncf(float x)
		{
			float ret = TruncfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double FmodNative(double x, double y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[103])(x, y);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[103])(x, y);
			#endif
		}

		public static double Fmod(double x, double y)
		{
			double ret = FmodNative(x, y);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float FmodfNative(float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[104])(x, y);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[104])(x, y);
			#endif
		}

		public static float Fmodf(float x, float y)
		{
			float ret = FmodfNative(x, y);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double LogNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[105])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[105])(x);
			#endif
		}

		public static double Log(double x)
		{
			double ret = LogNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float LogfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[106])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[106])(x);
			#endif
		}

		public static float Logf(float x)
		{
			float ret = LogfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Log10Native(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[107])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[107])(x);
			#endif
		}

		public static double Log10(double x)
		{
			double ret = Log10Native(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float Log10FNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[108])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[108])(x);
			#endif
		}

		public static float Log10F(float x)
		{
			float ret = Log10FNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double PowNative(double x, double y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[109])(x, y);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[109])(x, y);
			#endif
		}

		public static double Pow(double x, double y)
		{
			double ret = PowNative(x, y);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float PowfNative(float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[110])(x, y);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[110])(x, y);
			#endif
		}

		public static float Powf(float x, float y)
		{
			float ret = PowfNative(x, y);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double RoundNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[111])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[111])(x);
			#endif
		}

		public static double Round(double x)
		{
			double ret = RoundNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float RoundfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[112])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[112])(x);
			#endif
		}

		public static float Roundf(float x)
		{
			float ret = RoundfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LroundNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[113])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[113])(x);
			#endif
		}

		public static int Lround(double x)
		{
			int ret = LroundNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LroundfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int>)funcTable[114])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<float, int>)funcTable[114])(x);
			#endif
		}

		public static int Lroundf(float x)
		{
			int ret = LroundfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ScalbnNative(double x, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[115])(x, n);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[115])(x, n);
			#endif
		}

		public static double Scalbn(double x, int n)
		{
			double ret = ScalbnNative(x, n);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ScalbnfNative(float x, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int, float>)funcTable[116])(x, n);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, int, float>)funcTable[116])(x, n);
			#endif
		}

		public static float Scalbnf(float x, int n)
		{
			float ret = ScalbnfNative(x, n);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double SinNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[117])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[117])(x);
			#endif
		}

		public static double Sin(double x)
		{
			double ret = SinNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float SinfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[118])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[118])(x);
			#endif
		}

		public static float Sinf(float x)
		{
			float ret = SinfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double SqrtNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[119])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[119])(x);
			#endif
		}

		public static double Sqrt(double x)
		{
			double ret = SqrtNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float SqrtfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[120])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[120])(x);
			#endif
		}

		public static float Sqrtf(float x)
		{
			float ret = SqrtfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TanNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[121])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[121])(x);
			#endif
		}

		public static double Tan(double x)
		{
			double ret = TanNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TanfNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[122])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[122])(x);
			#endif
		}

		public static float Tanf(float x)
		{
			float ret = TanfNative(x);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIconv IconvOpenNative(byte* tocode, byte* fromcode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLIconv>)funcTable[123])(tocode, fromcode);
			#else
			return (SDLIconv)((delegate* unmanaged[Cdecl]<nint, nint, SDLIconv>)funcTable[123])((nint)tocode, (nint)fromcode);
			#endif
		}

		public static SDLIconv IconvOpen(byte* tocode, byte* fromcode)
		{
			SDLIconv ret = IconvOpenNative(tocode, fromcode);
			return ret;
		}

		public static SDLIconv IconvOpen(ref byte tocode, byte* fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				SDLIconv ret = IconvOpenNative((byte*)ptocode, fromcode);
				return ret;
			}
		}

		public static SDLIconv IconvOpen(ReadOnlySpan<byte> tocode, byte* fromcode)
		{
			fixed (byte* ptocode = tocode)
			{
				SDLIconv ret = IconvOpenNative((byte*)ptocode, fromcode);
				return ret;
			}
		}

		public static SDLIconv IconvOpen(string tocode, byte* fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconv ret = IconvOpenNative(pStr0, fromcode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLIconv IconvOpen(byte* tocode, ref byte fromcode)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				SDLIconv ret = IconvOpenNative(tocode, (byte*)pfromcode);
				return ret;
			}
		}

		public static SDLIconv IconvOpen(byte* tocode, ReadOnlySpan<byte> fromcode)
		{
			fixed (byte* pfromcode = fromcode)
			{
				SDLIconv ret = IconvOpenNative(tocode, (byte*)pfromcode);
				return ret;
			}
		}

		public static SDLIconv IconvOpen(byte* tocode, string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconv ret = IconvOpenNative(tocode, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLIconv IconvOpen(ref byte tocode, ref byte fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					SDLIconv ret = IconvOpenNative((byte*)ptocode, (byte*)pfromcode);
					return ret;
				}
			}
		}

		public static SDLIconv IconvOpen(ReadOnlySpan<byte> tocode, ReadOnlySpan<byte> fromcode)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					SDLIconv ret = IconvOpenNative((byte*)ptocode, (byte*)pfromcode);
					return ret;
				}
			}
		}

		public static SDLIconv IconvOpen(string tocode, string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLIconv ret = IconvOpenNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IconvCloseNative(SDLIconv cd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIconv, int>)funcTable[124])(cd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLIconv, int>)funcTable[124])(cd);
			#endif
		}

		public static int IconvClose(SDLIconv cd)
		{
			int ret = IconvCloseNative(cd);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint IconvNative(SDLIconv cd, byte** inbuf, nuint* inbytesleft, byte** outbuf, nuint* outbytesleft)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIconv, byte**, nuint*, byte**, nuint*, nuint>)funcTable[125])(cd, inbuf, inbytesleft, outbuf, outbytesleft);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<SDLIconv, nint, nint, nint, nint, nuint>)funcTable[125])(cd, (nint)inbuf, (nint)inbytesleft, (nint)outbuf, (nint)outbytesleft);
			#endif
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, nuint* inbytesleft, byte** outbuf, nuint* outbytesleft)
		{
			nuint ret = IconvNative(cd, inbuf, inbytesleft, outbuf, outbytesleft);
			return ret;
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, nuint* inbytesleft, byte** outbuf, nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, ref nuint inbytesleft, byte** outbuf, nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, ref nuint inbytesleft, byte** outbuf, nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
					return ret;
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, nuint* inbytesleft, ref byte* outbuf, nuint* outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				nuint ret = IconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
				return ret;
			}
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, nuint* inbytesleft, ref byte* outbuf, nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, ref nuint inbytesleft, ref byte* outbuf, nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, ref nuint inbytesleft, ref byte* outbuf, nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
						return ret;
					}
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, nuint* inbytesleft, byte** outbuf, ref nuint outbytesleft)
		{
			fixed (nuint* poutbytesleft = &outbytesleft)
			{
				nuint ret = IconvNative(cd, inbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
				return ret;
			}
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, nuint* inbytesleft, byte** outbuf, ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, ref nuint inbytesleft, byte** outbuf, ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, ref nuint inbytesleft, byte** outbuf, ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, nuint* inbytesleft, ref byte* outbuf, ref nuint outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, nuint* inbytesleft, ref byte* outbuf, ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, byte** inbuf, ref nuint inbytesleft, ref byte* outbuf, ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		public static nuint Iconv(SDLIconv cd, ref byte* inbuf, ref nuint inbytesleft, ref byte* outbuf, ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						fixed (nuint* poutbytesleft = &outbytesleft)
						{
							nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* IconvStringNative(byte* tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, nuint, byte*>)funcTable[126])(tocode, fromcode, inbuf, inbytesleft);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint, nint>)funcTable[126])((nint)tocode, (nint)fromcode, (nint)inbuf, inbytesleft);
			#endif
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			byte* ret = IconvStringNative(tocode, fromcode, inbuf, inbytesleft);
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, inbuf, inbytesleft));
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ref byte tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				byte* ret = IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ref byte tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ReadOnlySpan<byte> tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				byte* ret = IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ReadOnlySpan<byte> tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(string tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(pStr0, fromcode, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(string tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, fromcode, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, ref byte fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				byte* ret = IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, ref byte fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, ReadOnlySpan<byte> fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				byte* ret = IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, ReadOnlySpan<byte> fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, string fromcode, byte* inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(tocode, pStr0, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, string fromcode, byte* inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, pStr0, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ref byte tocode, ref byte fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ref byte tocode, ref byte fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ReadOnlySpan<byte> tocode, ReadOnlySpan<byte> fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ReadOnlySpan<byte> tocode, ReadOnlySpan<byte> fromcode, byte* inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(string tocode, string fromcode, byte* inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(pStr0, pStr1, inbuf, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(string tocode, string fromcode, byte* inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, pStr1, inbuf, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, byte* fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				byte* ret = IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, byte* fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, byte* fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* pinbuf = inbuf)
			{
				byte* ret = IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, byte* fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* pinbuf = inbuf)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, byte* fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(tocode, fromcode, pStr0, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, byte* fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, pStr0, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ref byte tocode, byte* fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ref byte tocode, byte* fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ReadOnlySpan<byte> tocode, byte* fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					byte* ret = IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ReadOnlySpan<byte> tocode, byte* fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(string tocode, byte* fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(pStr0, fromcode, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(string tocode, byte* fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, fromcode, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, ref byte fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, ref byte fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, ReadOnlySpan<byte> fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					byte* ret = IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, ReadOnlySpan<byte> fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(byte* tocode, string fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(tocode, pStr0, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(byte* tocode, string fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, pStr0, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ref byte tocode, ref byte fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ref byte tocode, ref byte fromcode, ref byte inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(ReadOnlySpan<byte> tocode, ReadOnlySpan<byte> fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					fixed (byte* pinbuf = inbuf)
					{
						byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(ReadOnlySpan<byte> tocode, ReadOnlySpan<byte> fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					fixed (byte* pinbuf = inbuf)
					{
						string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static byte* IconvString(string tocode, string fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = IconvStringNative(pStr0, pStr1, pStr2, inbytesleft);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(string tocode, string fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, pStr1, pStr2, inbytesleft));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MainNative(int argc, byte** argv)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte**, int>)funcTable[127])(argc, argv);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[127])(argc, (nint)argv);
			#endif
		}

		public static int Main(int argc, byte** argv)
		{
			int ret = MainNative(argc, argv);
			return ret;
		}

		public static int Main(int argc, string[] argv)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = MainNative(argc, pStrArray0);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMainReadyNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[128])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[128])();
			#endif
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetMainReady()
		{
			SetMainReadyNative();
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RegisterAppNative(byte* name, uint style, void* hInst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, void*, int>)funcTable[129])(name, style, hInst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, nint, int>)funcTable[129])((nint)name, style, (nint)hInst);
			#endif
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(byte* name, uint style, void* hInst)
		{
			int ret = RegisterAppNative(name, style, hInst);
			return ret;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(ref byte name, uint style, void* hInst)
		{
			fixed (byte* pname = &name)
			{
				int ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(ReadOnlySpan<byte> name, uint style, void* hInst)
		{
			fixed (byte* pname = name)
			{
				int ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(string name, uint style, void* hInst)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = RegisterAppNative(pStr0, style, hInst);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
