// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioSpec* LoadWAVRWNative(SDLRWops* src, int freesrc, SDLAudioSpec* spec, byte** audioBuf, uint* audioLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, SDLAudioSpec*, byte**, uint*, SDLAudioSpec*>)funcTable[227])(src, freesrc, spec, audioBuf, audioLen);
			#else
			return (SDLAudioSpec*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, nint, nint>)funcTable[227])((nint)src, freesrc, (nint)spec, (nint)audioBuf, (nint)audioLen);
			#endif
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, SDLAudioSpecPtr spec, byte** audioBuf, uint* audioLen)
		{
			SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)spec, audioBuf, audioLen);
			return ret;
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpecPtr spec, byte** audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)spec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, SDLAudioSpecPtr spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpecPtr spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, SDLAudioSpecPtr spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (uint* paudioLen = &audioLen)
			{
				SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpecPtr spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, SDLAudioSpecPtr spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, SDLAudioSpecPtr spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(SDLRWopsPtr src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioSpecPtr LoadWAVRW(ref SDLRWops src, int freesrc, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							SDLAudioSpecPtr ret = LoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>
		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>
		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>
		/// this function with a NULL pointer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeWAVNative(byte* audioBuf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[228])(audioBuf);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[228])((nint)audioBuf);
			#endif
		}

		/// <summary>
		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>
		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>
		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>
		/// this function with a NULL pointer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeWAV(byte* audioBuf)
		{
			FreeWAVNative(audioBuf);
		}

		/// <summary>
		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>
		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>
		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>
		/// this function with a NULL pointer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeWAV(ref byte audioBuf)
		{
			fixed (byte* paudioBuf = &audioBuf)
			{
				FreeWAVNative((byte*)paudioBuf);
			}
		}

		/// <summary>
		/// Initialize an SDL_AudioCVT structure for conversion.<br/>
		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>
		/// be initialized with source and destination information.<br/>
		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>
		/// called before the application fills in the final buffer information.<br/>
		/// Once this function has returned successfully, and reported that a<br/>
		/// conversion is necessary, the application fills in the rest of the fields in<br/>
		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>
		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BuildAudioCVTNative(SDLAudioCVT* cvt, ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioCVT*, ushort, byte, int, ushort, byte, int, int>)funcTable[229])(cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, byte, int, ushort, byte, int, int>)funcTable[229])((nint)cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#endif
		}

		/// <summary>
		/// Initialize an SDL_AudioCVT structure for conversion.<br/>
		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>
		/// be initialized with source and destination information.<br/>
		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>
		/// called before the application fills in the final buffer information.<br/>
		/// Once this function has returned successfully, and reported that a<br/>
		/// conversion is necessary, the application fills in the rest of the fields in<br/>
		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>
		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int BuildAudioCVT(SDLAudioCVT* cvt, ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			int ret = BuildAudioCVTNative(cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			return ret;
		}

		/// <summary>
		/// Initialize an SDL_AudioCVT structure for conversion.<br/>
		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>
		/// be initialized with source and destination information.<br/>
		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>
		/// called before the application fills in the final buffer information.<br/>
		/// Once this function has returned successfully, and reported that a<br/>
		/// conversion is necessary, the application fills in the rest of the fields in<br/>
		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>
		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int BuildAudioCVT(ref SDLAudioCVT cvt, ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			fixed (SDLAudioCVT* pcvt = &cvt)
			{
				int ret = BuildAudioCVTNative((SDLAudioCVT*)pcvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
				return ret;
			}
		}

		/// <summary>
		/// Convert audio data to a desired audio format.<br/>
		/// This function does the actual audio data conversion, after the application<br/>
		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>
		/// then filled in the buffer details.<br/>
		/// Once the application has initialized the `cvt` structure using<br/>
		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>
		/// data in the source format, this function will convert the buffer, in-place,<br/>
		/// to the desired format.<br/>
		/// The data conversion may go through several passes; any given pass may<br/>
		/// possibly temporarily increase the size of the data. For example, SDL might<br/>
		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>
		/// shrinking the data size after having grown it briefly. Since the supplied<br/>
		/// buffer will be both the source and destination, converting as necessary<br/>
		/// in-place, the application must allocate a buffer that will fully contain<br/>
		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>
		/// returns, the application should set the `cvt->len` field to the size, in<br/>
		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>
		/// cvt->len_mult` bytes long for the `buf` field.<br/>
		/// The source data should be copied into this buffer before the call to<br/>
		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>
		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>
		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>
		/// this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ConvertAudioNative(SDLAudioCVT* cvt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioCVT*, int>)funcTable[230])(cvt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[230])((nint)cvt);
			#endif
		}

		/// <summary>
		/// Convert audio data to a desired audio format.<br/>
		/// This function does the actual audio data conversion, after the application<br/>
		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>
		/// then filled in the buffer details.<br/>
		/// Once the application has initialized the `cvt` structure using<br/>
		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>
		/// data in the source format, this function will convert the buffer, in-place,<br/>
		/// to the desired format.<br/>
		/// The data conversion may go through several passes; any given pass may<br/>
		/// possibly temporarily increase the size of the data. For example, SDL might<br/>
		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>
		/// shrinking the data size after having grown it briefly. Since the supplied<br/>
		/// buffer will be both the source and destination, converting as necessary<br/>
		/// in-place, the application must allocate a buffer that will fully contain<br/>
		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>
		/// returns, the application should set the `cvt->len` field to the size, in<br/>
		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>
		/// cvt->len_mult` bytes long for the `buf` field.<br/>
		/// The source data should be copied into this buffer before the call to<br/>
		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>
		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>
		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>
		/// this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ConvertAudio(SDLAudioCVT* cvt)
		{
			int ret = ConvertAudioNative(cvt);
			return ret;
		}

		/// <summary>
		/// Convert audio data to a desired audio format.<br/>
		/// This function does the actual audio data conversion, after the application<br/>
		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>
		/// then filled in the buffer details.<br/>
		/// Once the application has initialized the `cvt` structure using<br/>
		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>
		/// data in the source format, this function will convert the buffer, in-place,<br/>
		/// to the desired format.<br/>
		/// The data conversion may go through several passes; any given pass may<br/>
		/// possibly temporarily increase the size of the data. For example, SDL might<br/>
		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>
		/// shrinking the data size after having grown it briefly. Since the supplied<br/>
		/// buffer will be both the source and destination, converting as necessary<br/>
		/// in-place, the application must allocate a buffer that will fully contain<br/>
		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>
		/// returns, the application should set the `cvt->len` field to the size, in<br/>
		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>
		/// cvt->len_mult` bytes long for the `buf` field.<br/>
		/// The source data should be copied into this buffer before the call to<br/>
		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>
		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>
		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>
		/// this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ConvertAudio(ref SDLAudioCVT cvt)
		{
			fixed (SDLAudioCVT* pcvt = &cvt)
			{
				int ret = ConvertAudioNative((SDLAudioCVT*)pcvt);
				return ret;
			}
		}

		/// <summary>
		/// Create a new audio stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAudioStream* NewAudioStreamNative(ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, byte, int, ushort, byte, int, SDLAudioStream*>)funcTable[231])(srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#else
			return (SDLAudioStream*)((delegate* unmanaged[Cdecl]<ushort, byte, int, ushort, byte, int, nint>)funcTable[231])(srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			#endif
		}

		/// <summary>
		/// Create a new audio stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAudioStream* NewAudioStream(ushort srcFormat, byte srcChannels, int srcRate, ushort dstFormat, byte dstChannels, int dstRate)
		{
			SDLAudioStream* ret = NewAudioStreamNative(srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			return ret;
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamPutNative(SDLAudioStream* stream, void* buf, int len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, void*, int, int>)funcTable[232])(stream, buf, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[232])((nint)stream, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamPut(SDLAudioStream* stream, void* buf, int len)
		{
			int ret = AudioStreamPutNative(stream, buf, len);
			return ret;
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamPut(ref SDLAudioStream stream, void* buf, int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamPutNative((SDLAudioStream*)pstream, buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamPut(SDLAudioStream* stream, nint buf, int len)
		{
			int ret = AudioStreamPutNative(stream, (void*)buf, len);
			return ret;
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamPut(ref SDLAudioStream stream, nint buf, int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamPutNative((SDLAudioStream*)pstream, (void*)buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamGetNative(SDLAudioStream* stream, void* buf, int len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, void*, int, int>)funcTable[233])(stream, buf, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[233])((nint)stream, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamGet(SDLAudioStream* stream, void* buf, int len)
		{
			int ret = AudioStreamGetNative(stream, buf, len);
			return ret;
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamGet(ref SDLAudioStream stream, void* buf, int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamGetNative((SDLAudioStream*)pstream, buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamGet(SDLAudioStream* stream, nint buf, int len)
		{
			int ret = AudioStreamGetNative(stream, (void*)buf, len);
			return ret;
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamGet(ref SDLAudioStream stream, nint buf, int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamGetNative((SDLAudioStream*)pstream, (void*)buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of converted/resampled bytes available.<br/>
		/// The stream may be buffering data behind the scenes until it has enough to<br/>
		/// resample correctly, so this number might be lower than what you expect, or<br/>
		/// even be zero. Add more data or flush the stream if you need the data now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamAvailableNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, int>)funcTable[234])(stream);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[234])((nint)stream);
			#endif
		}

		/// <summary>
		/// Get the number of converted/resampled bytes available.<br/>
		/// The stream may be buffering data behind the scenes until it has enough to<br/>
		/// resample correctly, so this number might be lower than what you expect, or<br/>
		/// even be zero. Add more data or flush the stream if you need the data now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamAvailable(SDLAudioStream* stream)
		{
			int ret = AudioStreamAvailableNative(stream);
			return ret;
		}

		/// <summary>
		/// Get the number of converted/resampled bytes available.<br/>
		/// The stream may be buffering data behind the scenes until it has enough to<br/>
		/// resample correctly, so this number might be lower than what you expect, or<br/>
		/// even be zero. Add more data or flush the stream if you need the data now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamAvailable(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamAvailableNative((SDLAudioStream*)pstream);
				return ret;
			}
		}

		/// <summary>
		/// Tell the stream that you're done sending data, and anything being buffered<br/>
		/// should be converted/resampled and made available immediately.<br/>
		/// It is legal to add more data to a stream after flushing, but there will be<br/>
		/// audio gaps in the output. Generally this is intended to signal the end of<br/>
		/// input, so the complete output becomes available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AudioStreamFlushNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStream*, int>)funcTable[235])(stream);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[235])((nint)stream);
			#endif
		}

		/// <summary>
		/// Tell the stream that you're done sending data, and anything being buffered<br/>
		/// should be converted/resampled and made available immediately.<br/>
		/// It is legal to add more data to a stream after flushing, but there will be<br/>
		/// audio gaps in the output. Generally this is intended to signal the end of<br/>
		/// input, so the complete output becomes available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamFlush(SDLAudioStream* stream)
		{
			int ret = AudioStreamFlushNative(stream);
			return ret;
		}

		/// <summary>
		/// Tell the stream that you're done sending data, and anything being buffered<br/>
		/// should be converted/resampled and made available immediately.<br/>
		/// It is legal to add more data to a stream after flushing, but there will be<br/>
		/// audio gaps in the output. Generally this is intended to signal the end of<br/>
		/// input, so the complete output becomes available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AudioStreamFlush(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = AudioStreamFlushNative((SDLAudioStream*)pstream);
				return ret;
			}
		}

		/// <summary>
		/// Clear any pending data in the stream without converting it<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AudioStreamClearNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAudioStream*, void>)funcTable[236])(stream);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[236])((nint)stream);
			#endif
		}

		/// <summary>
		/// Clear any pending data in the stream without converting it<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AudioStreamClear(SDLAudioStream* stream)
		{
			AudioStreamClearNative(stream);
		}

		/// <summary>
		/// Clear any pending data in the stream without converting it<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AudioStreamClear(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				AudioStreamClearNative((SDLAudioStream*)pstream);
			}
		}

		/// <summary>
		/// Free an audio stream<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeAudioStreamNative(SDLAudioStream* stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAudioStream*, void>)funcTable[237])(stream);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[237])((nint)stream);
			#endif
		}

		/// <summary>
		/// Free an audio stream<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeAudioStream(SDLAudioStream* stream)
		{
			FreeAudioStreamNative(stream);
		}

		/// <summary>
		/// Free an audio stream<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeAudioStream(ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				FreeAudioStreamNative((SDLAudioStream*)pstream);
			}
		}

		/// <summary>
		/// This function is a legacy means of mixing audio.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>
		/// ```<br/>
		/// ...where `format` is the obtained format of the audio device from the<br/>
		/// legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MixAudioNative(byte* dst, byte* src, uint len, int volume)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, uint, int, void>)funcTable[238])(dst, src, len, volume);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, int, void>)funcTable[238])((nint)dst, (nint)src, len, volume);
			#endif
		}

		/// <summary>
		/// This function is a legacy means of mixing audio.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>
		/// ```<br/>
		/// ...where `format` is the obtained format of the audio device from the<br/>
		/// legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudio(byte* dst, byte* src, uint len, int volume)
		{
			MixAudioNative(dst, src, len, volume);
		}

		/// <summary>
		/// This function is a legacy means of mixing audio.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>
		/// ```<br/>
		/// ...where `format` is the obtained format of the audio device from the<br/>
		/// legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudio(ref byte dst, byte* src, uint len, int volume)
		{
			fixed (byte* pdst = &dst)
			{
				MixAudioNative((byte*)pdst, src, len, volume);
			}
		}

		/// <summary>
		/// This function is a legacy means of mixing audio.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>
		/// ```<br/>
		/// ...where `format` is the obtained format of the audio device from the<br/>
		/// legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudio(byte* dst, in byte src, uint len, int volume)
		{
			fixed (byte* psrc = &src)
			{
				MixAudioNative(dst, (byte*)psrc, len, volume);
			}
		}

		/// <summary>
		/// This function is a legacy means of mixing audio.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>
		/// ```<br/>
		/// ...where `format` is the obtained format of the audio device from the<br/>
		/// legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudio(ref byte dst, in byte src, uint len, int volume)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					MixAudioNative((byte*)pdst, (byte*)psrc, len, volume);
				}
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>
		/// audio stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MixAudioFormatNative(byte* dst, byte* src, ushort format, uint len, int volume)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, ushort, uint, int, void>)funcTable[239])(dst, src, format, len, volume);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, ushort, uint, int, void>)funcTable[239])((nint)dst, (nint)src, format, len, volume);
			#endif
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>
		/// audio stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudioFormat(byte* dst, byte* src, ushort format, uint len, int volume)
		{
			MixAudioFormatNative(dst, src, format, len, volume);
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>
		/// audio stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudioFormat(ref byte dst, byte* src, ushort format, uint len, int volume)
		{
			fixed (byte* pdst = &dst)
			{
				MixAudioFormatNative((byte*)pdst, src, format, len, volume);
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>
		/// audio stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudioFormat(byte* dst, in byte src, ushort format, uint len, int volume)
		{
			fixed (byte* psrc = &src)
			{
				MixAudioFormatNative(dst, (byte*)psrc, format, len, volume);
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>
		/// audio stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MixAudioFormat(ref byte dst, in byte src, ushort format, uint len, int volume)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					MixAudioFormatNative((byte*)pdst, (byte*)psrc, format, len, volume);
				}
			}
		}

		/// <summary>
		/// Queue more audio on non-callback devices.<br/>
		/// If you are looking to retrieve queued audio from a non-callback capture<br/>
		/// device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return<br/>
		/// -1 to signify an error if you use it with capture devices.<br/>
		/// SDL offers two ways to feed audio to the device: you can either supply a<br/>
		/// callback that SDL triggers with some frequency to obtain more audio (pull<br/>
		/// method), or you can supply no callback, and then SDL will expect you to<br/>
		/// supply data at regular intervals (push method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Queued data will drain to the device as<br/>
		/// necessary without further intervention from you. If the device needs audio<br/>
		/// but there is not enough queued, it will play silence to make up the<br/>
		/// difference. This means you will have skips in your audio playback if you<br/>
		/// aren't routinely queueing sufficient data.<br/>
		/// This function copies the supplied data, so you are safe to free it when the<br/>
		/// function returns. This function is thread-safe, but queueing to the same<br/>
		/// device from two threads at once does not promise which buffer will be<br/>
		/// queued first.<br/>
		/// You may not queue audio on a device that is using an application-supplied<br/>
		/// callback; doing so returns an error. You have to use the audio callback or<br/>
		/// queue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before queueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// Note that SDL2 does not support planar audio. You will need to resample<br/>
		/// from planar audio formats into a non-planar one (see SDL_AudioFormat)<br/>
		/// before queuing audio.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int QueueAudioNative(uint dev, void* data, uint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*, uint, int>)funcTable[240])(dev, data, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, uint, int>)funcTable[240])(dev, (nint)data, len);
			#endif
		}

		/// <summary>
		/// Queue more audio on non-callback devices.<br/>
		/// If you are looking to retrieve queued audio from a non-callback capture<br/>
		/// device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return<br/>
		/// -1 to signify an error if you use it with capture devices.<br/>
		/// SDL offers two ways to feed audio to the device: you can either supply a<br/>
		/// callback that SDL triggers with some frequency to obtain more audio (pull<br/>
		/// method), or you can supply no callback, and then SDL will expect you to<br/>
		/// supply data at regular intervals (push method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Queued data will drain to the device as<br/>
		/// necessary without further intervention from you. If the device needs audio<br/>
		/// but there is not enough queued, it will play silence to make up the<br/>
		/// difference. This means you will have skips in your audio playback if you<br/>
		/// aren't routinely queueing sufficient data.<br/>
		/// This function copies the supplied data, so you are safe to free it when the<br/>
		/// function returns. This function is thread-safe, but queueing to the same<br/>
		/// device from two threads at once does not promise which buffer will be<br/>
		/// queued first.<br/>
		/// You may not queue audio on a device that is using an application-supplied<br/>
		/// callback; doing so returns an error. You have to use the audio callback or<br/>
		/// queue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before queueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// Note that SDL2 does not support planar audio. You will need to resample<br/>
		/// from planar audio formats into a non-planar one (see SDL_AudioFormat)<br/>
		/// before queuing audio.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueueAudio(uint dev, void* data, uint len)
		{
			int ret = QueueAudioNative(dev, data, len);
			return ret;
		}

		/// <summary>
		/// Queue more audio on non-callback devices.<br/>
		/// If you are looking to retrieve queued audio from a non-callback capture<br/>
		/// device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return<br/>
		/// -1 to signify an error if you use it with capture devices.<br/>
		/// SDL offers two ways to feed audio to the device: you can either supply a<br/>
		/// callback that SDL triggers with some frequency to obtain more audio (pull<br/>
		/// method), or you can supply no callback, and then SDL will expect you to<br/>
		/// supply data at regular intervals (push method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Queued data will drain to the device as<br/>
		/// necessary without further intervention from you. If the device needs audio<br/>
		/// but there is not enough queued, it will play silence to make up the<br/>
		/// difference. This means you will have skips in your audio playback if you<br/>
		/// aren't routinely queueing sufficient data.<br/>
		/// This function copies the supplied data, so you are safe to free it when the<br/>
		/// function returns. This function is thread-safe, but queueing to the same<br/>
		/// device from two threads at once does not promise which buffer will be<br/>
		/// queued first.<br/>
		/// You may not queue audio on a device that is using an application-supplied<br/>
		/// callback; doing so returns an error. You have to use the audio callback or<br/>
		/// queue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before queueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// Note that SDL2 does not support planar audio. You will need to resample<br/>
		/// from planar audio formats into a non-planar one (see SDL_AudioFormat)<br/>
		/// before queuing audio.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueueAudio(uint dev, nint data, uint len)
		{
			int ret = QueueAudioNative(dev, (void*)data, len);
			return ret;
		}

		/// <summary>
		/// Dequeue more audio on non-callback devices.<br/>
		/// If you are looking to queue audio for output on a non-callback playback<br/>
		/// device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always<br/>
		/// return 0 if you use it with playback devices.<br/>
		/// SDL offers two ways to retrieve audio from a capture device: you can either<br/>
		/// supply a callback that SDL triggers with some frequency as the device<br/>
		/// records more audio data, (push method), or you can supply no callback, and<br/>
		/// then SDL will expect you to retrieve data at regular intervals (pull<br/>
		/// method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Data from the device will keep queuing as<br/>
		/// necessary without further intervention from you. This means you will<br/>
		/// eventually run out of memory if you aren't routinely dequeueing data.<br/>
		/// Capture devices will not queue data when paused; if you are expecting to<br/>
		/// not need captured audio for some length of time, use SDL_PauseAudioDevice()<br/>
		/// to stop the capture device from queueing more data. This can be useful<br/>
		/// during, say, level loading times. When unpaused, capture devices will start<br/>
		/// queueing data from that point, having flushed any capturable data available<br/>
		/// while paused.<br/>
		/// This function is thread-safe, but dequeueing from the same device from two<br/>
		/// threads at once does not promise which thread will dequeue data first.<br/>
		/// You may not dequeue audio from a device that is using an<br/>
		/// application-supplied callback; doing so returns an error. You have to use<br/>
		/// the audio callback, or dequeue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before dequeueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint DequeueAudioNative(uint dev, void* data, uint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*, uint, uint>)funcTable[241])(dev, data, len);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint, uint>)funcTable[241])(dev, (nint)data, len);
			#endif
		}

		/// <summary>
		/// Dequeue more audio on non-callback devices.<br/>
		/// If you are looking to queue audio for output on a non-callback playback<br/>
		/// device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always<br/>
		/// return 0 if you use it with playback devices.<br/>
		/// SDL offers two ways to retrieve audio from a capture device: you can either<br/>
		/// supply a callback that SDL triggers with some frequency as the device<br/>
		/// records more audio data, (push method), or you can supply no callback, and<br/>
		/// then SDL will expect you to retrieve data at regular intervals (pull<br/>
		/// method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Data from the device will keep queuing as<br/>
		/// necessary without further intervention from you. This means you will<br/>
		/// eventually run out of memory if you aren't routinely dequeueing data.<br/>
		/// Capture devices will not queue data when paused; if you are expecting to<br/>
		/// not need captured audio for some length of time, use SDL_PauseAudioDevice()<br/>
		/// to stop the capture device from queueing more data. This can be useful<br/>
		/// during, say, level loading times. When unpaused, capture devices will start<br/>
		/// queueing data from that point, having flushed any capturable data available<br/>
		/// while paused.<br/>
		/// This function is thread-safe, but dequeueing from the same device from two<br/>
		/// threads at once does not promise which thread will dequeue data first.<br/>
		/// You may not dequeue audio from a device that is using an<br/>
		/// application-supplied callback; doing so returns an error. You have to use<br/>
		/// the audio callback, or dequeue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before dequeueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint DequeueAudio(uint dev, void* data, uint len)
		{
			uint ret = DequeueAudioNative(dev, data, len);
			return ret;
		}

		/// <summary>
		/// Dequeue more audio on non-callback devices.<br/>
		/// If you are looking to queue audio for output on a non-callback playback<br/>
		/// device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always<br/>
		/// return 0 if you use it with playback devices.<br/>
		/// SDL offers two ways to retrieve audio from a capture device: you can either<br/>
		/// supply a callback that SDL triggers with some frequency as the device<br/>
		/// records more audio data, (push method), or you can supply no callback, and<br/>
		/// then SDL will expect you to retrieve data at regular intervals (pull<br/>
		/// method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Data from the device will keep queuing as<br/>
		/// necessary without further intervention from you. This means you will<br/>
		/// eventually run out of memory if you aren't routinely dequeueing data.<br/>
		/// Capture devices will not queue data when paused; if you are expecting to<br/>
		/// not need captured audio for some length of time, use SDL_PauseAudioDevice()<br/>
		/// to stop the capture device from queueing more data. This can be useful<br/>
		/// during, say, level loading times. When unpaused, capture devices will start<br/>
		/// queueing data from that point, having flushed any capturable data available<br/>
		/// while paused.<br/>
		/// This function is thread-safe, but dequeueing from the same device from two<br/>
		/// threads at once does not promise which thread will dequeue data first.<br/>
		/// You may not dequeue audio from a device that is using an<br/>
		/// application-supplied callback; doing so returns an error. You have to use<br/>
		/// the audio callback, or dequeue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before dequeueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint DequeueAudio(uint dev, nint data, uint len)
		{
			uint ret = DequeueAudioNative(dev, (void*)data, len);
			return ret;
		}

		/// <summary>
		/// Get the number of bytes of still-queued audio.<br/>
		/// For playback devices: this is the number of bytes that have been queued for<br/>
		/// playback with SDL_QueueAudio(), but have not yet been sent to the hardware.<br/>
		/// Once we've sent it to the hardware, this function can not decide the exact<br/>
		/// byte boundary of what has been played. It's possible that we just gave the<br/>
		/// hardware several kilobytes right before you called this function, but it<br/>
		/// hasn't played any of it yet, or maybe half of it, etc.<br/>
		/// For capture devices, this is the number of bytes that have been captured by<br/>
		/// the device and are waiting for you to dequeue. This number may grow at any<br/>
		/// time, so this only informs of the lower-bound of available data.<br/>
		/// You may not queue or dequeue audio on a device that is using an<br/>
		/// application-supplied callback; calling this function on such a device<br/>
		/// always returns 0. You have to use the audio callback or queue audio, but<br/>
		/// not both.<br/>
		/// You should not call SDL_LockAudio() on the device before querying; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetQueuedAudioSizeNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[242])(dev);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[242])(dev);
			#endif
		}

		/// <summary>
		/// Get the number of bytes of still-queued audio.<br/>
		/// For playback devices: this is the number of bytes that have been queued for<br/>
		/// playback with SDL_QueueAudio(), but have not yet been sent to the hardware.<br/>
		/// Once we've sent it to the hardware, this function can not decide the exact<br/>
		/// byte boundary of what has been played. It's possible that we just gave the<br/>
		/// hardware several kilobytes right before you called this function, but it<br/>
		/// hasn't played any of it yet, or maybe half of it, etc.<br/>
		/// For capture devices, this is the number of bytes that have been captured by<br/>
		/// the device and are waiting for you to dequeue. This number may grow at any<br/>
		/// time, so this only informs of the lower-bound of available data.<br/>
		/// You may not queue or dequeue audio on a device that is using an<br/>
		/// application-supplied callback; calling this function on such a device<br/>
		/// always returns 0. You have to use the audio callback or queue audio, but<br/>
		/// not both.<br/>
		/// You should not call SDL_LockAudio() on the device before querying; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetQueuedAudioSize(uint dev)
		{
			uint ret = GetQueuedAudioSizeNative(dev);
			return ret;
		}

		/// <summary>
		/// Drop any queued audio data waiting to be sent to the hardware.<br/>
		/// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For<br/>
		/// output devices, the hardware will start playing silence if more audio isn't<br/>
		/// queued. For capture devices, the hardware will start filling the empty<br/>
		/// queue with new data if the capture device isn't paused.<br/>
		/// This will not prevent playback of queued audio that's already been sent to<br/>
		/// the hardware, as we can not undo that, so expect there to be some fraction<br/>
		/// of a second of audio that might still be heard. This can be useful if you<br/>
		/// want to, say, drop any pending music or any unprocessed microphone input<br/>
		/// during a level change in your game.<br/>
		/// You may not queue or dequeue audio on a device that is using an<br/>
		/// application-supplied callback; calling this function on such a device<br/>
		/// always returns 0. You have to use the audio callback or queue audio, but<br/>
		/// not both.<br/>
		/// You should not call SDL_LockAudio() on the device before clearing the<br/>
		/// queue; SDL handles locking internally for this function.<br/>
		/// This function always succeeds and thus returns void.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearQueuedAudioNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[243])(dev);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[243])(dev);
			#endif
		}

		/// <summary>
		/// Drop any queued audio data waiting to be sent to the hardware.<br/>
		/// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For<br/>
		/// output devices, the hardware will start playing silence if more audio isn't<br/>
		/// queued. For capture devices, the hardware will start filling the empty<br/>
		/// queue with new data if the capture device isn't paused.<br/>
		/// This will not prevent playback of queued audio that's already been sent to<br/>
		/// the hardware, as we can not undo that, so expect there to be some fraction<br/>
		/// of a second of audio that might still be heard. This can be useful if you<br/>
		/// want to, say, drop any pending music or any unprocessed microphone input<br/>
		/// during a level change in your game.<br/>
		/// You may not queue or dequeue audio on a device that is using an<br/>
		/// application-supplied callback; calling this function on such a device<br/>
		/// always returns 0. You have to use the audio callback or queue audio, but<br/>
		/// not both.<br/>
		/// You should not call SDL_LockAudio() on the device before clearing the<br/>
		/// queue; SDL handles locking internally for this function.<br/>
		/// This function always succeeds and thus returns void.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ClearQueuedAudio(uint dev)
		{
			ClearQueuedAudioNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of locking the audio device.<br/>
		/// New programs might want to use SDL_LockAudioDevice() instead. This function<br/>
		/// is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_LockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockAudioNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[244])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[244])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of locking the audio device.<br/>
		/// New programs might want to use SDL_LockAudioDevice() instead. This function<br/>
		/// is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_LockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockAudio()
		{
			LockAudioNative();
		}

		/// <summary>
		/// Use this function to lock out the audio callback function for a specified<br/>
		/// device.<br/>
		/// The lock manipulated by these functions protects the audio callback<br/>
		/// function specified in SDL_OpenAudioDevice(). During a<br/>
		/// SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed<br/>
		/// that the callback function for that device is not running, even if the<br/>
		/// device is not paused. While a device is locked, any other unpaused,<br/>
		/// unlocked devices may still run their callbacks.<br/>
		/// Calling this function from inside your audio callback is unnecessary. SDL<br/>
		/// obtains this lock before calling your function, and releases it when the<br/>
		/// function returns.<br/>
		/// You should not hold the lock longer than absolutely necessary. If you hold<br/>
		/// it too long, you'll experience dropouts in your audio playback. Ideally,<br/>
		/// your application locks the device, sets a few variables and unlocks again.<br/>
		/// Do not do heavy work while holding the lock for a device.<br/>
		/// It is safe to lock the audio device multiple times, as long as you unlock<br/>
		/// it an equivalent number of times. The callback will not run until the<br/>
		/// device has been unlocked completely in this way. If your application fails<br/>
		/// to unlock the device appropriately, your callback will never run, you might<br/>
		/// hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably<br/>
		/// deadlock.<br/>
		/// Internally, the audio device lock is a mutex; if you lock from two threads<br/>
		/// at once, not only will you block the audio callback, you'll block the other<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockAudioDeviceNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[245])(dev);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[245])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to lock out the audio callback function for a specified<br/>
		/// device.<br/>
		/// The lock manipulated by these functions protects the audio callback<br/>
		/// function specified in SDL_OpenAudioDevice(). During a<br/>
		/// SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed<br/>
		/// that the callback function for that device is not running, even if the<br/>
		/// device is not paused. While a device is locked, any other unpaused,<br/>
		/// unlocked devices may still run their callbacks.<br/>
		/// Calling this function from inside your audio callback is unnecessary. SDL<br/>
		/// obtains this lock before calling your function, and releases it when the<br/>
		/// function returns.<br/>
		/// You should not hold the lock longer than absolutely necessary. If you hold<br/>
		/// it too long, you'll experience dropouts in your audio playback. Ideally,<br/>
		/// your application locks the device, sets a few variables and unlocks again.<br/>
		/// Do not do heavy work while holding the lock for a device.<br/>
		/// It is safe to lock the audio device multiple times, as long as you unlock<br/>
		/// it an equivalent number of times. The callback will not run until the<br/>
		/// device has been unlocked completely in this way. If your application fails<br/>
		/// to unlock the device appropriately, your callback will never run, you might<br/>
		/// hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably<br/>
		/// deadlock.<br/>
		/// Internally, the audio device lock is a mutex; if you lock from two threads<br/>
		/// at once, not only will you block the audio callback, you'll block the other<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockAudioDevice(uint dev)
		{
			LockAudioDeviceNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of unlocking the audio device.<br/>
		/// New programs might want to use SDL_UnlockAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_UnlockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockAudioNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[246])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[246])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of unlocking the audio device.<br/>
		/// New programs might want to use SDL_UnlockAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_UnlockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockAudio()
		{
			UnlockAudioNative();
		}

		/// <summary>
		/// Use this function to unlock the audio callback function for a specified<br/>
		/// device.<br/>
		/// This function should be paired with a previous SDL_LockAudioDevice() call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockAudioDeviceNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[247])(dev);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[247])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to unlock the audio callback function for a specified<br/>
		/// device.<br/>
		/// This function should be paired with a previous SDL_LockAudioDevice() call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockAudioDevice(uint dev)
		{
			UnlockAudioDeviceNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of closing the audio device.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_CloseAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseAudioNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[248])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[248])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of closing the audio device.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_CloseAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseAudio()
		{
			CloseAudioNative();
		}

		/// <summary>
		/// Use this function to shut down audio processing and close the audio device.<br/>
		/// The application should close open audio devices once they are no longer<br/>
		/// needed. Calling this function will wait until the device's audio callback<br/>
		/// is not running, release the audio hardware and then clean up internal<br/>
		/// state. No further audio will play from this device once this function<br/>
		/// returns.<br/>
		/// This function may block briefly while pending audio data is played by the<br/>
		/// hardware, so that applications don't drop the last buffer of data they<br/>
		/// supplied.<br/>
		/// The device ID is invalid as soon as the device is closed, and is eligible<br/>
		/// for reuse in a new SDL_OpenAudioDevice() call immediately.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseAudioDeviceNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[249])(dev);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[249])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to shut down audio processing and close the audio device.<br/>
		/// The application should close open audio devices once they are no longer<br/>
		/// needed. Calling this function will wait until the device's audio callback<br/>
		/// is not running, release the audio hardware and then clean up internal<br/>
		/// state. No further audio will play from this device once this function<br/>
		/// returns.<br/>
		/// This function may block briefly while pending audio data is played by the<br/>
		/// hardware, so that applications don't drop the last buffer of data they<br/>
		/// supplied.<br/>
		/// The device ID is invalid as soon as the device is closed, and is eligible<br/>
		/// for reuse in a new SDL_OpenAudioDevice() call immediately.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseAudioDevice(uint dev)
		{
			CloseAudioDeviceNative(dev);
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetClipboardTextNative(byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[250])(text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[250])((nint)text);
			#endif
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(byte* text)
		{
			int ret = SetClipboardTextNative(text);
			return ret;
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(in byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SetClipboardTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = SetClipboardTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetClipboardTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[251])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[251])();
			#endif
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the clipboard exists and contains a non-empty text string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[252])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[252])();
			#endif
		}

		/// <summary>
		/// Query whether the clipboard exists and contains a non-empty text string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasClipboardText()
		{
			SDLBool ret = HasClipboardTextNative();
			return ret;
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPrimarySelectionTextNative(byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[253])(text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[253])((nint)text);
			#endif
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(byte* text)
		{
			int ret = SetPrimarySelectionTextNative(text);
			return ret;
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(in byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SetPrimarySelectionTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = SetPrimarySelectionTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetPrimarySelectionTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection, which must be freed with<br/>
		/// SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPrimarySelectionTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[254])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[254])();
			#endif
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection, which must be freed with<br/>
		/// SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetPrimarySelectionText()
		{
			byte* ret = GetPrimarySelectionTextNative();
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection, which must be freed with<br/>
		/// SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetPrimarySelectionTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetPrimarySelectionTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the primary selection exists and contains a non-empty text<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasPrimarySelectionTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[255])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[255])();
			#endif
		}

		/// <summary>
		/// Query whether the primary selection exists and contains a non-empty text<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasPrimarySelectionText()
		{
			SDLBool ret = HasPrimarySelectionTextNative();
			return ret;
		}

		/// <summary>
		/// Get the number of CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCPUCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[256])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[256])();
			#endif
		}

		/// <summary>
		/// Get the number of CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetCPUCount()
		{
			int ret = GetCPUCountNative();
			return ret;
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCPUCacheLineSizeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[257])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[257])();
			#endif
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetCPUCacheLineSize()
		{
			int ret = GetCPUCacheLineSizeNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has the RDTSC instruction.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasRDTSCNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[258])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[258])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has the RDTSC instruction.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasRDTSC()
		{
			SDLBool ret = HasRDTSCNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAltiVecNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[259])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[259])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAltiVec()
		{
			SDLBool ret = HasAltiVecNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasMMXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[260])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[260])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasMMX()
		{
			SDLBool ret = HasMMXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has 3DNow! features.<br/>
		/// This always returns false on CPUs that aren't using AMD instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool Has3DNowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[261])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[261])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has 3DNow! features.<br/>
		/// This always returns false on CPUs that aren't using AMD instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool Has3DNow()
		{
			SDLBool ret = Has3DNowNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSENative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[262])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[262])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE()
		{
			SDLBool ret = HasSSENative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[263])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[263])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE2()
		{
			SDLBool ret = HasSSE2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE3Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[264])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[264])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE3()
		{
			SDLBool ret = HasSSE3Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE41Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[265])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[265])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE41()
		{
			SDLBool ret = HasSSE41Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE42Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[266])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[266])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE42()
		{
			SDLBool ret = HasSSE42Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAVXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[267])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[267])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAVX()
		{
			SDLBool ret = HasAVXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAVX2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[268])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[268])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAVX2()
		{
			SDLBool ret = HasAVX2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAVX512FNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[269])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[269])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAVX512F()
		{
			SDLBool ret = HasAVX512FNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
		/// This is different from ARM NEON, which is a different instruction set.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasARMSIMDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[270])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[270])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
		/// This is different from ARM NEON, which is a different instruction set.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasARMSIMD()
		{
			SDLBool ret = HasARMSIMDNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasNEONNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[271])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[271])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasNEON()
		{
			SDLBool ret = HasNEONNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasLSXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[272])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[272])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasLSX()
		{
			SDLBool ret = HasLSXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasLASXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[273])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[273])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasLASX()
		{
			SDLBool ret = HasLASXNative();
			return ret;
		}

		/// <summary>
		/// Get the amount of RAM configured in the system.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSystemRAMNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[274])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[274])();
			#endif
		}

		/// <summary>
		/// Get the amount of RAM configured in the system.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetSystemRAM()
		{
			int ret = GetSystemRAMNative();
			return ret;
		}

		/// <summary>
		/// Report the alignment this system needs for SIMD allocations.<br/>
		/// This will return the minimum number of bytes to which a pointer must be<br/>
		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
		/// example, if the machine supports SSE only, it will return 16, but if it<br/>
		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
		/// Plan accordingly.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint SIMDGetAlignmentNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint>)funcTable[275])();
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nuint>)funcTable[275])();
			#endif
		}

		/// <summary>
		/// Report the alignment this system needs for SIMD allocations.<br/>
		/// This will return the minimum number of bytes to which a pointer must be<br/>
		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
		/// example, if the machine supports SSE only, it will return 16, but if it<br/>
		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
		/// Plan accordingly.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint SIMDGetAlignment()
		{
			nuint ret = SIMDGetAlignmentNative();
			return ret;
		}

		/// <summary>
		/// Allocate memory in a SIMD-friendly way.<br/>
		/// This will allocate a block of memory that is suitable for use with SIMD<br/>
		/// instructions. Specifically, it will be properly aligned and padded for the<br/>
		/// system's supported vector instructions.<br/>
		/// The memory returned will be padded such that it is safe to read or write an<br/>
		/// incomplete vector at the end of the memory block. This can be useful so you<br/>
		/// don't have to drop back to a scalar fallback at the end of your SIMD<br/>
		/// processing loop to deal with the final elements without overflowing the<br/>
		/// allocated buffer.<br/>
		/// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or<br/>
		/// delete[], etc.<br/>
		/// Note that SDL will only deal with SIMD instruction sets it is aware of; for<br/>
		/// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and<br/>
		/// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants<br/>
		/// 64. To be clear: if you can't decide to use an instruction set with an<br/>
		/// SDL_Has*() function, don't use that instruction set with memory allocated<br/>
		/// through here.<br/>
		/// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't<br/>
		/// out of memory, but you are not allowed to dereference it (because you only<br/>
		/// own zero bytes of that buffer).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SIMDAllocNative(nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, void*>)funcTable[276])(len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nint>)funcTable[276])(len);
			#endif
		}

		/// <summary>
		/// Allocate memory in a SIMD-friendly way.<br/>
		/// This will allocate a block of memory that is suitable for use with SIMD<br/>
		/// instructions. Specifically, it will be properly aligned and padded for the<br/>
		/// system's supported vector instructions.<br/>
		/// The memory returned will be padded such that it is safe to read or write an<br/>
		/// incomplete vector at the end of the memory block. This can be useful so you<br/>
		/// don't have to drop back to a scalar fallback at the end of your SIMD<br/>
		/// processing loop to deal with the final elements without overflowing the<br/>
		/// allocated buffer.<br/>
		/// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or<br/>
		/// delete[], etc.<br/>
		/// Note that SDL will only deal with SIMD instruction sets it is aware of; for<br/>
		/// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and<br/>
		/// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants<br/>
		/// 64. To be clear: if you can't decide to use an instruction set with an<br/>
		/// SDL_Has*() function, don't use that instruction set with memory allocated<br/>
		/// through here.<br/>
		/// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't<br/>
		/// out of memory, but you are not allowed to dereference it (because you only<br/>
		/// own zero bytes of that buffer).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SIMDAlloc(nuint len)
		{
			void* ret = SIMDAllocNative(len);
			return ret;
		}

		/// <summary>
		/// Reallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,<br/>
		/// SDL_malloc, memalign, new[], etc.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SIMDReallocNative(void* mem, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, void*>)funcTable[277])(mem, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[277])((nint)mem, len);
			#endif
		}

		/// <summary>
		/// Reallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,<br/>
		/// SDL_malloc, memalign, new[], etc.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SIMDRealloc(void* mem, nuint len)
		{
			void* ret = SIMDReallocNative(mem, len);
			return ret;
		}

		/// <summary>
		/// Reallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,<br/>
		/// SDL_malloc, memalign, new[], etc.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SIMDRealloc(nint mem, nuint len)
		{
			void* ret = SIMDReallocNative((void*)mem, len);
			return ret;
		}

		/// <summary>
		/// Deallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from<br/>
		/// malloc, realloc, SDL_malloc, memalign, new[], etc.<br/>
		/// However, SDL_SIMDFree(NULL) is a legal no-op.<br/>
		/// The memory pointed to by `ptr` is no longer valid for access upon return,<br/>
		/// and may be returned to the system or reused by a future allocation. The<br/>
		/// pointer passed to this function is no longer safe to dereference once this<br/>
		/// function returns, and should be discarded.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SIMDFreeNative(void* ptr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[278])(ptr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[278])((nint)ptr);
			#endif
		}

		/// <summary>
		/// Deallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from<br/>
		/// malloc, realloc, SDL_malloc, memalign, new[], etc.<br/>
		/// However, SDL_SIMDFree(NULL) is a legal no-op.<br/>
		/// The memory pointed to by `ptr` is no longer valid for access upon return,<br/>
		/// and may be returned to the system or reused by a future allocation. The<br/>
		/// pointer passed to this function is no longer safe to dereference once this<br/>
		/// function returns, and should be discarded.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SIMDFree(void* ptr)
		{
			SIMDFreeNative(ptr);
		}

		/// <summary>
		/// Deallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from<br/>
		/// malloc, realloc, SDL_malloc, memalign, new[], etc.<br/>
		/// However, SDL_SIMDFree(NULL) is a legal no-op.<br/>
		/// The memory pointed to by `ptr` is no longer valid for access upon return,<br/>
		/// and may be returned to the system or reused by a future allocation. The<br/>
		/// pointer passed to this function is no longer safe to dereference once this<br/>
		/// function returns, and should be discarded.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SIMDFree(nint ptr)
		{
			SIMDFreeNative((void*)ptr);
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPixelFormatNameNative(uint format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[279])(format);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[279])(format);
			#endif
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetPixelFormatName(uint format)
		{
			byte* ret = GetPixelFormatNameNative(format);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetPixelFormatNameS(uint format)
		{
			string ret = Utils.DecodeStringUTF8(GetPixelFormatNameNative(format));
			return ret;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool PixelFormatEnumToMasksNative(uint format, int* bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int*, uint*, uint*, uint*, uint*, SDLBool>)funcTable[280])(format, bpp, rmask, gmask, bmask, amask);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, nint, SDLBool>)funcTable[280])(format, (nint)bpp, (nint)rmask, (nint)gmask, (nint)bmask, (nint)amask);
			#endif
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, (uint*)pbmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* pamask = &amask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, bmask, (uint*)pamask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							fixed (uint* pamask = &amask)
							{
								SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MasksToPixelFormatEnumNative(int bpp, uint rmask, uint gmask, uint bmask, uint amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, uint>)funcTable[281])(bpp, rmask, gmask, bmask, amask);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, uint>)funcTable[281])(bpp, rmask, gmask, bmask, amask);
			#endif
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MasksToPixelFormatEnum(int bpp, uint rmask, uint gmask, uint bmask, uint amask)
		{
			uint ret = MasksToPixelFormatEnumNative(bpp, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Create an SDL_PixelFormat structure corresponding to a pixel format.<br/>
		/// Returned structure may come from a shared global cache (i.e. not newly<br/>
		/// allocated), and hence should not be modified, especially the palette. Weird<br/>
		/// errors such as `Blit combination not supported` may occur.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPixelFormat* AllocFormatNative(uint pixelFormat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLPixelFormat*>)funcTable[282])(pixelFormat);
			#else
			return (SDLPixelFormat*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[282])(pixelFormat);
			#endif
		}

		/// <summary>
		/// Create an SDL_PixelFormat structure corresponding to a pixel format.<br/>
		/// Returned structure may come from a shared global cache (i.e. not newly<br/>
		/// allocated), and hence should not be modified, especially the palette. Weird<br/>
		/// errors such as `Blit combination not supported` may occur.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPixelFormatPtr AllocFormat(uint pixelFormat)
		{
			SDLPixelFormatPtr ret = AllocFormatNative(pixelFormat);
			return ret;
		}

		/// <summary>
		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeFormatNative(SDLPixelFormat* format)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLPixelFormat*, void>)funcTable[283])(format);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[283])((nint)format);
			#endif
		}

		/// <summary>
		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeFormat(SDLPixelFormatPtr format)
		{
			FreeFormatNative((SDLPixelFormat*)format);
		}

		/// <summary>
		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeFormat(ref SDLPixelFormat format)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				FreeFormatNative((SDLPixelFormat*)pformat);
			}
		}

		/// <summary>
		/// Create a palette structure with the specified number of color entries.<br/>
		/// The palette entries are initialized to white.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPalette* AllocPaletteNative(int ncolors)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLPalette*>)funcTable[284])(ncolors);
			#else
			return (SDLPalette*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[284])(ncolors);
			#endif
		}

		/// <summary>
		/// Create a palette structure with the specified number of color entries.<br/>
		/// The palette entries are initialized to white.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPalettePtr AllocPalette(int ncolors)
		{
			SDLPalettePtr ret = AllocPaletteNative(ncolors);
			return ret;
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPixelFormatPaletteNative(SDLPixelFormat* format, SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat*, SDLPalette*, int>)funcTable[285])(format, palette);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[285])((nint)format, (nint)palette);
			#endif
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(SDLPixelFormatPtr format, SDLPalettePtr palette)
		{
			int ret = SetPixelFormatPaletteNative((SDLPixelFormat*)format, (SDLPalette*)palette);
			return ret;
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(ref SDLPixelFormat format, SDLPalettePtr palette)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				int ret = SetPixelFormatPaletteNative((SDLPixelFormat*)pformat, (SDLPalette*)palette);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(SDLPixelFormatPtr format, ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SetPixelFormatPaletteNative((SDLPixelFormat*)format, (SDLPalette*)ppalette);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(ref SDLPixelFormat format, ref SDLPalette palette)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					int ret = SetPixelFormatPaletteNative((SDLPixelFormat*)pformat, (SDLPalette*)ppalette);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPaletteColorsNative(SDLPalette* palette, SDLColor* colors, int firstcolor, int ncolors)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPalette*, SDLColor*, int, int, int>)funcTable[286])(palette, colors, firstcolor, ncolors);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int>)funcTable[286])((nint)palette, (nint)colors, firstcolor, ncolors);
			#endif
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(SDLPalettePtr palette, SDLColorPtr colors, int firstcolor, int ncolors)
		{
			int ret = SetPaletteColorsNative((SDLPalette*)palette, (SDLColor*)colors, firstcolor, ncolors);
			return ret;
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(ref SDLPalette palette, SDLColorPtr colors, int firstcolor, int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SetPaletteColorsNative((SDLPalette*)ppalette, (SDLColor*)colors, firstcolor, ncolors);
				return ret;
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(SDLPalettePtr palette, in SDLColor colors, int firstcolor, int ncolors)
		{
			fixed (SDLColor* pcolors = &colors)
			{
				int ret = SetPaletteColorsNative((SDLPalette*)palette, (SDLColor*)pcolors, firstcolor, ncolors);
				return ret;
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(ref SDLPalette palette, in SDLColor colors, int firstcolor, int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (SDLColor* pcolors = &colors)
				{
					int ret = SetPaletteColorsNative((SDLPalette*)ppalette, (SDLColor*)pcolors, firstcolor, ncolors);
					return ret;
				}
			}
		}

		/// <summary>
		/// Free a palette created with SDL_AllocPalette().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreePaletteNative(SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLPalette*, void>)funcTable[287])(palette);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[287])((nint)palette);
			#endif
		}

		/// <summary>
		/// Free a palette created with SDL_AllocPalette().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreePalette(SDLPalettePtr palette)
		{
			FreePaletteNative((SDLPalette*)palette);
		}

		/// <summary>
		/// Free a palette created with SDL_AllocPalette().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreePalette(ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				FreePaletteNative((SDLPalette*)ppalette);
			}
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapRGBNative(SDLPixelFormat* format, byte r, byte g, byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat*, byte, byte, byte, uint>)funcTable[288])(format, r, g, b);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, uint>)funcTable[288])((nint)format, r, g, b);
			#endif
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(SDLPixelFormatPtr format, byte r, byte g, byte b)
		{
			uint ret = MapRGBNative((SDLPixelFormat*)format, r, g, b);
			return ret;
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(in SDLPixelFormat format, byte r, byte g, byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				uint ret = MapRGBNative((SDLPixelFormat*)pformat, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapRGBANative(SDLPixelFormat* format, byte r, byte g, byte b, byte a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat*, byte, byte, byte, byte, uint>)funcTable[289])(format, r, g, b, a);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte, uint>)funcTable[289])((nint)format, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(SDLPixelFormatPtr format, byte r, byte g, byte b, byte a)
		{
			uint ret = MapRGBANative((SDLPixelFormat*)format, r, g, b, a);
			return ret;
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(in SDLPixelFormat format, byte r, byte g, byte b, byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				uint ret = MapRGBANative((SDLPixelFormat*)pformat, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRGBNative(uint pixel, SDLPixelFormat* format, byte* r, byte* g, byte* b)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, SDLPixelFormat*, byte*, byte*, byte*, void>)funcTable[290])(pixel, format, r, g, b);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, void>)funcTable[290])(pixel, (nint)format, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatPtr format, byte* r, byte* g, byte* b)
		{
			GetRGBNative(pixel, (SDLPixelFormat*)format, r, g, b);
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, in SDLPixelFormat format, byte* r, byte* g, byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				GetRGBNative(pixel, (SDLPixelFormat*)pformat, r, g, b);
			}
		}
	}
}
