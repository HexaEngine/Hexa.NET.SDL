// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Use this function to lock out the audio callback function for a specified<br/>
		/// device.<br/>
		/// The lock manipulated by these functions protects the audio callback<br/>
		/// function specified in SDL_OpenAudioDevice(). During a<br/>
		/// SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed<br/>
		/// that the callback function for that device is not running, even if the<br/>
		/// device is not paused. While a device is locked, any other unpaused,<br/>
		/// unlocked devices may still run their callbacks.<br/>
		/// Calling this function from inside your audio callback is unnecessary. SDL<br/>
		/// obtains this lock before calling your function, and releases it when the<br/>
		/// function returns.<br/>
		/// You should not hold the lock longer than absolutely necessary. If you hold<br/>
		/// it too long, you'll experience dropouts in your audio playback. Ideally,<br/>
		/// your application locks the device, sets a few variables and unlocks again.<br/>
		/// Do not do heavy work while holding the lock for a device.<br/>
		/// It is safe to lock the audio device multiple times, as long as you unlock<br/>
		/// it an equivalent number of times. The callback will not run until the<br/>
		/// device has been unlocked completely in this way. If your application fails<br/>
		/// to unlock the device appropriately, your callback will never run, you might<br/>
		/// hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably<br/>
		/// deadlock.<br/>
		/// Internally, the audio device lock is a mutex; if you lock from two threads<br/>
		/// at once, not only will you block the audio callback, you'll block the other<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockAudioDevice(uint dev)
		{
			LockAudioDeviceNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of unlocking the audio device.<br/>
		/// New programs might want to use SDL_UnlockAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_UnlockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockAudioNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[246])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[246])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of unlocking the audio device.<br/>
		/// New programs might want to use SDL_UnlockAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_UnlockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockAudio()
		{
			UnlockAudioNative();
		}

		/// <summary>
		/// Use this function to unlock the audio callback function for a specified<br/>
		/// device.<br/>
		/// This function should be paired with a previous SDL_LockAudioDevice() call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockAudioDeviceNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[247])(dev);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[247])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to unlock the audio callback function for a specified<br/>
		/// device.<br/>
		/// This function should be paired with a previous SDL_LockAudioDevice() call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockAudioDevice(uint dev)
		{
			UnlockAudioDeviceNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of closing the audio device.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_CloseAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseAudioNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[248])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[248])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of closing the audio device.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_CloseAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseAudio()
		{
			CloseAudioNative();
		}

		/// <summary>
		/// Use this function to shut down audio processing and close the audio device.<br/>
		/// The application should close open audio devices once they are no longer<br/>
		/// needed. Calling this function will wait until the device's audio callback<br/>
		/// is not running, release the audio hardware and then clean up internal<br/>
		/// state. No further audio will play from this device once this function<br/>
		/// returns.<br/>
		/// This function may block briefly while pending audio data is played by the<br/>
		/// hardware, so that applications don't drop the last buffer of data they<br/>
		/// supplied.<br/>
		/// The device ID is invalid as soon as the device is closed, and is eligible<br/>
		/// for reuse in a new SDL_OpenAudioDevice() call immediately.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseAudioDeviceNative(uint dev)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[249])(dev);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[249])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to shut down audio processing and close the audio device.<br/>
		/// The application should close open audio devices once they are no longer<br/>
		/// needed. Calling this function will wait until the device's audio callback<br/>
		/// is not running, release the audio hardware and then clean up internal<br/>
		/// state. No further audio will play from this device once this function<br/>
		/// returns.<br/>
		/// This function may block briefly while pending audio data is played by the<br/>
		/// hardware, so that applications don't drop the last buffer of data they<br/>
		/// supplied.<br/>
		/// The device ID is invalid as soon as the device is closed, and is eligible<br/>
		/// for reuse in a new SDL_OpenAudioDevice() call immediately.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseAudioDevice(uint dev)
		{
			CloseAudioDeviceNative(dev);
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetClipboardTextNative(byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[250])(text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[250])((nint)text);
			#endif
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(byte* text)
		{
			int ret = SetClipboardTextNative(text);
			return ret;
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SetClipboardTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = SetClipboardTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetClipboardText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetClipboardTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[251])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[251])();
			#endif
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the clipboard exists and contains a non-empty text string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[252])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[252])();
			#endif
		}

		/// <summary>
		/// Query whether the clipboard exists and contains a non-empty text string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasClipboardText()
		{
			SDLBool ret = HasClipboardTextNative();
			return ret;
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPrimarySelectionTextNative(byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[253])(text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[253])((nint)text);
			#endif
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(byte* text)
		{
			int ret = SetPrimarySelectionTextNative(text);
			return ret;
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SetPrimarySelectionTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = SetPrimarySelectionTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPrimarySelectionText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetPrimarySelectionTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection, which must be freed with<br/>
		/// SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPrimarySelectionTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[254])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[254])();
			#endif
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection, which must be freed with<br/>
		/// SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetPrimarySelectionText()
		{
			byte* ret = GetPrimarySelectionTextNative();
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection, which must be freed with<br/>
		/// SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetPrimarySelectionTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetPrimarySelectionTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the primary selection exists and contains a non-empty text<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasPrimarySelectionTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[255])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[255])();
			#endif
		}

		/// <summary>
		/// Query whether the primary selection exists and contains a non-empty text<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasPrimarySelectionText()
		{
			SDLBool ret = HasPrimarySelectionTextNative();
			return ret;
		}

		/// <summary>
		/// Get the number of CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCPUCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[256])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[256])();
			#endif
		}

		/// <summary>
		/// Get the number of CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetCPUCount()
		{
			int ret = GetCPUCountNative();
			return ret;
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCPUCacheLineSizeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[257])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[257])();
			#endif
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetCPUCacheLineSize()
		{
			int ret = GetCPUCacheLineSizeNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has the RDTSC instruction.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasRDTSCNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[258])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[258])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has the RDTSC instruction.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasRDTSC()
		{
			SDLBool ret = HasRDTSCNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAltiVecNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[259])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[259])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAltiVec()
		{
			SDLBool ret = HasAltiVecNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasMMXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[260])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[260])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasMMX()
		{
			SDLBool ret = HasMMXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has 3DNow! features.<br/>
		/// This always returns false on CPUs that aren't using AMD instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool Has3DNowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[261])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[261])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has 3DNow! features.<br/>
		/// This always returns false on CPUs that aren't using AMD instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool Has3DNow()
		{
			SDLBool ret = Has3DNowNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSENative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[262])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[262])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE()
		{
			SDLBool ret = HasSSENative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[263])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[263])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE2()
		{
			SDLBool ret = HasSSE2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE3Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[264])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[264])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE3()
		{
			SDLBool ret = HasSSE3Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE41Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[265])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[265])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE41()
		{
			SDLBool ret = HasSSE41Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasSSE42Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[266])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[266])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasSSE42()
		{
			SDLBool ret = HasSSE42Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAVXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[267])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[267])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAVX()
		{
			SDLBool ret = HasAVXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAVX2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[268])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[268])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAVX2()
		{
			SDLBool ret = HasAVX2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasAVX512FNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[269])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[269])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasAVX512F()
		{
			SDLBool ret = HasAVX512FNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
		/// This is different from ARM NEON, which is a different instruction set.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasARMSIMDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[270])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[270])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
		/// This is different from ARM NEON, which is a different instruction set.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasARMSIMD()
		{
			SDLBool ret = HasARMSIMDNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasNEONNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[271])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[271])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasNEON()
		{
			SDLBool ret = HasNEONNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasLSXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[272])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[272])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasLSX()
		{
			SDLBool ret = HasLSXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasLASXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[273])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[273])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasLASX()
		{
			SDLBool ret = HasLASXNative();
			return ret;
		}

		/// <summary>
		/// Get the amount of RAM configured in the system.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSystemRAMNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[274])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[274])();
			#endif
		}

		/// <summary>
		/// Get the amount of RAM configured in the system.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetSystemRAM()
		{
			int ret = GetSystemRAMNative();
			return ret;
		}

		/// <summary>
		/// Report the alignment this system needs for SIMD allocations.<br/>
		/// This will return the minimum number of bytes to which a pointer must be<br/>
		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
		/// example, if the machine supports SSE only, it will return 16, but if it<br/>
		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
		/// Plan accordingly.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint SIMDGetAlignmentNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint>)funcTable[275])();
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nuint>)funcTable[275])();
			#endif
		}

		/// <summary>
		/// Report the alignment this system needs for SIMD allocations.<br/>
		/// This will return the minimum number of bytes to which a pointer must be<br/>
		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
		/// example, if the machine supports SSE only, it will return 16, but if it<br/>
		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
		/// Plan accordingly.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint SIMDGetAlignment()
		{
			nuint ret = SIMDGetAlignmentNative();
			return ret;
		}

		/// <summary>
		/// Allocate memory in a SIMD-friendly way.<br/>
		/// This will allocate a block of memory that is suitable for use with SIMD<br/>
		/// instructions. Specifically, it will be properly aligned and padded for the<br/>
		/// system's supported vector instructions.<br/>
		/// The memory returned will be padded such that it is safe to read or write an<br/>
		/// incomplete vector at the end of the memory block. This can be useful so you<br/>
		/// don't have to drop back to a scalar fallback at the end of your SIMD<br/>
		/// processing loop to deal with the final elements without overflowing the<br/>
		/// allocated buffer.<br/>
		/// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or<br/>
		/// delete[], etc.<br/>
		/// Note that SDL will only deal with SIMD instruction sets it is aware of; for<br/>
		/// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and<br/>
		/// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants<br/>
		/// 64. To be clear: if you can't decide to use an instruction set with an<br/>
		/// SDL_Has*() function, don't use that instruction set with memory allocated<br/>
		/// through here.<br/>
		/// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't<br/>
		/// out of memory, but you are not allowed to dereference it (because you only<br/>
		/// own zero bytes of that buffer).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SIMDAllocNative(nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, void*>)funcTable[276])(len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nint>)funcTable[276])(len);
			#endif
		}

		/// <summary>
		/// Allocate memory in a SIMD-friendly way.<br/>
		/// This will allocate a block of memory that is suitable for use with SIMD<br/>
		/// instructions. Specifically, it will be properly aligned and padded for the<br/>
		/// system's supported vector instructions.<br/>
		/// The memory returned will be padded such that it is safe to read or write an<br/>
		/// incomplete vector at the end of the memory block. This can be useful so you<br/>
		/// don't have to drop back to a scalar fallback at the end of your SIMD<br/>
		/// processing loop to deal with the final elements without overflowing the<br/>
		/// allocated buffer.<br/>
		/// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or<br/>
		/// delete[], etc.<br/>
		/// Note that SDL will only deal with SIMD instruction sets it is aware of; for<br/>
		/// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and<br/>
		/// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants<br/>
		/// 64. To be clear: if you can't decide to use an instruction set with an<br/>
		/// SDL_Has*() function, don't use that instruction set with memory allocated<br/>
		/// through here.<br/>
		/// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't<br/>
		/// out of memory, but you are not allowed to dereference it (because you only<br/>
		/// own zero bytes of that buffer).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SIMDAlloc(nuint len)
		{
			void* ret = SIMDAllocNative(len);
			return ret;
		}

		/// <summary>
		/// Reallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,<br/>
		/// SDL_malloc, memalign, new[], etc.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SIMDReallocNative(void* mem, nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, void*>)funcTable[277])(mem, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[277])((nint)mem, len);
			#endif
		}

		/// <summary>
		/// Reallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,<br/>
		/// SDL_malloc, memalign, new[], etc.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SIMDRealloc(void* mem, nuint len)
		{
			void* ret = SIMDReallocNative(mem, len);
			return ret;
		}

		/// <summary>
		/// Deallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from<br/>
		/// malloc, realloc, SDL_malloc, memalign, new[], etc.<br/>
		/// However, SDL_SIMDFree(NULL) is a legal no-op.<br/>
		/// The memory pointed to by `ptr` is no longer valid for access upon return,<br/>
		/// and may be returned to the system or reused by a future allocation. The<br/>
		/// pointer passed to this function is no longer safe to dereference once this<br/>
		/// function returns, and should be discarded.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SIMDFreeNative(void* ptr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[278])(ptr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[278])((nint)ptr);
			#endif
		}

		/// <summary>
		/// Deallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from<br/>
		/// malloc, realloc, SDL_malloc, memalign, new[], etc.<br/>
		/// However, SDL_SIMDFree(NULL) is a legal no-op.<br/>
		/// The memory pointed to by `ptr` is no longer valid for access upon return,<br/>
		/// and may be returned to the system or reused by a future allocation. The<br/>
		/// pointer passed to this function is no longer safe to dereference once this<br/>
		/// function returns, and should be discarded.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SIMDFree(void* ptr)
		{
			SIMDFreeNative(ptr);
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPixelFormatNameNative(uint format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[279])(format);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[279])(format);
			#endif
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetPixelFormatName(uint format)
		{
			byte* ret = GetPixelFormatNameNative(format);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetPixelFormatNameS(uint format)
		{
			string ret = Utils.DecodeStringUTF8(GetPixelFormatNameNative(format));
			return ret;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool PixelFormatEnumToMasksNative(uint format, int* bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int*, uint*, uint*, uint*, uint*, SDLBool>)funcTable[280])(format, bpp, rmask, gmask, bmask, amask);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, nint, SDLBool>)funcTable[280])(format, (nint)bpp, (nint)rmask, (nint)gmask, (nint)bmask, (nint)amask);
			#endif
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, (uint*)pbmask, amask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* pamask = &amask)
			{
				SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, bmask, (uint*)pamask);
				return ret;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, uint* rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, uint* rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, int* bpp, ref uint rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = PixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool PixelFormatEnumToMasks(uint format, ref int bpp, ref uint rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							fixed (uint* pamask = &amask)
							{
								SDLBool ret = PixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MasksToPixelFormatEnumNative(int bpp, uint rmask, uint gmask, uint bmask, uint amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, uint>)funcTable[281])(bpp, rmask, gmask, bmask, amask);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, uint>)funcTable[281])(bpp, rmask, gmask, bmask, amask);
			#endif
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MasksToPixelFormatEnum(int bpp, uint rmask, uint gmask, uint bmask, uint amask)
		{
			uint ret = MasksToPixelFormatEnumNative(bpp, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Create an SDL_PixelFormat structure corresponding to a pixel format.<br/>
		/// Returned structure may come from a shared global cache (i.e. not newly<br/>
		/// allocated), and hence should not be modified, especially the palette. Weird<br/>
		/// errors such as `Blit combination not supported` may occur.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPixelFormat* AllocFormatNative(uint pixelFormat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLPixelFormat*>)funcTable[282])(pixelFormat);
			#else
			return (SDLPixelFormat*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[282])(pixelFormat);
			#endif
		}

		/// <summary>
		/// Create an SDL_PixelFormat structure corresponding to a pixel format.<br/>
		/// Returned structure may come from a shared global cache (i.e. not newly<br/>
		/// allocated), and hence should not be modified, especially the palette. Weird<br/>
		/// errors such as `Blit combination not supported` may occur.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPixelFormat* AllocFormat(uint pixelFormat)
		{
			SDLPixelFormat* ret = AllocFormatNative(pixelFormat);
			return ret;
		}

		/// <summary>
		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeFormatNative(SDLPixelFormat* format)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLPixelFormat*, void>)funcTable[283])(format);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[283])((nint)format);
			#endif
		}

		/// <summary>
		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeFormat(SDLPixelFormat* format)
		{
			FreeFormatNative(format);
		}

		/// <summary>
		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreeFormat(ref SDLPixelFormat format)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				FreeFormatNative((SDLPixelFormat*)pformat);
			}
		}

		/// <summary>
		/// Create a palette structure with the specified number of color entries.<br/>
		/// The palette entries are initialized to white.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPalette* AllocPaletteNative(int ncolors)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLPalette*>)funcTable[284])(ncolors);
			#else
			return (SDLPalette*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[284])(ncolors);
			#endif
		}

		/// <summary>
		/// Create a palette structure with the specified number of color entries.<br/>
		/// The palette entries are initialized to white.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPalette* AllocPalette(int ncolors)
		{
			SDLPalette* ret = AllocPaletteNative(ncolors);
			return ret;
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPixelFormatPaletteNative(SDLPixelFormat* format, SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat*, SDLPalette*, int>)funcTable[285])(format, palette);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[285])((nint)format, (nint)palette);
			#endif
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(SDLPixelFormat* format, SDLPalette* palette)
		{
			int ret = SetPixelFormatPaletteNative(format, palette);
			return ret;
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(ref SDLPixelFormat format, SDLPalette* palette)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				int ret = SetPixelFormatPaletteNative((SDLPixelFormat*)pformat, palette);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(SDLPixelFormat* format, ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SetPixelFormatPaletteNative(format, (SDLPalette*)ppalette);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPixelFormatPalette(ref SDLPixelFormat format, ref SDLPalette palette)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					int ret = SetPixelFormatPaletteNative((SDLPixelFormat*)pformat, (SDLPalette*)ppalette);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPaletteColorsNative(SDLPalette* palette, SDLColor* colors, int firstcolor, int ncolors)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPalette*, SDLColor*, int, int, int>)funcTable[286])(palette, colors, firstcolor, ncolors);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int>)funcTable[286])((nint)palette, (nint)colors, firstcolor, ncolors);
			#endif
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(SDLPalette* palette, SDLColor* colors, int firstcolor, int ncolors)
		{
			int ret = SetPaletteColorsNative(palette, colors, firstcolor, ncolors);
			return ret;
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(ref SDLPalette palette, SDLColor* colors, int firstcolor, int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SetPaletteColorsNative((SDLPalette*)ppalette, colors, firstcolor, ncolors);
				return ret;
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(SDLPalette* palette, ref SDLColor colors, int firstcolor, int ncolors)
		{
			fixed (SDLColor* pcolors = &colors)
			{
				int ret = SetPaletteColorsNative(palette, (SDLColor*)pcolors, firstcolor, ncolors);
				return ret;
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetPaletteColors(ref SDLPalette palette, ref SDLColor colors, int firstcolor, int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (SDLColor* pcolors = &colors)
				{
					int ret = SetPaletteColorsNative((SDLPalette*)ppalette, (SDLColor*)pcolors, firstcolor, ncolors);
					return ret;
				}
			}
		}

		/// <summary>
		/// Free a palette created with SDL_AllocPalette().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreePaletteNative(SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLPalette*, void>)funcTable[287])(palette);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[287])((nint)palette);
			#endif
		}

		/// <summary>
		/// Free a palette created with SDL_AllocPalette().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreePalette(SDLPalette* palette)
		{
			FreePaletteNative(palette);
		}

		/// <summary>
		/// Free a palette created with SDL_AllocPalette().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void FreePalette(ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				FreePaletteNative((SDLPalette*)ppalette);
			}
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapRGBNative(SDLPixelFormat* format, byte r, byte g, byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat*, byte, byte, byte, uint>)funcTable[288])(format, r, g, b);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, uint>)funcTable[288])((nint)format, r, g, b);
			#endif
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(SDLPixelFormat* format, byte r, byte g, byte b)
		{
			uint ret = MapRGBNative(format, r, g, b);
			return ret;
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(ref SDLPixelFormat format, byte r, byte g, byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				uint ret = MapRGBNative((SDLPixelFormat*)pformat, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapRGBANative(SDLPixelFormat* format, byte r, byte g, byte b, byte a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat*, byte, byte, byte, byte, uint>)funcTable[289])(format, r, g, b, a);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte, uint>)funcTable[289])((nint)format, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(SDLPixelFormat* format, byte r, byte g, byte b, byte a)
		{
			uint ret = MapRGBANative(format, r, g, b, a);
			return ret;
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(ref SDLPixelFormat format, byte r, byte g, byte b, byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				uint ret = MapRGBANative((SDLPixelFormat*)pformat, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRGBNative(uint pixel, SDLPixelFormat* format, byte* r, byte* g, byte* b)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, SDLPixelFormat*, byte*, byte*, byte*, void>)funcTable[290])(pixel, format, r, g, b);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, void>)funcTable[290])(pixel, (nint)format, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, byte* r, byte* g, byte* b)
		{
			GetRGBNative(pixel, format, r, g, b);
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, byte* r, byte* g, byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				GetRGBNative(pixel, (SDLPixelFormat*)pformat, r, g, b);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, ref byte r, byte* g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				GetRGBNative(pixel, format, (byte*)pr, g, b);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, ref byte r, byte* g, byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					GetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, byte* r, ref byte g, byte* b)
		{
			fixed (byte* pg = &g)
			{
				GetRGBNative(pixel, format, r, (byte*)pg, b);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, byte* r, ref byte g, byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					GetRGBNative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, ref byte r, ref byte g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					GetRGBNative(pixel, format, (byte*)pr, (byte*)pg, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, b);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, byte* r, byte* g, ref byte b)
		{
			fixed (byte* pb = &b)
			{
				GetRGBNative(pixel, format, r, g, (byte*)pb);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, byte* r, byte* g, ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					GetRGBNative(pixel, (SDLPixelFormat*)pformat, r, g, (byte*)pb);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, ref byte r, byte* g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					GetRGBNative(pixel, format, (byte*)pr, g, (byte*)pb);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, byte* r, ref byte g, ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					GetRGBNative(pixel, format, r, (byte*)pg, (byte*)pb);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormat* format, ref byte r, ref byte g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormat format, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRGBANative(uint pixel, SDLPixelFormat* format, byte* r, byte* g, byte* b, byte* a)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, SDLPixelFormat*, byte*, byte*, byte*, byte*, void>)funcTable[291])(pixel, format, r, g, b, a);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, nint, void>)funcTable[291])(pixel, (nint)format, (nint)r, (nint)g, (nint)b, (nint)a);
			#endif
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, byte* g, byte* b, byte* a)
		{
			GetRGBANative(pixel, format, r, g, b, a);
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, b, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				GetRGBANative(pixel, format, (byte*)pr, g, b, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (byte* pg = &g)
			{
				GetRGBANative(pixel, format, r, (byte*)pg, b, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					GetRGBANative(pixel, format, (byte*)pr, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, b, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (byte* pb = &b)
			{
				GetRGBANative(pixel, format, r, g, (byte*)pb, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, (byte*)pr, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, ref byte g, ref byte b, byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, r, (byte*)pg, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, ref byte g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, ref byte g, ref byte b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, ref byte g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, byte* g, byte* b, ref byte a)
		{
			fixed (byte* pa = &a)
			{
				GetRGBANative(pixel, format, r, g, b, (byte*)pa);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, byte* g, byte* b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, byte* g, byte* b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, (byte*)pr, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, byte* g, byte* b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, ref byte g, byte* b, ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, r, (byte*)pg, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, ref byte g, byte* b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, ref byte g, byte* b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, (byte*)pr, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, ref byte g, byte* b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, b, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, byte* g, ref byte b, ref byte a)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, r, g, (byte*)pb, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, byte* g, ref byte b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, byte* g, ref byte b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, (byte*)pr, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, byte* g, ref byte b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, byte* r, ref byte g, ref byte b, ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, r, (byte*)pg, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, byte* r, ref byte g, ref byte b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormat* format, ref byte r, ref byte g, ref byte b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormat format, ref byte r, ref byte g, ref byte b, ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								GetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateGammaRampNative(float gamma, ushort* ramp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, ushort*, void>)funcTable[292])(gamma, ramp);
			#else
			((delegate* unmanaged[Cdecl]<float, nint, void>)funcTable[292])(gamma, (nint)ramp);
			#endif
		}

		/// <summary>
		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CalculateGammaRamp(float gamma, ushort* ramp)
		{
			CalculateGammaRampNative(gamma, ramp);
		}

		/// <summary>
		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CalculateGammaRamp(float gamma, ref ushort ramp)
		{
			fixed (ushort* pramp = &ramp)
			{
				CalculateGammaRampNative(gamma, (ushort*)pramp);
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasIntersectionNative(SDLRect* a, SDLRect* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLBool>)funcTable[293])(a, b);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, SDLBool>)funcTable[293])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersection(SDLRect* a, SDLRect* b)
		{
			SDLBool ret = HasIntersectionNative(a, b);
			return ret;
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersection(ref SDLRect a, SDLRect* b)
		{
			fixed (SDLRect* pa = &a)
			{
				SDLBool ret = HasIntersectionNative((SDLRect*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersection(SDLRect* a, ref SDLRect b)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = HasIntersectionNative(a, (SDLRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersection(ref SDLRect a, ref SDLRect b)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					SDLBool ret = HasIntersectionNative((SDLRect*)pa, (SDLRect*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IntersectRectNative(SDLRect* a, SDLRect* b, SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLRect*, SDLBool>)funcTable[294])(a, b, result);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, SDLBool>)funcTable[294])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(SDLRect* a, SDLRect* b, SDLRect* result)
		{
			SDLBool ret = IntersectRectNative(a, b, result);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(ref SDLRect a, SDLRect* b, SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				SDLBool ret = IntersectRectNative((SDLRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(SDLRect* a, ref SDLRect b, SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = IntersectRectNative(a, (SDLRect*)pb, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(ref SDLRect a, ref SDLRect b, SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					SDLBool ret = IntersectRectNative((SDLRect*)pa, (SDLRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(SDLRect* a, SDLRect* b, ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = IntersectRectNative(a, b, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(ref SDLRect a, SDLRect* b, ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = IntersectRectNative((SDLRect*)pa, b, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(SDLRect* a, ref SDLRect b, ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = IntersectRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRect(ref SDLRect a, ref SDLRect b, ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						SDLBool ret = IntersectRectNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnionRectNative(SDLRect* a, SDLRect* b, SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLRect*, void>)funcTable[295])(a, b, result);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[295])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(SDLRect* a, SDLRect* b, SDLRect* result)
		{
			UnionRectNative(a, b, result);
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(ref SDLRect a, SDLRect* b, SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				UnionRectNative((SDLRect*)pa, b, result);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(SDLRect* a, ref SDLRect b, SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				UnionRectNative(a, (SDLRect*)pb, result);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(ref SDLRect a, ref SDLRect b, SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					UnionRectNative((SDLRect*)pa, (SDLRect*)pb, result);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(SDLRect* a, SDLRect* b, ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				UnionRectNative(a, b, (SDLRect*)presult);
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(ref SDLRect a, SDLRect* b, ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					UnionRectNative((SDLRect*)pa, b, (SDLRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(SDLRect* a, ref SDLRect b, ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					UnionRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnionRect(ref SDLRect a, ref SDLRect b, ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						UnionRectNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool EnclosePointsNative(SDLPoint* points, int count, SDLRect* clip, SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPoint*, int, SDLRect*, SDLRect*, SDLBool>)funcTable[296])(points, count, clip, result);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, SDLBool>)funcTable[296])((nint)points, count, (nint)clip, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(SDLPoint* points, int count, SDLRect* clip, SDLRect* result)
		{
			SDLBool ret = EnclosePointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(ref SDLPoint points, int count, SDLRect* clip, SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, clip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(SDLPoint* points, int count, ref SDLRect clip, SDLRect* result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				SDLBool ret = EnclosePointsNative(points, count, (SDLRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(ref SDLPoint points, int count, ref SDLRect clip, SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(SDLPoint* points, int count, SDLRect* clip, ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = EnclosePointsNative(points, count, clip, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(ref SDLPoint points, int count, SDLRect* clip, ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, clip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(SDLPoint* points, int count, ref SDLRect clip, ref SDLRect result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = EnclosePointsNative(points, count, (SDLRect*)pclip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool EnclosePoints(ref SDLPoint points, int count, ref SDLRect clip, ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					fixed (SDLRect* presult = &result)
					{
						SDLBool ret = EnclosePointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IntersectRectAndLineNative(SDLRect* rect, int* x1, int* y1, int* x2, int* y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, int*, int*, int*, int*, SDLBool>)funcTable[297])(rect, x1, y1, x2, y2);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, SDLBool>)funcTable[297])((nint)rect, (nint)x1, (nint)y1, (nint)x2, (nint)y2);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, int* y1, int* x2, int* y2)
		{
			SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, int* y1, int* x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, int* y1, int* x2, int* y2)
		{
			fixed (int* px1 = &x1)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, int* y1, int* x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, ref int y1, int* x2, int* y2)
		{
			fixed (int* py1 = &y1)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, ref int y1, int* x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, ref int y1, int* x2, int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, ref int y1, int* x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, int* y1, ref int x2, int* y2)
		{
			fixed (int* px2 = &x2)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, (int*)px2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, int* y1, ref int x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, int* y1, ref int x2, int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, int* y1, ref int x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, ref int y1, ref int x2, int* y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, ref int y1, ref int x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, ref int y1, ref int x2, int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, ref int y1, ref int x2, int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, y2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, int* y1, int* x2, ref int y2)
		{
			fixed (int* py2 = &y2)
			{
				SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, x2, (int*)py2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, int* y1, int* x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, int* y1, int* x2, ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, int* y1, int* x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, ref int y1, int* x2, ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, ref int y1, int* x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, ref int y1, int* x2, ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, ref int y1, int* x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, int* y1, ref int x2, ref int y2)
		{
			fixed (int* px2 = &x2)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = IntersectRectAndLineNative(rect, x1, y1, (int*)px2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, int* y1, ref int x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, int* y1, ref int x2, ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, int* y1, ref int x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, int* x1, ref int y1, ref int x2, ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = IntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, int* x1, ref int y1, ref int x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(SDLRect* rect, ref int x1, ref int y1, ref int x2, ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = IntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IntersectRectAndLine(ref SDLRect rect, ref int x1, ref int y1, ref int x2, ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							fixed (int* py2 = &y2)
							{
								SDLBool ret = IntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasIntersectionFNative(SDLFRect* a, SDLFRect* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLBool>)funcTable[298])(a, b);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, SDLBool>)funcTable[298])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersectionF(SDLFRect* a, SDLFRect* b)
		{
			SDLBool ret = HasIntersectionFNative(a, b);
			return ret;
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersectionF(ref SDLFRect a, SDLFRect* b)
		{
			fixed (SDLFRect* pa = &a)
			{
				SDLBool ret = HasIntersectionFNative((SDLFRect*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersectionF(SDLFRect* a, ref SDLFRect b)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLBool ret = HasIntersectionFNative(a, (SDLFRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasIntersectionF(ref SDLFRect a, ref SDLFRect b)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					SDLBool ret = HasIntersectionFNative((SDLFRect*)pa, (SDLFRect*)pb);
					return ret;
				}
			}
		}
	}
}
