// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowMaximumSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowMaximumSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowMaximumSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowBorderedNative(SDLWindow* window, SDLBool bordered)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[386])(window, bordered);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[386])((nint)window, bordered);
			#endif
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowBordered(SDLWindow* window, SDLBool bordered)
		{
			SetWindowBorderedNative(window, bordered);
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowBordered(ref SDLWindow window, SDLBool bordered)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowBorderedNative((SDLWindow*)pwindow, bordered);
			}
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowResizableNative(SDLWindow* window, SDLBool resizable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[387])(window, resizable);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[387])((nint)window, resizable);
			#endif
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowResizable(SDLWindow* window, SDLBool resizable)
		{
			SetWindowResizableNative(window, resizable);
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowResizable(ref SDLWindow window, SDLBool resizable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowResizableNative((SDLWindow*)pwindow, resizable);
			}
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowAlwaysOnTopNative(SDLWindow* window, SDLBool onTop)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[388])(window, onTop);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[388])((nint)window, onTop);
			#endif
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowAlwaysOnTop(SDLWindow* window, SDLBool onTop)
		{
			SetWindowAlwaysOnTopNative(window, onTop);
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowAlwaysOnTop(ref SDLWindow window, SDLBool onTop)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowAlwaysOnTopNative((SDLWindow*)pwindow, onTop);
			}
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[389])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[389])((nint)window);
			#endif
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowWindow(SDLWindow* window)
		{
			ShowWindowNative(window);
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HideWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[390])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[390])((nint)window);
			#endif
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void HideWindow(SDLWindow* window)
		{
			HideWindowNative(window);
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void HideWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				HideWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Raise a window above other windows and set the input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RaiseWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[391])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[391])((nint)window);
			#endif
		}

		/// <summary>
		/// Raise a window above other windows and set the input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RaiseWindow(SDLWindow* window)
		{
			RaiseWindowNative(window);
		}

		/// <summary>
		/// Raise a window above other windows and set the input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RaiseWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				RaiseWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Make a window as large as possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaximizeWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[392])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[392])((nint)window);
			#endif
		}

		/// <summary>
		/// Make a window as large as possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MaximizeWindow(SDLWindow* window)
		{
			MaximizeWindowNative(window);
		}

		/// <summary>
		/// Make a window as large as possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MaximizeWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				MaximizeWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Minimize a window to an iconic representation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MinimizeWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[393])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[393])((nint)window);
			#endif
		}

		/// <summary>
		/// Minimize a window to an iconic representation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MinimizeWindow(SDLWindow* window)
		{
			MinimizeWindowNative(window);
		}

		/// <summary>
		/// Minimize a window to an iconic representation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MinimizeWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				MinimizeWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Restore the size and position of a minimized or maximized window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RestoreWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[394])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[394])((nint)window);
			#endif
		}

		/// <summary>
		/// Restore the size and position of a minimized or maximized window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RestoreWindow(SDLWindow* window)
		{
			RestoreWindowNative(window);
		}

		/// <summary>
		/// Restore the size and position of a minimized or maximized window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RestoreWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				RestoreWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Set a window's fullscreen state.<br/>
		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>
		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>
		/// that takes the size of the desktop; and 0 for windowed mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowFullscreenNative(SDLWindow* window, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint, int>)funcTable[395])(window, flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[395])((nint)window, flags);
			#endif
		}

		/// <summary>
		/// Set a window's fullscreen state.<br/>
		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>
		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>
		/// that takes the size of the desktop; and 0 for windowed mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowFullscreen(SDLWindow* window, uint flags)
		{
			int ret = SetWindowFullscreenNative(window, flags);
			return ret;
		}

		/// <summary>
		/// Set a window's fullscreen state.<br/>
		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>
		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>
		/// that takes the size of the desktop; and 0 for windowed mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowFullscreen(ref SDLWindow window, uint flags)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowFullscreenNative((SDLWindow*)pwindow, flags);
				return ret;
			}
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[396])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[396])((nint)window);
			#endif
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasWindowSurface(SDLWindow* window)
		{
			SDLBool ret = HasWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = HasWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* GetWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*>)funcTable[397])(window);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[397])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* GetWindowSurface(SDLWindow* window)
		{
			SDLSurface* ret = GetWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* GetWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSurface* ret = GetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[398])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[398])((nint)window);
			#endif
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurface(SDLWindow* window)
		{
			int ret = UpdateWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = UpdateWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what<br/>
		/// method SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateWindowSurfaceRectsNative(SDLWindow* window, SDLRect* rects, int numrects)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int, int>)funcTable[399])(window, rects, numrects);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[399])((nint)window, (nint)rects, numrects);
			#endif
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what<br/>
		/// method SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(SDLWindow* window, SDLRect* rects, int numrects)
		{
			int ret = UpdateWindowSurfaceRectsNative(window, rects, numrects);
			return ret;
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what<br/>
		/// method SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(ref SDLWindow window, SDLRect* rects, int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, rects, numrects);
				return ret;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what<br/>
		/// method SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(SDLWindow* window, ref SDLRect rects, int numrects)
		{
			fixed (SDLRect* prects = &rects)
			{
				int ret = UpdateWindowSurfaceRectsNative(window, (SDLRect*)prects, numrects);
				return ret;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what<br/>
		/// method SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(ref SDLWindow window, ref SDLRect rects, int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prects = &rects)
				{
					int ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)prects, numrects);
					return ret;
				}
			}
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DestroyWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[400])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[400])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int DestroyWindowSurface(SDLWindow* window)
		{
			int ret = DestroyWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int DestroyWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = DestroyWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set a window's input grab mode.<br/>
		/// When input is grabbed, the mouse is confined to the window. This function<br/>
		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>
		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowGrabNative(SDLWindow* window, SDLBool grabbed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[401])(window, grabbed);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[401])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's input grab mode.<br/>
		/// When input is grabbed, the mouse is confined to the window. This function<br/>
		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>
		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowGrab(SDLWindow* window, SDLBool grabbed)
		{
			SetWindowGrabNative(window, grabbed);
		}

		/// <summary>
		/// Set a window's input grab mode.<br/>
		/// When input is grabbed, the mouse is confined to the window. This function<br/>
		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>
		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowGrab(ref SDLWindow window, SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowKeyboardGrabNative(SDLWindow* window, SDLBool grabbed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[402])(window, grabbed);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[402])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowKeyboardGrab(SDLWindow* window, SDLBool grabbed)
		{
			SetWindowKeyboardGrabNative(window, grabbed);
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowKeyboardGrab(ref SDLWindow window, SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowKeyboardGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMouseGrabNative(SDLWindow* window, SDLBool grabbed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[403])(window, grabbed);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[403])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMouseGrab(SDLWindow* window, SDLBool grabbed)
		{
			SetWindowMouseGrabNative(window, grabbed);
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMouseGrab(ref SDLWindow window, SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowMouseGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Get a window's input grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetWindowGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[404])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[404])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's input grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowGrab(SDLWindow* window)
		{
			SDLBool ret = GetWindowGrabNative(window);
			return ret;
		}

		/// <summary>
		/// Get a window's input grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = GetWindowGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetWindowKeyboardGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[405])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[405])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowKeyboardGrab(SDLWindow* window)
		{
			SDLBool ret = GetWindowKeyboardGrabNative(window);
			return ret;
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowKeyboardGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = GetWindowKeyboardGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetWindowMouseGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[406])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[406])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowMouseGrab(SDLWindow* window)
		{
			SDLBool ret = GetWindowMouseGrabNative(window);
			return ret;
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowMouseGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = GetWindowMouseGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetGrabbedWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[407])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[407])();
			#endif
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GetGrabbedWindow()
		{
			SDLWindow* ret = GetGrabbedWindowNative();
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowMouseRectNative(SDLWindow* window, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int>)funcTable[408])(window, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[408])((nint)window, (nint)rect);
			#endif
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(SDLWindow* window, SDLRect* rect)
		{
			int ret = SetWindowMouseRectNative(window, rect);
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(ref SDLWindow window, SDLRect* rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowMouseRectNative((SDLWindow*)pwindow, rect);
				return ret;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(SDLWindow* window, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SetWindowMouseRectNative(window, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(ref SDLWindow window, ref SDLRect rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRect* GetWindowMouseRectNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*>)funcTable[409])(window);
			#else
			return (SDLRect*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[409])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRect* GetWindowMouseRect(SDLWindow* window)
		{
			SDLRect* ret = GetWindowMouseRectNative(window);
			return ret;
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRect* GetWindowMouseRect(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRect* ret = GetWindowMouseRectNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method sets the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>
		/// brightness set will not follow the window if it is moved to another<br/>
		/// display.<br/>
		/// Many platforms will refuse to set the display brightness in modern times.<br/>
		/// You are better off using a shader to adjust gamma during rendering, or<br/>
		/// something similar.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowBrightnessNative(SDLWindow* window, float brightness)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, int>)funcTable[410])(window, brightness);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, int>)funcTable[410])((nint)window, brightness);
			#endif
		}

		/// <summary>
		/// Set the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method sets the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>
		/// brightness set will not follow the window if it is moved to another<br/>
		/// display.<br/>
		/// Many platforms will refuse to set the display brightness in modern times.<br/>
		/// You are better off using a shader to adjust gamma during rendering, or<br/>
		/// something similar.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowBrightness(SDLWindow* window, float brightness)
		{
			int ret = SetWindowBrightnessNative(window, brightness);
			return ret;
		}

		/// <summary>
		/// Set the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method sets the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>
		/// brightness set will not follow the window if it is moved to another<br/>
		/// display.<br/>
		/// Many platforms will refuse to set the display brightness in modern times.<br/>
		/// You are better off using a shader to adjust gamma during rendering, or<br/>
		/// something similar.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowBrightness(ref SDLWindow window, float brightness)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowBrightnessNative((SDLWindow*)pwindow, brightness);
				return ret;
			}
		}

		/// <summary>
		/// Get the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowBrightnessNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float>)funcTable[411])(window);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[411])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetWindowBrightness(SDLWindow* window)
		{
			float ret = GetWindowBrightnessNative(window);
			return ret;
		}

		/// <summary>
		/// Get the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetWindowBrightness(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				float ret = GetWindowBrightnessNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns -1 if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowOpacityNative(SDLWindow* window, float opacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, int>)funcTable[412])(window, opacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, int>)funcTable[412])((nint)window, opacity);
			#endif
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns -1 if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowOpacity(SDLWindow* window, float opacity)
		{
			int ret = SetWindowOpacityNative(window, opacity);
			return ret;
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns -1 if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowOpacity(ref SDLWindow window, float opacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowOpacityNative((SDLWindow*)pwindow, opacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowOpacityNative(SDLWindow* window, float* outOpacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float*, int>)funcTable[413])(window, outOpacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[413])((nint)window, (nint)outOpacity);
			#endif
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(SDLWindow* window, float* outOpacity)
		{
			int ret = GetWindowOpacityNative(window, outOpacity);
			return ret;
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(ref SDLWindow window, float* outOpacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowOpacityNative((SDLWindow*)pwindow, outOpacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(SDLWindow* window, ref float outOpacity)
		{
			fixed (float* poutOpacity = &outOpacity)
			{
				int ret = GetWindowOpacityNative(window, (float*)poutOpacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(ref SDLWindow window, ref float outOpacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* poutOpacity = &outOpacity)
				{
					int ret = GetWindowOpacityNative((SDLWindow*)pwindow, (float*)poutOpacity);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowModalForNative(SDLWindow* modalWindow, SDLWindow* parentWindow)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLWindow*, int>)funcTable[414])(modalWindow, parentWindow);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[414])((nint)modalWindow, (nint)parentWindow);
			#endif
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(SDLWindow* modalWindow, SDLWindow* parentWindow)
		{
			int ret = SetWindowModalForNative(modalWindow, parentWindow);
			return ret;
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(ref SDLWindow modalWindow, SDLWindow* parentWindow)
		{
			fixed (SDLWindow* pmodalWindow = &modalWindow)
			{
				int ret = SetWindowModalForNative((SDLWindow*)pmodalWindow, parentWindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(SDLWindow* modalWindow, ref SDLWindow parentWindow)
		{
			fixed (SDLWindow* pparentWindow = &parentWindow)
			{
				int ret = SetWindowModalForNative(modalWindow, (SDLWindow*)pparentWindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(ref SDLWindow modalWindow, ref SDLWindow parentWindow)
		{
			fixed (SDLWindow* pmodalWindow = &modalWindow)
			{
				fixed (SDLWindow* pparentWindow = &parentWindow)
				{
					int ret = SetWindowModalForNative((SDLWindow*)pmodalWindow, (SDLWindow*)pparentWindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Explicitly set input focus to the window.<br/>
		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>
		/// this with caution, as you might give focus to a window that is completely<br/>
		/// obscured by other windows.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowInputFocusNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[415])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[415])((nint)window);
			#endif
		}

		/// <summary>
		/// Explicitly set input focus to the window.<br/>
		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>
		/// this with caution, as you might give focus to a window that is completely<br/>
		/// obscured by other windows.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowInputFocus(SDLWindow* window)
		{
			int ret = SetWindowInputFocusNative(window);
			return ret;
		}

		/// <summary>
		/// Explicitly set input focus to the window.<br/>
		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>
		/// this with caution, as you might give focus to a window that is completely<br/>
		/// obscured by other windows.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowInputFocus(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowInputFocusNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowGammaRampNative(SDLWindow* window, ushort* red, ushort* green, ushort* blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, ushort*, ushort*, ushort*, int>)funcTable[416])(window, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[416])((nint)window, (nint)red, (nint)green, (nint)blue);
			#endif
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ushort* red, ushort* green, ushort* blue)
		{
			int ret = SetWindowGammaRampNative(window, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ref ushort red, ushort* green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				int ret = SetWindowGammaRampNative(window, (ushort*)pred, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ref ushort red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ushort* red, ref ushort green, ushort* blue)
		{
			fixed (ushort* pgreen = &green)
			{
				int ret = SetWindowGammaRampNative(window, red, (ushort*)pgreen, blue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, ref ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ref ushort red, ref ushort green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ref ushort red, ref ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, blue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ushort* red, ushort* green, ref ushort blue)
		{
			fixed (ushort* pblue = &blue)
			{
				int ret = SetWindowGammaRampNative(window, red, green, (ushort*)pblue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ref ushort red, ushort* green, ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SetWindowGammaRampNative(window, (ushort*)pred, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ref ushort red, ushort* green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ushort* red, ref ushort green, ref ushort blue)
		{
			fixed (ushort* pgreen = &green)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SetWindowGammaRampNative(window, red, (ushort*)pgreen, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, ref ushort green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindow* window, ref ushort red, ref ushort green, ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ref ushort red, ref ushort green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						fixed (ushort* pblue = &blue)
						{
							int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowGammaRampNative(SDLWindow* window, ushort* red, ushort* green, ushort* blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, ushort*, ushort*, ushort*, int>)funcTable[417])(window, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[417])((nint)window, (nint)red, (nint)green, (nint)blue);
			#endif
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ushort* red, ushort* green, ushort* blue)
		{
			int ret = GetWindowGammaRampNative(window, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ref ushort red, ushort* green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				int ret = GetWindowGammaRampNative(window, (ushort*)pred, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ushort* red, ref ushort green, ushort* blue)
		{
			fixed (ushort* pgreen = &green)
			{
				int ret = GetWindowGammaRampNative(window, red, (ushort*)pgreen, blue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ref ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ref ushort red, ref ushort green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = GetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ref ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, blue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ushort* red, ushort* green, ref ushort blue)
		{
			fixed (ushort* pblue = &blue)
			{
				int ret = GetWindowGammaRampNative(window, red, green, (ushort*)pblue);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ref ushort red, ushort* green, ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = GetWindowGammaRampNative(window, (ushort*)pred, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ushort* green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ushort* red, ref ushort green, ref ushort blue)
		{
			fixed (ushort* pgreen = &green)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = GetWindowGammaRampNative(window, red, (ushort*)pgreen, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ushort* red, ref ushort green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(SDLWindow* window, ref ushort red, ref ushort green, ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = GetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowGammaRamp(ref SDLWindow window, ref ushort red, ref ushort green, ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						fixed (ushort* pblue = &blue)
						{
							int ret = GetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowHitTestNative(SDLWindow* window, SDLHitTest callback, void* callbackData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>, void*, int>)funcTable[418])(window, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), callbackData);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[418])((nint)window, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)callbackData);
			#endif
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(SDLWindow* window, SDLHitTest callback, void* callbackData)
		{
			int ret = SetWindowHitTestNative(window, callback, callbackData);
			return ret;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowHitTest(ref SDLWindow window, SDLHitTest callback, void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowHitTestNative((SDLWindow*)pwindow, callback, callbackData);
				return ret;
			}
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FlashWindowNative(SDLWindow* window, SDLFlashOperation operation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLFlashOperation, int>)funcTable[419])(window, operation);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLFlashOperation, int>)funcTable[419])((nint)window, operation);
			#endif
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int FlashWindow(SDLWindow* window, SDLFlashOperation operation)
		{
			int ret = FlashWindowNative(window, operation);
			return ret;
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int FlashWindow(ref SDLWindow window, SDLFlashOperation operation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = FlashWindowNative((SDLWindow*)pwindow, operation);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[420])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[420])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyWindow(SDLWindow* window)
		{
			DestroyWindowNative(window);
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				DestroyWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsScreenSaverEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[421])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[421])();
			#endif
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsScreenSaverEnabled()
		{
			SDLBool ret = IsScreenSaverEnabledNative();
			return ret;
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[422])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[422])();
			#endif
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void EnableScreenSaver()
		{
			EnableScreenSaverNative();
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[423])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[423])();
			#endif
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DisableScreenSaver()
		{
			DisableScreenSaverNative();
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLLoadLibraryNative(byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[424])(path);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[424])((nint)path);
			#endif
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(byte* path)
		{
			int ret = GLLoadLibraryNative(path);
			return ret;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				int ret = GLLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				int ret = GLLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLLoadLibrary(string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GLLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GLGetProcAddressNative(byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*>)funcTable[425])(proc);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[425])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(byte* proc)
		{
			void* ret = GLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(ref byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				void* ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				void* ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GLGetProcAddress(string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLUnloadLibraryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[426])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[426])();
			#endif
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLUnloadLibrary()
		{
			GLUnloadLibraryNative();
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GLExtensionSupportedNative(byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLBool>)funcTable[427])(extension);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[427])((nint)extension);
			#endif
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(byte* extension)
		{
			SDLBool ret = GLExtensionSupportedNative(extension);
			return ret;
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				SDLBool ret = GLExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				SDLBool ret = GLExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GLExtensionSupported(string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = GLExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLResetAttributesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[428])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[428])();
			#endif
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLResetAttributes()
		{
			GLResetAttributesNative();
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLSetAttributeNative(SDLGLattr attr, int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int, int>)funcTable[429])(attr, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLGLattr, int, int>)funcTable[429])(attr, value);
			#endif
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLSetAttribute(SDLGLattr attr, int value)
		{
			int ret = GLSetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLGetAttributeNative(SDLGLattr attr, int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int*, int>)funcTable[430])(attr, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLGLattr, nint, int>)funcTable[430])(attr, (nint)value);
			#endif
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLGetAttribute(SDLGLattr attr, int* value)
		{
			int ret = GLGetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLGetAttribute(SDLGLattr attr, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				int ret = GLGetAttributeNative(attr, (int*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLCreateContextNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext>)funcTable[431])(window);
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<nint, SDLGLContext>)funcTable[431])((nint)window);
			#endif
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGLContext GLCreateContext(SDLWindow* window)
		{
			SDLGLContext ret = GLCreateContextNative(window);
			return ret;
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGLContext GLCreateContext(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLContext ret = GLCreateContextNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLMakeCurrentNative(SDLWindow* window, SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext, int>)funcTable[432])(window, context);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLGLContext, int>)funcTable[432])((nint)window, context);
			#endif
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLMakeCurrent(SDLWindow* window, SDLGLContext context)
		{
			int ret = GLMakeCurrentNative(window, context);
			return ret;
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLMakeCurrent(ref SDLWindow window, SDLGLContext context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GLMakeCurrentNative((SDLWindow*)pwindow, context);
				return ret;
			}
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GLGetCurrentWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[433])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[433])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GLGetCurrentWindow()
		{
			SDLWindow* ret = GLGetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLGetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[434])();
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[434])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGLContext GLGetCurrentContext()
		{
			SDLGLContext ret = GLGetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLGetDrawableSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[435])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[435])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindow* window, int* w, int* h)
		{
			GLGetDrawableSizeNative(window, w, h);
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GLGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GLGetDrawableSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GLGetDrawableSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GLGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GLGetDrawableSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLGetDrawableSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return -1. In such a case, you should probably<br/>
		/// retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLSetSwapIntervalNative(int interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[436])(interval);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[436])(interval);
			#endif
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return -1. In such a case, you should probably<br/>
		/// retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLSetSwapInterval(int interval)
		{
			int ret = GLSetSwapIntervalNative(interval);
			return ret;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will return 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLGetSwapIntervalNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[437])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[437])();
			#endif
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will return 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLGetSwapInterval()
		{
			int ret = GLGetSwapIntervalNative();
			return ret;
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLSwapWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[438])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[438])((nint)window);
			#endif
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLSwapWindow(SDLWindow* window)
		{
			GLSwapWindowNative(window);
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLSwapWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GLSwapWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLDeleteContextNative(SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGLContext, void>)funcTable[439])(context);
			#else
			((delegate* unmanaged[Cdecl]<SDLGLContext, void>)funcTable[439])(context);
			#endif
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLDeleteContext(SDLGLContext context)
		{
			GLDeleteContextNative(context);
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetKeyboardFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[440])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[440])();
			#endif
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GetKeyboardFocus()
		{
			SDLWindow* ret = GetKeyboardFocusNative();
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyboardStateNative(int* numkeys)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte*>)funcTable[441])(numkeys);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[441])((nint)numkeys);
			#endif
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetKeyboardState(int* numkeys)
		{
			byte* ret = GetKeyboardStateNative(numkeys);
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetKeyboardStateS(int* numkeys)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyboardStateNative(numkeys));
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetKeyboardState(ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				byte* ret = GetKeyboardStateNative((int*)pnumkeys);
				return ret;
			}
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetKeyboardStateS(ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				string ret = Utils.DecodeStringUTF8(GetKeyboardStateNative((int*)pnumkeys));
				return ret;
			}
		}

		/// <summary>
		/// Clear the state of the keyboard<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetKeyboardNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[442])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[442])();
			#endif
		}

		/// <summary>
		/// Clear the state of the keyboard<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ResetKeyboard()
		{
			ResetKeyboardNative();
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLKeymod GetModStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLKeymod>)funcTable[443])();
			#else
			return (SDLKeymod)((delegate* unmanaged[Cdecl]<SDLKeymod>)funcTable[443])();
			#endif
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLKeymod GetModState()
		{
			SDLKeymod ret = GetModStateNative();
			return ret;
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetModStateNative(SDLKeymod modstate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLKeymod, void>)funcTable[444])(modstate);
			#else
			((delegate* unmanaged[Cdecl]<SDLKeymod, void>)funcTable[444])(modstate);
			#endif
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetModState(SDLKeymod modstate)
		{
			SetModStateNative(modstate);
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromScancodeNative(SDLScancode scancode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, int>)funcTable[445])(scancode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLScancode, int>)funcTable[445])(scancode);
			#endif
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromScancode(SDLScancode scancode)
		{
			int ret = GetKeyFromScancodeNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Scancode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromKeyNative(int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLScancode>)funcTable[446])(key);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<int, SDLScancode>)funcTable[446])(key);
			#endif
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Scancode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromKey(int key)
		{
			SDLScancode ret = GetScancodeFromKeyNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetScancodeNameNative(SDLScancode scancode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, byte*>)funcTable[447])(scancode);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLScancode, nint>)funcTable[447])(scancode);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetScancodeName(SDLScancode scancode)
		{
			byte* ret = GetScancodeNameNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetScancodeNameS(SDLScancode scancode)
		{
			string ret = Utils.DecodeStringUTF8(GetScancodeNameNative(scancode));
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromNameNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLScancode>)funcTable[448])(name);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<nint, SDLScancode>)funcTable[448])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(byte* name)
		{
			SDLScancode ret = GetScancodeFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLScancode GetScancodeFromName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLScancode ret = GetScancodeFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyNameNative(int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[449])(key);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[449])(key);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetKeyName(int key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetKeyNameS(int key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromNameNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[450])(name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[450])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(byte* name)
		{
			int ret = GetKeyFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetKeyFromName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetKeyFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events.<br/>
		/// This function will start accepting Unicode text input events in the focused<br/>
		/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>
		/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>
		/// pair with SDL_StopTextInput().<br/>
		/// On some platforms using this function activates the screen keyboard.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StartTextInputNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[451])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[451])();
			#endif
		}

		/// <summary>
		/// Start accepting Unicode text input events.<br/>
		/// This function will start accepting Unicode text input events in the focused<br/>
		/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>
		/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>
		/// pair with SDL_StopTextInput().<br/>
		/// On some platforms using this function activates the screen keyboard.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void StartTextInput()
		{
			StartTextInputNative();
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsTextInputActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[452])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[452])();
			#endif
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsTextInputActive()
		{
			SDLBool ret = IsTextInputActiveNative();
			return ret;
		}

		/// <summary>
		/// Stop receiving any text input events.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StopTextInputNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[453])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[453])();
			#endif
		}

		/// <summary>
		/// Stop receiving any text input events.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void StopTextInput()
		{
			StopTextInputNative();
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearCompositionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[454])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[454])();
			#endif
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ClearComposition()
		{
			ClearCompositionNative();
		}

		/// <summary>
		/// Returns if an IME Composite or Candidate window is currently shown.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsTextInputShownNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[455])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[455])();
			#endif
		}

		/// <summary>
		/// Returns if an IME Composite or Candidate window is currently shown.<br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsTextInputShown()
		{
			SDLBool ret = IsTextInputShownNative();
			return ret;
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs. Native input methods<br/>
		/// will place a window with word suggestions near it, without covering the<br/>
		/// text being inputted.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextInputRectNative(SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRect*, void>)funcTable[456])(rect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[456])((nint)rect);
			#endif
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs. Native input methods<br/>
		/// will place a window with word suggestions near it, without covering the<br/>
		/// text being inputted.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetTextInputRect(SDLRect* rect)
		{
			SetTextInputRectNative(rect);
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs. Native input methods<br/>
		/// will place a window with word suggestions near it, without covering the<br/>
		/// text being inputted.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetTextInputRect(ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SetTextInputRectNative((SDLRect*)prect);
			}
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasScreenKeyboardSupportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[457])();
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<SDLBool>)funcTable[457])();
			#endif
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasScreenKeyboardSupport()
		{
			SDLBool ret = HasScreenKeyboardSupportNative();
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsScreenKeyboardShownNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[458])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[458])((nint)window);
			#endif
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsScreenKeyboardShown(SDLWindow* window)
		{
			SDLBool ret = IsScreenKeyboardShownNative(window);
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsScreenKeyboardShown(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = IsScreenKeyboardShownNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetMouseFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[459])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[459])();
			#endif
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GetMouseFocus()
		{
			SDLWindow* ret = GetMouseFocusNative();
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetMouseStateNative(int* x, int* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)funcTable[460])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[460])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(int* x, int* y)
		{
			uint ret = GetMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = GetMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = GetMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetMouseState(ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = GetMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}
	}
}
