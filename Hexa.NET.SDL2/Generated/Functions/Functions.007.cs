// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Create an SDL window from an existing native window.<br/>
		/// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)<br/>
		/// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured<br/>
		/// before using SDL_CreateWindowFrom().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr CreateWindowFrom(nint data)
		{
			SDLWindowPtr ret = CreateWindowFromNative((void*)data);
			return ret;
		}

		/// <summary>
		/// Get the numeric ID of a window.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetWindowIDNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint>)funcTable[368])(window);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[368])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the numeric ID of a window.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowID(SDLWindowPtr window)
		{
			uint ret = GetWindowIDNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the numeric ID of a window.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowID(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = GetWindowIDNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window from a stored ID.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetWindowFromIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLWindow*>)funcTable[369])(id);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[369])(id);
			#endif
		}

		/// <summary>
		/// Get a window from a stored ID.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr GetWindowFromID(uint id)
		{
			SDLWindowPtr ret = GetWindowFromIDNative(id);
			return ret;
		}

		/// <summary>
		/// Get the window flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetWindowFlagsNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint>)funcTable[370])(window);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[370])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the window flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowFlags(SDLWindowPtr window)
		{
			uint ret = GetWindowFlagsNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the window flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetWindowFlags(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = GetWindowFlagsNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowTitleNative(SDLWindow* window, byte* title)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, byte*, void>)funcTable[371])(window, title);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[371])((nint)window, (nint)title);
			#endif
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindowPtr window, byte* title)
		{
			SetWindowTitleNative((SDLWindow*)window, title);
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, byte* title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowTitleNative((SDLWindow*)pwindow, title);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindowPtr window, in byte title)
		{
			fixed (byte* ptitle = &title)
			{
				SetWindowTitleNative((SDLWindow*)window, (byte*)ptitle);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindowPtr window, ReadOnlySpan<byte> title)
		{
			fixed (byte* ptitle = title)
			{
				SetWindowTitleNative((SDLWindow*)window, (byte*)ptitle);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(SDLWindowPtr window, string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowTitleNative((SDLWindow*)window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, in byte title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* ptitle = &title)
				{
					SetWindowTitleNative((SDLWindow*)pwindow, (byte*)ptitle);
				}
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, ReadOnlySpan<byte> title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* ptitle = title)
				{
					SetWindowTitleNative((SDLWindow*)pwindow, (byte*)ptitle);
				}
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowTitle(ref SDLWindow window, string title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (title != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(title);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetWindowTitleNative((SDLWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetWindowTitleNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte*>)funcTable[372])(window);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[372])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWindowTitle(SDLWindowPtr window)
		{
			byte* ret = GetWindowTitleNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWindowTitleS(SDLWindowPtr window)
		{
			string ret = Utils.DecodeStringUTF8(GetWindowTitleNative((SDLWindow*)window));
			return ret;
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWindowTitle(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* ret = GetWindowTitleNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWindowTitleS(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				string ret = Utils.DecodeStringUTF8(GetWindowTitleNative((SDLWindow*)pwindow));
				return ret;
			}
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowIconNative(SDLWindow* window, SDLSurface* icon)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*, void>)funcTable[373])(window, icon);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[373])((nint)window, (nint)icon);
			#endif
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(SDLWindowPtr window, SDLSurfacePtr icon)
		{
			SetWindowIconNative((SDLWindow*)window, (SDLSurface*)icon);
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(ref SDLWindow window, SDLSurfacePtr icon)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowIconNative((SDLWindow*)pwindow, (SDLSurface*)icon);
			}
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(SDLWindowPtr window, ref SDLSurface icon)
		{
			fixed (SDLSurface* picon = &icon)
			{
				SetWindowIconNative((SDLWindow*)window, (SDLSurface*)picon);
			}
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowIcon(ref SDLWindow window, ref SDLSurface icon)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* picon = &icon)
				{
					SetWindowIconNative((SDLWindow*)pwindow, (SDLSurface*)picon);
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SetWindowDataNative(SDLWindow* window, byte* name, void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte*, void*, void*>)funcTable[374])(window, name, userdata);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)funcTable[374])((nint)window, (nint)name, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, byte* name, void* userdata)
		{
			void* ret = SetWindowDataNative((SDLWindow*)window, name, userdata);
			return ret;
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, byte* name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = SetWindowDataNative((SDLWindow*)pwindow, name, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, in byte name, void* userdata)
		{
			fixed (byte* pname = &name)
			{
				void* ret = SetWindowDataNative((SDLWindow*)window, (byte*)pname, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, ReadOnlySpan<byte> name, void* userdata)
		{
			fixed (byte* pname = name)
			{
				void* ret = SetWindowDataNative((SDLWindow*)window, (byte*)pname, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, string name, void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SetWindowDataNative((SDLWindow*)window, pStr0, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, in byte name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					void* ret = SetWindowDataNative((SDLWindow*)pwindow, (byte*)pname, userdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, ReadOnlySpan<byte> name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = name)
				{
					void* ret = SetWindowDataNative((SDLWindow*)pwindow, (byte*)pname, userdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, string name, void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = SetWindowDataNative((SDLWindow*)pwindow, pStr0, userdata);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, byte* name, nint userdata)
		{
			void* ret = SetWindowDataNative((SDLWindow*)window, name, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, byte* name, nint userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = SetWindowDataNative((SDLWindow*)pwindow, name, (void*)userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, in byte name, nint userdata)
		{
			fixed (byte* pname = &name)
			{
				void* ret = SetWindowDataNative((SDLWindow*)window, (byte*)pname, (void*)userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, ReadOnlySpan<byte> name, nint userdata)
		{
			fixed (byte* pname = name)
			{
				void* ret = SetWindowDataNative((SDLWindow*)window, (byte*)pname, (void*)userdata);
				return ret;
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(SDLWindowPtr window, string name, nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SetWindowDataNative((SDLWindow*)window, pStr0, (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, in byte name, nint userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					void* ret = SetWindowDataNative((SDLWindow*)pwindow, (byte*)pname, (void*)userdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, ReadOnlySpan<byte> name, nint userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = name)
				{
					void* ret = SetWindowDataNative((SDLWindow*)pwindow, (byte*)pname, (void*)userdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* SetWindowData(ref SDLWindow window, string name, nint userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = SetWindowDataNative((SDLWindow*)pwindow, pStr0, (void*)userdata);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetWindowDataNative(SDLWindow* window, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte*, void*>)funcTable[375])(window, name);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[375])((nint)window, (nint)name);
			#endif
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindowPtr window, byte* name)
		{
			void* ret = GetWindowDataNative((SDLWindow*)window, name);
			return ret;
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, byte* name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = GetWindowDataNative((SDLWindow*)pwindow, name);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindowPtr window, in byte name)
		{
			fixed (byte* pname = &name)
			{
				void* ret = GetWindowDataNative((SDLWindow*)window, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindowPtr window, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				void* ret = GetWindowDataNative((SDLWindow*)window, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(SDLWindowPtr window, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetWindowDataNative((SDLWindow*)window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, in byte name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					void* ret = GetWindowDataNative((SDLWindow*)pwindow, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, ReadOnlySpan<byte> name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = name)
				{
					void* ret = GetWindowDataNative((SDLWindow*)pwindow, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetWindowData(ref SDLWindow window, string name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = GetWindowDataNative((SDLWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Set the position of a window.<br/>
		/// The window coordinate origin is the upper left of the display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowPositionNative(SDLWindow* window, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[376])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[376])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Set the position of a window.<br/>
		/// The window coordinate origin is the upper left of the display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowPosition(SDLWindowPtr window, int x, int y)
		{
			SetWindowPositionNative((SDLWindow*)window, x, y);
		}

		/// <summary>
		/// Set the position of a window.<br/>
		/// The window coordinate origin is the upper left of the display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowPosition(ref SDLWindow window, int x, int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowPositionNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowPositionNative(SDLWindow* window, int* x, int* y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[377])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[377])((nint)window, (nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindowPtr window, int* x, int* y)
		{
			GetWindowPositionNative((SDLWindow*)window, x, y);
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, int* x, int* y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowPositionNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindowPtr window, ref int x, int* y)
		{
			fixed (int* px = &x)
			{
				GetWindowPositionNative((SDLWindow*)window, (int*)px, y);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, ref int x, int* y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* px = &x)
				{
					GetWindowPositionNative((SDLWindow*)pwindow, (int*)px, y);
				}
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindowPtr window, int* x, ref int y)
		{
			fixed (int* py = &y)
			{
				GetWindowPositionNative((SDLWindow*)window, x, (int*)py);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, int* x, ref int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* py = &y)
				{
					GetWindowPositionNative((SDLWindow*)pwindow, x, (int*)py);
				}
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(SDLWindowPtr window, ref int x, ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					GetWindowPositionNative((SDLWindow*)window, (int*)px, (int*)py);
				}
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowPosition(ref SDLWindow window, ref int x, ref int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* px = &x)
				{
					fixed (int* py = &y)
					{
						GetWindowPositionNative((SDLWindow*)pwindow, (int*)px, (int*)py);
					}
				}
			}
		}

		/// <summary>
		/// Set the size of a window's client area.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>
		/// Fullscreen windows automatically match the size of the display mode, and<br/>
		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowSizeNative(SDLWindow* window, int w, int h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[378])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[378])((nint)window, w, h);
			#endif
		}

		/// <summary>
		/// Set the size of a window's client area.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>
		/// Fullscreen windows automatically match the size of the display mode, and<br/>
		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowSize(SDLWindowPtr window, int w, int h)
		{
			SetWindowSizeNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Set the size of a window's client area.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>
		/// Fullscreen windows automatically match the size of the display mode, and<br/>
		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowSize(ref SDLWindow window, int w, int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[379])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[379])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindowPtr window, int* w, int* h)
		{
			GetWindowSizeNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindowPtr window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowSizeNative((SDLWindow*)window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindowPtr window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowSizeNative((SDLWindow*)window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(SDLWindowPtr window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowBordersSizeNative(SDLWindow* window, int* top, int* left, int* bottom, int* right)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, int*, int*, int>)funcTable[380])(window, top, left, bottom, right);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[380])((nint)window, (nint)top, (nint)left, (nint)bottom, (nint)right);
			#endif
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, int* left, int* bottom, int* right)
		{
			int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, bottom, right);
			return ret;
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, int* left, int* bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, bottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, ref int left, int* bottom, int* right)
		{
			fixed (int* pleft = &left)
			{
				int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, bottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, ref int left, int* bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, int* bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, int* left, ref int bottom, int* right)
		{
			fixed (int* pbottom = &bottom)
			{
				int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, (int*)pbottom, right);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, int* left, ref int bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, ref int left, ref int bottom, int* right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, ref int left, ref int bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, right);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, int* left, int* bottom, ref int right)
		{
			fixed (int* pright = &right)
			{
				int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, bottom, (int*)pright);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, int* left, int* bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, ref int left, int* bottom, ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, ref int left, int* bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, int* left, ref int bottom, ref int right)
		{
			fixed (int* pbottom = &bottom)
			{
				fixed (int* pright = &right)
				{
					int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, (int*)pbottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, int* left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, int* left, ref int bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, int* top, ref int left, ref int bottom, ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(SDLWindowPtr window, ref int top, ref int left, ref int bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							fixed (int* pright = &right)
							{
								int ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowSizeInPixelsNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[381])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[381])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindowPtr window, int* w, int* h)
		{
			GetWindowSizeInPixelsNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindowPtr window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowSizeInPixelsNative((SDLWindow*)window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindowPtr window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowSizeInPixelsNative((SDLWindow*)window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(SDLWindowPtr window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowSizeInPixelsNative((SDLWindow*)window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowSizeInPixels(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMinimumSizeNative(SDLWindow* window, int minW, int minH)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[382])(window, minW, minH);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[382])((nint)window, minW, minH);
			#endif
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMinimumSize(SDLWindowPtr window, int minW, int minH)
		{
			SetWindowMinimumSizeNative((SDLWindow*)window, minW, minH);
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMinimumSize(ref SDLWindow window, int minW, int minH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowMinimumSizeNative((SDLWindow*)pwindow, minW, minH);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowMinimumSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[383])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[383])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindowPtr window, int* w, int* h)
		{
			GetWindowMinimumSizeNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindowPtr window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowMinimumSizeNative((SDLWindow*)window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindowPtr window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowMinimumSizeNative((SDLWindow*)window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(SDLWindowPtr window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowMinimumSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMinimumSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMaximumSizeNative(SDLWindow* window, int maxW, int maxH)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)funcTable[384])(window, maxW, maxH);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[384])((nint)window, maxW, maxH);
			#endif
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMaximumSize(SDLWindowPtr window, int maxW, int maxH)
		{
			SetWindowMaximumSizeNative((SDLWindow*)window, maxW, maxH);
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMaximumSize(ref SDLWindow window, int maxW, int maxH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowMaximumSizeNative((SDLWindow*)pwindow, maxW, maxH);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowMaximumSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[385])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[385])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindowPtr window, int* w, int* h)
		{
			GetWindowMaximumSizeNative((SDLWindow*)window, w, h);
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindowPtr window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				GetWindowMaximumSizeNative((SDLWindow*)window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindowPtr window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				GetWindowMaximumSizeNative((SDLWindow*)window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(SDLWindowPtr window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					GetWindowMaximumSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetWindowMaximumSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowBorderedNative(SDLWindow* window, SDLBool bordered)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[386])(window, bordered);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[386])((nint)window, bordered);
			#endif
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowBordered(SDLWindowPtr window, SDLBool bordered)
		{
			SetWindowBorderedNative((SDLWindow*)window, bordered);
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowBordered(ref SDLWindow window, SDLBool bordered)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowBorderedNative((SDLWindow*)pwindow, bordered);
			}
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowResizableNative(SDLWindow* window, SDLBool resizable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[387])(window, resizable);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[387])((nint)window, resizable);
			#endif
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowResizable(SDLWindowPtr window, SDLBool resizable)
		{
			SetWindowResizableNative((SDLWindow*)window, resizable);
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowResizable(ref SDLWindow window, SDLBool resizable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowResizableNative((SDLWindow*)pwindow, resizable);
			}
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowAlwaysOnTopNative(SDLWindow* window, SDLBool onTop)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[388])(window, onTop);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[388])((nint)window, onTop);
			#endif
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowAlwaysOnTop(SDLWindowPtr window, SDLBool onTop)
		{
			SetWindowAlwaysOnTopNative((SDLWindow*)window, onTop);
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowAlwaysOnTop(ref SDLWindow window, SDLBool onTop)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowAlwaysOnTopNative((SDLWindow*)pwindow, onTop);
			}
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[389])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[389])((nint)window);
			#endif
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowWindow(SDLWindowPtr window)
		{
			ShowWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HideWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[390])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[390])((nint)window);
			#endif
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void HideWindow(SDLWindowPtr window)
		{
			HideWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void HideWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				HideWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Raise a window above other windows and set the input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RaiseWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[391])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[391])((nint)window);
			#endif
		}

		/// <summary>
		/// Raise a window above other windows and set the input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RaiseWindow(SDLWindowPtr window)
		{
			RaiseWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Raise a window above other windows and set the input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RaiseWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				RaiseWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Make a window as large as possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaximizeWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[392])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[392])((nint)window);
			#endif
		}

		/// <summary>
		/// Make a window as large as possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MaximizeWindow(SDLWindowPtr window)
		{
			MaximizeWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Make a window as large as possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MaximizeWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				MaximizeWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Minimize a window to an iconic representation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MinimizeWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[393])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[393])((nint)window);
			#endif
		}

		/// <summary>
		/// Minimize a window to an iconic representation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MinimizeWindow(SDLWindowPtr window)
		{
			MinimizeWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Minimize a window to an iconic representation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MinimizeWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				MinimizeWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Restore the size and position of a minimized or maximized window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RestoreWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[394])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[394])((nint)window);
			#endif
		}

		/// <summary>
		/// Restore the size and position of a minimized or maximized window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RestoreWindow(SDLWindowPtr window)
		{
			RestoreWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Restore the size and position of a minimized or maximized window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RestoreWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				RestoreWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Set a window's fullscreen state.<br/>
		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>
		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>
		/// that takes the size of the desktop; and 0 for windowed mode.<br/>
		/// Note that for some renderers, this function may trigger an<br/>
		/// SDL_RENDER_TARGETS_RESET event. Your application should be prepared to<br/>
		/// handle this event by reuploading textures!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowFullscreenNative(SDLWindow* window, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint, int>)funcTable[395])(window, flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[395])((nint)window, flags);
			#endif
		}

		/// <summary>
		/// Set a window's fullscreen state.<br/>
		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>
		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>
		/// that takes the size of the desktop; and 0 for windowed mode.<br/>
		/// Note that for some renderers, this function may trigger an<br/>
		/// SDL_RENDER_TARGETS_RESET event. Your application should be prepared to<br/>
		/// handle this event by reuploading textures!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowFullscreen(SDLWindowPtr window, uint flags)
		{
			int ret = SetWindowFullscreenNative((SDLWindow*)window, flags);
			return ret;
		}

		/// <summary>
		/// Set a window's fullscreen state.<br/>
		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>
		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>
		/// that takes the size of the desktop; and 0 for windowed mode.<br/>
		/// Note that for some renderers, this function may trigger an<br/>
		/// SDL_RENDER_TARGETS_RESET event. Your application should be prepared to<br/>
		/// handle this event by reuploading textures!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowFullscreen(ref SDLWindow window, uint flags)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowFullscreenNative((SDLWindow*)pwindow, flags);
				return ret;
			}
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool HasWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[396])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[396])((nint)window);
			#endif
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasWindowSurface(SDLWindowPtr window)
		{
			SDLBool ret = HasWindowSurfaceNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool HasWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = HasWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// Note that on some platforms the pixels pointer of the surface may be<br/>
		/// modified after each call to SDL_UpdateWindowSurface(), so that the platform<br/>
		/// code can implement efficient double or triple buffering.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* GetWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*>)funcTable[397])(window);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[397])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// Note that on some platforms the pixels pointer of the surface may be<br/>
		/// modified after each call to SDL_UpdateWindowSurface(), so that the platform<br/>
		/// code can implement efficient double or triple buffering.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurfacePtr GetWindowSurface(SDLWindowPtr window)
		{
			SDLSurfacePtr ret = GetWindowSurfaceNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// Note that on some platforms the pixels pointer of the surface may be<br/>
		/// modified after each call to SDL_UpdateWindowSurface(), so that the platform<br/>
		/// code can implement efficient double or triple buffering.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurfacePtr GetWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSurfacePtr ret = GetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[398])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[398])((nint)window);
			#endif
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurface(SDLWindowPtr window)
		{
			int ret = UpdateWindowSurfaceNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = UpdateWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateWindowSurfaceRectsNative(SDLWindow* window, SDLRect* rects, int numrects)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int, int>)funcTable[399])(window, rects, numrects);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[399])((nint)window, (nint)rects, numrects);
			#endif
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(SDLWindowPtr window, SDLRectPtr rects, int numrects)
		{
			int ret = UpdateWindowSurfaceRectsNative((SDLWindow*)window, (SDLRect*)rects, numrects);
			return ret;
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(ref SDLWindow window, SDLRectPtr rects, int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)rects, numrects);
				return ret;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(SDLWindowPtr window, in SDLRect rects, int numrects)
		{
			fixed (SDLRect* prects = &rects)
			{
				int ret = UpdateWindowSurfaceRectsNative((SDLWindow*)window, (SDLRect*)prects, numrects);
				return ret;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateWindowSurfaceRects(ref SDLWindow window, in SDLRect rects, int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prects = &rects)
				{
					int ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)prects, numrects);
					return ret;
				}
			}
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DestroyWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[400])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[400])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int DestroyWindowSurface(SDLWindowPtr window)
		{
			int ret = DestroyWindowSurfaceNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int DestroyWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = DestroyWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set a window's input grab mode.<br/>
		/// When input is grabbed, the mouse is confined to the window. This function<br/>
		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>
		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowGrabNative(SDLWindow* window, SDLBool grabbed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[401])(window, grabbed);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[401])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's input grab mode.<br/>
		/// When input is grabbed, the mouse is confined to the window. This function<br/>
		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>
		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowGrab(SDLWindowPtr window, SDLBool grabbed)
		{
			SetWindowGrabNative((SDLWindow*)window, grabbed);
		}

		/// <summary>
		/// Set a window's input grab mode.<br/>
		/// When input is grabbed, the mouse is confined to the window. This function<br/>
		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>
		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowGrab(ref SDLWindow window, SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowKeyboardGrabNative(SDLWindow* window, SDLBool grabbed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[402])(window, grabbed);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[402])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowKeyboardGrab(SDLWindowPtr window, SDLBool grabbed)
		{
			SetWindowKeyboardGrabNative((SDLWindow*)window, grabbed);
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowKeyboardGrab(ref SDLWindow window, SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowKeyboardGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMouseGrabNative(SDLWindow* window, SDLBool grabbed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool, void>)funcTable[403])(window, grabbed);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLBool, void>)funcTable[403])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMouseGrab(SDLWindowPtr window, SDLBool grabbed)
		{
			SetWindowMouseGrabNative((SDLWindow*)window, grabbed);
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetWindowMouseGrab(ref SDLWindow window, SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SetWindowMouseGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Get a window's input grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetWindowGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[404])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[404])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's input grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowGrab(SDLWindowPtr window)
		{
			SDLBool ret = GetWindowGrabNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get a window's input grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = GetWindowGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetWindowKeyboardGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[405])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[405])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowKeyboardGrab(SDLWindowPtr window)
		{
			SDLBool ret = GetWindowKeyboardGrabNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowKeyboardGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = GetWindowKeyboardGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool GetWindowMouseGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[406])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[406])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowMouseGrab(SDLWindowPtr window)
		{
			SDLBool ret = GetWindowMouseGrabNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetWindowMouseGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = GetWindowMouseGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetGrabbedWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[407])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[407])();
			#endif
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr GetGrabbedWindow()
		{
			SDLWindowPtr ret = GetGrabbedWindowNative();
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowMouseRectNative(SDLWindow* window, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int>)funcTable[408])(window, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[408])((nint)window, (nint)rect);
			#endif
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(SDLWindowPtr window, SDLRectPtr rect)
		{
			int ret = SetWindowMouseRectNative((SDLWindow*)window, (SDLRect*)rect);
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(ref SDLWindow window, SDLRectPtr rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)rect);
				return ret;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(SDLWindowPtr window, in SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SetWindowMouseRectNative((SDLWindow*)window, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowMouseRect(ref SDLWindow window, in SDLRect rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRect* GetWindowMouseRectNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*>)funcTable[409])(window);
			#else
			return (SDLRect*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[409])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRectPtr GetWindowMouseRect(SDLWindowPtr window)
		{
			SDLRectPtr ret = GetWindowMouseRectNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRectPtr GetWindowMouseRect(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRectPtr ret = GetWindowMouseRectNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method sets the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>
		/// brightness set will not follow the window if it is moved to another<br/>
		/// display.<br/>
		/// Many platforms will refuse to set the display brightness in modern times.<br/>
		/// You are better off using a shader to adjust gamma during rendering, or<br/>
		/// something similar.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowBrightnessNative(SDLWindow* window, float brightness)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, int>)funcTable[410])(window, brightness);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, int>)funcTable[410])((nint)window, brightness);
			#endif
		}

		/// <summary>
		/// Set the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method sets the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>
		/// brightness set will not follow the window if it is moved to another<br/>
		/// display.<br/>
		/// Many platforms will refuse to set the display brightness in modern times.<br/>
		/// You are better off using a shader to adjust gamma during rendering, or<br/>
		/// something similar.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowBrightness(SDLWindowPtr window, float brightness)
		{
			int ret = SetWindowBrightnessNative((SDLWindow*)window, brightness);
			return ret;
		}

		/// <summary>
		/// Set the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method sets the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>
		/// brightness set will not follow the window if it is moved to another<br/>
		/// display.<br/>
		/// Many platforms will refuse to set the display brightness in modern times.<br/>
		/// You are better off using a shader to adjust gamma during rendering, or<br/>
		/// something similar.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowBrightness(ref SDLWindow window, float brightness)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowBrightnessNative((SDLWindow*)pwindow, brightness);
				return ret;
			}
		}

		/// <summary>
		/// Get the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowBrightnessNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float>)funcTable[411])(window);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[411])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetWindowBrightness(SDLWindowPtr window)
		{
			float ret = GetWindowBrightnessNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetWindowBrightness(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				float ret = GetWindowBrightnessNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns -1 if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowOpacityNative(SDLWindow* window, float opacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, int>)funcTable[412])(window, opacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, int>)funcTable[412])((nint)window, opacity);
			#endif
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns -1 if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowOpacity(SDLWindowPtr window, float opacity)
		{
			int ret = SetWindowOpacityNative((SDLWindow*)window, opacity);
			return ret;
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns -1 if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowOpacity(ref SDLWindow window, float opacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowOpacityNative((SDLWindow*)pwindow, opacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowOpacityNative(SDLWindow* window, float* outOpacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float*, int>)funcTable[413])(window, outOpacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[413])((nint)window, (nint)outOpacity);
			#endif
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(SDLWindowPtr window, float* outOpacity)
		{
			int ret = GetWindowOpacityNative((SDLWindow*)window, outOpacity);
			return ret;
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(ref SDLWindow window, float* outOpacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowOpacityNative((SDLWindow*)pwindow, outOpacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(SDLWindowPtr window, ref float outOpacity)
		{
			fixed (float* poutOpacity = &outOpacity)
			{
				int ret = GetWindowOpacityNative((SDLWindow*)window, (float*)poutOpacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetWindowOpacity(ref SDLWindow window, ref float outOpacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* poutOpacity = &outOpacity)
				{
					int ret = GetWindowOpacityNative((SDLWindow*)pwindow, (float*)poutOpacity);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowModalForNative(SDLWindow* modalWindow, SDLWindow* parentWindow)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLWindow*, int>)funcTable[414])(modalWindow, parentWindow);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[414])((nint)modalWindow, (nint)parentWindow);
			#endif
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(SDLWindowPtr modalWindow, SDLWindowPtr parentWindow)
		{
			int ret = SetWindowModalForNative((SDLWindow*)modalWindow, (SDLWindow*)parentWindow);
			return ret;
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(ref SDLWindow modalWindow, SDLWindowPtr parentWindow)
		{
			fixed (SDLWindow* pmodalWindow = &modalWindow)
			{
				int ret = SetWindowModalForNative((SDLWindow*)pmodalWindow, (SDLWindow*)parentWindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(SDLWindowPtr modalWindow, ref SDLWindow parentWindow)
		{
			fixed (SDLWindow* pparentWindow = &parentWindow)
			{
				int ret = SetWindowModalForNative((SDLWindow*)modalWindow, (SDLWindow*)pparentWindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowModalFor(ref SDLWindow modalWindow, ref SDLWindow parentWindow)
		{
			fixed (SDLWindow* pmodalWindow = &modalWindow)
			{
				fixed (SDLWindow* pparentWindow = &parentWindow)
				{
					int ret = SetWindowModalForNative((SDLWindow*)pmodalWindow, (SDLWindow*)pparentWindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Explicitly set input focus to the window.<br/>
		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>
		/// this with caution, as you might give focus to a window that is completely<br/>
		/// obscured by other windows.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowInputFocusNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[415])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[415])((nint)window);
			#endif
		}

		/// <summary>
		/// Explicitly set input focus to the window.<br/>
		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>
		/// this with caution, as you might give focus to a window that is completely<br/>
		/// obscured by other windows.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowInputFocus(SDLWindowPtr window)
		{
			int ret = SetWindowInputFocusNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Explicitly set input focus to the window.<br/>
		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>
		/// this with caution, as you might give focus to a window that is completely<br/>
		/// obscured by other windows.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowInputFocus(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowInputFocusNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowGammaRampNative(SDLWindow* window, ushort* red, ushort* green, ushort* blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, ushort*, ushort*, ushort*, int>)funcTable[416])(window, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[416])((nint)window, (nint)red, (nint)green, (nint)blue);
			#endif
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, ushort* red, ushort* green, ushort* blue)
		{
			int ret = SetWindowGammaRampNative((SDLWindow*)window, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, in ushort red, ushort* green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				int ret = SetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, in ushort red, ushort* green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, ushort* red, in ushort green, ushort* blue)
		{
			fixed (ushort* pgreen = &green)
			{
				int ret = SetWindowGammaRampNative((SDLWindow*)window, red, (ushort*)pgreen, blue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, in ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, in ushort red, in ushort green, ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, in ushort red, in ushort green, ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, blue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, ushort* red, ushort* green, in ushort blue)
		{
			fixed (ushort* pblue = &blue)
			{
				int ret = SetWindowGammaRampNative((SDLWindow*)window, red, green, (ushort*)pblue);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, ushort* green, in ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, in ushort red, ushort* green, in ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, in ushort red, ushort* green, in ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, ushort* red, in ushort green, in ushort blue)
		{
			fixed (ushort* pgreen = &green)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SetWindowGammaRampNative((SDLWindow*)window, red, (ushort*)pgreen, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(ref SDLWindow window, ushort* red, in ushort green, in ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowGammaRamp(SDLWindowPtr window, in ushort red, in ushort green, in ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SetWindowGammaRampNative((SDLWindow*)window, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}
	}
}
