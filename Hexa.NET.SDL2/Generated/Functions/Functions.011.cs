// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetHintBoolean(ReadOnlySpan<byte> name, SDLBool defaultValue)
		{
			fixed (byte* pname = name)
			{
				SDLBool ret = GetHintBooleanNative((byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool GetHintBoolean(string name, SDLBool defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = GetHintBooleanNative(pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddHintCallbackNative(byte* name, SDLHintCallback callback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, byte*, byte*, byte*, void>, void*, void>)funcTable[695])(name, (delegate*<void*, byte*, byte*, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[695])((nint)name, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AddHintCallback(byte* name, SDLHintCallback callback, void* userdata)
		{
			AddHintCallbackNative(name, callback, userdata);
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AddHintCallback(ref byte name, SDLHintCallback callback, void* userdata)
		{
			fixed (byte* pname = &name)
			{
				AddHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AddHintCallback(ReadOnlySpan<byte> name, SDLHintCallback callback, void* userdata)
		{
			fixed (byte* pname = name)
			{
				AddHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AddHintCallback(string name, SDLHintCallback callback, void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DelHintCallbackNative(byte* name, SDLHintCallback callback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, byte*, byte*, byte*, void>, void*, void>)funcTable[696])(name, (delegate*<void*, byte*, byte*, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[696])((nint)name, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DelHintCallback(byte* name, SDLHintCallback callback, void* userdata)
		{
			DelHintCallbackNative(name, callback, userdata);
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DelHintCallback(ref byte name, SDLHintCallback callback, void* userdata)
		{
			fixed (byte* pname = &name)
			{
				DelHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DelHintCallback(ReadOnlySpan<byte> name, SDLHintCallback callback, void* userdata)
		{
			fixed (byte* pname = name)
			{
				DelHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DelHintCallback(string name, SDLHintCallback callback, void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DelHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Clear all hints.<br/>
		/// This function is automatically called during SDL_Quit(), and deletes all<br/>
		/// callbacks without calling them and frees all memory associated with hints.<br/>
		/// If you're calling this from application code you probably want to call<br/>
		/// SDL_ResetHints() instead.<br/>
		/// This function will be removed from the API the next time we rev the ABI.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearHintsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[697])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[697])();
			#endif
		}

		/// <summary>
		/// Clear all hints.<br/>
		/// This function is automatically called during SDL_Quit(), and deletes all<br/>
		/// callbacks without calling them and frees all memory associated with hints.<br/>
		/// If you're calling this from application code you probably want to call<br/>
		/// SDL_ResetHints() instead.<br/>
		/// This function will be removed from the API the next time we rev the ABI.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ClearHints()
		{
			ClearHintsNative();
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadObjectNative(byte* sofile)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*>)funcTable[698])(sofile);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[698])((nint)sofile);
			#endif
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadObject(byte* sofile)
		{
			void* ret = LoadObjectNative(sofile);
			return ret;
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadObject(ref byte sofile)
		{
			fixed (byte* psofile = &sofile)
			{
				void* ret = LoadObjectNative((byte*)psofile);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadObject(ReadOnlySpan<byte> sofile)
		{
			fixed (byte* psofile = sofile)
			{
				void* ret = LoadObjectNative((byte*)psofile);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadObject(string sofile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sofile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sofile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sofile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = LoadObjectNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadFunctionNative(void* handle, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, byte*, void*>)funcTable[699])(handle, name);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[699])((nint)handle, (nint)name);
			#endif
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFunction(void* handle, byte* name)
		{
			void* ret = LoadFunctionNative(handle, name);
			return ret;
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFunction(void* handle, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				void* ret = LoadFunctionNative(handle, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFunction(void* handle, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				void* ret = LoadFunctionNative(handle, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* LoadFunction(void* handle, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = LoadFunctionNative(handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload a shared object from memory.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadObjectNative(void* handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[700])(handle);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[700])((nint)handle);
			#endif
		}

		/// <summary>
		/// Unload a shared object from memory.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnloadObject(void* handle)
		{
			UnloadObjectNative(handle);
		}

		/// <summary>
		/// Set the priority of all log categories.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogSetAllPriorityNative(SDLLogPriority priority)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLLogPriority, void>)funcTable[701])(priority);
			#else
			((delegate* unmanaged[Cdecl]<SDLLogPriority, void>)funcTable[701])(priority);
			#endif
		}

		/// <summary>
		/// Set the priority of all log categories.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogSetAllPriority(SDLLogPriority priority)
		{
			LogSetAllPriorityNative(priority);
		}

		/// <summary>
		/// Set the priority of a particular log category.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogSetPriorityNative(int category, SDLLogPriority priority)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, void>)funcTable[702])(category, priority);
			#else
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, void>)funcTable[702])(category, priority);
			#endif
		}

		/// <summary>
		/// Set the priority of a particular log category.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogSetPriority(int category, SDLLogPriority priority)
		{
			LogSetPriorityNative(category, priority);
		}

		/// <summary>
		/// Get the priority of a particular log category.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLLogPriority LogGetPriorityNative(int category)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLLogPriority>)funcTable[703])(category);
			#else
			return (SDLLogPriority)((delegate* unmanaged[Cdecl]<int, SDLLogPriority>)funcTable[703])(category);
			#endif
		}

		/// <summary>
		/// Get the priority of a particular log category.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLLogPriority LogGetPriority(int category)
		{
			SDLLogPriority ret = LogGetPriorityNative(category);
			return ret;
		}

		/// <summary>
		/// Reset all priorities to default.<br/>
		/// This is called by SDL_Quit().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogResetPrioritiesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[704])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[704])();
			#endif
		}

		/// <summary>
		/// Reset all priorities to default.<br/>
		/// This is called by SDL_Quit().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogResetPriorities()
		{
			LogResetPrioritiesNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[705])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[705])((nint)fmt);
			#endif
		}

		public static void Log(byte* fmt)
		{
			LogNative(fmt);
		}

		public static void Log(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogNative((byte*)pfmt);
			}
		}

		public static void Log(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogNative((byte*)pfmt);
			}
		}

		public static void Log(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogVerboseNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[706])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[706])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogVerbose(int category, byte* fmt)
		{
			LogVerboseNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogVerbose(int category, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogVerboseNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogVerbose(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogVerboseNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogVerbose(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogVerboseNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogDebugNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[707])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[707])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogDebug(int category, byte* fmt)
		{
			LogDebugNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogDebug(int category, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogDebugNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogDebug(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogDebugNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogDebug(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogDebugNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogInfoNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[708])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[708])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogInfo(int category, byte* fmt)
		{
			LogInfoNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogInfo(int category, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogInfoNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogInfo(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogInfoNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogInfo(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogInfoNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogWarnNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[709])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[709])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, byte* fmt)
		{
			LogWarnNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogWarnNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogWarnNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogWarn(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogWarnNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogErrorNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[710])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[710])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, byte* fmt)
		{
			LogErrorNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogErrorNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogErrorNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogError(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogErrorNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogCriticalNative(int category, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[711])(category, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[711])(category, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, byte* fmt)
		{
			LogCriticalNative(category, fmt);
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogCriticalNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogCriticalNative(category, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogCritical(int category, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogCriticalNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogMessageNative(int category, SDLLogPriority priority, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, byte*, void>)funcTable[712])(category, priority, fmt);
			#else
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, nint, void>)funcTable[712])(category, priority, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, byte* fmt)
		{
			LogMessageNative(category, priority, fmt);
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogMessageNative(category, priority, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LogMessageNative(category, priority, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessage(int category, SDLLogPriority priority, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogMessageNative(category, priority, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogMessageVNative(int category, SDLLogPriority priority, byte* fmt, nint ap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, byte*, nint, void>)funcTable[713])(category, priority, fmt, ap);
			#else
			((delegate* unmanaged[Cdecl]<int, SDLLogPriority, nint, nint, void>)funcTable[713])(category, priority, (nint)fmt, ap);
			#endif
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, byte* fmt, nint ap)
		{
			LogMessageVNative(category, priority, fmt, ap);
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, ref byte fmt, nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogMessageVNative(category, priority, (byte*)pfmt, ap);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, ReadOnlySpan<byte> fmt, nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				LogMessageVNative(category, priority, (byte*)pfmt, ap);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogMessageV(int category, SDLLogPriority priority, string fmt, nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogMessageVNative(category, priority, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Get the current log output function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogGetOutputFunctionNative(delegate*<void*, int, SDLLogPriority, byte*, void>* callback, void** userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, int, SDLLogPriority, byte*, void>*, void**, void>)funcTable[714])(callback, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[714])((nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Get the current log output function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogGetOutputFunction(delegate*<void*, int, SDLLogPriority, byte*, void>* callback, void** userdata)
		{
			LogGetOutputFunctionNative(callback, userdata);
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogSetOutputFunctionNative(SDLLogOutputFunction callback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, int, SDLLogPriority, byte*, void>, void*, void>)funcTable[715])((delegate*<void*, int, SDLLogPriority, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[715])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LogSetOutputFunction(SDLLogOutputFunction callback, void* userdata)
		{
			LogSetOutputFunctionNative(callback, userdata);
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShowMessageBoxNative(SDLMessageBoxData* messageboxdata, int* buttonid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMessageBoxData*, int*, int>)funcTable[716])(messageboxdata, buttonid);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[716])((nint)messageboxdata, (nint)buttonid);
			#endif
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(SDLMessageBoxData* messageboxdata, int* buttonid)
		{
			int ret = ShowMessageBoxNative(messageboxdata, buttonid);
			return ret;
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(ref SDLMessageBoxData messageboxdata, int* buttonid)
		{
			fixed (SDLMessageBoxData* pmessageboxdata = &messageboxdata)
			{
				int ret = ShowMessageBoxNative((SDLMessageBoxData*)pmessageboxdata, buttonid);
				return ret;
			}
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(SDLMessageBoxData* messageboxdata, ref int buttonid)
		{
			fixed (int* pbuttonid = &buttonid)
			{
				int ret = ShowMessageBoxNative(messageboxdata, (int*)pbuttonid);
				return ret;
			}
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowMessageBox(ref SDLMessageBoxData messageboxdata, ref int buttonid)
		{
			fixed (SDLMessageBoxData* pmessageboxdata = &messageboxdata)
			{
				fixed (int* pbuttonid = &buttonid)
				{
					int ret = ShowMessageBoxNative((SDLMessageBoxData*)pmessageboxdata, (int*)pbuttonid);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShowSimpleMessageBoxNative(uint flags, byte* title, byte* message, SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, SDLWindow*, int>)funcTable[717])(flags, title, message, window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, int>)funcTable[717])(flags, (nint)title, (nint)message, (nint)window);
			#endif
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, byte* message, SDLWindow* window)
		{
			int ret = ShowSimpleMessageBoxNative(flags, title, message, window);
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ref byte title, byte* message, SDLWindow* window)
		{
			fixed (byte* ptitle = &title)
			{
				int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, byte* message, SDLWindow* window)
		{
			fixed (byte* ptitle = title)
			{
				int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, byte* message, SDLWindow* window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ShowSimpleMessageBoxNative(flags, pStr0, message, window);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, ref byte message, SDLWindow* window)
		{
			fixed (byte* pmessage = &message)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, ReadOnlySpan<byte> message, SDLWindow* window)
		{
			fixed (byte* pmessage = message)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, window);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, string message, SDLWindow* window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ShowSimpleMessageBoxNative(flags, title, pStr0, window);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ref byte title, ref byte message, SDLWindow* window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (byte* pmessage = &message)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, window);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, ReadOnlySpan<byte> message, SDLWindow* window)
		{
			fixed (byte* ptitle = title)
			{
				fixed (byte* pmessage = message)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, window);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, string message, SDLWindow* window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (message != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(message);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(message, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ShowSimpleMessageBoxNative(flags, pStr0, pStr1, window);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, byte* message, ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, message, (SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ref byte title, byte* message, ref SDLWindow window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, byte* message, ref SDLWindow window)
		{
			fixed (byte* ptitle = title)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, byte* message, ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, pStr0, message, (SDLWindow*)pwindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, ref byte message, ref SDLWindow window)
		{
			fixed (byte* pmessage = &message)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, ReadOnlySpan<byte> message, ref SDLWindow window)
		{
			fixed (byte* pmessage = message)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = ShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, byte* title, string message, ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, title, pStr0, (SDLWindow*)pwindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ref byte title, ref byte message, ref SDLWindow window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (byte* pmessage = &message)
				{
					fixed (SDLWindow* pwindow = &window)
					{
						int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, (SDLWindow*)pwindow);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, ReadOnlySpan<byte> title, ReadOnlySpan<byte> message, ref SDLWindow window)
		{
			fixed (byte* ptitle = title)
			{
				fixed (byte* pmessage = message)
				{
					fixed (SDLWindow* pwindow = &window)
					{
						int ret = ShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, (SDLWindow*)pwindow);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ShowSimpleMessageBox(uint flags, string title, string message, ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (message != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(message);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(message, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ShowSimpleMessageBoxNative(flags, pStr0, pStr1, (SDLWindow*)pwindow);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
		/// window.<br/>
		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
		/// its own. It is up to user code to do that.<br/>
		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLMetalView MetalCreateViewNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLMetalView>)funcTable[718])(window);
			#else
			return (SDLMetalView)((delegate* unmanaged[Cdecl]<nint, SDLMetalView>)funcTable[718])((nint)window);
			#endif
		}

		/// <summary>
		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
		/// window.<br/>
		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
		/// its own. It is up to user code to do that.<br/>
		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLMetalView MetalCreateView(SDLWindow* window)
		{
			SDLMetalView ret = MetalCreateViewNative(window);
			return ret;
		}

		/// <summary>
		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
		/// window.<br/>
		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
		/// its own. It is up to user code to do that.<br/>
		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLMetalView MetalCreateView(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLMetalView ret = MetalCreateViewNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Destroy an existing SDL_MetalView object.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>
		/// called after SDL_CreateWindow.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MetalDestroyViewNative(SDLMetalView view)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMetalView, void>)funcTable[719])(view);
			#else
			((delegate* unmanaged[Cdecl]<SDLMetalView, void>)funcTable[719])(view);
			#endif
		}

		/// <summary>
		/// Destroy an existing SDL_MetalView object.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>
		/// called after SDL_CreateWindow.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalDestroyView(SDLMetalView view)
		{
			MetalDestroyViewNative(view);
		}

		/// <summary>
		/// Get a pointer to the backing CAMetalLayer for the given view.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MetalGetLayerNative(SDLMetalView view)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMetalView, void*>)funcTable[720])(view);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<SDLMetalView, nint>)funcTable[720])(view);
			#endif
		}

		/// <summary>
		/// Get a pointer to the backing CAMetalLayer for the given view.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* MetalGetLayer(SDLMetalView view)
		{
			void* ret = MetalGetLayerNative(view);
			return ret;
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MetalGetDrawableSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)funcTable[721])(window, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[721])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindow* window, int* w, int* h)
		{
			MetalGetDrawableSizeNative(window, w, h);
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				MetalGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				MetalGetDrawableSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					MetalGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				MetalGetDrawableSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					MetalGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					MetalGetDrawableSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MetalGetDrawableSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						MetalGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetPowerInfoNative(int* seconds, int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, SDLPowerState>)funcTable[722])(seconds, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[722])((nint)seconds, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(int* seconds, int* percent)
		{
			SDLPowerState ret = GetPowerInfoNative(seconds, percent);
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(ref int seconds, int* percent)
		{
			fixed (int* pseconds = &seconds)
			{
				SDLPowerState ret = GetPowerInfoNative((int*)pseconds, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(int* seconds, ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetPowerInfoNative(seconds, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(ref int seconds, ref int percent)
		{
			fixed (int* pseconds = &seconds)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetPowerInfoNative((int*)pseconds, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of 2D rendering drivers available for the current display.<br/>
		/// A render driver is a set of code that handles rendering and texture<br/>
		/// management on a particular display. Normally there is only one, but some<br/>
		/// drivers may have several available with different capabilities.<br/>
		/// There may be none if SDL was compiled without render support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumRenderDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[723])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[723])();
			#endif
		}

		/// <summary>
		/// Get the number of 2D rendering drivers available for the current display.<br/>
		/// A render driver is a set of code that handles rendering and texture<br/>
		/// management on a particular display. Normally there is only one, but some<br/>
		/// drivers may have several available with different capabilities.<br/>
		/// There may be none if SDL was compiled without render support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumRenderDrivers()
		{
			int ret = GetNumRenderDriversNative();
			return ret;
		}

		/// <summary>
		/// Get info about a specific 2D rendering driver for the current display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRenderDriverInfoNative(int index, SDLRendererInfo* info)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLRendererInfo*, int>)funcTable[724])(index, info);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[724])(index, (nint)info);
			#endif
		}

		/// <summary>
		/// Get info about a specific 2D rendering driver for the current display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRenderDriverInfo(int index, SDLRendererInfo* info)
		{
			int ret = GetRenderDriverInfoNative(index, info);
			return ret;
		}

		/// <summary>
		/// Get info about a specific 2D rendering driver for the current display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRenderDriverInfo(int index, ref SDLRendererInfo info)
		{
			fixed (SDLRendererInfo* pinfo = &info)
			{
				int ret = GetRenderDriverInfoNative(index, (SDLRendererInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateWindowAndRendererNative(int width, int height, uint windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, uint, SDLWindow**, SDLRenderer**, int>)funcTable[725])(width, height, windowFlags, window, renderer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, uint, nint, nint, int>)funcTable[725])(width, height, windowFlags, (nint)window, (nint)renderer);
			#endif
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			int ret = CreateWindowAndRendererNative(width, height, windowFlags, window, renderer);
			return ret;
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, ref SDLWindow* window, SDLRenderer** renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				int ret = CreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)pwindow, renderer);
				return ret;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, SDLWindow** window, ref SDLRenderer* renderer)
		{
			fixed (SDLRenderer** prenderer = &renderer)
			{
				int ret = CreateWindowAndRendererNative(width, height, windowFlags, window, (SDLRenderer**)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateWindowAndRenderer(int width, int height, uint windowFlags, ref SDLWindow* window, ref SDLRenderer* renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				fixed (SDLRenderer** prenderer = &renderer)
				{
					int ret = CreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)prenderer);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* CreateRendererNative(SDLWindow* window, int index, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, uint, SDLRenderer*>)funcTable[726])(window, index, flags);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, int, uint, nint>)funcTable[726])((nint)window, index, flags);
			#endif
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(SDLWindow* window, int index, uint flags)
		{
			SDLRenderer* ret = CreateRendererNative(window, index, flags);
			return ret;
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(ref SDLWindow window, int index, uint flags)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRenderer* ret = CreateRendererNative((SDLWindow*)pwindow, index, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* CreateSoftwareRendererNative(SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRenderer*>)funcTable[727])(surface);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[727])((nint)surface);
			#endif
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateSoftwareRenderer(SDLSurface* surface)
		{
			SDLRenderer* ret = CreateSoftwareRendererNative(surface);
			return ret;
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateSoftwareRenderer(ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLRenderer* ret = CreateSoftwareRendererNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* GetRendererNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRenderer*>)funcTable[728])(window);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[728])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* GetRenderer(SDLWindow* window)
		{
			SDLRenderer* ret = GetRendererNative(window);
			return ret;
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* GetRenderer(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRenderer* ret = GetRendererNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* RenderGetWindowNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLWindow*>)funcTable[729])(renderer);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[729])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* RenderGetWindow(SDLRenderer* renderer)
		{
			SDLWindow* ret = RenderGetWindowNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* RenderGetWindow(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLWindow* ret = RenderGetWindowNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRendererInfoNative(SDLRenderer* renderer, SDLRendererInfo* info)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRendererInfo*, int>)funcTable[730])(renderer, info);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[730])((nint)renderer, (nint)info);
			#endif
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(SDLRenderer* renderer, SDLRendererInfo* info)
		{
			int ret = GetRendererInfoNative(renderer, info);
			return ret;
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(ref SDLRenderer renderer, SDLRendererInfo* info)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = GetRendererInfoNative((SDLRenderer*)prenderer, info);
				return ret;
			}
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(SDLRenderer* renderer, ref SDLRendererInfo info)
		{
			fixed (SDLRendererInfo* pinfo = &info)
			{
				int ret = GetRendererInfoNative(renderer, (SDLRendererInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererInfo(ref SDLRenderer renderer, ref SDLRendererInfo info)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRendererInfo* pinfo = &info)
				{
					int ret = GetRendererInfoNative((SDLRenderer*)prenderer, (SDLRendererInfo*)pinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRendererOutputSizeNative(SDLRenderer* renderer, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int*, int*, int>)funcTable[731])(renderer, w, h);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[731])((nint)renderer, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRenderer* renderer, int* w, int* h)
		{
			int ret = GetRendererOutputSizeNative(renderer, w, h);
			return ret;
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, int* w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRenderer* renderer, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				int ret = GetRendererOutputSizeNative(renderer, (int*)pw, h);
				return ret;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, ref int w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRenderer* renderer, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				int ret = GetRendererOutputSizeNative(renderer, w, (int*)ph);
				return ret;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, int* w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(SDLRenderer* renderer, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					int ret = GetRendererOutputSizeNative(renderer, (int*)pw, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetRendererOutputSize(ref SDLRenderer renderer, ref int w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = GetRendererOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// You can set the texture scaling method by setting<br/>
		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* CreateTextureNative(SDLRenderer* renderer, uint format, int access, int w, int h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, uint, int, int, int, SDLTexture*>)funcTable[732])(renderer, format, access, w, h);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, uint, int, int, int, nint>)funcTable[732])((nint)renderer, format, access, w, h);
			#endif
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// You can set the texture scaling method by setting<br/>
		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTexture(SDLRenderer* renderer, uint format, int access, int w, int h)
		{
			SDLTexture* ret = CreateTextureNative(renderer, format, access, w, h);
			return ret;
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// You can set the texture scaling method by setting<br/>
		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTexture(ref SDLRenderer renderer, uint format, int access, int w, int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = CreateTextureNative((SDLRenderer*)prenderer, format, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* CreateTextureFromSurfaceNative(SDLRenderer* renderer, SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLSurface*, SDLTexture*>)funcTable[733])(renderer, surface);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[733])((nint)renderer, (nint)surface);
			#endif
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(SDLRenderer* renderer, SDLSurface* surface)
		{
			SDLTexture* ret = CreateTextureFromSurfaceNative(renderer, surface);
			return ret;
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(ref SDLRenderer renderer, SDLSurface* surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, surface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(SDLRenderer* renderer, ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLTexture* ret = CreateTextureFromSurfaceNative(renderer, (SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(ref SDLRenderer renderer, ref SDLSurface surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLSurface* psurface = &surface)
				{
					SDLTexture* ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, (SDLSurface*)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int QueryTextureNative(SDLTexture* texture, uint* format, int* access, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, uint*, int*, int*, int*, int>)funcTable[734])(texture, format, access, w, h);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[734])((nint)texture, (nint)format, (nint)access, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, int* access, int* w, int* h)
		{
			int ret = QueryTextureNative(texture, format, access, w, h);
			return ret;
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, int* access, int* w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				int ret = QueryTextureNative(texture, (uint*)pformat, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, ref int access, int* w, int* h)
		{
			fixed (int* paccess = &access)
			{
				int ret = QueryTextureNative(texture, format, (int*)paccess, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, ref int access, int* w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, int* w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, int* access, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				int ret = QueryTextureNative(texture, format, access, (int*)pw, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, int* access, ref int w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative(texture, (uint*)pformat, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, ref int access, ref int w, int* h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative(texture, format, (int*)paccess, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, ref int access, ref int w, int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, ref int w, int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, h);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, int* access, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				int ret = QueryTextureNative(texture, format, access, w, (int*)ph);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, int* access, int* w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative(texture, (uint*)pformat, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, ref int access, int* w, ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative(texture, format, (int*)paccess, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, ref int access, int* w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, int* w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, int* access, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative(texture, format, access, (int*)pw, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, int* access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, int* access, ref int w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative(texture, (uint*)pformat, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, int* access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, uint* format, ref int access, ref int w, ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative(texture, format, (int*)paccess, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, uint* format, ref int access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(SDLTexture* texture, ref uint format, ref int access, ref int w, ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int QueryTexture(ref SDLTexture texture, ref uint format, ref int access, ref int w, ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							fixed (int* ph = &h)
							{
								int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureColorModNative(SDLTexture* texture, byte r, byte g, byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, byte, byte, int>)funcTable[735])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)funcTable[735])((nint)texture, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureColorMod(SDLTexture* texture, byte r, byte g, byte b)
		{
			int ret = SetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureColorMod(ref SDLTexture texture, byte r, byte g, byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureColorModNative(SDLTexture* texture, byte* r, byte* g, byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, byte*, byte*, int>)funcTable[736])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[736])((nint)texture, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, byte* r, byte* g, byte* b)
		{
			int ret = GetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, byte* g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, ref byte r, byte* g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = GetTextureColorModNative(texture, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, byte* g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, byte* r, ref byte g, byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = GetTextureColorModNative(texture, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, ref byte g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, ref byte r, ref byte g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetTextureColorModNative(texture, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, b);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, byte* r, byte* g, ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = GetTextureColorModNative(texture, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, byte* g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, ref byte r, byte* g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative(texture, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, byte* r, ref byte g, ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative(texture, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(SDLTexture* texture, ref byte r, ref byte g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative(texture, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureColorMod(ref SDLTexture texture, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureAlphaModNative(SDLTexture* texture, byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, int>)funcTable[737])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)funcTable[737])((nint)texture, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureAlphaMod(SDLTexture* texture, byte alpha)
		{
			int ret = SetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureAlphaMod(ref SDLTexture texture, byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureAlphaModNative(SDLTexture* texture, byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, int>)funcTable[738])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[738])((nint)texture, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(SDLTexture* texture, byte* alpha)
		{
			int ret = GetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(ref SDLTexture texture, byte* alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(SDLTexture* texture, ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				int ret = GetTextureAlphaModNative(texture, (byte*)palpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureAlphaMod(ref SDLTexture texture, ref byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* palpha = &alpha)
				{
					int ret = GetTextureAlphaModNative((SDLTexture*)ptexture, (byte*)palpha);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureBlendModeNative(SDLTexture* texture, SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode, int>)funcTable[739])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, int>)funcTable[739])((nint)texture, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureBlendMode(SDLTexture* texture, SDLBlendMode blendMode)
		{
			int ret = SetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureBlendMode(ref SDLTexture texture, SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureBlendModeNative(SDLTexture* texture, SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode*, int>)funcTable[740])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[740])((nint)texture, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(SDLTexture* texture, SDLBlendMode* blendMode)
		{
			int ret = GetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(ref SDLTexture texture, SDLBlendMode* blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(SDLTexture* texture, ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = GetTextureBlendModeNative(texture, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureBlendMode(ref SDLTexture texture, ref SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					int ret = GetTextureBlendModeNative((SDLTexture*)ptexture, (SDLBlendMode*)pblendMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureScaleModeNative(SDLTexture* texture, SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode, int>)funcTable[741])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLScaleMode, int>)funcTable[741])((nint)texture, scaleMode);
			#endif
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureScaleMode(SDLTexture* texture, SDLScaleMode scaleMode)
		{
			int ret = SetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetTextureScaleMode(ref SDLTexture texture, SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureScaleModeNative(SDLTexture* texture, SDLScaleMode* scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode*, int>)funcTable[742])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[742])((nint)texture, (nint)scaleMode);
			#endif
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(SDLTexture* texture, SDLScaleMode* scaleMode)
		{
			int ret = GetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(ref SDLTexture texture, SDLScaleMode* scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(SDLTexture* texture, ref SDLScaleMode scaleMode)
		{
			fixed (SDLScaleMode* pscaleMode = &scaleMode)
			{
				int ret = GetTextureScaleModeNative(texture, (SDLScaleMode*)pscaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetTextureScaleMode(ref SDLTexture texture, ref SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLScaleMode* pscaleMode = &scaleMode)
				{
					int ret = GetTextureScaleModeNative((SDLTexture*)ptexture, (SDLScaleMode*)pscaleMode);
					return ret;
				}
			}
		}
	}
}
