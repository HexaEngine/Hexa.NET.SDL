// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass,<br/>
		/// returning a string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		public static string IconvStringS(string tocode, string fromcode, string inbuf, nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, pStr1, pStr2, inbytesleft));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MainNative(int argc, byte** argv)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte**, int>)funcTable[127])(argc, argv);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[127])(argc, (nint)argv);
			#endif
		}

		public static int Main(int argc, byte** argv)
		{
			int ret = MainNative(argc, argv);
			return ret;
		}

		public static int Main(int argc, ref byte* argv)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = MainNative(argc, (byte**)pargv);
				return ret;
			}
		}

		public static int Main(int argc, string[] argv)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = MainNative(argc, pStrArray0);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMainReadyNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[128])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[128])();
			#endif
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetMainReady()
		{
			SetMainReadyNative();
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RegisterAppNative(byte* name, uint style, void* hInst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, void*, int>)funcTable[129])(name, style, hInst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, nint, int>)funcTable[129])((nint)name, style, (nint)hInst);
			#endif
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(byte* name, uint style, void* hInst)
		{
			int ret = RegisterAppNative(name, style, hInst);
			return ret;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(in byte name, uint style, void* hInst)
		{
			fixed (byte* pname = &name)
			{
				int ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(ReadOnlySpan<byte> name, uint style, void* hInst)
		{
			fixed (byte* pname = name)
			{
				int ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(string name, uint style, void* hInst)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = RegisterAppNative(pStr0, style, hInst);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(byte* name, uint style, nint hInst)
		{
			int ret = RegisterAppNative(name, style, (void*)hInst);
			return ret;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(in byte name, uint style, nint hInst)
		{
			fixed (byte* pname = &name)
			{
				int ret = RegisterAppNative((byte*)pname, style, (void*)hInst);
				return ret;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(ReadOnlySpan<byte> name, uint style, nint hInst)
		{
			fixed (byte* pname = name)
			{
				int ret = RegisterAppNative((byte*)pname, style, (void*)hInst);
				return ret;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RegisterApp(string name, uint style, nint hInst)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = RegisterAppNative(pStr0, style, (void*)hInst);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnregisterAppNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[130])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[130])();
			#endif
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		public static void UnregisterApp()
		{
			UnregisterAppNative();
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugbreakNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[131])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[131])();
			#endif
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		public static void Debugbreak()
		{
			DebugbreakNative();
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAssertionHandlerNative(delegate*<SDLAssertData*, void*, SDLAssertState> handler, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<SDLAssertData*, void*, SDLAssertState>, void*, void>)funcTable[132])(handler, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[132])((nint)handler, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetAssertionHandler(delegate*<SDLAssertData*, void*, SDLAssertState> handler, void* userdata)
		{
			SetAssertionHandlerNative(handler, userdata);
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetAssertionHandler(SDLAssertionHandler handler, void* userdata)
		{
			SetAssertionHandlerNative((delegate*<SDLAssertData*, void*, SDLAssertState>)Utils.GetFunctionPointerForDelegate(handler), userdata);
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetAssertionHandler(delegate*<SDLAssertData*, void*, SDLAssertState> handler, nint userdata)
		{
			SetAssertionHandlerNative(handler, (void*)userdata);
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetAssertionHandler(SDLAssertionHandler handler, nint userdata)
		{
			SetAssertionHandlerNative((delegate*<SDLAssertData*, void*, SDLAssertState>)Utils.GetFunctionPointerForDelegate(handler), (void*)userdata);
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<SDLAssertData*, void*, SDLAssertState> GetDefaultAssertionHandlerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<SDLAssertData*, void*, SDLAssertState>>)funcTable[133])();
			#else
			return (delegate*<SDLAssertData*, void*, SDLAssertState>)((delegate* unmanaged[Cdecl]<nint>)funcTable[133])();
			#endif
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetDefaultAssertionHandler()
		{
			delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetDefaultAssertionHandlerNative();
			return ret;
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandlerNative(void** puserdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, delegate*<SDLAssertData*, void*, SDLAssertState>>)funcTable[134])(puserdata);
			#else
			return (delegate*<SDLAssertData*, void*, SDLAssertState>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[134])((nint)puserdata);
			#endif
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandler(void** puserdata)
		{
			delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetAssertionHandlerNative(puserdata);
			return ret;
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandler(ref nint puserdata)
		{
			fixed (nint* ppuserdata = &puserdata)
			{
				delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetAssertionHandlerNative((void**)ppuserdata);
				return ret;
			}
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAssertData* GetAssertionReportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAssertData*>)funcTable[135])();
			#else
			return (SDLAssertData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[135])();
			#endif
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLAssertDataPtr GetAssertionReport()
		{
			SDLAssertDataPtr ret = GetAssertionReportNative();
			return ret;
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetAssertionReportNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[136])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[136])();
			#endif
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ResetAssertionReport()
		{
			ResetAssertionReportNative();
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool AtomicTryLockNative(int* lock0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, SDLBool>)funcTable[137])(lock0);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[137])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicTryLock(int* lock0)
		{
			SDLBool ret = AtomicTryLockNative(lock0);
			return ret;
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicTryLock(ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				SDLBool ret = AtomicTryLockNative((int*)plock0);
				return ret;
			}
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AtomicLockNative(int* lock0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[138])(lock0);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[138])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AtomicLock(int* lock0)
		{
			AtomicLockNative(lock0);
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AtomicLock(ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				AtomicLockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AtomicUnlockNative(int* lock0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[139])(lock0);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[139])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AtomicUnlock(int* lock0)
		{
			AtomicUnlockNative(lock0);
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void AtomicUnlock(ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				AtomicUnlockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Memory barriers are designed to prevent reads and writes from being<br/>
		/// reordered by the compiler and being seen out of order on multi-core CPUs.<br/>
		/// A typical pattern would be for thread A to write some data and a flag, and<br/>
		/// for thread B to read the flag and get the data. In this case you would<br/>
		/// insert a release barrier between writing the data and the flag,<br/>
		/// guaranteeing that the data write completes no later than the flag is<br/>
		/// written, and you would insert an acquire barrier between reading the flag<br/>
		/// and reading the data, to ensure that all the reads associated with the flag<br/>
		/// have completed.<br/>
		/// In this pattern you should always see a release barrier paired with an<br/>
		/// acquire barrier and you should gate the data reads/writes with a single<br/>
		/// flag variable.<br/>
		/// For more information on these semantics, take a look at the blog post:<br/>
		/// http://preshing.com/20120913/acquire-and-release-semantics<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierReleaseFunctionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[140])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[140])();
			#endif
		}

		/// <summary>
		/// Memory barriers are designed to prevent reads and writes from being<br/>
		/// reordered by the compiler and being seen out of order on multi-core CPUs.<br/>
		/// A typical pattern would be for thread A to write some data and a flag, and<br/>
		/// for thread B to read the flag and get the data. In this case you would<br/>
		/// insert a release barrier between writing the data and the flag,<br/>
		/// guaranteeing that the data write completes no later than the flag is<br/>
		/// written, and you would insert an acquire barrier between reading the flag<br/>
		/// and reading the data, to ensure that all the reads associated with the flag<br/>
		/// have completed.<br/>
		/// In this pattern you should always see a release barrier paired with an<br/>
		/// acquire barrier and you should gate the data reads/writes with a single<br/>
		/// flag variable.<br/>
		/// For more information on these semantics, take a look at the blog post:<br/>
		/// http://preshing.com/20120913/acquire-and-release-semantics<br/>
		/// <br/>
		/// </summary>
		public static void MemoryBarrierReleaseFunction()
		{
			MemoryBarrierReleaseFunctionNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierAcquireFunctionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[141])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[141])();
			#endif
		}

		public static void MemoryBarrierAcquireFunction()
		{
			MemoryBarrierAcquireFunctionNative();
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool AtomicCASNative(SDLAtomic* a, int oldval, int newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomic*, int, int, SDLBool>)funcTable[142])(a, oldval, newval);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, int, int, SDLBool>)funcTable[142])((nint)a, oldval, newval);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCAS(SDLAtomicPtr a, int oldval, int newval)
		{
			SDLBool ret = AtomicCASNative((SDLAtomic*)a, oldval, newval);
			return ret;
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCAS(ref SDLAtomic a, int oldval, int newval)
		{
			fixed (SDLAtomic* pa = &a)
			{
				SDLBool ret = AtomicCASNative((SDLAtomic*)pa, oldval, newval);
				return ret;
			}
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AtomicSetNative(SDLAtomic* a, int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomic*, int, int>)funcTable[143])(a, v);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[143])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AtomicSet(SDLAtomicPtr a, int v)
		{
			int ret = AtomicSetNative((SDLAtomic*)a, v);
			return ret;
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AtomicSet(ref SDLAtomic a, int v)
		{
			fixed (SDLAtomic* pa = &a)
			{
				int ret = AtomicSetNative((SDLAtomic*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AtomicGetNative(SDLAtomic* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomic*, int>)funcTable[144])(a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[144])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AtomicGet(SDLAtomicPtr a)
		{
			int ret = AtomicGetNative((SDLAtomic*)a);
			return ret;
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AtomicGet(ref SDLAtomic a)
		{
			fixed (SDLAtomic* pa = &a)
			{
				int ret = AtomicGetNative((SDLAtomic*)pa);
				return ret;
			}
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AtomicAddNative(SDLAtomic* a, int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomic*, int, int>)funcTable[145])(a, v);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[145])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AtomicAdd(SDLAtomicPtr a, int v)
		{
			int ret = AtomicAddNative((SDLAtomic*)a, v);
			return ret;
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AtomicAdd(ref SDLAtomic a, int v)
		{
			fixed (SDLAtomic* pa = &a)
			{
				int ret = AtomicAddNative((SDLAtomic*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool AtomicCASPtrNative(void** a, void* oldval, void* newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*, void*, SDLBool>)funcTable[146])(a, oldval, newval);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, nint, SDLBool>)funcTable[146])((nint)a, (nint)oldval, (nint)newval);
			#endif
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(void** a, void* oldval, void* newval)
		{
			SDLBool ret = AtomicCASPtrNative(a, oldval, newval);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(ref nint a, void* oldval, void* newval)
		{
			fixed (nint* pa = &a)
			{
				SDLBool ret = AtomicCASPtrNative((void**)pa, oldval, newval);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(void** a, nint oldval, void* newval)
		{
			SDLBool ret = AtomicCASPtrNative(a, (void*)oldval, newval);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(ref nint a, nint oldval, void* newval)
		{
			fixed (nint* pa = &a)
			{
				SDLBool ret = AtomicCASPtrNative((void**)pa, (void*)oldval, newval);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(void** a, void* oldval, nint newval)
		{
			SDLBool ret = AtomicCASPtrNative(a, oldval, (void*)newval);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(ref nint a, void* oldval, nint newval)
		{
			fixed (nint* pa = &a)
			{
				SDLBool ret = AtomicCASPtrNative((void**)pa, oldval, (void*)newval);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(void** a, nint oldval, nint newval)
		{
			SDLBool ret = AtomicCASPtrNative(a, (void*)oldval, (void*)newval);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool AtomicCASPtr(ref nint a, nint oldval, nint newval)
		{
			fixed (nint* pa = &a)
			{
				SDLBool ret = AtomicCASPtrNative((void**)pa, (void*)oldval, (void*)newval);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* AtomicSetPtrNative(void** a, void* v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*, void*>)funcTable[147])(a, v);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[147])((nint)a, (nint)v);
			#endif
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* AtomicSetPtr(void** a, void* v)
		{
			void* ret = AtomicSetPtrNative(a, v);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* AtomicSetPtr(ref nint a, void* v)
		{
			fixed (nint* pa = &a)
			{
				void* ret = AtomicSetPtrNative((void**)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* AtomicSetPtr(void** a, nint v)
		{
			void* ret = AtomicSetPtrNative(a, (void*)v);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* AtomicSetPtr(ref nint a, nint v)
		{
			fixed (nint* pa = &a)
			{
				void* ret = AtomicSetPtrNative((void**)pa, (void*)v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* AtomicGetPtrNative(void** a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*>)funcTable[148])(a);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[148])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* AtomicGetPtr(void** a)
		{
			void* ret = AtomicGetPtrNative(a);
			return ret;
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* AtomicGetPtr(ref nint a)
		{
			fixed (nint* pa = &a)
			{
				void* ret = AtomicGetPtrNative((void**)pa);
				return ret;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>
		/// failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetErrorNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[149])(fmt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[149])((nint)fmt);
			#endif
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>
		/// failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetError(byte* fmt)
		{
			int ret = SetErrorNative(fmt);
			return ret;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>
		/// failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetError(in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SetErrorNative((byte*)pfmt);
				return ret;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>
		/// failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetError(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				int ret = SetErrorNative((byte*)pfmt);
				return ret;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>
		/// failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetError(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetErrorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned string is internally allocated and must not be freed by the<br/>
		/// application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[150])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[150])();
			#endif
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned string is internally allocated and must not be freed by the<br/>
		/// application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetError()
		{
			byte* ret = GetErrorNative();
			return ret;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned string is internally allocated and must not be freed by the<br/>
		/// application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetErrorS()
		{
			string ret = Utils.DecodeStringUTF8(GetErrorNative());
			return ret;
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetErrorMsgNative(byte* errstr, int maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[151])(errstr, maxlen);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[151])((nint)errstr, maxlen);
			#endif
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetErrorMsg(byte* errstr, int maxlen)
		{
			byte* ret = GetErrorMsgNative(errstr, maxlen);
			return ret;
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetErrorMsgS(byte* errstr, int maxlen)
		{
			string ret = Utils.DecodeStringUTF8(GetErrorMsgNative(errstr, maxlen));
			return ret;
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetErrorMsg(ref byte errstr, int maxlen)
		{
			fixed (byte* perrstr = &errstr)
			{
				byte* ret = GetErrorMsgNative((byte*)perrstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetErrorMsgS(ref byte errstr, int maxlen)
		{
			fixed (byte* perrstr = &errstr)
			{
				string ret = Utils.DecodeStringUTF8(GetErrorMsgNative((byte*)perrstr, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetErrorMsg(ref string errstr, int maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errstr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errstr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errstr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetErrorMsgNative(pStr0, maxlen);
			errstr = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetErrorMsgS(ref string errstr, int maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errstr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errstr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errstr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetErrorMsgNative(pStr0, maxlen));
			errstr = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearErrorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[152])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[152])();
			#endif
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ClearError()
		{
			ClearErrorNative();
		}

		/// <summary>
		/// SDL_Error() unconditionally returns -1. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ErrorNative(SDLErrorcode code)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLErrorcode, int>)funcTable[153])(code);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLErrorcode, int>)funcTable[153])(code);
			#endif
		}

		/// <summary>
		/// SDL_Error() unconditionally returns -1. <br/>
		/// </summary>
		public static int Error(SDLErrorcode code)
		{
			int ret = ErrorNative(code);
			return ret;
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLMutex* CreateMutexNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*>)funcTable[154])();
			#else
			return (SDLMutex*)((delegate* unmanaged[Cdecl]<nint>)funcTable[154])();
			#endif
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLMutexPtr CreateMutex()
		{
			SDLMutexPtr ret = CreateMutexNative();
			return ret;
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LockMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*, int>)funcTable[155])(mutex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[155])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LockMutex(SDLMutexPtr mutex)
		{
			int ret = LockMutexNative((SDLMutex*)mutex);
			return ret;
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int LockMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = LockMutexNative((SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TryLockMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*, int>)funcTable[156])(mutex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[156])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TryLockMutex(SDLMutexPtr mutex)
		{
			int ret = TryLockMutexNative((SDLMutex*)mutex);
			return ret;
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TryLockMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = TryLockMutexNative((SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is an error to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// It is also an error to unlock a mutex that isn't locked at all.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UnlockMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*, int>)funcTable[157])(mutex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[157])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is an error to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// It is also an error to unlock a mutex that isn't locked at all.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UnlockMutex(SDLMutexPtr mutex)
		{
			int ret = UnlockMutexNative((SDLMutex*)mutex);
			return ret;
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is an error to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// It is also an error to unlock a mutex that isn't locked at all.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UnlockMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = UnlockMutexNative((SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMutex*, void>)funcTable[158])(mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[158])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyMutex(SDLMutexPtr mutex)
		{
			DestroyMutexNative((SDLMutex*)mutex);
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				DestroyMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSemaphore* CreateSemaphoreNative(uint initialValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLSemaphore*>)funcTable[159])(initialValue);
			#else
			return (SDLSemaphore*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[159])(initialValue);
			#endif
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSemaphore* CreateSemaphore(uint initialValue)
		{
			SDLSemaphore* ret = CreateSemaphoreNative(initialValue);
			return ret;
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroySemaphoreNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[160])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[160])((nint)sem);
			#endif
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroySemaphore(SDLSemaphore* sem)
		{
			DestroySemaphoreNative(sem);
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroySemaphore(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				DestroySemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>
		/// length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SemWaitNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int>)funcTable[161])(sem);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[161])((nint)sem);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>
		/// length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemWait(SDLSemaphore* sem)
		{
			int ret = SemWaitNative(sem);
			return ret;
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>
		/// length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemWait(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SemWaitNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SemTryWaitNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int>)funcTable[162])(sem);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[162])((nint)sem);
			#endif
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemTryWait(SDLSemaphore* sem)
		{
			int ret = SemTryWaitNative(sem);
			return ret;
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemTryWait(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SemTryWaitNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SemWaitTimeoutNative(SDLSemaphore* sem, uint timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, uint, int>)funcTable[163])(sem, timeout);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[163])((nint)sem, timeout);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemWaitTimeout(SDLSemaphore* sem, uint timeout)
		{
			int ret = SemWaitTimeoutNative(sem, timeout);
			return ret;
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemWaitTimeout(ref SDLSemaphore sem, uint timeout)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SemWaitTimeoutNative((SDLSemaphore*)psem, timeout);
				return ret;
			}
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SemPostNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int>)funcTable[164])(sem);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[164])((nint)sem);
			#endif
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemPost(SDLSemaphore* sem)
		{
			int ret = SemPostNative(sem);
			return ret;
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SemPost(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SemPostNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint SemValueNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, uint>)funcTable[165])(sem);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[165])((nint)sem);
			#endif
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint SemValue(SDLSemaphore* sem)
		{
			uint ret = SemValueNative(sem);
			return ret;
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint SemValue(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				uint ret = SemValueNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCond* CreateCondNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCond*>)funcTable[166])();
			#else
			return (SDLCond*)((delegate* unmanaged[Cdecl]<nint>)funcTable[166])();
			#endif
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCondPtr CreateCond()
		{
			SDLCondPtr ret = CreateCondNative();
			return ret;
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyCondNative(SDLCond* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCond*, void>)funcTable[167])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[167])((nint)cond);
			#endif
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyCond(SDLCondPtr cond)
		{
			DestroyCondNative((SDLCond*)cond);
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyCond(ref SDLCond cond)
		{
			fixed (SDLCond* pcond = &cond)
			{
				DestroyCondNative((SDLCond*)pcond);
			}
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CondSignalNative(SDLCond* cond)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCond*, int>)funcTable[168])(cond);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[168])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondSignal(SDLCondPtr cond)
		{
			int ret = CondSignalNative((SDLCond*)cond);
			return ret;
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondSignal(ref SDLCond cond)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = CondSignalNative((SDLCond*)pcond);
				return ret;
			}
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CondBroadcastNative(SDLCond* cond)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCond*, int>)funcTable[169])(cond);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[169])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondBroadcast(SDLCondPtr cond)
		{
			int ret = CondBroadcastNative((SDLCond*)cond);
			return ret;
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondBroadcast(ref SDLCond cond)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = CondBroadcastNative((SDLCond*)pcond);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>
		/// the function returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>
		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CondWaitNative(SDLCond* cond, SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCond*, SDLMutex*, int>)funcTable[170])(cond, mutex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[170])((nint)cond, (nint)mutex);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>
		/// the function returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>
		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWait(SDLCondPtr cond, SDLMutexPtr mutex)
		{
			int ret = CondWaitNative((SDLCond*)cond, (SDLMutex*)mutex);
			return ret;
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>
		/// the function returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>
		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWait(ref SDLCond cond, SDLMutexPtr mutex)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = CondWaitNative((SDLCond*)pcond, (SDLMutex*)mutex);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>
		/// the function returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>
		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWait(SDLCondPtr cond, ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = CondWaitNative((SDLCond*)cond, (SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>
		/// the function returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>
		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWait(ref SDLCond cond, ref SDLMutex mutex)
		{
			fixed (SDLCond* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					int ret = CondWaitNative((SDLCond*)pcond, (SDLMutex*)pmutex);
					return ret;
				}
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>
		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>
		/// returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CondWaitTimeoutNative(SDLCond* cond, SDLMutex* mutex, uint ms)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCond*, SDLMutex*, uint, int>)funcTable[171])(cond, mutex, ms);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, int>)funcTable[171])((nint)cond, (nint)mutex, ms);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>
		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>
		/// returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWaitTimeout(SDLCondPtr cond, SDLMutexPtr mutex, uint ms)
		{
			int ret = CondWaitTimeoutNative((SDLCond*)cond, (SDLMutex*)mutex, ms);
			return ret;
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>
		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>
		/// returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWaitTimeout(ref SDLCond cond, SDLMutexPtr mutex, uint ms)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = CondWaitTimeoutNative((SDLCond*)pcond, (SDLMutex*)mutex, ms);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>
		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>
		/// returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWaitTimeout(SDLCondPtr cond, ref SDLMutex mutex, uint ms)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = CondWaitTimeoutNative((SDLCond*)cond, (SDLMutex*)pmutex, ms);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>
		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>
		/// returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CondWaitTimeout(ref SDLCond cond, ref SDLMutex mutex, uint ms)
		{
			fixed (SDLCond* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					int ret = CondWaitTimeoutNative((SDLCond*)pcond, (SDLMutex*)pmutex, ms);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadNative(delegate*<void*, int> fn, byte* name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, int>, byte*, void*, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>, delegate*<uint, void>, SDLThread*>)funcTable[172])(fn, name, data, pfnBeginThread, pfnEndThread);
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint>)funcTable[172])((nint)fn, (nint)name, (nint)data, (nint)pfnBeginThread, (nint)pfnEndThread);
			#endif
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, (void*)data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, (void*)data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, (void*)data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, (void*)data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, byte* name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative(fn, name, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, byte* name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, in byte name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative(fn, (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(delegate*<void*, int> fn, string name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative(fn, pStr0, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, in byte name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, ReadOnlySpan<byte> name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThread(SDLThreadFunction fn, string name, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadWithStackSizeNative(delegate*<void*, int> fn, byte* name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, int>, byte*, nuint, void*, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>, delegate*<uint, void>, SDLThread*>)funcTable[173])(fn, name, stacksize, data, pfnBeginThread, pfnEndThread);
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint, nint, nint, nint>)funcTable[173])((nint)fn, (nint)name, stacksize, (nint)data, (nint)pfnBeginThread, (nint)pfnEndThread);
			#endif
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, (void*)data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, delegate*<uint, void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, void* data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, nint data, delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint> pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, (void*)data, pfnBeginThread, (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, void* data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, byte* name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, name, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, byte* name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, in byte name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(delegate*<void*, int> fn, string name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative(fn, pStr0, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, in byte name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, ReadOnlySpan<byte> name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		public static SDLThreadPtr CreateThreadWithStackSize(SDLThreadFunction fn, string name, nuint stacksize, nint data, PfnSDLCurrentBeginThread pfnBeginThread, PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadWithStackSizeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, stacksize, (void*)data, (delegate*<void*, uint, delegate*<void*, uint>, void*, uint, uint*, nuint>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<uint, void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// This is internal memory, not to be freed by the caller, and remains valid<br/>
		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetThreadNameNative(SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, byte*>)funcTable[174])(thread);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[174])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// This is internal memory, not to be freed by the caller, and remains valid<br/>
		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetThreadName(SDLThreadPtr thread)
		{
			byte* ret = GetThreadNameNative((SDLThread*)thread);
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// This is internal memory, not to be freed by the caller, and remains valid<br/>
		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetThreadNameS(SDLThreadPtr thread)
		{
			string ret = Utils.DecodeStringUTF8(GetThreadNameNative((SDLThread*)thread));
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// This is internal memory, not to be freed by the caller, and remains valid<br/>
		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetThreadName(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				byte* ret = GetThreadNameNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// This is internal memory, not to be freed by the caller, and remains valid<br/>
		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetThreadNameS(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				string ret = Utils.DecodeStringUTF8(GetThreadNameNative((SDLThread*)pthread));
				return ret;
			}
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ThreadIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[175])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[175])();
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint ThreadID()
		{
			uint ret = ThreadIDNative();
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetThreadIDNative(SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, uint>)funcTable[176])(thread);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[176])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetThreadID(SDLThreadPtr thread)
		{
			uint ret = GetThreadIDNative((SDLThread*)thread);
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetThreadID(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				uint ret = GetThreadIDNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetThreadPriorityNative(SDLThreadPriority priority)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThreadPriority, int>)funcTable[177])(priority);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLThreadPriority, int>)funcTable[177])(priority);
			#endif
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetThreadPriority(SDLThreadPriority priority)
		{
			int ret = SetThreadPriorityNative(priority);
			return ret;
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitThreadNative(SDLThread* thread, int* status)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, int*, void>)funcTable[178])(thread, status);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[178])((nint)thread, (nint)status);
			#endif
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(SDLThreadPtr thread, int* status)
		{
			WaitThreadNative((SDLThread*)thread, status);
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(ref SDLThread thread, int* status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				WaitThreadNative((SDLThread*)pthread, status);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(SDLThreadPtr thread, ref int status)
		{
			fixed (int* pstatus = &status)
			{
				WaitThreadNative((SDLThread*)thread, (int*)pstatus);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(ref SDLThread thread, ref int status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				fixed (int* pstatus = &status)
				{
					WaitThreadNative((SDLThread*)pthread, (int*)pstatus);
				}
			}
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachThreadNative(SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, void>)funcTable[179])(thread);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[179])((nint)thread);
			#endif
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DetachThread(SDLThreadPtr thread)
		{
			DetachThreadNative((SDLThread*)thread);
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DetachThread(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				DetachThreadNative((SDLThread*)pthread);
			}
		}

		/// <summary>
		/// Create a piece of thread-local storage.<br/>
		/// This creates an identifier that is globally visible to all threads but<br/>
		/// refers to data that is thread-specific.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TLSCreateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[180])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[180])();
			#endif
		}

		/// <summary>
		/// Create a piece of thread-local storage.<br/>
		/// This creates an identifier that is globally visible to all threads but<br/>
		/// refers to data that is thread-specific.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint TLSCreate()
		{
			uint ret = TLSCreateNative();
			return ret;
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* TLSGetNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*>)funcTable[181])(id);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[181])(id);
			#endif
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* TLSGet(uint id)
		{
			void* ret = TLSGetNative(id);
			return ret;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TLSSetNative(uint id, void* value, delegate*<void*, void> destructor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*, delegate*<void*, void>, int>)funcTable[182])(id, value, destructor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, int>)funcTable[182])(id, (nint)value, (nint)destructor);
			#endif
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TLSSet(uint id, void* value, delegate*<void*, void> destructor)
		{
			int ret = TLSSetNative(id, value, destructor);
			return ret;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int TLSSet(uint id, nint value, delegate*<void*, void> destructor)
		{
			int ret = TLSSetNative(id, (void*)value, destructor);
			return ret;
		}
	}
}
