// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLRect dstrect, double angle, SDLPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)center, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLPoint* pcenter = &center)
			{
				int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, SDLRectPtr dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)dstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = RenderCopyExNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyEx(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLRect dstrect, double angle, in SDLPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							fixed (SDLPoint* pcenter = &center)
							{
								int ret = RenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawPointFNative(SDLRenderer* renderer, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, int>)funcTable[782])(renderer, x, y);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, float, int>)funcTable[782])((nint)renderer, x, y);
			#endif
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointF(SDLRendererPtr renderer, float x, float y)
		{
			int ret = RenderDrawPointFNative((SDLRenderer*)renderer, x, y);
			return ret;
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointF(ref SDLRenderer renderer, float x, float y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawPointFNative((SDLRenderer*)prenderer, x, y);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawPointsFNative(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFPoint*, int, int>)funcTable[783])(renderer, points, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[783])((nint)renderer, (nint)points, count);
			#endif
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(SDLRendererPtr renderer, SDLFPointPtr points, int count)
		{
			int ret = RenderDrawPointsFNative((SDLRenderer*)renderer, (SDLFPoint*)points, count);
			return ret;
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(ref SDLRenderer renderer, SDLFPointPtr points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawPointsFNative((SDLRenderer*)prenderer, (SDLFPoint*)points, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(SDLRendererPtr renderer, in SDLFPoint points, int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				int ret = RenderDrawPointsFNative((SDLRenderer*)renderer, (SDLFPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawPointsF(ref SDLRenderer renderer, in SDLFPoint points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					int ret = RenderDrawPointsFNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawLineFNative(SDLRenderer* renderer, float x1, float y1, float x2, float y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, float, float, int>)funcTable[784])(renderer, x1, y1, x2, y2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, int>)funcTable[784])((nint)renderer, x1, y1, x2, y2);
			#endif
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLineF(SDLRendererPtr renderer, float x1, float y1, float x2, float y2)
		{
			int ret = RenderDrawLineFNative((SDLRenderer*)renderer, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLineF(ref SDLRenderer renderer, float x1, float y1, float x2, float y2)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawLineFNative((SDLRenderer*)prenderer, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawLinesFNative(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFPoint*, int, int>)funcTable[785])(renderer, points, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[785])((nint)renderer, (nint)points, count);
			#endif
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(SDLRendererPtr renderer, SDLFPointPtr points, int count)
		{
			int ret = RenderDrawLinesFNative((SDLRenderer*)renderer, (SDLFPoint*)points, count);
			return ret;
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(ref SDLRenderer renderer, SDLFPointPtr points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawLinesFNative((SDLRenderer*)prenderer, (SDLFPoint*)points, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(SDLRendererPtr renderer, in SDLFPoint points, int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				int ret = RenderDrawLinesFNative((SDLRenderer*)renderer, (SDLFPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawLinesF(ref SDLRenderer renderer, in SDLFPoint points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					int ret = RenderDrawLinesFNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawRectFNative(SDLRenderer* renderer, SDLFRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int>)funcTable[786])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[786])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(SDLRendererPtr renderer, SDLFRectPtr rect)
		{
			int ret = RenderDrawRectFNative((SDLRenderer*)renderer, (SDLFRect*)rect);
			return ret;
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(ref SDLRenderer renderer, SDLFRectPtr rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawRectFNative((SDLRenderer*)prenderer, (SDLFRect*)rect);
				return ret;
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(SDLRendererPtr renderer, in SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				int ret = RenderDrawRectFNative((SDLRenderer*)renderer, (SDLFRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectF(ref SDLRenderer renderer, in SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					int ret = RenderDrawRectFNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderDrawRectsFNative(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int, int>)funcTable[787])(renderer, rects, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[787])((nint)renderer, (nint)rects, count);
			#endif
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(SDLRendererPtr renderer, SDLFRectPtr rects, int count)
		{
			int ret = RenderDrawRectsFNative((SDLRenderer*)renderer, (SDLFRect*)rects, count);
			return ret;
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(ref SDLRenderer renderer, SDLFRectPtr rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderDrawRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)rects, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(SDLRendererPtr renderer, in SDLFRect rects, int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				int ret = RenderDrawRectsFNative((SDLRenderer*)renderer, (SDLFRect*)prects, count);
				return ret;
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderDrawRectsF(ref SDLRenderer renderer, in SDLFRect rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					int ret = RenderDrawRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderFillRectFNative(SDLRenderer* renderer, SDLFRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int>)funcTable[788])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[788])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(SDLRendererPtr renderer, SDLFRectPtr rect)
		{
			int ret = RenderFillRectFNative((SDLRenderer*)renderer, (SDLFRect*)rect);
			return ret;
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(ref SDLRenderer renderer, SDLFRectPtr rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderFillRectFNative((SDLRenderer*)prenderer, (SDLFRect*)rect);
				return ret;
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(SDLRendererPtr renderer, in SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				int ret = RenderFillRectFNative((SDLRenderer*)renderer, (SDLFRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectF(ref SDLRenderer renderer, in SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					int ret = RenderFillRectFNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderFillRectsFNative(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int, int>)funcTable[789])(renderer, rects, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[789])((nint)renderer, (nint)rects, count);
			#endif
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(SDLRendererPtr renderer, SDLFRectPtr rects, int count)
		{
			int ret = RenderFillRectsFNative((SDLRenderer*)renderer, (SDLFRect*)rects, count);
			return ret;
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(ref SDLRenderer renderer, SDLFRectPtr rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderFillRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)rects, count);
				return ret;
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(SDLRendererPtr renderer, in SDLFRect rects, int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				int ret = RenderFillRectsFNative((SDLRenderer*)renderer, (SDLFRect*)prects, count);
				return ret;
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFillRectsF(ref SDLRenderer renderer, in SDLFRect rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					int ret = RenderFillRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderCopyFNative(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLRect*, SDLFRect*, int>)funcTable[790])(renderer, texture, srcrect, dstrect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[790])((nint)renderer, (nint)texture, (nint)srcrect, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLFRectPtr dstrect)
		{
			int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)dstrect);
			return ret;
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLFRectPtr dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLFRectPtr dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLFRectPtr dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLFRectPtr dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)dstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLFRectPtr dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, SDLFRectPtr dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)dstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, SDLFRectPtr dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLFRect dstrect)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLFRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyF(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							int ret = RenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderCopyExFNative(SDLRenderer* renderer, SDLTexture* texture, SDLRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLRendererFlip flip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLRect*, SDLFRect*, double, SDLFPoint*, SDLRendererFlip, int>)funcTable[791])(renderer, texture, srcrect, dstrect, angle, center, flip);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, double, nint, SDLRendererFlip, int>)funcTable[791])((nint)renderer, (nint)texture, (nint)srcrect, (nint)dstrect, angle, (nint)center, flip);
			#endif
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
			return ret;
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, SDLFPointPtr center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)center, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLFPoint* pcenter = &center)
			{
				int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
				return ret;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, SDLFRectPtr dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)dstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, SDLRectPtr srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(SDLRendererPtr renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = RenderCopyExFNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderCopyExF(ref SDLRenderer renderer, ref SDLTexture texture, in SDLRect srcrect, in SDLFRect dstrect, double angle, in SDLFPoint center, SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							fixed (SDLFPoint* pcenter = &center)
							{
								int ret = RenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderGeometryNative(SDLRenderer* renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLVertex*, int, int*, int, int>)funcTable[792])(renderer, texture, vertices, numVertices, indices, numIndices);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, int>)funcTable[792])((nint)renderer, (nint)texture, (nint)vertices, numVertices, (nint)indices, numIndices);
			#endif
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, SDLTexturePtr texture, SDLVertexPtr vertices, int numVertices, int* indices, int numIndices)
		{
			int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLVertex*)vertices, numVertices, indices, numIndices);
			return ret;
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexturePtr texture, SDLVertexPtr vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLVertex*)vertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, ref SDLTexture texture, SDLVertexPtr vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLVertex*)vertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, SDLVertexPtr vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)vertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, ref SDLTexture texture, in SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, in SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, SDLTexturePtr texture, SDLVertexPtr vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (int* pindices = &indices)
			{
				int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLVertex*)vertices, numVertices, (int*)pindices, numIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexturePtr texture, SDLVertexPtr vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pindices = &indices)
				{
					int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLVertex*)vertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, ref SDLTexture texture, SDLVertexPtr vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pindices = &indices)
				{
					int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLVertex*)vertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, SDLVertexPtr vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (int* pindices = &indices)
					{
						int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)vertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, SDLTexturePtr texture, in SDLVertex vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				fixed (int* pindices = &indices)
				{
					int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, SDLTexturePtr texture, in SDLVertex vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(SDLRendererPtr renderer, ref SDLTexture texture, in SDLVertex vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						int ret = RenderGeometryNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, in SDLVertex vertices, int numVertices, in int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						fixed (int* pindices = &indices)
						{
							int ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderGeometryRawNative(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, SDLColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, float*, int, SDLColor*, int, float*, int, int, void*, int, int, int>)funcTable[793])(renderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int, int, nint, int, int, int>)funcTable[793])((nint)renderer, (nint)texture, (nint)xy, xyStride, (nint)color, colorStride, (nint)uv, uvStride, numVertices, (nint)indices, numIndices, sizeIndices);
			#endif
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
			return ret;
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* puv = &uv)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							fixed (float* puv = &uv)
							{
								int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
			return ret;
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, float* uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (float* puv = &uv)
			{
				int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, SDLColorPtr color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)color, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				fixed (float* puv = &uv)
				{
					int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, SDLTexturePtr texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(SDLRendererPtr renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = RenderGeometryRawNative((SDLRenderer*)renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, in float xy, int xyStride, in SDLColor color, int colorStride, in float uv, int uvStride, int numVertices, nint indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							fixed (float* puv = &uv)
							{
								int ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, (void*)indices, numIndices, sizeIndices);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderReadPixelsNative(SDLRenderer* renderer, SDLRect* rect, uint format, void* pixels, int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, uint, void*, int, int>)funcTable[794])(renderer, rect, format, pixels, pitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, int, int>)funcTable[794])((nint)renderer, (nint)rect, format, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(SDLRendererPtr renderer, SDLRectPtr rect, uint format, void* pixels, int pitch)
		{
			int ret = RenderReadPixelsNative((SDLRenderer*)renderer, (SDLRect*)rect, format, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(ref SDLRenderer renderer, SDLRectPtr rect, uint format, void* pixels, int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderReadPixelsNative((SDLRenderer*)prenderer, (SDLRect*)rect, format, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(SDLRendererPtr renderer, in SDLRect rect, uint format, void* pixels, int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = RenderReadPixelsNative((SDLRenderer*)renderer, (SDLRect*)prect, format, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(ref SDLRenderer renderer, in SDLRect rect, uint format, void* pixels, int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = RenderReadPixelsNative((SDLRenderer*)prenderer, (SDLRect*)prect, format, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(SDLRendererPtr renderer, SDLRectPtr rect, uint format, nint pixels, int pitch)
		{
			int ret = RenderReadPixelsNative((SDLRenderer*)renderer, (SDLRect*)rect, format, (void*)pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(ref SDLRenderer renderer, SDLRectPtr rect, uint format, nint pixels, int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderReadPixelsNative((SDLRenderer*)prenderer, (SDLRect*)rect, format, (void*)pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(SDLRendererPtr renderer, in SDLRect rect, uint format, nint pixels, int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = RenderReadPixelsNative((SDLRenderer*)renderer, (SDLRect*)prect, format, (void*)pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderReadPixels(ref SDLRenderer renderer, in SDLRect rect, uint format, nint pixels, int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = RenderReadPixelsNative((SDLRenderer*)prenderer, (SDLRect*)prect, format, (void*)pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the screen with any rendering performed since the previous call.<br/>
		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>
		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>
		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>
		/// complete picture.<br/>
		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
		/// for the frame, and then calls this function once per frame to present the<br/>
		/// final drawing to the user.<br/>
		/// The backbuffer should be considered invalidated after each present; do not<br/>
		/// assume that previous contents will exist between frames. You are strongly<br/>
		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
		/// starting each new frame's drawing, even if you plan to overwrite every<br/>
		/// pixel.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function on the main thread. If this<br/>
		/// happens to work on a background thread on any given platform<br/>
		/// or backend, it's purely by luck and you should not rely on it<br/>
		/// to work next time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderPresentNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, void>)funcTable[795])(renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[795])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Update the screen with any rendering performed since the previous call.<br/>
		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>
		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>
		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>
		/// complete picture.<br/>
		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
		/// for the frame, and then calls this function once per frame to present the<br/>
		/// final drawing to the user.<br/>
		/// The backbuffer should be considered invalidated after each present; do not<br/>
		/// assume that previous contents will exist between frames. You are strongly<br/>
		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
		/// starting each new frame's drawing, even if you plan to overwrite every<br/>
		/// pixel.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function on the main thread. If this<br/>
		/// happens to work on a background thread on any given platform<br/>
		/// or backend, it's purely by luck and you should not rely on it<br/>
		/// to work next time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RenderPresent(SDLRendererPtr renderer)
		{
			RenderPresentNative((SDLRenderer*)renderer);
		}

		/// <summary>
		/// Update the screen with any rendering performed since the previous call.<br/>
		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>
		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>
		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>
		/// complete picture.<br/>
		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
		/// for the frame, and then calls this function once per frame to present the<br/>
		/// final drawing to the user.<br/>
		/// The backbuffer should be considered invalidated after each present; do not<br/>
		/// assume that previous contents will exist between frames. You are strongly<br/>
		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
		/// starting each new frame's drawing, even if you plan to overwrite every<br/>
		/// pixel.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function on the main thread. If this<br/>
		/// happens to work on a background thread on any given platform<br/>
		/// or backend, it's purely by luck and you should not rely on it<br/>
		/// to work next time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void RenderPresent(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				RenderPresentNative((SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Destroy the specified texture.<br/>
		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
		/// to "Invalid texture".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyTextureNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTexture*, void>)funcTable[796])(texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[796])((nint)texture);
			#endif
		}

		/// <summary>
		/// Destroy the specified texture.<br/>
		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
		/// to "Invalid texture".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyTexture(SDLTexturePtr texture)
		{
			DestroyTextureNative((SDLTexture*)texture);
		}

		/// <summary>
		/// Destroy the specified texture.<br/>
		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
		/// to "Invalid texture".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyTexture(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				DestroyTextureNative((SDLTexture*)ptexture);
			}
		}

		/// <summary>
		/// Destroy the rendering context for a window and free associated textures.<br/>
		/// If `renderer` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyRendererNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, void>)funcTable[797])(renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[797])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Destroy the rendering context for a window and free associated textures.<br/>
		/// If `renderer` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyRenderer(SDLRendererPtr renderer)
		{
			DestroyRendererNative((SDLRenderer*)renderer);
		}

		/// <summary>
		/// Destroy the rendering context for a window and free associated textures.<br/>
		/// If `renderer` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyRenderer(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				DestroyRendererNative((SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Force the rendering context to flush any pending commands to the underlying<br/>
		/// rendering API.<br/>
		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>
		/// addition to using an SDL_Renderer.<br/>
		/// This is for a very-specific case: if you are using SDL's render API, you<br/>
		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>
		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>
		/// calls in addition to SDL render API calls. If all of this applies, you<br/>
		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>
		/// low-level API you're using in cooperation.<br/>
		/// In all other cases, you can ignore this function. This is only here to get<br/>
		/// maximum performance out of a specific situation. In all other cases, SDL<br/>
		/// will do the right thing, perhaps at a performance loss.<br/>
		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>
		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>
		/// instead flushing them to the OS immediately.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderFlushNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int>)funcTable[798])(renderer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[798])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Force the rendering context to flush any pending commands to the underlying<br/>
		/// rendering API.<br/>
		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>
		/// addition to using an SDL_Renderer.<br/>
		/// This is for a very-specific case: if you are using SDL's render API, you<br/>
		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>
		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>
		/// calls in addition to SDL render API calls. If all of this applies, you<br/>
		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>
		/// low-level API you're using in cooperation.<br/>
		/// In all other cases, you can ignore this function. This is only here to get<br/>
		/// maximum performance out of a specific situation. In all other cases, SDL<br/>
		/// will do the right thing, perhaps at a performance loss.<br/>
		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>
		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>
		/// instead flushing them to the OS immediately.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFlush(SDLRendererPtr renderer)
		{
			int ret = RenderFlushNative((SDLRenderer*)renderer);
			return ret;
		}

		/// <summary>
		/// Force the rendering context to flush any pending commands to the underlying<br/>
		/// rendering API.<br/>
		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>
		/// addition to using an SDL_Renderer.<br/>
		/// This is for a very-specific case: if you are using SDL's render API, you<br/>
		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>
		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>
		/// calls in addition to SDL render API calls. If all of this applies, you<br/>
		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>
		/// low-level API you're using in cooperation.<br/>
		/// In all other cases, you can ignore this function. This is only here to get<br/>
		/// maximum performance out of a specific situation. In all other cases, SDL<br/>
		/// will do the right thing, perhaps at a performance loss.<br/>
		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>
		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>
		/// instead flushing them to the OS immediately.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderFlush(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderFlushNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLBindTextureNative(SDLTexture* texture, float* texw, float* texh)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, float*, float*, int>)funcTable[799])(texture, texw, texh);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[799])((nint)texture, (nint)texw, (nint)texh);
			#endif
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexturePtr texture, float* texw, float* texh)
		{
			int ret = GLBindTextureNative((SDLTexture*)texture, texw, texh);
			return ret;
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, float* texw, float* texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GLBindTextureNative((SDLTexture*)ptexture, texw, texh);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexturePtr texture, ref float texw, float* texh)
		{
			fixed (float* ptexw = &texw)
			{
				int ret = GLBindTextureNative((SDLTexture*)texture, (float*)ptexw, texh);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, ref float texw, float* texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexw = &texw)
				{
					int ret = GLBindTextureNative((SDLTexture*)ptexture, (float*)ptexw, texh);
					return ret;
				}
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexturePtr texture, float* texw, ref float texh)
		{
			fixed (float* ptexh = &texh)
			{
				int ret = GLBindTextureNative((SDLTexture*)texture, texw, (float*)ptexh);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, float* texw, ref float texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexh = &texh)
				{
					int ret = GLBindTextureNative((SDLTexture*)ptexture, texw, (float*)ptexh);
					return ret;
				}
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(SDLTexturePtr texture, ref float texw, ref float texh)
		{
			fixed (float* ptexw = &texw)
			{
				fixed (float* ptexh = &texh)
				{
					int ret = GLBindTextureNative((SDLTexture*)texture, (float*)ptexw, (float*)ptexh);
					return ret;
				}
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLBindTexture(ref SDLTexture texture, ref float texw, ref float texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexw = &texw)
				{
					fixed (float* ptexh = &texh)
					{
						int ret = GLBindTextureNative((SDLTexture*)ptexture, (float*)ptexw, (float*)ptexh);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>
		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GLUnbindTextureNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, int>)funcTable[800])(texture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[800])((nint)texture);
			#endif
		}

		/// <summary>
		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>
		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLUnbindTexture(SDLTexturePtr texture)
		{
			int ret = GLUnbindTextureNative((SDLTexture*)texture);
			return ret;
		}

		/// <summary>
		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>
		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GLUnbindTexture(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GLUnbindTextureNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* RenderGetMetalLayerNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, void*>)funcTable[801])(renderer);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[801])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalLayer(SDLRendererPtr renderer)
		{
			void* ret = RenderGetMetalLayerNative((SDLRenderer*)renderer);
			return ret;
		}

		/// <summary>
		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalLayer(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				void* ret = RenderGetMetalLayerNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the Metal command encoder for the current frame<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to an `id<br/>
		/// <MTLRenderCommandEncoder<br/>
		/// >`.<br/>
		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>
		/// SDL a drawable to render to, which might happen if the window is<br/>
		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>
		/// render targets, just the window's backbuffer. Check your return values!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* RenderGetMetalCommandEncoderNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, void*>)funcTable[802])(renderer);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[802])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the Metal command encoder for the current frame<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to an `id<br/>
		/// <MTLRenderCommandEncoder<br/>
		/// >`.<br/>
		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>
		/// SDL a drawable to render to, which might happen if the window is<br/>
		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>
		/// render targets, just the window's backbuffer. Check your return values!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalCommandEncoder(SDLRendererPtr renderer)
		{
			void* ret = RenderGetMetalCommandEncoderNative((SDLRenderer*)renderer);
			return ret;
		}

		/// <summary>
		/// Get the Metal command encoder for the current frame<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to an `id<br/>
		/// <MTLRenderCommandEncoder<br/>
		/// >`.<br/>
		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>
		/// SDL a drawable to render to, which might happen if the window is<br/>
		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>
		/// render targets, just the window's backbuffer. Check your return values!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* RenderGetMetalCommandEncoder(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				void* ret = RenderGetMetalCommandEncoderNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Toggle VSync of the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderSetVSyncNative(SDLRenderer* renderer, int vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int, int>)funcTable[803])(renderer, vsync);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[803])((nint)renderer, vsync);
			#endif
		}

		/// <summary>
		/// Toggle VSync of the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderSetVSync(SDLRendererPtr renderer, int vsync)
		{
			int ret = RenderSetVSyncNative((SDLRenderer*)renderer, vsync);
			return ret;
		}

		/// <summary>
		/// Toggle VSync of the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int RenderSetVSync(ref SDLRenderer renderer, int vsync)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderSetVSyncNative((SDLRenderer*)prenderer, vsync);
				return ret;
			}
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* CreateShapedWindowNative(byte* title, uint x, uint y, uint w, uint h, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, uint, uint, uint, uint, SDLWindow*>)funcTable[804])(title, x, y, w, h, flags);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, uint, uint, nint>)funcTable[804])((nint)title, x, y, w, h, flags);
			#endif
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr CreateShapedWindow(byte* title, uint x, uint y, uint w, uint h, uint flags)
		{
			SDLWindowPtr ret = CreateShapedWindowNative(title, x, y, w, h, flags);
			return ret;
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr CreateShapedWindow(in byte title, uint x, uint y, uint w, uint h, uint flags)
		{
			fixed (byte* ptitle = &title)
			{
				SDLWindowPtr ret = CreateShapedWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr CreateShapedWindow(ReadOnlySpan<byte> title, uint x, uint y, uint w, uint h, uint flags)
		{
			fixed (byte* ptitle = title)
			{
				SDLWindowPtr ret = CreateShapedWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindowPtr CreateShapedWindow(string title, uint x, uint y, uint w, uint h, uint flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLWindowPtr ret = CreateShapedWindowNative(pStr0, x, y, w, h, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Return whether the given window is a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool IsShapedWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)funcTable[805])(window);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[805])((nint)window);
			#endif
		}

		/// <summary>
		/// Return whether the given window is a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsShapedWindow(SDLWindowPtr window)
		{
			SDLBool ret = IsShapedWindowNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Return whether the given window is a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBool IsShapedWindow(in SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = IsShapedWindowNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowShapeNative(SDLWindow* window, SDLSurface* shape, SDLWindowShapeMode* shapeMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*, SDLWindowShapeMode*, int>)funcTable[806])(window, shape, shapeMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[806])((nint)window, (nint)shape, (nint)shapeMode);
			#endif
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindowPtr window, SDLSurfacePtr shape, SDLWindowShapeModePtr shapeMode)
		{
			int ret = SetWindowShapeNative((SDLWindow*)window, (SDLSurface*)shape, (SDLWindowShapeMode*)shapeMode);
			return ret;
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, SDLSurfacePtr shape, SDLWindowShapeModePtr shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)shape, (SDLWindowShapeMode*)shapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindowPtr window, ref SDLSurface shape, SDLWindowShapeModePtr shapeMode)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				int ret = SetWindowShapeNative((SDLWindow*)window, (SDLSurface*)pshape, (SDLWindowShapeMode*)shapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, ref SDLSurface shape, SDLWindowShapeModePtr shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					int ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape, (SDLWindowShapeMode*)shapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindowPtr window, SDLSurfacePtr shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
			{
				int ret = SetWindowShapeNative((SDLWindow*)window, (SDLSurface*)shape, (SDLWindowShapeMode*)pshapeMode);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, SDLSurfacePtr shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)shape, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(SDLWindowPtr window, ref SDLSurface shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = SetWindowShapeNative((SDLWindow*)window, (SDLSurface*)pshape, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int SetWindowShape(ref SDLWindow window, ref SDLSurface shape, ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
					{
						int ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape, (SDLWindowShapeMode*)pshapeMode);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetShapedWindowModeNative(SDLWindow* window, SDLWindowShapeMode* shapeMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLWindowShapeMode*, int>)funcTable[807])(window, shapeMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[807])((nint)window, (nint)shapeMode);
			#endif
		}
	}
}
