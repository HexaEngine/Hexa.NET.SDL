// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* CreateTextureFromSurface([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, surface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* CreateTextureFromSurface([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLTexture* ret = CreateTextureFromSurfaceNative(renderer, (SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* CreateTextureFromSurface([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLSurface* psurface = &surface)
				{
					SDLTexture* ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, (SDLSurface*)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int QueryTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, uint*, int*, int*, int*, int>)funcTable[734])(texture, format, access, w, h);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[734])((nint)texture, (nint)format, (nint)access, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			int ret = QueryTextureNative(texture, format, access, w, h);
			return ret;
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				int ret = QueryTextureNative(texture, (uint*)pformat, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* paccess = &access)
			{
				int ret = QueryTextureNative(texture, format, (int*)paccess, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				int ret = QueryTextureNative(texture, format, access, (int*)pw, h);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative(texture, (uint*)pformat, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					int ret = QueryTextureNative(texture, format, (int*)paccess, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, h);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				int ret = QueryTextureNative(texture, format, access, w, (int*)ph);
				return ret;
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative(texture, (uint*)pformat, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative(texture, format, (int*)paccess, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					int ret = QueryTextureNative(texture, format, access, (int*)pw, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative(texture, (uint*)pformat, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = QueryTextureNative(texture, format, (int*)paccess, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = QueryTextureNative(texture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							fixed (int* ph = &h)
							{
								int ret = QueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureColorModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, byte, byte, int>)funcTable[735])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)funcTable[735])((nint)texture, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			int ret = SetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureColorModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, byte*, byte*, int>)funcTable[736])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[736])((nint)texture, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			int ret = GetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = GetTextureColorModNative(texture, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = GetTextureColorModNative(texture, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = GetTextureColorModNative(texture, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, b);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = GetTextureColorModNative(texture, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative(texture, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = GetTextureColorModNative(texture, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = GetTextureColorModNative(texture, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureAlphaModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, int>)funcTable[737])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)funcTable[737])((nint)texture, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			int ret = SetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureAlphaModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, int>)funcTable[738])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[738])((nint)texture, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			int ret = GetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				int ret = GetTextureAlphaModNative(texture, (byte*)palpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* palpha = &alpha)
				{
					int ret = GetTextureAlphaModNative((SDLTexture*)ptexture, (byte*)palpha);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureBlendModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode, int>)funcTable[739])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, int>)funcTable[739])((nint)texture, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			int ret = SetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureBlendModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode*, int>)funcTable[740])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[740])((nint)texture, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			int ret = GetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = GetTextureBlendModeNative(texture, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					int ret = GetTextureBlendModeNative((SDLTexture*)ptexture, (SDLBlendMode*)pblendMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureScaleModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode, int>)funcTable[741])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLScaleMode, int>)funcTable[741])((nint)texture, scaleMode);
			#endif
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			int ret = SetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextureScaleModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode*, int>)funcTable[742])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[742])((nint)texture, (nint)scaleMode);
			#endif
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			int ret = GetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = GetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] ref SDLScaleMode scaleMode)
		{
			fixed (SDLScaleMode* pscaleMode = &scaleMode)
			{
				int ret = GetTextureScaleModeNative(texture, (SDLScaleMode*)pscaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] ref SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLScaleMode* pscaleMode = &scaleMode)
				{
					int ret = GetTextureScaleModeNative((SDLTexture*)ptexture, (SDLScaleMode*)pscaleMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextureUserDataNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, void*, int>)funcTable[743])(texture, userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[743])((nint)texture, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			int ret = SetTextureUserDataNative(texture, userdata);
			return ret;
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetTextureUserDataNative((SDLTexture*)ptexture, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetTextureUserDataNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, void*>)funcTable[744])(texture);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[744])((nint)texture);
			#endif
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* GetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			void* ret = GetTextureUserDataNative(texture);
			return ret;
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* GetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				void* ret = GetTextureUserDataNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, void*, int, int>)funcTable[745])(texture, rect, pixels, pitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)funcTable[745])((nint)texture, (nint)rect, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			int ret = UpdateTextureNative(texture, rect, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = UpdateTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = UpdateTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = UpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateYUVTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, byte*, int, byte*, int, byte*, int, int>)funcTable[746])(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int, int>)funcTable[746])((nint)texture, (nint)rect, (nint)yplane, ypitch, (nint)uplane, upitch, (nint)vplane, vpitch);
			#endif
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			int ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			return ret;
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				int ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				int ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pvplane = &vplane)
			{
				int ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							fixed (byte* pvplane = &vplane)
							{
								int ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateNVTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, byte*, int, byte*, int, int>)funcTable[747])(texture, rect, yplane, ypitch, uVplane, uVpitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, int>)funcTable[747])((nint)texture, (nint)rect, (nint)yplane, ypitch, (nint)uVplane, uVpitch);
			#endif
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			int ret = UpdateNVTextureNative(texture, rect, yplane, ypitch, uVplane, uVpitch);
			return ret;
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = UpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				int ret = UpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = UpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						int ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* puVplane = &uVplane)
			{
				int ret = UpdateNVTextureNative(texture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = UpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = UpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = UpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puVplane = &uVplane)
						{
							int ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LockTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, void**, int*, int>)funcTable[748])(texture, rect, pixels, pitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[748])((nint)texture, (nint)rect, (nint)pixels, (nint)pitch);
			#endif
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			int ret = LockTextureNative(texture, rect, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = LockTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = LockTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = LockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (int* ppitch = &pitch)
			{
				int ret = LockTextureNative(texture, rect, pixels, (int*)ppitch);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ppitch = &pitch)
				{
					int ret = LockTextureNative((SDLTexture*)ptexture, rect, pixels, (int*)ppitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* ppitch = &pitch)
				{
					int ret = LockTextureNative(texture, (SDLRect*)prect, pixels, (int*)ppitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (int* ppitch = &pitch)
					{
						int ret = LockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, (int*)ppitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LockTextureToSurfaceNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, SDLSurface**, int>)funcTable[749])(texture, rect, surface);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[749])((nint)texture, (nint)rect, (nint)surface);
			#endif
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			int ret = LockTextureToSurfaceNative(texture, rect, surface);
			return ret;
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, rect, surface);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = LockTextureToSurfaceNative(texture, (SDLRect*)prect, surface);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, surface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLSurface** psurface = &surface)
			{
				int ret = LockTextureToSurfaceNative(texture, rect, (SDLSurface**)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					int ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, rect, (SDLSurface**)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					int ret = LockTextureToSurfaceNative(texture, (SDLRect*)prect, (SDLSurface**)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (SDLSurface** psurface = &surface)
					{
						int ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, (SDLSurface**)psurface);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTexture*, void>)funcTable[750])(texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[750])((nint)texture);
			#endif
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			UnlockTextureNative(texture);
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				UnlockTextureNative((SDLTexture*)ptexture);
			}
		}

		/// <summary>
		/// Determine whether a renderer supports the use of render targets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool RenderTargetSupportedNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool>)funcTable[751])(renderer);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[751])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Determine whether a renderer supports the use of render targets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool RenderTargetSupported([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = RenderTargetSupportedNative(renderer);
			return ret;
		}

		/// <summary>
		/// Determine whether a renderer supports the use of render targets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool RenderTargetSupported([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = RenderTargetSupportedNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetRenderTargetNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, int>)funcTable[752])(renderer, texture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[752])((nint)renderer, (nint)texture);
			#endif
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			int ret = SetRenderTargetNative(renderer, texture);
			return ret;
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SetRenderTargetNative((SDLRenderer*)prenderer, texture);
				return ret;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SetRenderTargetNative(renderer, (SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SetRenderTargetNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* GetRenderTargetNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*>)funcTable[753])(renderer);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[753])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* GetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLTexture* ret = GetRenderTargetNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* GetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = GetRenderTargetNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set a device independent resolution for rendering.<br/>
		/// This function uses the viewport and scaling functionality to allow a fixed<br/>
		/// logical resolution for rendering, regardless of the actual output<br/>
		/// resolution. If the actual output resolution doesn't have the same aspect<br/>
		/// ratio the output rendering will be centered within the output display.<br/>
		/// If the output display is a window, mouse and touch events in the window<br/>
		/// will be filtered and scaled so they seem to arrive within the logical<br/>
		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>
		/// relative motion events are also scaled.<br/>
		/// If this function results in scaling or subpixel drawing by the rendering<br/>
		/// backend, it will be handled using the appropriate quality hints.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderSetLogicalSizeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int, int, int>)funcTable[754])(renderer, w, h);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int>)funcTable[754])((nint)renderer, w, h);
			#endif
		}

		/// <summary>
		/// Set a device independent resolution for rendering.<br/>
		/// This function uses the viewport and scaling functionality to allow a fixed<br/>
		/// logical resolution for rendering, regardless of the actual output<br/>
		/// resolution. If the actual output resolution doesn't have the same aspect<br/>
		/// ratio the output rendering will be centered within the output display.<br/>
		/// If the output display is a window, mouse and touch events in the window<br/>
		/// will be filtered and scaled so they seem to arrive within the logical<br/>
		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>
		/// relative motion events are also scaled.<br/>
		/// If this function results in scaling or subpixel drawing by the rendering<br/>
		/// backend, it will be handled using the appropriate quality hints.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			int ret = RenderSetLogicalSizeNative(renderer, w, h);
			return ret;
		}

		/// <summary>
		/// Set a device independent resolution for rendering.<br/>
		/// This function uses the viewport and scaling functionality to allow a fixed<br/>
		/// logical resolution for rendering, regardless of the actual output<br/>
		/// resolution. If the actual output resolution doesn't have the same aspect<br/>
		/// ratio the output rendering will be centered within the output display.<br/>
		/// If the output display is a window, mouse and touch events in the window<br/>
		/// will be filtered and scaled so they seem to arrive within the logical<br/>
		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>
		/// relative motion events are also scaled.<br/>
		/// If this function results in scaling or subpixel drawing by the rendering<br/>
		/// backend, it will be handled using the appropriate quality hints.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderSetLogicalSizeNative((SDLRenderer*)prenderer, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderGetLogicalSizeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, int*, int*, void>)funcTable[755])(renderer, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[755])((nint)renderer, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			RenderGetLogicalSizeNative(renderer, w, h);
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				RenderGetLogicalSizeNative((SDLRenderer*)prenderer, w, h);
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				RenderGetLogicalSizeNative(renderer, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					RenderGetLogicalSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				RenderGetLogicalSizeNative(renderer, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					RenderGetLogicalSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					RenderGetLogicalSizeNative(renderer, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						RenderGetLogicalSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set whether to force integer scales for resolution-independent rendering.<br/>
		/// This function restricts the logical viewport to integer values - that is,<br/>
		/// when a resolution is between two multiples of a logical size, the viewport<br/>
		/// size is rounded down to the lower multiple.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderSetIntegerScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool, int>)funcTable[756])(renderer, enable);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLBool, int>)funcTable[756])((nint)renderer, enable);
			#endif
		}

		/// <summary>
		/// Set whether to force integer scales for resolution-independent rendering.<br/>
		/// This function restricts the logical viewport to integer values - that is,<br/>
		/// when a resolution is between two multiples of a logical size, the viewport<br/>
		/// size is rounded down to the lower multiple.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			int ret = RenderSetIntegerScaleNative(renderer, enable);
			return ret;
		}

		/// <summary>
		/// Set whether to force integer scales for resolution-independent rendering.<br/>
		/// This function restricts the logical viewport to integer values - that is,<br/>
		/// when a resolution is between two multiples of a logical size, the viewport<br/>
		/// size is rounded down to the lower multiple.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderSetIntegerScaleNative((SDLRenderer*)prenderer, enable);
				return ret;
			}
		}

		/// <summary>
		/// Get whether integer scales are forced for resolution-independent rendering.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool RenderGetIntegerScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool>)funcTable[757])(renderer);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[757])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get whether integer scales are forced for resolution-independent rendering.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool RenderGetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = RenderGetIntegerScaleNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get whether integer scales are forced for resolution-independent rendering.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool RenderGetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = RenderGetIntegerScaleNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderSetViewportNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, int>)funcTable[758])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[758])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = RenderSetViewportNative(renderer, rect);
			return ret;
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderSetViewportNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = RenderSetViewportNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = RenderSetViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderGetViewportNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, void>)funcTable[759])(renderer, rect);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[759])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			RenderGetViewportNative(renderer, rect);
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				RenderGetViewportNative((SDLRenderer*)prenderer, rect);
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				RenderGetViewportNative(renderer, (SDLRect*)prect);
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					RenderGetViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
				}
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderSetClipRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, int>)funcTable[760])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[760])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = RenderSetClipRectNative(renderer, rect);
			return ret;
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderSetClipRectNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = RenderSetClipRectNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = RenderSetClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderGetClipRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, void>)funcTable[761])(renderer, rect);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[761])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			RenderGetClipRectNative(renderer, rect);
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				RenderGetClipRectNative((SDLRenderer*)prenderer, rect);
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				RenderGetClipRectNative(renderer, (SDLRect*)prect);
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					RenderGetClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
				}
			}
		}

		/// <summary>
		/// Get whether clipping is enabled on the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBool RenderIsClipEnabledNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool>)funcTable[762])(renderer);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)funcTable[762])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get whether clipping is enabled on the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool RenderIsClipEnabled([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = RenderIsClipEnabledNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get whether clipping is enabled on the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool RenderIsClipEnabled([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = RenderIsClipEnabledNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderSetScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, int>)funcTable[763])(renderer, scaleX, scaleY);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, float, int>)funcTable[763])((nint)renderer, scaleX, scaleY);
			#endif
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			int ret = RenderSetScaleNative(renderer, scaleX, scaleY);
			return ret;
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RenderSetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = RenderSetScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
				return ret;
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderGetScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, float*, float*, void>)funcTable[764])(renderer, scaleX, scaleY);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[764])((nint)renderer, (nint)scaleX, (nint)scaleY);
			#endif
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			RenderGetScaleNative(renderer, scaleX, scaleY);
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				RenderGetScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				RenderGetScaleNative(renderer, (float*)pscaleX, scaleY);
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					RenderGetScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, scaleY);
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (float* pscaleY = &scaleY)
			{
				RenderGetScaleNative(renderer, scaleX, (float*)pscaleY);
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleY = &scaleY)
				{
					RenderGetScaleNative((SDLRenderer*)prenderer, scaleX, (float*)pscaleY);
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				fixed (float* pscaleY = &scaleY)
				{
					RenderGetScaleNative(renderer, (float*)pscaleX, (float*)pscaleY);
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					fixed (float* pscaleY = &scaleY)
					{
						RenderGetScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, (float*)pscaleY);
					}
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderWindowToLogicalNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, int, int, float*, float*, void>)funcTable[765])(renderer, windowX, windowY, logicalX, logicalY);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, void>)funcTable[765])((nint)renderer, windowX, windowY, (nint)logicalX, (nint)logicalY);
			#endif
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			RenderWindowToLogicalNative(renderer, windowX, windowY, logicalX, logicalY);
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				RenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, logicalX, logicalY);
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (float* plogicalX = &logicalX)
			{
				RenderWindowToLogicalNative(renderer, windowX, windowY, (float*)plogicalX, logicalY);
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalX = &logicalX)
				{
					RenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, (float*)plogicalX, logicalY);
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (float* plogicalY = &logicalY)
			{
				RenderWindowToLogicalNative(renderer, windowX, windowY, logicalX, (float*)plogicalY);
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalY = &logicalY)
				{
					RenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, logicalX, (float*)plogicalY);
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (float* plogicalX = &logicalX)
			{
				fixed (float* plogicalY = &logicalY)
				{
					RenderWindowToLogicalNative(renderer, windowX, windowY, (float*)plogicalX, (float*)plogicalY);
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalX = &logicalX)
				{
					fixed (float* plogicalY = &logicalY)
					{
						RenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, (float*)plogicalX, (float*)plogicalY);
					}
				}
			}
		}
	}
}
