// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Search a string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrstrS(byte* haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strstr(ref byte haystack, ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrstrS(ref byte haystack, ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strstr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrstrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strstr(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrstrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrstrS(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrnstrNative(byte* haystack, byte* needle, nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, byte*>)funcTable[73])(haystack, needle, maxlen);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[73])((nint)haystack, (nint)needle, maxlen);
			#endif
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(byte* haystack, byte* needle, nuint maxlen)
		{
			byte* ret = StrnstrNative(haystack, needle, maxlen);
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(byte* haystack, byte* needle, nuint maxlen)
		{
			string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, needle, maxlen));
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(ref byte haystack, byte* needle, nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrnstrNative((byte*)phaystack, needle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(ref byte haystack, byte* needle, nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, needle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(ReadOnlySpan<byte> haystack, byte* needle, nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrnstrNative((byte*)phaystack, needle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(ReadOnlySpan<byte> haystack, byte* needle, nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, needle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(string haystack, byte* needle, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrnstrNative(pStr0, needle, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(string haystack, byte* needle, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(pStr0, needle, maxlen));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(byte* haystack, ref byte needle, nuint maxlen)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrnstrNative(haystack, (byte*)pneedle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(byte* haystack, ref byte needle, nuint maxlen)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, (byte*)pneedle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(byte* haystack, ReadOnlySpan<byte> needle, nuint maxlen)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrnstrNative(haystack, (byte*)pneedle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(byte* haystack, ReadOnlySpan<byte> needle, nuint maxlen)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, (byte*)pneedle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(byte* haystack, string needle, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrnstrNative(haystack, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(byte* haystack, string needle, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, pStr0, maxlen));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(ref byte haystack, ref byte needle, nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(ref byte haystack, ref byte needle, nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle, nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle, nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strnstr(string haystack, string needle, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrnstrNative(pStr0, pStr1, maxlen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a string, up to n bytes, for the first instance of a specific<br/>
		/// substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string, or `maxlen` bytes have been examined. It is<br/>
		/// possible to use this function on a string without a null terminator.<br/>
		/// Note that this looks for strings of _bytes_, not _characters_, so it's<br/>
		/// legal to search for malformed and incomplete UTF-8 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrnstrS(string haystack, string needle, nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(pStr0, pStr1, maxlen));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrcasestrNative(byte* haystack, byte* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[74])(haystack, needle);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[74])((nint)haystack, (nint)needle);
			#endif
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(byte* haystack, byte* needle)
		{
			byte* ret = StrcasestrNative(haystack, needle);
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(byte* haystack, byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, needle));
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(ref byte haystack, byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(ref byte haystack, byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(ReadOnlySpan<byte> haystack, byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(ReadOnlySpan<byte> haystack, byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(string haystack, byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(string haystack, byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(byte* haystack, ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(byte* haystack, ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(byte* haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(byte* haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(byte* haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(byte* haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(ref byte haystack, ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(ref byte haystack, ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* Strcasestr(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Search a UTF-8 string for the first instance of a specific substring,<br/>
		/// case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrcasestrS(string haystack, string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrtokRNative(byte* str, byte* delim, byte** saveptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte**, byte*>)funcTable[75])(str, delim, saveptr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)funcTable[75])((nint)str, (nint)delim, (nint)saveptr);
			#endif
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, byte* delim, byte** saveptr)
		{
			byte* ret = StrtokRNative(str, delim, saveptr);
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, byte* delim, byte** saveptr)
		{
			string ret = Utils.DecodeStringUTF8(StrtokRNative(str, delim, saveptr));
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref byte str, byte* delim, byte** saveptr)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrtokRNative((byte*)pstr, delim, saveptr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref byte str, byte* delim, byte** saveptr)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)pstr, delim, saveptr));
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref string str, byte* delim, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrtokRNative(pStr0, delim, saveptr);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref string str, byte* delim, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, delim, saveptr));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, ref byte delim, byte** saveptr)
		{
			fixed (byte* pdelim = &delim)
			{
				byte* ret = StrtokRNative(str, (byte*)pdelim, saveptr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, ref byte delim, byte** saveptr)
		{
			fixed (byte* pdelim = &delim)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(str, (byte*)pdelim, saveptr));
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, ReadOnlySpan<byte> delim, byte** saveptr)
		{
			fixed (byte* pdelim = delim)
			{
				byte* ret = StrtokRNative(str, (byte*)pdelim, saveptr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, ReadOnlySpan<byte> delim, byte** saveptr)
		{
			fixed (byte* pdelim = delim)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(str, (byte*)pdelim, saveptr));
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, string delim, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delim != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delim);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delim, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrtokRNative(str, pStr0, saveptr);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, string delim, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delim != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delim);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delim, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokRNative(str, pStr0, saveptr));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref byte str, ref byte delim, byte** saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = &delim)
				{
					byte* ret = StrtokRNative((byte*)pstr, (byte*)pdelim, saveptr);
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref byte str, ref byte delim, byte** saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = &delim)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)pstr, (byte*)pdelim, saveptr));
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref byte str, ReadOnlySpan<byte> delim, byte** saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = delim)
				{
					byte* ret = StrtokRNative((byte*)pstr, (byte*)pdelim, saveptr);
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref byte str, ReadOnlySpan<byte> delim, byte** saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = delim)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)pstr, (byte*)pdelim, saveptr));
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref string str, string delim, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (delim != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(delim);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(delim, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrtokRNative(pStr0, pStr1, saveptr);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref string str, string delim, byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (delim != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(delim);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(delim, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, pStr1, saveptr));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, byte* delim, ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(str, delim, (byte**)psaveptr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, byte* delim, ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(str, delim, (byte**)psaveptr));
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref byte str, byte* delim, ref byte* saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokRNative((byte*)pstr, delim, (byte**)psaveptr);
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref byte str, byte* delim, ref byte* saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)pstr, delim, (byte**)psaveptr));
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref string str, byte* delim, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(pStr0, delim, (byte**)psaveptr);
				str = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref string str, byte* delim, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, delim, (byte**)psaveptr));
				str = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, ref byte delim, ref byte* saveptr)
		{
			fixed (byte* pdelim = &delim)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokRNative(str, (byte*)pdelim, (byte**)psaveptr);
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, ref byte delim, ref byte* saveptr)
		{
			fixed (byte* pdelim = &delim)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative(str, (byte*)pdelim, (byte**)psaveptr));
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, ReadOnlySpan<byte> delim, ref byte* saveptr)
		{
			fixed (byte* pdelim = delim)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokRNative(str, (byte*)pdelim, (byte**)psaveptr);
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, ReadOnlySpan<byte> delim, ref byte* saveptr)
		{
			fixed (byte* pdelim = delim)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative(str, (byte*)pdelim, (byte**)psaveptr));
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(byte* str, string delim, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delim != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delim);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delim, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(str, pStr0, (byte**)psaveptr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(byte* str, string delim, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delim != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delim);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delim, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(str, pStr0, (byte**)psaveptr));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref byte str, ref byte delim, ref byte* saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = &delim)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						byte* ret = StrtokRNative((byte*)pstr, (byte*)pdelim, (byte**)psaveptr);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref byte str, ref byte delim, ref byte* saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = &delim)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)pstr, (byte*)pdelim, (byte**)psaveptr));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref byte str, ReadOnlySpan<byte> delim, ref byte* saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = delim)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						byte* ret = StrtokRNative((byte*)pstr, (byte*)pdelim, (byte**)psaveptr);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref byte str, ReadOnlySpan<byte> delim, ref byte* saveptr)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pdelim = delim)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)pstr, (byte*)pdelim, (byte**)psaveptr));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* StrtokR(ref string str, string delim, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (delim != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(delim);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(delim, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(pStr0, pStr1, (byte**)psaveptr);
				str = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strtok_r() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Break a string up into a series of tokens.<br/>
		/// To start tokenizing a new string, `str` should be the non-NULL address of<br/>
		/// the string to start tokenizing. Future calls to get the next token from the<br/>
		/// same string should specify a NULL.<br/>
		/// Note that this function will overwrite pieces of `str` with null chars to<br/>
		/// split it into tokens. This function cannot be used with const/read-only<br/>
		/// strings!<br/>
		/// `saveptr` just needs to point to a `char *` that can be overwritten; SDL<br/>
		/// will use this to save tokenizing state between calls. It is initialized if<br/>
		/// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string StrtokRS(ref string str, string delim, ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (delim != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(delim);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(delim, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, pStr1, (byte**)psaveptr));
				str = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strlen().<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrlenNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint>)funcTable[76])(str);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[76])((nint)str);
			#endif
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strlen().<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strlen(byte* str)
		{
			nuint ret = Utf8StrlenNative(str);
			return ret;
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strlen().<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strlen(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = Utf8StrlenNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strlen().<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strlen(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = Utf8StrlenNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strlen().<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strlen(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string, up to n bytes.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strnlen().<br/>
		/// The counting stops at `bytes` bytes (not codepoints!). This seems<br/>
		/// counterintuitive, but makes it easy to express the total size of the<br/>
		/// string's buffer.<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrnlenNative(byte* str, nuint bytes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, nuint>)funcTable[77])(str, bytes);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint, nuint>)funcTable[77])((nint)str, bytes);
			#endif
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string, up to n bytes.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strnlen().<br/>
		/// The counting stops at `bytes` bytes (not codepoints!). This seems<br/>
		/// counterintuitive, but makes it easy to express the total size of the<br/>
		/// string's buffer.<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strnlen(byte* str, nuint bytes)
		{
			nuint ret = Utf8StrnlenNative(str, bytes);
			return ret;
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string, up to n bytes.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strnlen().<br/>
		/// The counting stops at `bytes` bytes (not codepoints!). This seems<br/>
		/// counterintuitive, but makes it easy to express the total size of the<br/>
		/// string's buffer.<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strnlen(ref byte str, nuint bytes)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = Utf8StrnlenNative((byte*)pstr, bytes);
				return ret;
			}
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string, up to n bytes.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strnlen().<br/>
		/// The counting stops at `bytes` bytes (not codepoints!). This seems<br/>
		/// counterintuitive, but makes it easy to express the total size of the<br/>
		/// string's buffer.<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strnlen(ReadOnlySpan<byte> str, nuint bytes)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = Utf8StrnlenNative((byte*)pstr, bytes);
				return ret;
			}
		}

		/// <summary>
		/// Count the number of codepoints in a UTF-8 string, up to n bytes.<br/>
		/// Counts the _codepoints_, not _bytes_, in `str`, excluding the null<br/>
		/// terminator.<br/>
		/// If you need to count the bytes in a string instead, consider using<br/>
		/// SDL_strnlen().<br/>
		/// The counting stops at `bytes` bytes (not codepoints!). This seems<br/>
		/// counterintuitive, but makes it easy to express the total size of the<br/>
		/// string's buffer.<br/>
		/// Since this handles Unicode, it expects the strings to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the<br/>
		/// count by several replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nuint Utf8Strnlen(string str, nuint bytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrnlenNative(pStr0, bytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert an integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ItoaNative(int value, byte* str, int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, int, byte*>)funcTable[78])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint, int, nint>)funcTable[78])(value, (nint)str, radix);
			#endif
		}

		/// <summary>
		/// Convert an integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Itoa(int value, byte* str, int radix)
		{
			byte* ret = ItoaNative(value, str, radix);
			return ret;
		}

		/// <summary>
		/// Convert an integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string ItoaS(int value, byte* str, int radix)
		{
			string ret = Utils.DecodeStringUTF8(ItoaNative(value, str, radix));
			return ret;
		}

		/// <summary>
		/// Convert an integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Itoa(int value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ItoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		/// <summary>
		/// Convert an integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string ItoaS(int value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ItoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		/// <summary>
		/// Convert an integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Itoa(int value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ItoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert an integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string ItoaS(int value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ItoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert an unsigned integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* UitoaNative(uint value, byte* str, int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int, byte*>)funcTable[79])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint, int, nint>)funcTable[79])(value, (nint)str, radix);
			#endif
		}

		/// <summary>
		/// Convert an unsigned integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Uitoa(uint value, byte* str, int radix)
		{
			byte* ret = UitoaNative(value, str, radix);
			return ret;
		}

		/// <summary>
		/// Convert an unsigned integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string UitoaS(uint value, byte* str, int radix)
		{
			string ret = Utils.DecodeStringUTF8(UitoaNative(value, str, radix));
			return ret;
		}

		/// <summary>
		/// Convert an unsigned integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Uitoa(uint value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = UitoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		/// <summary>
		/// Convert an unsigned integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string UitoaS(uint value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(UitoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		/// <summary>
		/// Convert an unsigned integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Uitoa(uint value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = UitoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert an unsigned integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string UitoaS(uint value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(UitoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* LltoaNative(long value, byte* str, int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, byte*, int, byte*>)funcTable[80])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<long, nint, int, nint>)funcTable[80])(value, (nint)str, radix);
			#endif
		}

		/// <summary>
		/// Convert a long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Lltoa(long value, byte* str, int radix)
		{
			byte* ret = LltoaNative(value, str, radix);
			return ret;
		}

		/// <summary>
		/// Convert a long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string LltoaS(long value, byte* str, int radix)
		{
			string ret = Utils.DecodeStringUTF8(LltoaNative(value, str, radix));
			return ret;
		}

		/// <summary>
		/// Convert a long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Lltoa(long value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = LltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		/// <summary>
		/// Convert a long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string LltoaS(long value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(LltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		/// <summary>
		/// Convert a long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Lltoa(long value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = LltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget possible negative<br/>
		/// signs, null terminator bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string LltoaS(long value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(LltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert an unsigned long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* UlltoaNative(ulong value, byte* str, int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte*, int, byte*>)funcTable[81])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ulong, nint, int, nint>)funcTable[81])(value, (nint)str, radix);
			#endif
		}

		/// <summary>
		/// Convert an unsigned long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Ulltoa(ulong value, byte* str, int radix)
		{
			byte* ret = UlltoaNative(value, str, radix);
			return ret;
		}

		/// <summary>
		/// Convert an unsigned long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string UlltoaS(ulong value, byte* str, int radix)
		{
			string ret = Utils.DecodeStringUTF8(UlltoaNative(value, str, radix));
			return ret;
		}

		/// <summary>
		/// Convert an unsigned long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Ulltoa(ulong value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = UlltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		/// <summary>
		/// Convert an unsigned long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string UlltoaS(ulong value, ref byte str, int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(UlltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		/// <summary>
		/// Convert an unsigned long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* Ulltoa(ulong value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = UlltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert an unsigned long long integer into a string.<br/>
		/// This requires a radix to specified for string format. Specifying 10<br/>
		/// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2<br/>
		/// to 36.<br/>
		/// Note that this function will overflow a buffer if `str` is not large enough<br/>
		/// to hold the output! It may be safer to use SDL_snprintf to clamp output, or<br/>
		/// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate<br/>
		/// much more space than you expect to use (and don't forget null terminator<br/>
		/// bytes, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string UlltoaS(ulong value, ref string str, int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(UlltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Parse an `int` from a string.<br/>
		/// The result of calling `SDL_atoi(str)` is equivalent to<br/>
		/// `(int)SDL_strtol(str, NULL, 10)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AtoiNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[82])(str);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[82])((nint)str);
			#endif
		}

		/// <summary>
		/// Parse an `int` from a string.<br/>
		/// The result of calling `SDL_atoi(str)` is equivalent to<br/>
		/// `(int)SDL_strtol(str, NULL, 10)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Atoi(byte* str)
		{
			int ret = AtoiNative(str);
			return ret;
		}

		/// <summary>
		/// Parse an `int` from a string.<br/>
		/// The result of calling `SDL_atoi(str)` is equivalent to<br/>
		/// `(int)SDL_strtol(str, NULL, 10)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Atoi(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				int ret = AtoiNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Parse an `int` from a string.<br/>
		/// The result of calling `SDL_atoi(str)` is equivalent to<br/>
		/// `(int)SDL_strtol(str, NULL, 10)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Atoi(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				int ret = AtoiNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Parse an `int` from a string.<br/>
		/// The result of calling `SDL_atoi(str)` is equivalent to<br/>
		/// `(int)SDL_strtol(str, NULL, 10)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Atoi(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AtoiNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Parse a `double` from a string.<br/>
		/// The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,<br/>
		/// NULL)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double AtofNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, double>)funcTable[83])(str);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[83])((nint)str);
			#endif
		}

		/// <summary>
		/// Parse a `double` from a string.<br/>
		/// The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,<br/>
		/// NULL)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static double Atof(byte* str)
		{
			double ret = AtofNative(str);
			return ret;
		}

		/// <summary>
		/// Parse a `double` from a string.<br/>
		/// The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,<br/>
		/// NULL)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static double Atof(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				double ret = AtofNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `double` from a string.<br/>
		/// The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,<br/>
		/// NULL)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static double Atof(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				double ret = AtofNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `double` from a string.<br/>
		/// The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,<br/>
		/// NULL)`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static double Atof(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			double ret = AtofNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrtolNative(byte* str, byte** endp, int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, int>)funcTable[84])(str, endp, baseValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[84])((nint)str, (nint)endp, baseValue);
			#endif
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(byte* str, byte** endp, int baseValue)
		{
			int ret = StrtolNative(str, endp, baseValue);
			return ret;
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(ref byte str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				int ret = StrtolNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(ReadOnlySpan<byte> str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				int ret = StrtolNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(string str, byte** endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrtolNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(byte* str, ref byte* endp, int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				int ret = StrtolNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(ref byte str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					int ret = StrtolNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(ReadOnlySpan<byte> str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					int ret = StrtolNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int Strtol(string str, ref byte* endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				int ret = StrtolNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint StrtoulNative(byte* str, byte** endp, int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, uint>)funcTable[85])(str, endp, baseValue);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, uint>)funcTable[85])((nint)str, (nint)endp, baseValue);
			#endif
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(byte* str, byte** endp, int baseValue)
		{
			uint ret = StrtoulNative(str, endp, baseValue);
			return ret;
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(ref byte str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = StrtoulNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(ReadOnlySpan<byte> str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				uint ret = StrtoulNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(string str, byte** endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = StrtoulNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(byte* str, ref byte* endp, int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				uint ret = StrtoulNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(ref byte str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					uint ret = StrtoulNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(ReadOnlySpan<byte> str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					uint ret = StrtoulNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse an `unsigned long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
		/// clamped to the maximum representable `unsigned long` value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint Strtoul(string str, ref byte* endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				uint ret = StrtoulNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long StrtollNative(byte* str, byte** endp, int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, long>)funcTable[86])(str, endp, baseValue);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, nint, int, long>)funcTable[86])((nint)str, (nint)endp, baseValue);
			#endif
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long Strtoll(byte* str, byte** endp, int baseValue)
		{
			long ret = StrtollNative(str, endp, baseValue);
			return ret;
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long Strtoll(ref byte str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				long ret = StrtollNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long Strtoll(ReadOnlySpan<byte> str, byte** endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				long ret = StrtollNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long Strtoll(string str, byte** endp, int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = StrtollNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long Strtoll(byte* str, ref byte* endp, int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				long ret = StrtollNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long Strtoll(ref byte str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					long ret = StrtollNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long long` from a string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long long`, the result is<br/>
		/// clamped to the minimum and maximum representable `long long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long Strtoll(ReadOnlySpan<byte> str, ref byte* endp, int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					long ret = StrtollNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}
	}
}
