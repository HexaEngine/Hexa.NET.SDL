// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrrevNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[58])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[58])((nint)str);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			byte* ret = StrrevNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrrevNative(str));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrrevNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrrevNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrrevNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrrevNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StruprNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[59])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[59])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			byte* ret = StruprNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StruprNative(str));
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StruprNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StruprNative((byte*)pstr));
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StruprNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StruprNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrlwrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[60])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[60])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			byte* ret = StrlwrNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrlwrNative(str));
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrlwrNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrlwrNative((byte*)pstr));
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrlwrNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrlwrNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrchrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[61])(str, c);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[61])((nint)str, c);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* ret = StrchrNative(str, c);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			string ret = Utils.DecodeStringUTF8(StrchrNative(str, c));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrrchrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[62])(str, c);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[62])((nint)str, c);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* ret = StrrchrNative(str, c);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			string ret = Utils.DecodeStringUTF8(StrrchrNative(str, c));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[63])(haystack, needle);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[63])((nint)haystack, (nint)needle);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* ret = StrstrNative(haystack, needle);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, needle));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrstrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrstrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrstrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrstrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrstrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrstrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrstrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrnstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, byte*>)funcTable[64])(haystack, needle, maxlen);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[64])((nint)haystack, (nint)needle, maxlen);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* ret = StrnstrNative(haystack, needle, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, needle, maxlen));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrnstrNative((byte*)phaystack, needle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, needle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrnstrNative((byte*)phaystack, needle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, needle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrnstrNative(pStr0, needle, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(pStr0, needle, maxlen));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrnstrNative(haystack, (byte*)pneedle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, (byte*)pneedle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrnstrNative(haystack, (byte*)pneedle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, (byte*)pneedle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrnstrNative(haystack, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, pStr0, maxlen));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrnstrNative(pStr0, pStr1, maxlen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(pStr0, pStr1, maxlen));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrcasestrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[65])(haystack, needle);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[65])((nint)haystack, (nint)needle);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* ret = StrcasestrNative(haystack, needle);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, needle));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrtokRNative([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte**, byte*>)funcTable[66])(s1, s2, saveptr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)funcTable[66])((nint)s1, (nint)s2, (nint)saveptr);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			byte* ret = StrtokRNative(s1, s2, saveptr);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, s2, saveptr));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				byte* ret = StrtokRNative((byte*)ps1, s2, saveptr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)ps1, s2, saveptr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrtokRNative(pStr0, s2, saveptr);
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, s2, saveptr));
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				byte* ret = StrtokRNative(s1, (byte*)ps2, saveptr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, (byte*)ps2, saveptr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				byte* ret = StrtokRNative(s1, (byte*)ps2, saveptr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, (byte*)ps2, saveptr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrtokRNative(s1, pStr0, saveptr);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, pStr0, saveptr));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					byte* ret = StrtokRNative((byte*)ps1, (byte*)ps2, saveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)ps1, (byte*)ps2, saveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					byte* ret = StrtokRNative((byte*)ps1, (byte*)ps2, saveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)ps1, (byte*)ps2, saveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrtokRNative(pStr0, pStr1, saveptr);
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, pStr1, saveptr));
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(s1, s2, (byte**)psaveptr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, s2, (byte**)psaveptr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokRNative((byte*)ps1, s2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)ps1, s2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(pStr0, s2, (byte**)psaveptr);
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, s2, (byte**)psaveptr));
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokRNative(s1, (byte*)ps2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, (byte*)ps2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = StrtokRNative(s1, (byte*)ps2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps2 = s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, (byte*)ps2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(s1, pStr0, (byte**)psaveptr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(s1, pStr0, (byte**)psaveptr));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						byte* ret = StrtokRNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr));
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						byte* ret = StrtokRNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						string ret = Utils.DecodeStringUTF8(StrtokRNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr));
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* StrtokR([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = StrtokRNative(pStr0, pStr1, (byte**)psaveptr);
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtok_r")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrtokRS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char *")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "char const *")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char * *")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(StrtokRNative(pStr0, pStr1, (byte**)psaveptr));
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint>)funcTable[67])(str);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[67])((nint)str);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			nuint ret = Utf8StrlenNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = Utf8StrlenNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = Utf8StrlenNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrnlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, nuint>)funcTable[68])(str, bytes);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint, nuint>)funcTable[68])((nint)str, bytes);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			nuint ret = Utf8StrnlenNative(str, bytes);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = Utf8StrnlenNative((byte*)pstr, bytes);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = Utf8StrnlenNative((byte*)pstr, bytes);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrnlenNative(pStr0, bytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ItoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, int, byte*>)funcTable[69])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint, int, nint>)funcTable[69])(value, (nint)str, radix);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Itoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = ItoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string ItoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(ItoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Itoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ItoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string ItoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ItoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Itoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ItoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string ItoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ItoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* UitoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int, byte*>)funcTable[70])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint, int, nint>)funcTable[70])(value, (nint)str, radix);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Uitoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = UitoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string UitoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(UitoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Uitoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = UitoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string UitoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(UitoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Uitoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = UitoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string UitoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(UitoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* LltoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, byte*, int, byte*>)funcTable[71])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<long, nint, int, nint>)funcTable[71])(value, (nint)str, radix);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Lltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = LltoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(LltoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Lltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = LltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(LltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Lltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = LltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(LltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* UlltoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte*, int, byte*>)funcTable[72])(value, str, radix);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ulong, nint, int, nint>)funcTable[72])(value, (nint)str, radix);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Ulltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = UlltoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string UlltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(UlltoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Ulltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = UlltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string UlltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(UlltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Ulltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = UlltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string UlltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(UlltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AtoiNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[73])(str);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[73])((nint)str);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Atoi([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			int ret = AtoiNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Atoi([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				int ret = AtoiNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Atoi([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				int ret = AtoiNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Atoi([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AtoiNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double AtofNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, double>)funcTable[74])(str);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[74])((nint)str);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Atof([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			double ret = AtofNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Atof([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				double ret = AtofNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Atof([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				double ret = AtofNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Atof([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			double ret = AtofNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrtolNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, int>)funcTable[75])(str, endp, baseValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[75])((nint)str, (nint)endp, baseValue);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			int ret = StrtolNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				int ret = StrtolNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				int ret = StrtolNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrtolNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				int ret = StrtolNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					int ret = StrtolNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					int ret = StrtolNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Strtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				int ret = StrtolNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint StrtoulNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, uint>)funcTable[76])(str, endp, baseValue);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, int, uint>)funcTable[76])((nint)str, (nint)endp, baseValue);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			uint ret = StrtoulNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = StrtoulNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				uint ret = StrtoulNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = StrtoulNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				uint ret = StrtoulNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					uint ret = StrtoulNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					uint ret = StrtoulNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned long")]
		public static uint Strtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				uint ret = StrtoulNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long StrtollNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, long>)funcTable[77])(str, endp, baseValue);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, nint, int, long>)funcTable[77])((nint)str, (nint)endp, baseValue);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			long ret = StrtollNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				long ret = StrtollNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				long ret = StrtollNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = StrtollNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				long ret = StrtollNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					long ret = StrtollNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					long ret = StrtollNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long Strtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				long ret = StrtollNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong StrtoullNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, int, ulong>)funcTable[78])(str, endp, baseValue);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, nint, int, ulong>)funcTable[78])((nint)str, (nint)endp, baseValue);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			ulong ret = StrtoullNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				ulong ret = StrtoullNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				ulong ret = StrtoullNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ulong ret = StrtoullNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				ulong ret = StrtoullNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					ulong ret = StrtoullNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					ulong ret = StrtoullNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong Strtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				ulong ret = StrtoullNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double StrtodNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte**, double>)funcTable[79])(str, endp);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, nint, double>)funcTable[79])((nint)str, (nint)endp);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp)
		{
			double ret = StrtodNative(str, endp);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp)
		{
			fixed (byte* pstr = &str)
			{
				double ret = StrtodNative((byte*)pstr, endp);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp)
		{
			fixed (byte* pstr = str)
			{
				double ret = StrtodNative((byte*)pstr, endp);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] byte** endp)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			double ret = StrtodNative(pStr0, endp);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp)
		{
			fixed (byte** pendp = &endp)
			{
				double ret = StrtodNative(str, (byte**)pendp);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					double ret = StrtodNative((byte*)pstr, (byte**)pendp);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte** pendp = &endp)
				{
					double ret = StrtodNative((byte*)pstr, (byte**)pendp);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Strtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char * *")] ref byte* endp)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				double ret = StrtodNative(pStr0, (byte**)pendp);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrcmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[80])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[80])((nint)str1, (nint)str2);
			#endif
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			int ret = StrcmpNative(str1, str2);
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = StrcmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = StrcmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrcmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = StrcmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = StrcmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrcmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = StrcmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = StrcmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = StrcmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrncmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, int>)funcTable[81])(str1, str2, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[81])((nint)str1, (nint)str2, maxlen);
			#endif
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = StrncmpNative(str1, str2, maxlen);
			return ret;
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = StrncmpNative((byte*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = StrncmpNative((byte*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrncmpNative(pStr0, str2, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ref byte str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = StrncmpNative(str1, (byte*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = StrncmpNative(str1, (byte*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrncmpNative(str1, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ref byte str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = StrncmpNative((byte*)pstr1, (byte*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = StrncmpNative((byte*)pstr1, (byte*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two UTF-8 strings up to a number of bytes.<br/>
		/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
		/// since effectively this function just compares bytes until it hits a<br/>
		/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
		/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
		/// Note that while this function is intended to be used with UTF-8, it is<br/>
		/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
		/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
		/// compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
		/// match to this number of bytes (or both have matched to a null-terminator<br/>
		/// character before this number of bytes), they will be considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = StrncmpNative(pStr0, pStr1, maxlen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the string to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StrcasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[82])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[82])((nint)str1, (nint)str2);
			#endif
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the string to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			int ret = StrcasecmpNative(str1, str2);
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the string to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = StrcasecmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the string to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = StrcasecmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated UTF-8 strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Since this handles Unicode, it expects the string to be well-formed UTF-8<br/>
		/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
		/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Strcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "char const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "char const *")] byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = StrcasecmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
