// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsnstrNative(haystack, (char*)pneedle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative(haystack, (char*)pneedle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsnstrNative(haystack, pneedle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative(haystack, pneedle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] ref char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] ref char needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					char* ret = WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] ref char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] ref char needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsnstrNative(phaystack, pneedle, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsnstrNative(phaystack, pneedle, maxlen));
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcscmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, int>)funcTable[55])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[55])((nint)str1, (nint)str2);
			#endif
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			int ret = WcscmpNative(str1, str2);
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcscmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscmpNative(pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcscmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscmpNative(str1, pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcscmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscmpNative(pstr1, pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcsncmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, int>)funcTable[56])(str1, str2, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[56])((nint)str1, (nint)str2, maxlen);
			#endif
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = WcsncmpNative(str1, str2, maxlen);
			return ret;
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcsncmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncmpNative(pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcsncmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncmpNative(str1, pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcsncmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncmpNative(pstr1, pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcscasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, int>)funcTable[57])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[57])((nint)str1, (nint)str2);
			#endif
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			int ret = WcscasecmpNative(str1, str2);
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcscasecmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscasecmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscasecmpNative(pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcscasecmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscasecmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscasecmpNative(str1, pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcscasecmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscasecmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscasecmpNative(pstr1, pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcsncasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, int>)funcTable[58])(str1, str2, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[58])((nint)str1, (nint)str2, maxlen);
			#endif
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = WcsncasecmpNative(str1, str2, maxlen);
			return ret;
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcsncasecmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncasecmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncasecmpNative(pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcsncasecmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncasecmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncasecmpNative(str1, pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcsncasecmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncasecmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncasecmpNative(pstr1, pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcstolNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] char* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char**, int, int>)funcTable[59])(str, endp, baseValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[59])((nint)str, (nint)endp, baseValue);
			#endif
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] char* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			int ret = WcstolNative(str, endp, baseValue);
			return ret;
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = &str)
			{
				int ret = WcstolNative((char*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				int ret = WcstolNative((char*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				int ret = WcstolNative(pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] char* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char** pendp = &endp)
			{
				int ret = WcstolNative(str, (char**)pendp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] ref char str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = &str)
			{
				fixed (char** pendp = &endp)
				{
					int ret = WcstolNative((char*)pstr, (char**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				fixed (char** pendp = &endp)
				{
					int ret = WcstolNative((char*)pstr, (char**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				fixed (char** pendp = &endp)
				{
					int ret = WcstolNative(pstr, (char**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint>)funcTable[60])(str);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[60])((nint)str);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			nuint ret = StrlenNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = StrlenNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = StrlenNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrnlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, nuint>)funcTable[61])(str, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint, nuint>)funcTable[61])((nint)str, maxlen);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = StrnlenNative(str, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = StrnlenNative((byte*)pstr, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = StrnlenNative((byte*)pstr, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrnlenNative(pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrlcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, nuint>)funcTable[62])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[62])((nint)dst, (nint)src, maxlen);
			#endif
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = StrlcpyNative(dst, src, maxlen);
			return ret;
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = StrlcpyNative((byte*)pdst, src, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcpyNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = StrlcpyNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* psrc = src)
			{
				nuint ret = StrlcpyNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcpyNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = StrlcpyNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					nuint ret = StrlcpyNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a string.<br/>
		/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
		/// then appends a null terminator.<br/>
		/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
		/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = StrlcpyNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint Utf8StrlcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, nuint>)funcTable[63])(dst, src, dstBytes);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[63])((nint)dst, (nint)src, dstBytes);
			#endif
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			nuint ret = Utf8StrlcpyNative(dst, src, dstBytes);
			return ret;
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = Utf8StrlcpyNative((byte*)pdst, src, dstBytes);
				return ret;
			}
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrlcpyNative(pStr0, src, dstBytes);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = Utf8StrlcpyNative(dst, (byte*)psrc, dstBytes);
				return ret;
			}
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* psrc = src)
			{
				nuint ret = Utf8StrlcpyNative(dst, (byte*)psrc, dstBytes);
				return ret;
			}
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = Utf8StrlcpyNative(dst, pStr0, dstBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = Utf8StrlcpyNative((byte*)pdst, (byte*)psrc, dstBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					nuint ret = Utf8StrlcpyNative((byte*)pdst, (byte*)psrc, dstBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy an UTF-8 string.<br/>
		/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
		/// also ensuring that the string written to `dst` does not end in a truncated<br/>
		/// multi-byte sequence. Finally, it appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
		/// written, not the length of `src`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Utf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = Utf8StrlcpyNative(pStr0, pStr1, dstBytes);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrlcatNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, nuint>)funcTable[64])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[64])((nint)dst, (nint)src, maxlen);
			#endif
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = StrlcatNative(dst, src, maxlen);
			return ret;
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = StrlcatNative((byte*)pdst, src, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcatNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = StrlcatNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* psrc = src)
			{
				nuint ret = StrlcatNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlcatNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = StrlcatNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					nuint ret = StrlcatNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Concatenate strings.<br/>
		/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
		/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = StrlcatNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrdupNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[65])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[65])((nint)str);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strdup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			byte* ret = StrdupNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrdupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrdupNative(str));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strdup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrdupNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrdupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrdupNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strdup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrdupNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrdupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrdupNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strdup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrdupNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrdupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrdupNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrndupNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, byte*>)funcTable[66])(str, maxlen);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[66])((nint)str, maxlen);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strndup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* ret = StrndupNative(str, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrndupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			string ret = Utils.DecodeStringUTF8(StrndupNative(str, maxlen));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strndup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrndupNative((byte*)pstr, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrndupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrndupNative((byte*)pstr, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strndup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrndupNative((byte*)pstr, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrndupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrndupNative((byte*)pstr, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strndup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrndupNative(pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strndup")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrndupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrndupNative(pStr0, maxlen));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrrevNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[67])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[67])((nint)str);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			byte* ret = StrrevNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrrevNative(str));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrrevNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrrevNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrrevNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrrevNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StruprNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[68])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[68])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			byte* ret = StruprNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StruprNative(str));
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StruprNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StruprNative((byte*)pstr));
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StruprNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to uppercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
		/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StruprNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrlwrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[69])(str);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[69])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			byte* ret = StrlwrNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(StrlwrNative(str));
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrlwrNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrlwrNative((byte*)pstr));
				return ret;
			}
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrlwrNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert a string to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function operates on a null-terminated string of bytes--even if it is<br/>
		/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
		/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char *")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrlwrNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrchrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[70])(str, c);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[70])((nint)str, c);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* ret = StrchrNative(str, c);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			string ret = Utils.DecodeStringUTF8(StrchrNative(str, c));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrrchrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[71])(str, c);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[71])((nint)str, c);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* ret = StrrchrNative(str, c);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			string ret = Utils.DecodeStringUTF8(StrrchrNative(str, c));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = StrrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(StrrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = StrrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(StrrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[72])(haystack, needle);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[72])((nint)haystack, (nint)needle);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* ret = StrstrNative(haystack, needle);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, needle));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrstrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrstrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrstrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrstrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrstrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrstrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrstrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrstrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrnstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, byte*>)funcTable[73])(haystack, needle, maxlen);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[73])((nint)haystack, (nint)needle, maxlen);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* ret = StrnstrNative(haystack, needle, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, needle, maxlen));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrnstrNative((byte*)phaystack, needle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, needle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrnstrNative((byte*)phaystack, needle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, needle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrnstrNative(pStr0, needle, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(pStr0, needle, maxlen));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrnstrNative(haystack, (byte*)pneedle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, (byte*)pneedle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrnstrNative(haystack, (byte*)pneedle, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, (byte*)pneedle, maxlen));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrnstrNative(haystack, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(haystack, pStr0, maxlen));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrnstrNative((byte*)phaystack, (byte*)pneedle, maxlen));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrnstrNative(pStr0, pStr1, maxlen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strnstr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrnstrNative(pStr0, pStr1, maxlen));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* StrcasestrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[74])(haystack, needle);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[74])((nint)haystack, (nint)needle);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* ret = StrcasestrNative(haystack, needle);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, needle));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = StrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = StrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = StrcasestrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = StrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> needle)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(StrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* Strcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = StrcasestrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string StrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "char const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "char const *")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(StrcasestrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
