// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative((void*)key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Compute the absolute value of `x`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_abs")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AbsNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[25])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[25])(x);
			#endif
		}

		/// <summary>
		/// Compute the absolute value of `x`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_abs")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Abs([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = AbsNative(x);
			return ret;
		}

		/// <summary>
		/// Query if a character is alphabetic (a letter).<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// for English 'a-z' and 'A-Z' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isalpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsalphaNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[26])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[26])(x);
			#endif
		}

		/// <summary>
		/// Query if a character is alphabetic (a letter).<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// for English 'a-z' and 'A-Z' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isalpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isalpha([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsalphaNative(x);
			return ret;
		}

		/// <summary>
		/// Query if a character is alphabetic (a letter) or a number.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// for English 'a-z', 'A-Z', and '0-9' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isalnum")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsalnumNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[27])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[27])(x);
			#endif
		}

		/// <summary>
		/// Query if a character is alphabetic (a letter) or a number.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// for English 'a-z', 'A-Z', and '0-9' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isalnum")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isalnum([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsalnumNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is blank (a space or tab).<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 0x20 (space) or 0x9 (tab) as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isblank")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsblankNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[28])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[28])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is blank (a space or tab).<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 0x20 (space) or 0x9 (tab) as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isblank")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isblank([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsblankNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is a control character.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 0 through 0x1F, and 0x7F, as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iscntrl")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IscntrlNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[29])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[29])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is a control character.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 0 through 0x1F, and 0x7F, as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iscntrl")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Iscntrl([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IscntrlNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is a numeric digit.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// '0' (0x30) through '9' (0x39), as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsdigitNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[30])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[30])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is a numeric digit.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// '0' (0x30) through '9' (0x39), as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isdigit([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsdigitNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is a hexadecimal digit.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 'A' through 'F', 'a' through 'f', and '0' through '9', as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isxdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsxdigitNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[31])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[31])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is a hexadecimal digit.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 'A' through 'F', 'a' through 'f', and '0' through '9', as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isxdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isxdigit([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsxdigitNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is a punctuation mark.<br/>
		/// **WARNING**: Regardless of system locale, this is equivalent to<br/>
		/// `((SDL_isgraph(x)) <br/>
		/// &<br/>
		/// &<br/>
		/// (!SDL_isalnum(x)))`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ispunct")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IspunctNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[32])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[32])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is a punctuation mark.<br/>
		/// **WARNING**: Regardless of system locale, this is equivalent to<br/>
		/// `((SDL_isgraph(x)) <br/>
		/// &<br/>
		/// &<br/>
		/// (!SDL_isalnum(x)))`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ispunct")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Ispunct([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IspunctNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is whitespace.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat the<br/>
		/// following ASCII values as true:<br/>
		/// - space (0x20)<br/>
		/// - tab (0x09)<br/>
		/// - newline (0x0A)<br/>
		/// - vertical tab (0x0B)<br/>
		/// - form feed (0x0C)<br/>
		/// - return (0x0D)<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isspace")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsspaceNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[33])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[33])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is whitespace.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat the<br/>
		/// following ASCII values as true:<br/>
		/// - space (0x20)<br/>
		/// - tab (0x09)<br/>
		/// - newline (0x0A)<br/>
		/// - vertical tab (0x0B)<br/>
		/// - form feed (0x0C)<br/>
		/// - return (0x0D)<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isspace")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isspace([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsspaceNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is upper case.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 'A' through 'Z' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsupperNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[34])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[34])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is upper case.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 'A' through 'Z' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isupper([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsupperNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is lower case.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 'a' through 'z' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_islower")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IslowerNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[35])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[35])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is lower case.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// 'a' through 'z' as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_islower")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Islower([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IslowerNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is "printable".<br/>
		/// Be advised that "printable" has a definition that goes back to text<br/>
		/// terminals from the dawn of computing, making this a sort of special case<br/>
		/// function that is not suitable for Unicode (or most any) text management.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// ' ' (0x20) through '~' (0x7E) as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isprint")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsprintNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[36])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[36])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is "printable".<br/>
		/// Be advised that "printable" has a definition that goes back to text<br/>
		/// terminals from the dawn of computing, making this a sort of special case<br/>
		/// function that is not suitable for Unicode (or most any) text management.<br/>
		/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
		/// ' ' (0x20) through '~' (0x7E) as true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isprint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isprint([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsprintNative(x);
			return ret;
		}

		/// <summary>
		/// Report if a character is any "printable" except space.<br/>
		/// Be advised that "printable" has a definition that goes back to text<br/>
		/// terminals from the dawn of computing, making this a sort of special case<br/>
		/// function that is not suitable for Unicode (or most any) text management.<br/>
		/// **WARNING**: Regardless of system locale, this is equivalent to<br/>
		/// `(SDL_isprint(x)) <br/>
		/// &<br/>
		/// &<br/>
		/// ((x) != ' ')`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isgraph")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsgraphNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[37])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[37])(x);
			#endif
		}

		/// <summary>
		/// Report if a character is any "printable" except space.<br/>
		/// Be advised that "printable" has a definition that goes back to text<br/>
		/// terminals from the dawn of computing, making this a sort of special case<br/>
		/// function that is not suitable for Unicode (or most any) text management.<br/>
		/// **WARNING**: Regardless of system locale, this is equivalent to<br/>
		/// `(SDL_isprint(x)) <br/>
		/// &<br/>
		/// &<br/>
		/// ((x) != ' ')`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isgraph")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isgraph([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = IsgraphNative(x);
			return ret;
		}

		/// <summary>
		/// Convert low-ASCII English letters to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'a' through 'z' to uppercase.<br/>
		/// This function returns the uppercase equivalent of `x`. If a character<br/>
		/// cannot be converted, or is already uppercase, this function returns `x`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_toupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ToupperNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[38])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[38])(x);
			#endif
		}

		/// <summary>
		/// Convert low-ASCII English letters to uppercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'a' through 'z' to uppercase.<br/>
		/// This function returns the uppercase equivalent of `x`. If a character<br/>
		/// cannot be converted, or is already uppercase, this function returns `x`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_toupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Toupper([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = ToupperNative(x);
			return ret;
		}

		/// <summary>
		/// Convert low-ASCII English letters to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function returns the lowercase equivalent of `x`. If a character<br/>
		/// cannot be converted, or is already lowercase, this function returns `x`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tolower")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TolowerNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[39])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[39])(x);
			#endif
		}

		/// <summary>
		/// Convert low-ASCII English letters to lowercase.<br/>
		/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
		/// values 'A' through 'Z' to lowercase.<br/>
		/// This function returns the lowercase equivalent of `x`. If a character<br/>
		/// cannot be converted, or is already lowercase, this function returns `x`.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tolower")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Tolower([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = TolowerNative(x);
			return ret;
		}

		/// <summary>
		/// Calculate a CRC-16 value.<br/>
		/// https://en.wikipedia.org/wiki/Cyclic_redundancy_check<br/>
		/// This function can be called multiple times, to stream data to be<br/>
		/// checksummed in blocks. Each call must provide the previous CRC-16 return<br/>
		/// value to be updated with the next block. The first call to this function<br/>
		/// for a set of blocks should pass in a zero CRC value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_crc16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort Crc16Native([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint16")] ushort crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, void*, nuint, ushort>)funcTable[40])(crc, data, len);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, nint, nuint, ushort>)funcTable[40])(crc, (nint)data, len);
			#endif
		}

		/// <summary>
		/// Calculate a CRC-16 value.<br/>
		/// https://en.wikipedia.org/wiki/Cyclic_redundancy_check<br/>
		/// This function can be called multiple times, to stream data to be<br/>
		/// checksummed in blocks. Each call must provide the previous CRC-16 return<br/>
		/// value to be updated with the next block. The first call to this function<br/>
		/// for a set of blocks should pass in a zero CRC value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_crc16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort Crc16([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint16")] ushort crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			ushort ret = Crc16Native(crc, data, len);
			return ret;
		}

		/// <summary>
		/// Calculate a CRC-16 value.<br/>
		/// https://en.wikipedia.org/wiki/Cyclic_redundancy_check<br/>
		/// This function can be called multiple times, to stream data to be<br/>
		/// checksummed in blocks. Each call must provide the previous CRC-16 return<br/>
		/// value to be updated with the next block. The first call to this function<br/>
		/// for a set of blocks should pass in a zero CRC value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_crc16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort Crc16([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint16")] ushort crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] nint data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			ushort ret = Crc16Native(crc, (void*)data, len);
			return ret;
		}

		/// <summary>
		/// Calculate a CRC-32 value.<br/>
		/// https://en.wikipedia.org/wiki/Cyclic_redundancy_check<br/>
		/// This function can be called multiple times, to stream data to be<br/>
		/// checksummed in blocks. Each call must provide the previous CRC-32 return<br/>
		/// value to be updated with the next block. The first call to this function<br/>
		/// for a set of blocks should pass in a zero CRC value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_crc32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Crc32Native([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint32")] uint crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*, nuint, uint>)funcTable[41])(crc, data, len);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, nuint, uint>)funcTable[41])(crc, (nint)data, len);
			#endif
		}

		/// <summary>
		/// Calculate a CRC-32 value.<br/>
		/// https://en.wikipedia.org/wiki/Cyclic_redundancy_check<br/>
		/// This function can be called multiple times, to stream data to be<br/>
		/// checksummed in blocks. Each call must provide the previous CRC-32 return<br/>
		/// value to be updated with the next block. The first call to this function<br/>
		/// for a set of blocks should pass in a zero CRC value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_crc32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint Crc32([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint32")] uint crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			uint ret = Crc32Native(crc, data, len);
			return ret;
		}

		/// <summary>
		/// Calculate a CRC-32 value.<br/>
		/// https://en.wikipedia.org/wiki/Cyclic_redundancy_check<br/>
		/// This function can be called multiple times, to stream data to be<br/>
		/// checksummed in blocks. Each call must provide the previous CRC-32 return<br/>
		/// value to be updated with the next block. The first call to this function<br/>
		/// for a set of blocks should pass in a zero CRC value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_crc32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint Crc32([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint32")] uint crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] nint data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			uint ret = Crc32Native(crc, (void*)data, len);
			return ret;
		}

		/// <summary>
		/// Calculate a 32-bit MurmurHash3 value for a block of data.<br/>
		/// https://en.wikipedia.org/wiki/MurmurHash<br/>
		/// A seed may be specified, which changes the final results consistently, but<br/>
		/// this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous<br/>
		/// result from this function back into itself as the next seed value to<br/>
		/// calculate a hash in chunks; it won't produce the same hash as it would if<br/>
		/// the same data was provided in a single call.<br/>
		/// If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not<br/>
		/// cryptographically secure, so it shouldn't be used for hashing top-secret<br/>
		/// data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_murmur3_32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Murmur332Native([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len, [NativeName(NativeNameType.Param, "seed")] [NativeName(NativeNameType.Type, "Uint32")] uint seed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, uint, uint>)funcTable[42])(data, len, seed);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nuint, uint, uint>)funcTable[42])((nint)data, len, seed);
			#endif
		}

		/// <summary>
		/// Calculate a 32-bit MurmurHash3 value for a block of data.<br/>
		/// https://en.wikipedia.org/wiki/MurmurHash<br/>
		/// A seed may be specified, which changes the final results consistently, but<br/>
		/// this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous<br/>
		/// result from this function back into itself as the next seed value to<br/>
		/// calculate a hash in chunks; it won't produce the same hash as it would if<br/>
		/// the same data was provided in a single call.<br/>
		/// If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not<br/>
		/// cryptographically secure, so it shouldn't be used for hashing top-secret<br/>
		/// data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_murmur3_32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint Murmur332([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len, [NativeName(NativeNameType.Param, "seed")] [NativeName(NativeNameType.Type, "Uint32")] uint seed)
		{
			uint ret = Murmur332Native(data, len, seed);
			return ret;
		}

		/// <summary>
		/// Calculate a 32-bit MurmurHash3 value for a block of data.<br/>
		/// https://en.wikipedia.org/wiki/MurmurHash<br/>
		/// A seed may be specified, which changes the final results consistently, but<br/>
		/// this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous<br/>
		/// result from this function back into itself as the next seed value to<br/>
		/// calculate a hash in chunks; it won't produce the same hash as it would if<br/>
		/// the same data was provided in a single call.<br/>
		/// If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not<br/>
		/// cryptographically secure, so it shouldn't be used for hashing top-secret<br/>
		/// data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_murmur3_32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint Murmur332([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] nint data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len, [NativeName(NativeNameType.Param, "seed")] [NativeName(NativeNameType.Type, "Uint32")] uint seed)
		{
			uint ret = Murmur332Native((void*)data, len, seed);
			return ret;
		}

		/// <summary>
		/// Copy non-overlapping memory.<br/>
		/// The memory regions must not overlap. If they do, use SDL_memmove() instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcpy")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, void*>)funcTable[43])(dst, src, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[43])((nint)dst, (nint)src, len);
			#endif
		}

		/// <summary>
		/// Copy non-overlapping memory.<br/>
		/// The memory regions must not overlap. If they do, use SDL_memmove() instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcpy")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemcpyNative(dst, src, len);
			return ret;
		}

		/// <summary>
		/// Copy non-overlapping memory.<br/>
		/// The memory regions must not overlap. If they do, use SDL_memmove() instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcpy")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] nint dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemcpyNative((void*)dst, src, len);
			return ret;
		}

		/// <summary>
		/// Copy non-overlapping memory.<br/>
		/// The memory regions must not overlap. If they do, use SDL_memmove() instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcpy")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] nint src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemcpyNative(dst, (void*)src, len);
			return ret;
		}

		/// <summary>
		/// Copy non-overlapping memory.<br/>
		/// The memory regions must not overlap. If they do, use SDL_memmove() instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcpy")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] nint dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] nint src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemcpyNative((void*)dst, (void*)src, len);
			return ret;
		}

		/// <summary>
		/// Copy memory ranges that might overlap.<br/>
		/// It is okay for the memory regions to overlap. If you are confident that the<br/>
		/// regions never overlap, using SDL_memcpy() may improve performance.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memmove")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemmoveNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, void*>)funcTable[44])(dst, src, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[44])((nint)dst, (nint)src, len);
			#endif
		}

		/// <summary>
		/// Copy memory ranges that might overlap.<br/>
		/// It is okay for the memory regions to overlap. If you are confident that the<br/>
		/// regions never overlap, using SDL_memcpy() may improve performance.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memmove")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memmove([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemmoveNative(dst, src, len);
			return ret;
		}

		/// <summary>
		/// Copy memory ranges that might overlap.<br/>
		/// It is okay for the memory regions to overlap. If you are confident that the<br/>
		/// regions never overlap, using SDL_memcpy() may improve performance.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memmove")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memmove([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] nint dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemmoveNative((void*)dst, src, len);
			return ret;
		}

		/// <summary>
		/// Copy memory ranges that might overlap.<br/>
		/// It is okay for the memory regions to overlap. If you are confident that the<br/>
		/// regions never overlap, using SDL_memcpy() may improve performance.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memmove")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memmove([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] nint src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemmoveNative(dst, (void*)src, len);
			return ret;
		}

		/// <summary>
		/// Copy memory ranges that might overlap.<br/>
		/// It is okay for the memory regions to overlap. If you are confident that the<br/>
		/// regions never overlap, using SDL_memcpy() may improve performance.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memmove")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memmove([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] nint dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] nint src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemmoveNative((void*)dst, (void*)src, len);
			return ret;
		}

		/// <summary>
		/// Initialize all bytes of buffer of memory to a specific value.<br/>
		/// This function will set `len` bytes, pointed to by `dst`, to the value<br/>
		/// specified in `c`.<br/>
		/// Despite `c` being an `int` instead of a `char`, this only operates on<br/>
		/// bytes; `c` must be a value between 0 and 255, inclusive.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memset")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemsetNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int, nuint, void*>)funcTable[45])(dst, c, len);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, int, nuint, nint>)funcTable[45])((nint)dst, c, len);
			#endif
		}

		/// <summary>
		/// Initialize all bytes of buffer of memory to a specific value.<br/>
		/// This function will set `len` bytes, pointed to by `dst`, to the value<br/>
		/// specified in `c`.<br/>
		/// Despite `c` being an `int` instead of a `char`, this only operates on<br/>
		/// bytes; `c` must be a value between 0 and 255, inclusive.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memset")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memset([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemsetNative(dst, c, len);
			return ret;
		}

		/// <summary>
		/// Initialize all bytes of buffer of memory to a specific value.<br/>
		/// This function will set `len` bytes, pointed to by `dst`, to the value<br/>
		/// specified in `c`.<br/>
		/// Despite `c` being an `int` instead of a `char`, this only operates on<br/>
		/// bytes; `c` must be a value between 0 and 255, inclusive.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memset")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memset([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] nint dst, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = MemsetNative((void*)dst, c, len);
			return ret;
		}

		/// <summary>
		/// Initialize all 32-bit words of buffer of memory to a specific value.<br/>
		/// This function will set a buffer of `dwords` Uint32 values, pointed to by<br/>
		/// `dst`, to the value specified in `val`.<br/>
		/// Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited<br/>
		/// to a range of 0-255.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memset4")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* Memset4Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "val")] [NativeName(NativeNameType.Type, "Uint32")] uint val, [NativeName(NativeNameType.Param, "dwords")] [NativeName(NativeNameType.Type, "size_t")] nuint dwords)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, uint, nuint, void*>)funcTable[46])(dst, val, dwords);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, uint, nuint, nint>)funcTable[46])((nint)dst, val, dwords);
			#endif
		}

		/// <summary>
		/// Initialize all 32-bit words of buffer of memory to a specific value.<br/>
		/// This function will set a buffer of `dwords` Uint32 values, pointed to by<br/>
		/// `dst`, to the value specified in `val`.<br/>
		/// Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited<br/>
		/// to a range of 0-255.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memset4")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memset4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "val")] [NativeName(NativeNameType.Type, "Uint32")] uint val, [NativeName(NativeNameType.Param, "dwords")] [NativeName(NativeNameType.Type, "size_t")] nuint dwords)
		{
			void* ret = Memset4Native(dst, val, dwords);
			return ret;
		}

		/// <summary>
		/// Initialize all 32-bit words of buffer of memory to a specific value.<br/>
		/// This function will set a buffer of `dwords` Uint32 values, pointed to by<br/>
		/// `dst`, to the value specified in `val`.<br/>
		/// Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited<br/>
		/// to a range of 0-255.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memset4")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Memset4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] nint dst, [NativeName(NativeNameType.Param, "val")] [NativeName(NativeNameType.Type, "Uint32")] uint val, [NativeName(NativeNameType.Param, "dwords")] [NativeName(NativeNameType.Type, "size_t")] nuint dwords)
		{
			void* ret = Memset4Native((void*)dst, val, dwords);
			return ret;
		}

		/// <summary>
		/// Compare two buffers of memory.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MemcmpNative([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "void const *")] void* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "void const *")] void* s2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, int>)funcTable[47])(s1, s2, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[47])((nint)s1, (nint)s2, len);
			#endif
		}

		/// <summary>
		/// Compare two buffers of memory.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Memcmp([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "void const *")] void* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "void const *")] void* s2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			int ret = MemcmpNative(s1, s2, len);
			return ret;
		}

		/// <summary>
		/// Compare two buffers of memory.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Memcmp([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "void const *")] nint s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "void const *")] void* s2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			int ret = MemcmpNative((void*)s1, s2, len);
			return ret;
		}

		/// <summary>
		/// Compare two buffers of memory.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Memcmp([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "void const *")] void* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "void const *")] nint s2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			int ret = MemcmpNative(s1, (void*)s2, len);
			return ret;
		}

		/// <summary>
		/// Compare two buffers of memory.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_memcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Memcmp([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "void const *")] nint s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "void const *")] nint s2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			int ret = MemcmpNative((void*)s1, (void*)s2, len);
			return ret;
		}

		/// <summary>
		/// This works exactly like wcslen() but doesn't require access to a C runtime.<br/>
		/// Counts the number of wchar_t values in `wstr`, excluding the null<br/>
		/// terminator.<br/>
		/// Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WcslenNative([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* wstr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, nuint>)funcTable[48])(wstr);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[48])((nint)wstr);
			#endif
		}

		/// <summary>
		/// This works exactly like wcslen() but doesn't require access to a C runtime.<br/>
		/// Counts the number of wchar_t values in `wstr`, excluding the null<br/>
		/// terminator.<br/>
		/// Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* wstr)
		{
			nuint ret = WcslenNative(wstr);
			return ret;
		}

		/// <summary>
		/// This works exactly like wcslen() but doesn't require access to a C runtime.<br/>
		/// Counts the number of wchar_t values in `wstr`, excluding the null<br/>
		/// terminator.<br/>
		/// Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				nuint ret = WcslenNative((char*)pwstr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like wcslen() but doesn't require access to a C runtime.<br/>
		/// Counts the number of wchar_t values in `wstr`, excluding the null<br/>
		/// terminator.<br/>
		/// Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> wstr)
		{
			fixed (char* pwstr = wstr)
			{
				nuint ret = WcslenNative((char*)pwstr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like wcslen() but doesn't require access to a C runtime.<br/>
		/// Counts the number of wchar_t values in `wstr`, excluding the null<br/>
		/// terminator.<br/>
		/// Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] string wstr)
		{
			fixed (char* pwstr = wstr)
			{
				nuint ret = WcslenNative(pwstr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like wcsnlen() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the<br/>
		/// null terminator.<br/>
		/// Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// Also, `maxlen` is a count of wide characters, not bytes!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WcsnlenNative([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* wstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, nuint, nuint>)funcTable[49])(wstr, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint, nuint>)funcTable[49])((nint)wstr, maxlen);
			#endif
		}

		/// <summary>
		/// This works exactly like wcsnlen() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the<br/>
		/// null terminator.<br/>
		/// Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// Also, `maxlen` is a count of wide characters, not bytes!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcsnlen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* wstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = WcsnlenNative(wstr, maxlen);
			return ret;
		}

		/// <summary>
		/// This works exactly like wcsnlen() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the<br/>
		/// null terminator.<br/>
		/// Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// Also, `maxlen` is a count of wide characters, not bytes!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcsnlen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char wstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pwstr = &wstr)
			{
				nuint ret = WcsnlenNative((char*)pwstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like wcsnlen() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the<br/>
		/// null terminator.<br/>
		/// Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// Also, `maxlen` is a count of wide characters, not bytes!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcsnlen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> wstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pwstr = wstr)
			{
				nuint ret = WcsnlenNative((char*)pwstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like wcsnlen() but doesn't require access to a C<br/>
		/// runtime.<br/>
		/// Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the<br/>
		/// null terminator.<br/>
		/// Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,<br/>
		/// this counts wchar_t values in a string, even if the string's encoding is of<br/>
		/// variable width, like UTF-16.<br/>
		/// Also be aware that wchar_t is different sizes on different platforms (4<br/>
		/// bytes on Linux, 2 on Windows, etc).<br/>
		/// Also, `maxlen` is a count of wide characters, not bytes!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcsnlen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] string wstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pwstr = wstr)
			{
				nuint ret = WcsnlenNative(pwstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WcslcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, nuint>)funcTable[50])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[50])((nint)dst, (nint)src, maxlen);
			#endif
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = WcslcpyNative(dst, src, maxlen);
			return ret;
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				nuint ret = WcslcpyNative((char*)pdst, src, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = WcslcpyNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = &src)
			{
				nuint ret = WcslcpyNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcpyNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcpyNative(dst, psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = &src)
				{
					nuint ret = WcslcpyNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = src)
				{
					nuint ret = WcslcpyNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a wide string.<br/>
		/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
		/// appends a null terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
		/// written.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (char* psrc = src)
			{
				nuint ret = WcslcpyNative(pStr0, psrc, maxlen);
				dst = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WcslcatNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, nuint>)funcTable[51])(dst, src, maxlen);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[51])((nint)dst, (nint)src, maxlen);
			#endif
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = WcslcatNative(dst, src, maxlen);
			return ret;
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				nuint ret = WcslcatNative((char*)pdst, src, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = WcslcatNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = &src)
			{
				nuint ret = WcslcatNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcatNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = src)
			{
				nuint ret = WcslcatNative(dst, psrc, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = &src)
				{
					nuint ret = WcslcatNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = src)
				{
					nuint ret = WcslcatNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Concatenate wide strings.<br/>
		/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
		/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
		/// terminator.<br/>
		/// `src` and `dst` must not overlap.<br/>
		/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
		/// unmodified.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Wcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar_t *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "wchar_t const *")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (char* psrc = src)
			{
				nuint ret = WcslcatNative(pStr0, psrc, maxlen);
				dst = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static char* WcsdupNative([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* wstr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*>)funcTable[52])(wstr);
			#else
			return (char*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[52])((nint)wstr);
			#endif
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsdup([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* wstr)
		{
			char* ret = WcsdupNative(wstr);
			return ret;
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsdupS([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* wstr)
		{
			string ret = Utils.DecodeStringUTF16(WcsdupNative(wstr));
			return ret;
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsdup([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				char* ret = WcsdupNative((char*)pwstr);
				return ret;
			}
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsdupS([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				string ret = Utils.DecodeStringUTF16(WcsdupNative((char*)pwstr));
				return ret;
			}
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsdup([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> wstr)
		{
			fixed (char* pwstr = wstr)
			{
				char* ret = WcsdupNative((char*)pwstr);
				return ret;
			}
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsdupS([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> wstr)
		{
			fixed (char* pwstr = wstr)
			{
				string ret = Utils.DecodeStringUTF16(WcsdupNative((char*)pwstr));
				return ret;
			}
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsdup([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] string wstr)
		{
			fixed (char* pwstr = wstr)
			{
				char* ret = WcsdupNative(pwstr);
				return ret;
			}
		}

		/// <summary>
		/// Allocate a copy of a wide string.<br/>
		/// This allocates enough space for a null-terminated copy of `wstr`, using<br/>
		/// SDL_malloc, and then makes a copy of the string into this space.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsdupS([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "wchar_t const *")] string wstr)
		{
			fixed (char* pwstr = wstr)
			{
				string ret = Utils.DecodeStringUTF16(WcsdupNative(pwstr));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static char* WcsstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, char*>)funcTable[53])(haystack, needle);
			#else
			return (char*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[53])((nint)haystack, (nint)needle);
			#endif
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			char* ret = WcsstrNative(haystack, needle);
			return ret;
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, needle));
			return ret;
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			fixed (char* phaystack = &haystack)
			{
				char* ret = WcsstrNative((char*)phaystack, needle);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			fixed (char* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, needle));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				char* ret = WcsstrNative((char*)phaystack, needle);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, needle));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				char* ret = WcsstrNative(phaystack, needle);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle)
		{
			fixed (char* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(phaystack, needle));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle)
		{
			fixed (char* pneedle = &needle)
			{
				char* ret = WcsstrNative(haystack, (char*)pneedle);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle)
		{
			fixed (char* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, (char*)pneedle));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsstrNative(haystack, (char*)pneedle);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, (char*)pneedle));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsstrNative(haystack, pneedle);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsstrNative(haystack, pneedle));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					char* ret = WcsstrNative((char*)phaystack, (char*)pneedle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, (char*)pneedle));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsstrNative((char*)phaystack, (char*)pneedle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsstrNative((char*)phaystack, (char*)pneedle));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsstrNative(phaystack, pneedle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string for the first instance of a specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// byte to end the string.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsstrNative(phaystack, pneedle));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static char* WcsnstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, char*>)funcTable[54])(haystack, needle, maxlen);
			#else
			return (char*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[54])((nint)haystack, (nint)needle, maxlen);
			#endif
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* ret = WcsnstrNative(haystack, needle, maxlen);
			return ret;
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			string ret = Utils.DecodeStringUTF16(WcsnstrNative(haystack, needle, maxlen));
			return ret;
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = &haystack)
			{
				char* ret = WcsnstrNative((char*)phaystack, needle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative((char*)phaystack, needle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				char* ret = WcsnstrNative((char*)phaystack, needle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative((char*)phaystack, needle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				char* ret = WcsnstrNative(phaystack, needle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative(phaystack, needle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = &needle)
			{
				char* ret = WcsnstrNative(haystack, (char*)pneedle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative(haystack, (char*)pneedle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsnstrNative(haystack, (char*)pneedle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative(haystack, (char*)pneedle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				char* ret = WcsnstrNative(haystack, pneedle, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF16(WcsnstrNative(haystack, pneedle, maxlen));
				return ret;
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					char* ret = WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsnstrNative((char*)phaystack, (char*)pneedle, maxlen));
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static char* Wcsnstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					char* ret = WcsnstrNative(phaystack, pneedle, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Search a wide string, up to n wide chars, for the first instance of a<br/>
		/// specific substring.<br/>
		/// The search ends once it finds the requested substring, or a null terminator<br/>
		/// value to end the string, or `maxlen` wide character have been examined. It<br/>
		/// is possible to use this function on a wide string without a null<br/>
		/// terminator.<br/>
		/// Note that this looks for strings of _wide characters_, not _codepoints_, so<br/>
		/// it's legal to search for malformed and incomplete UTF-16 sequences.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsnstr")]
		[return: NativeName(NativeNameType.Type, "wchar_t *")]
		public static string WcsnstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "wchar_t const *")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "wchar_t const *")] string needle, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* phaystack = haystack)
			{
				fixed (char* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF16(WcsnstrNative(phaystack, pneedle, maxlen));
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcscmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, int>)funcTable[55])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[55])((nint)str1, (nint)str2);
			#endif
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			int ret = WcscmpNative(str1, str2);
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcscmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscmpNative(pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcscmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscmpNative(str1, pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcscmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings.<br/>
		/// This only compares wchar_t values until it hits a null-terminating<br/>
		/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
		/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscmpNative(pstr1, pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcsncmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, int>)funcTable[56])(str1, str2, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[56])((nint)str1, (nint)str2, maxlen);
			#endif
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = WcsncmpNative(str1, str2, maxlen);
			return ret;
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcsncmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncmpNative(pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcsncmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncmpNative(str1, pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcsncmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings up to a number of wchar_t values.<br/>
		/// This only compares wchar_t values; it does not care if the string is<br/>
		/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
		/// or uses valid Unicode values.<br/>
		/// Note that while this function is intended to be used with UTF-16 (or<br/>
		/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
		/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
		/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
		/// sequence, it will only compare a portion of the final character.<br/>
		/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
		/// match to this number of wide chars (or both have matched to a<br/>
		/// null-terminator character before this count), they will be considered<br/>
		/// equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncmpNative(pstr1, pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcscasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, int>)funcTable[57])(str1, str2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[57])((nint)str1, (nint)str2);
			#endif
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			int ret = WcscasecmpNative(str1, str2);
			return ret;
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcscasecmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscasecmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcscasecmpNative(pstr1, str2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcscasecmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscasecmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcscasecmpNative(str1, pstr2);
				return ret;
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcscasecmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscasecmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two null-terminated wide strings, case-insensitively.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcscasecmpNative(pstr1, pstr2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcsncasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char*, nuint, int>)funcTable[58])(str1, str2, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[58])((nint)str1, (nint)str2, maxlen);
			#endif
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = WcsncasecmpNative(str1, str2, maxlen);
			return ret;
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = WcsncasecmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncasecmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				int ret = WcsncasecmpNative(pstr1, str2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = WcsncasecmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncasecmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = str2)
			{
				int ret = WcsncasecmpNative(str1, pstr2, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = WcsncasecmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncasecmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
		/// This will work with Unicode strings, using a technique called<br/>
		/// "case-folding" to handle the vast majority of case-sensitive human<br/>
		/// languages regardless of system locale. It can deal with expanding values: a<br/>
		/// German Eszett character can compare against two ASCII 's' chars and be<br/>
		/// considered a match, for example. A notable exception: it does not handle<br/>
		/// the Turkish 'i' character; human language is complicated!<br/>
		/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
		/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
		/// handles Unicode, it expects the string to be well-formed and not a<br/>
		/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
		/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
		/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
		/// match if they convert to the same amount of replacement characters.<br/>
		/// Note that while this function might deal with variable-sized characters,<br/>
		/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
		/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
		/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
		/// to overflow a buffer.<br/>
		/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
		/// strings match to this number of wchar_t (or both have matched to a<br/>
		/// null-terminator character before this number of bytes), they will be<br/>
		/// considered equal.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Wcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = str1)
			{
				fixed (char* pstr2 = str2)
				{
					int ret = WcsncasecmpNative(pstr1, pstr2, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WcstolNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, char**, int, int>)funcTable[59])(str, endp, baseValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[59])((nint)str, (nint)endp, baseValue);
			#endif
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			int ret = WcstolNative(str, endp, baseValue);
			return ret;
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = &str)
			{
				int ret = WcstolNative((char*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				int ret = WcstolNative((char*)pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] char** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				int ret = WcstolNative(pstr, endp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char** pendp = &endp)
			{
				int ret = WcstolNative(str, (char**)pendp, baseValue);
				return ret;
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = &str)
			{
				fixed (char** pendp = &endp)
				{
					int ret = WcstolNative((char*)pstr, (char**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				fixed (char** pendp = &endp)
				{
					int ret = WcstolNative((char*)pstr, (char**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Parse a `long` from a wide string.<br/>
		/// If `str` starts with whitespace, then those whitespace characters are<br/>
		/// skipped before attempting to parse the number.<br/>
		/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
		/// the minimum and maximum representable `long` values.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_wcstol")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Wcstol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "wchar_t const *")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "wchar_t * *")] ref char* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (char* pstr = str)
			{
				fixed (char** pendp = &endp)
				{
					int ret = WcstolNative(pstr, (char**)pendp, baseValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// This works exactly like strlen() but doesn't require access to a C runtime.<br/>
		/// Counts the bytes in `str`, excluding the null terminator.<br/>
		/// If you need the length of a UTF-8 string, consider using SDL_utf8strlen().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint StrlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint>)funcTable[60])(str);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[60])((nint)str);
			#endif
		}

		/// <summary>
		/// This works exactly like strlen() but doesn't require access to a C runtime.<br/>
		/// Counts the bytes in `str`, excluding the null terminator.<br/>
		/// If you need the length of a UTF-8 string, consider using SDL_utf8strlen().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			nuint ret = StrlenNative(str);
			return ret;
		}

		/// <summary>
		/// This works exactly like strlen() but doesn't require access to a C runtime.<br/>
		/// Counts the bytes in `str`, excluding the null terminator.<br/>
		/// If you need the length of a UTF-8 string, consider using SDL_utf8strlen().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] in byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = StrlenNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strlen() but doesn't require access to a C runtime.<br/>
		/// Counts the bytes in `str`, excluding the null terminator.<br/>
		/// If you need the length of a UTF-8 string, consider using SDL_utf8strlen().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = StrlenNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// This works exactly like strlen() but doesn't require access to a C runtime.<br/>
		/// Counts the bytes in `str`, excluding the null terminator.<br/>
		/// If you need the length of a UTF-8 string, consider using SDL_utf8strlen().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = StrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
