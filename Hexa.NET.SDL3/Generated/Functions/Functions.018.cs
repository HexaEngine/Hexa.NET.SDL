// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Write-only storage textures, followed by write-only storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - u registers: Write-only storage textures, followed by write-only storage<br/>
		/// buffers<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Write-only storage textures, followed by write-only<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by write-only storage buffers,<br/>
		/// followed by write-only storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by write-only storage textures<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfo* createinfo)
		{
			SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Write-only storage textures, followed by write-only storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - u registers: Write-only storage textures, followed by write-only storage<br/>
		/// buffers<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Write-only storage textures, followed by write-only<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by write-only storage buffers,<br/>
		/// followed by write-only storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by write-only storage textures<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Write-only storage textures, followed by write-only storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - u registers: Write-only storage textures, followed by write-only storage<br/>
		/// buffers<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Write-only storage textures, followed by write-only<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by write-only storage buffers,<br/>
		/// followed by write-only storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by write-only storage textures<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] ref SDLGPUComputePipelineCreateInfo createinfo)
		{
			fixed (SDLGPUComputePipelineCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative(device, (SDLGPUComputePipelineCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Write-only storage textures, followed by write-only storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - u registers: Write-only storage textures, followed by write-only storage<br/>
		/// buffers<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Write-only storage textures, followed by write-only<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by write-only storage buffers,<br/>
		/// followed by write-only storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by write-only storage textures<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] ref SDLGPUComputePipelineCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUComputePipelineCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative((SDLGPUDevice*)pdevice, (SDLGPUComputePipelineCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] SDLGPUGraphicsPipelineCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUGraphicsPipelineCreateInfo*, SDLGPUGraphicsPipeline*>)funcTable[819])(device, createinfo);
			#else
			return (SDLGPUGraphicsPipeline*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[819])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] SDLGPUGraphicsPipelineCreateInfo* createinfo)
		{
			SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] SDLGPUGraphicsPipelineCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] ref SDLGPUGraphicsPipelineCreateInfo createinfo)
		{
			fixed (SDLGPUGraphicsPipelineCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative(device, (SDLGPUGraphicsPipelineCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] ref SDLGPUGraphicsPipelineCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUGraphicsPipelineCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, (SDLGPUGraphicsPipelineCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUSampler* CreateGPUSamplerNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] SDLGPUSamplerCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUSamplerCreateInfo*, SDLGPUSampler*>)funcTable[820])(device, createinfo);
			#else
			return (SDLGPUSampler*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[820])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] SDLGPUSamplerCreateInfo* createinfo)
		{
			SDLGPUSampler* ret = CreateGPUSamplerNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] SDLGPUSamplerCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUSampler* ret = CreateGPUSamplerNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] ref SDLGPUSamplerCreateInfo createinfo)
		{
			fixed (SDLGPUSamplerCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUSampler* ret = CreateGPUSamplerNative(device, (SDLGPUSamplerCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] ref SDLGPUSamplerCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUSamplerCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUSampler* ret = CreateGPUSamplerNative((SDLGPUDevice*)pdevice, (SDLGPUSamplerCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by storage textures, followed by<br/>
		/// storage buffers<br/>
		/// - s registers: Samplers with indices corresponding to the sampled textures<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUPipeline.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUShader* CreateGPUShaderNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] SDLGPUShaderCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUShaderCreateInfo*, SDLGPUShader*>)funcTable[821])(device, createinfo);
			#else
			return (SDLGPUShader*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[821])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by storage textures, followed by<br/>
		/// storage buffers<br/>
		/// - s registers: Samplers with indices corresponding to the sampled textures<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUPipeline.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] SDLGPUShaderCreateInfo* createinfo)
		{
			SDLGPUShader* ret = CreateGPUShaderNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by storage textures, followed by<br/>
		/// storage buffers<br/>
		/// - s registers: Samplers with indices corresponding to the sampled textures<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUPipeline.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] SDLGPUShaderCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUShader* ret = CreateGPUShaderNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by storage textures, followed by<br/>
		/// storage buffers<br/>
		/// - s registers: Samplers with indices corresponding to the sampled textures<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUPipeline.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] ref SDLGPUShaderCreateInfo createinfo)
		{
			fixed (SDLGPUShaderCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUShader* ret = CreateGPUShaderNative(device, (SDLGPUShaderCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
		/// - t registers: Sampled textures, followed by storage textures, followed by<br/>
		/// storage buffers<br/>
		/// - s registers: Samplers with indices corresponding to the sampled textures<br/>
		/// - b registers: Uniform buffers<br/>
		/// For DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUPipeline.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] ref SDLGPUShaderCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUShaderCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUShader* ret = CreateGPUShaderNative((SDLGPUDevice*)pdevice, (SDLGPUShaderCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTexture* CreateGPUTextureNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] SDLGPUTextureCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureCreateInfo*, SDLGPUTexture*>)funcTable[822])(device, createinfo);
			#else
			return (SDLGPUTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[822])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] SDLGPUTextureCreateInfo* createinfo)
		{
			SDLGPUTexture* ret = CreateGPUTextureNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] SDLGPUTextureCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUTexture* ret = CreateGPUTextureNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] ref SDLGPUTextureCreateInfo createinfo)
		{
			fixed (SDLGPUTextureCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUTexture* ret = CreateGPUTextureNative(device, (SDLGPUTextureCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] ref SDLGPUTextureCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTextureCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUTexture* ret = CreateGPUTextureNative((SDLGPUDevice*)pdevice, (SDLGPUTextureCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUBuffer* CreateGPUBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] SDLGPUBufferCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUBufferCreateInfo*, SDLGPUBuffer*>)funcTable[823])(device, createinfo);
			#else
			return (SDLGPUBuffer*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[823])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] SDLGPUBufferCreateInfo* createinfo)
		{
			SDLGPUBuffer* ret = CreateGPUBufferNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] SDLGPUBufferCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUBuffer* ret = CreateGPUBufferNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] ref SDLGPUBufferCreateInfo createinfo)
		{
			fixed (SDLGPUBufferCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUBuffer* ret = CreateGPUBufferNative(device, (SDLGPUBufferCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] ref SDLGPUBufferCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBufferCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUBuffer* ret = CreateGPUBufferNative((SDLGPUDevice*)pdevice, (SDLGPUBufferCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTransferBuffer* CreateGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] SDLGPUTransferBufferCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBufferCreateInfo*, SDLGPUTransferBuffer*>)funcTable[824])(device, createinfo);
			#else
			return (SDLGPUTransferBuffer*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[824])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] SDLGPUTransferBufferCreateInfo* createinfo)
		{
			SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] SDLGPUTransferBufferCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] ref SDLGPUTransferBufferCreateInfo createinfo)
		{
			fixed (SDLGPUTransferBufferCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative(device, (SDLGPUTransferBufferCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] ref SDLGPUTransferBufferCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBufferCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBufferCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUBufferNameNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUBuffer*, byte*, void>)funcTable[825])(device, buffer, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[825])((nint)device, (nint)buffer, (nint)text);
			#endif
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			SetGPUBufferNameNative(device, buffer, text);
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, text);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetGPUBufferNameNative(device, buffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				SetGPUBufferNameNative(device, buffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetGPUBufferNameNative(device, buffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = text)
				{
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				fixed (byte* ptext = text)
				{
					SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					fixed (byte* ptext = &text)
					{
						SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					fixed (byte* ptext = text)
					{
						SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (text != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(text);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUTextureNameNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTexture*, byte*, void>)funcTable[826])(device, texture, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[826])((nint)device, (nint)texture, (nint)text);
			#endif
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			SetGPUTextureNameNative(device, texture, text);
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, text);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetGPUTextureNameNative(device, texture, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				SetGPUTextureNameNative(device, texture, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetGPUTextureNameNative(device, texture, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = text)
				{
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				fixed (byte* ptext = text)
				{
					SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					fixed (byte* ptext = &text)
					{
						SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					fixed (byte* ptext = text)
					{
						SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (text != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(text);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InsertGPUDebugLabelNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte*, void>)funcTable[827])(commandBuffer, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[827])((nint)commandBuffer, (nint)text);
			#endif
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			InsertGPUDebugLabelNative(commandBuffer, text);
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, text);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				InsertGPUDebugLabelNative(commandBuffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				InsertGPUDebugLabelNative(commandBuffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertGPUDebugLabelNative(commandBuffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* ptext = &text)
				{
					InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* ptext = text)
				{
					InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUDebugGroupNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte*, void>)funcTable[828])(commandBuffer, name);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[828])((nint)commandBuffer, (nint)name);
			#endif
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			PushGPUDebugGroupNative(commandBuffer, name);
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, name);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				PushGPUDebugGroupNative(commandBuffer, (byte*)pname);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				PushGPUDebugGroupNative(commandBuffer, (byte*)pname);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushGPUDebugGroupNative(commandBuffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* pname = &name)
				{
					PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)pname);
				}
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* pname = name)
				{
					PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)pname);
				}
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Ends the most-recently pushed debug group.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PopGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopGPUDebugGroupNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, void>)funcTable[829])(commandBuffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[829])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Ends the most-recently pushed debug group.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PopGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PopGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			PopGPUDebugGroupNative(commandBuffer);
		}

		/// <summary>
		/// Ends the most-recently pushed debug group.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PopGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PopGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PopGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer);
			}
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUTextureNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTexture*, void>)funcTable[830])(device, texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[830])((nint)device, (nint)texture);
			#endif
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			ReleaseGPUTextureNative(device, texture);
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUTextureNative((SDLGPUDevice*)pdevice, texture);
			}
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				ReleaseGPUTextureNative(device, (SDLGPUTexture*)ptexture);
			}
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					ReleaseGPUTextureNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture);
				}
			}
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUSamplerNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] SDLGPUSampler* sampler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUSampler*, void>)funcTable[831])(device, sampler);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[831])((nint)device, (nint)sampler);
			#endif
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] SDLGPUSampler* sampler)
		{
			ReleaseGPUSamplerNative(device, sampler);
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] SDLGPUSampler* sampler)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUSamplerNative((SDLGPUDevice*)pdevice, sampler);
			}
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] ref SDLGPUSampler sampler)
		{
			fixed (SDLGPUSampler* psampler = &sampler)
			{
				ReleaseGPUSamplerNative(device, (SDLGPUSampler*)psampler);
			}
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] ref SDLGPUSampler sampler)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUSampler* psampler = &sampler)
				{
					ReleaseGPUSamplerNative((SDLGPUDevice*)pdevice, (SDLGPUSampler*)psampler);
				}
			}
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUBuffer*, void>)funcTable[832])(device, buffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[832])((nint)device, (nint)buffer);
			#endif
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer)
		{
			ReleaseGPUBufferNative(device, buffer);
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUBufferNative((SDLGPUDevice*)pdevice, buffer);
			}
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				ReleaseGPUBufferNative(device, (SDLGPUBuffer*)pbuffer);
			}
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					ReleaseGPUBufferNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer);
				}
			}
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBuffer*, void>)funcTable[833])(device, transferBuffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[833])((nint)device, (nint)transferBuffer);
			#endif
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			ReleaseGPUTransferBufferNative(device, transferBuffer);
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUTransferBufferNative((SDLGPUDevice*)pdevice, transferBuffer);
			}
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
			{
				ReleaseGPUTransferBufferNative(device, (SDLGPUTransferBuffer*)ptransferBuffer);
			}
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
				{
					ReleaseGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBuffer*)ptransferBuffer);
				}
			}
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUComputePipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUComputePipeline*, void>)funcTable[834])(device, computePipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[834])((nint)device, (nint)computePipeline);
			#endif
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			ReleaseGPUComputePipelineNative(device, computePipeline);
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUComputePipelineNative((SDLGPUDevice*)pdevice, computePipeline);
			}
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
			{
				ReleaseGPUComputePipelineNative(device, (SDLGPUComputePipeline*)pcomputePipeline);
			}
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
				{
					ReleaseGPUComputePipelineNative((SDLGPUDevice*)pdevice, (SDLGPUComputePipeline*)pcomputePipeline);
				}
			}
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUShaderNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] SDLGPUShader* shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUShader*, void>)funcTable[835])(device, shader);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[835])((nint)device, (nint)shader);
			#endif
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] SDLGPUShader* shader)
		{
			ReleaseGPUShaderNative(device, shader);
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] SDLGPUShader* shader)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUShaderNative((SDLGPUDevice*)pdevice, shader);
			}
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] ref SDLGPUShader shader)
		{
			fixed (SDLGPUShader* pshader = &shader)
			{
				ReleaseGPUShaderNative(device, (SDLGPUShader*)pshader);
			}
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] ref SDLGPUShader shader)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUShader* pshader = &shader)
				{
					ReleaseGPUShaderNative((SDLGPUDevice*)pdevice, (SDLGPUShader*)pshader);
				}
			}
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUGraphicsPipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUGraphicsPipeline*, void>)funcTable[836])(device, graphicsPipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[836])((nint)device, (nint)graphicsPipeline);
			#endif
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			ReleaseGPUGraphicsPipelineNative(device, graphicsPipeline);
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, graphicsPipeline);
			}
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
			{
				ReleaseGPUGraphicsPipelineNative(device, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
			}
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
				{
					ReleaseGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
				}
			}
		}

		/// <summary>
		/// Acquire a command buffer.<br/>
		/// This command buffer is managed by the implementation and should not be<br/>
		/// freed by the user. The command buffer may only be used on the thread it was<br/>
		/// acquired on. The command buffer should be submitted on the thread it was<br/>
		/// acquired on.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUCommandBuffer* AcquireGPUCommandBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUCommandBuffer*>)funcTable[837])(device);
			#else
			return (SDLGPUCommandBuffer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[837])((nint)device);
			#endif
		}

		/// <summary>
		/// Acquire a command buffer.<br/>
		/// This command buffer is managed by the implementation and should not be<br/>
		/// freed by the user. The command buffer may only be used on the thread it was<br/>
		/// acquired on. The command buffer should be submitted on the thread it was<br/>
		/// acquired on.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")]
		public static SDLGPUCommandBuffer* AcquireGPUCommandBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			SDLGPUCommandBuffer* ret = AcquireGPUCommandBufferNative(device);
			return ret;
		}

		/// <summary>
		/// Acquire a command buffer.<br/>
		/// This command buffer is managed by the implementation and should not be<br/>
		/// freed by the user. The command buffer may only be used on the thread it was<br/>
		/// acquired on. The command buffer should be submitted on the thread it was<br/>
		/// acquired on.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")]
		public static SDLGPUCommandBuffer* AcquireGPUCommandBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUCommandBuffer* ret = AcquireGPUCommandBufferNative((SDLGPUDevice*)pdevice);
				return ret;
			}
		}

		/// <summary>
		/// Pushes data to a vertex uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUVertexUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUVertexUniformDataNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, uint, void*, uint, void>)funcTable[838])(commandBuffer, slotIndex, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[838])((nint)commandBuffer, slotIndex, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Pushes data to a vertex uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUVertexUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUVertexUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			PushGPUVertexUniformDataNative(commandBuffer, slotIndex, data, length);
		}

		/// <summary>
		/// Pushes data to a vertex uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUVertexUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUVertexUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUVertexUniformDataNative((SDLGPUCommandBuffer*)pcommandBuffer, slotIndex, data, length);
			}
		}

		/// <summary>
		/// Pushes data to a fragment uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUFragmentUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUFragmentUniformDataNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, uint, void*, uint, void>)funcTable[839])(commandBuffer, slotIndex, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[839])((nint)commandBuffer, slotIndex, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Pushes data to a fragment uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUFragmentUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUFragmentUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			PushGPUFragmentUniformDataNative(commandBuffer, slotIndex, data, length);
		}

		/// <summary>
		/// Pushes data to a fragment uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUFragmentUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUFragmentUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUFragmentUniformDataNative((SDLGPUCommandBuffer*)pcommandBuffer, slotIndex, data, length);
			}
		}

		/// <summary>
		/// Pushes data to a uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUComputeUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUComputeUniformDataNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, uint, void*, uint, void>)funcTable[840])(commandBuffer, slotIndex, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[840])((nint)commandBuffer, slotIndex, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Pushes data to a uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUComputeUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUComputeUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			PushGPUComputeUniformDataNative(commandBuffer, slotIndex, data, length);
		}

		/// <summary>
		/// Pushes data to a uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUComputeUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUComputeUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUComputeUniformDataNative((SDLGPUCommandBuffer*)pcommandBuffer, slotIndex, data, length);
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPURenderPass* BeginGPURenderPassNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUColorTargetInfo*, uint, SDLGPUDepthStencilTargetInfo*, SDLGPURenderPass*>)funcTable[841])(commandBuffer, colorTargetInfos, numColorTargets, depthStencilTargetInfo);
			#else
			return (SDLGPURenderPass*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, nint>)funcTable[841])((nint)commandBuffer, (nint)colorTargetInfos, numColorTargets, (nint)depthStencilTargetInfo);
			#endif
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, colorTargetInfos, numColorTargets, depthStencilTargetInfo);
			return ret;
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, colorTargetInfos, numColorTargets, depthStencilTargetInfo);
				return ret;
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
			{
				SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, depthStencilTargetInfo);
				return ret;
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
				{
					SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, depthStencilTargetInfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
			{
				SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, colorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
				return ret;
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
				{
					SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, colorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
			{
				fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
				{
					SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
				{
					fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
					{
						SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUGraphicsPipelineNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUGraphicsPipeline*, void>)funcTable[842])(renderPass, graphicsPipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[842])((nint)renderPass, (nint)graphicsPipeline);
			#endif
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			BindGPUGraphicsPipelineNative(renderPass, graphicsPipeline);
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUGraphicsPipelineNative((SDLGPURenderPass*)prenderPass, graphicsPipeline);
			}
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
			{
				BindGPUGraphicsPipelineNative(renderPass, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
			}
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
				{
					BindGPUGraphicsPipelineNative((SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
				}
			}
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUViewportNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] SDLGPUViewport* viewport)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUViewport*, void>)funcTable[843])(renderPass, viewport);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[843])((nint)renderPass, (nint)viewport);
			#endif
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] SDLGPUViewport* viewport)
		{
			SetGPUViewportNative(renderPass, viewport);
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] SDLGPUViewport* viewport)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUViewportNative((SDLGPURenderPass*)prenderPass, viewport);
			}
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] ref SDLGPUViewport viewport)
		{
			fixed (SDLGPUViewport* pviewport = &viewport)
			{
				SetGPUViewportNative(renderPass, (SDLGPUViewport*)pviewport);
			}
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] ref SDLGPUViewport viewport)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUViewport* pviewport = &viewport)
				{
					SetGPUViewportNative((SDLGPURenderPass*)prenderPass, (SDLGPUViewport*)pviewport);
				}
			}
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUScissorNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* scissor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLRect*, void>)funcTable[844])(renderPass, scissor);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[844])((nint)renderPass, (nint)scissor);
			#endif
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* scissor)
		{
			SetGPUScissorNative(renderPass, scissor);
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* scissor)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUScissorNative((SDLGPURenderPass*)prenderPass, scissor);
			}
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect scissor)
		{
			fixed (SDLRect* pscissor = &scissor)
			{
				SetGPUScissorNative(renderPass, (SDLRect*)pscissor);
			}
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect scissor)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLRect* pscissor = &scissor)
				{
					SetGPUScissorNative((SDLGPURenderPass*)prenderPass, (SDLRect*)pscissor);
				}
			}
		}

		/// <summary>
		/// Sets the current blend constants on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBlendConstants")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUBlendConstantsNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "blend_constants")] [NativeName(NativeNameType.Type, "SDL_FColor")] SDLFColor blendConstants)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLFColor, void>)funcTable[845])(renderPass, blendConstants);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLFColor, void>)funcTable[845])((nint)renderPass, blendConstants);
			#endif
		}

		/// <summary>
		/// Sets the current blend constants on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBlendConstants")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBlendConstants([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "blend_constants")] [NativeName(NativeNameType.Type, "SDL_FColor")] SDLFColor blendConstants)
		{
			SetGPUBlendConstantsNative(renderPass, blendConstants);
		}

		/// <summary>
		/// Sets the current blend constants on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBlendConstants")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBlendConstants([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "blend_constants")] [NativeName(NativeNameType.Type, "SDL_FColor")] SDLFColor blendConstants)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUBlendConstantsNative((SDLGPURenderPass*)prenderPass, blendConstants);
			}
		}

		/// <summary>
		/// Sets the current stencil reference value on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUStencilReference")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUStencilReferenceNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "Uint8")] byte reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, byte, void>)funcTable[846])(renderPass, reference);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[846])((nint)renderPass, reference);
			#endif
		}

		/// <summary>
		/// Sets the current stencil reference value on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUStencilReference")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUStencilReference([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "Uint8")] byte reference)
		{
			SetGPUStencilReferenceNative(renderPass, reference);
		}

		/// <summary>
		/// Sets the current stencil reference value on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUStencilReference")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUStencilReference([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "Uint8")] byte reference)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUStencilReferenceNative((SDLGPURenderPass*)prenderPass, reference);
			}
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexBuffersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUBufferBinding*, uint, void>)funcTable[847])(renderPass, firstSlot, bindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[847])((nint)renderPass, firstSlot, (nint)bindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexBuffersNative(renderPass, firstSlot, bindings, numBindings);
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, bindings, numBindings);
			}
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBufferBinding* pbindings = &bindings)
			{
				BindGPUVertexBuffersNative(renderPass, firstSlot, (SDLGPUBufferBinding*)pbindings, numBindings);
			}
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBufferBinding* pbindings = &bindings)
				{
					BindGPUVertexBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUBufferBinding*)pbindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUIndexBufferNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUBufferBinding*, SDLGPUIndexElementSize, void>)funcTable[848])(renderPass, binding, indexElementSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUIndexElementSize, void>)funcTable[848])((nint)renderPass, (nint)binding, indexElementSize);
			#endif
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			BindGPUIndexBufferNative(renderPass, binding, indexElementSize);
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUIndexBufferNative((SDLGPURenderPass*)prenderPass, binding, indexElementSize);
			}
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			fixed (SDLGPUBufferBinding* pbinding = &binding)
			{
				BindGPUIndexBufferNative(renderPass, (SDLGPUBufferBinding*)pbinding, indexElementSize);
			}
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBufferBinding* pbinding = &binding)
				{
					BindGPUIndexBufferNative((SDLGPURenderPass*)prenderPass, (SDLGPUBufferBinding*)pbinding, indexElementSize);
				}
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexSamplersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTextureSamplerBinding*, uint, void>)funcTable[849])(renderPass, firstSlot, textureSamplerBindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[849])((nint)renderPass, firstSlot, (nint)textureSamplerBindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexSamplersNative(renderPass, firstSlot, textureSamplerBindings, numBindings);
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, textureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
			{
				BindGPUVertexSamplersNative(renderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
				{
					BindGPUVertexSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexStorageTexturesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTexture**, uint, void>)funcTable[850])(renderPass, firstSlot, storageTextures, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[850])((nint)renderPass, firstSlot, (nint)storageTextures, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexStorageTexturesNative(renderPass, firstSlot, storageTextures, numBindings);
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, storageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
			{
				BindGPUVertexStorageTexturesNative(renderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
				{
					BindGPUVertexStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexStorageBuffersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUBuffer**, uint, void>)funcTable[851])(renderPass, firstSlot, storageBuffers, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[851])((nint)renderPass, firstSlot, (nint)storageBuffers, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexStorageBuffersNative(renderPass, firstSlot, storageBuffers, numBindings);
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, storageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
			{
				BindGPUVertexStorageBuffersNative(renderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
				{
					BindGPUVertexStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUFragmentSamplersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTextureSamplerBinding*, uint, void>)funcTable[852])(renderPass, firstSlot, textureSamplerBindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[852])((nint)renderPass, firstSlot, (nint)textureSamplerBindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUFragmentSamplersNative(renderPass, firstSlot, textureSamplerBindings, numBindings);
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUFragmentSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, textureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
			{
				BindGPUFragmentSamplersNative(renderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
				{
					BindGPUFragmentSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUFragmentStorageTexturesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTexture**, uint, void>)funcTable[853])(renderPass, firstSlot, storageTextures, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[853])((nint)renderPass, firstSlot, (nint)storageTextures, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUFragmentStorageTexturesNative(renderPass, firstSlot, storageTextures, numBindings);
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUFragmentStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, storageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
			{
				BindGPUFragmentStorageTexturesNative(renderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
				{
					BindGPUFragmentStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUFragmentStorageBuffersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUBuffer**, uint, void>)funcTable[854])(renderPass, firstSlot, storageBuffers, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[854])((nint)renderPass, firstSlot, (nint)storageBuffers, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUFragmentStorageBuffersNative(renderPass, firstSlot, storageBuffers, numBindings);
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUFragmentStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, storageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
			{
				BindGPUFragmentStorageBuffersNative(renderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
				{
					BindGPUFragmentStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
				}
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer and instancing<br/>
		/// enabled.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID). If your shader depends on these variables, the<br/>
		/// correlating draw call parameter MUST be 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUIndexedPrimitivesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "Uint32")] uint numIndices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_index")] [NativeName(NativeNameType.Type, "Uint32")] uint firstIndex, [NativeName(NativeNameType.Param, "vertex_offset")] [NativeName(NativeNameType.Type, "Sint32")] int vertexOffset, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, uint, uint, int, uint, void>)funcTable[855])(renderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, int, uint, void>)funcTable[855])((nint)renderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer and instancing<br/>
		/// enabled.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID). If your shader depends on these variables, the<br/>
		/// correlating draw call parameter MUST be 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "Uint32")] uint numIndices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_index")] [NativeName(NativeNameType.Type, "Uint32")] uint firstIndex, [NativeName(NativeNameType.Param, "vertex_offset")] [NativeName(NativeNameType.Type, "Sint32")] int vertexOffset, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			DrawGPUIndexedPrimitivesNative(renderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer and instancing<br/>
		/// enabled.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID). If your shader depends on these variables, the<br/>
		/// correlating draw call parameter MUST be 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "Uint32")] uint numIndices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_index")] [NativeName(NativeNameType.Type, "Uint32")] uint firstIndex, [NativeName(NativeNameType.Param, "vertex_offset")] [NativeName(NativeNameType.Type, "Sint32")] int vertexOffset, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUIndexedPrimitivesNative((SDLGPURenderPass*)prenderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID). If your shader depends on these variables, the<br/>
		/// correlating draw call parameter MUST be 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUPrimitivesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "Uint32")] uint numVertices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_vertex")] [NativeName(NativeNameType.Type, "Uint32")] uint firstVertex, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, uint, uint, uint, void>)funcTable[856])(renderPass, numVertices, numInstances, firstVertex, firstInstance);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, uint, void>)funcTable[856])((nint)renderPass, numVertices, numInstances, firstVertex, firstInstance);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID). If your shader depends on these variables, the<br/>
		/// correlating draw call parameter MUST be 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "Uint32")] uint numVertices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_vertex")] [NativeName(NativeNameType.Type, "Uint32")] uint firstVertex, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			DrawGPUPrimitivesNative(renderPass, numVertices, numInstances, firstVertex, firstInstance);
		}

		/// <summary>
		/// Draws data using bound graphics state.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID). If your shader depends on these variables, the<br/>
		/// correlating draw call parameter MUST be 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "Uint32")] uint numVertices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_vertex")] [NativeName(NativeNameType.Type, "Uint32")] uint firstVertex, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUPrimitivesNative((SDLGPURenderPass*)prenderPass, numVertices, numInstances, firstVertex, firstInstance);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUPrimitivesIndirectNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUBuffer*, uint, uint, void>)funcTable[857])(renderPass, buffer, offset, drawCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, void>)funcTable[857])((nint)renderPass, (nint)buffer, offset, drawCount);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			DrawGPUPrimitivesIndirectNative(renderPass, buffer, offset, drawCount);
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, buffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				DrawGPUPrimitivesIndirectNative(renderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					DrawGPUPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
				}
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUIndexedPrimitivesIndirectNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUBuffer*, uint, uint, void>)funcTable[858])(renderPass, buffer, offset, drawCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, void>)funcTable[858])((nint)renderPass, (nint)buffer, offset, drawCount);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			DrawGPUIndexedPrimitivesIndirectNative(renderPass, buffer, offset, drawCount);
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUIndexedPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, buffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				DrawGPUIndexedPrimitivesIndirectNative(renderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					DrawGPUIndexedPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
				}
			}
		}

		/// <summary>
		/// Ends the given render pass.<br/>
		/// All bound graphics state on the render pass command buffer is unset. The<br/>
		/// render pass handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGPURenderPassNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, void>)funcTable[859])(renderPass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[859])((nint)renderPass);
			#endif
		}

		/// <summary>
		/// Ends the given render pass.<br/>
		/// All bound graphics state on the render pass command buffer is unset. The<br/>
		/// render pass handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPURenderPass([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass)
		{
			EndGPURenderPassNative(renderPass);
		}

		/// <summary>
		/// Ends the given render pass.<br/>
		/// All bound graphics state on the render pass command buffer is unset. The<br/>
		/// render pass handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPURenderPass([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				EndGPURenderPassNative((SDLGPURenderPass*)prenderPass);
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUComputePass* BeginGPUComputePassNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUStorageTextureReadWriteBinding*, uint, SDLGPUStorageBufferReadWriteBinding*, uint, SDLGPUComputePass*>)funcTable[860])(commandBuffer, storageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
			#else
			return (SDLGPUComputePass*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, uint, nint>)funcTable[860])((nint)commandBuffer, (nint)storageTextureBindings, numStorageTextureBindings, (nint)storageBufferBindings, numStorageBufferBindings);
			#endif
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, storageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
			return ret;
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, storageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
				return ret;
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
			{
				SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
				return ret;
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
				{
					SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
			{
				SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, storageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
				return ret;
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
				{
					SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, storageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
			{
				fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
				{
					SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
				{
					fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
					{
						SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputePipelineNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, SDLGPUComputePipeline*, void>)funcTable[861])(computePass, computePipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[861])((nint)computePass, (nint)computePipeline);
			#endif
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			BindGPUComputePipelineNative(computePass, computePipeline);
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputePipelineNative((SDLGPUComputePass*)pcomputePass, computePipeline);
			}
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
			{
				BindGPUComputePipelineNative(computePass, (SDLGPUComputePipeline*)pcomputePipeline);
			}
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
				{
					BindGPUComputePipelineNative((SDLGPUComputePass*)pcomputePass, (SDLGPUComputePipeline*)pcomputePipeline);
				}
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputeSamplersNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, SDLGPUTextureSamplerBinding*, uint, void>)funcTable[862])(computePass, firstSlot, textureSamplerBindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[862])((nint)computePass, firstSlot, (nint)textureSamplerBindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUComputeSamplersNative(computePass, firstSlot, textureSamplerBindings, numBindings);
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputeSamplersNative((SDLGPUComputePass*)pcomputePass, firstSlot, textureSamplerBindings, numBindings);
			}
		}
	}
}
