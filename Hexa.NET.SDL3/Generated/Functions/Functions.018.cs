// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = FlashWindowNative((SDLWindow*)pwindow, operation);
				return ret != 0;
			}
		}

		/// <summary>
		/// Sets the state of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowProgressState")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowProgressStateNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_ProgressState")] SDLProgressState state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLProgressState, byte>)funcTable[587])(window, state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLProgressState, byte>)funcTable[587])((nint)window, state);
			#endif
		}

		/// <summary>
		/// Sets the state of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowProgressState")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowProgressState([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_ProgressState")] SDLProgressState state)
		{
			byte ret = SetWindowProgressStateNative((SDLWindow*)window, state);
			return ret != 0;
		}

		/// <summary>
		/// Sets the state of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowProgressState")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowProgressState([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_ProgressState")] SDLProgressState state)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowProgressStateNative((SDLWindow*)pwindow, state);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the state of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowProgressState")]
		[return: NativeName(NativeNameType.Type, "SDL_ProgressState")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLProgressState GetWindowProgressStateNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLProgressState>)funcTable[588])(window);
			#else
			return (SDLProgressState)((delegate* unmanaged[Cdecl]<nint, SDLProgressState>)funcTable[588])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the state of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowProgressState")]
		[return: NativeName(NativeNameType.Type, "SDL_ProgressState")]
		public static SDLProgressState GetWindowProgressState([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			SDLProgressState ret = GetWindowProgressStateNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the state of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowProgressState")]
		[return: NativeName(NativeNameType.Type, "SDL_ProgressState")]
		public static SDLProgressState GetWindowProgressState([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLProgressState ret = GetWindowProgressStateNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Sets the value of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowProgressValue")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowProgressValueNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, byte>)funcTable[589])(window, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, byte>)funcTable[589])((nint)window, value);
			#endif
		}

		/// <summary>
		/// Sets the value of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowProgressValue")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowProgressValue([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			byte ret = SetWindowProgressValueNative((SDLWindow*)window, value);
			return ret != 0;
		}

		/// <summary>
		/// Sets the value of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowProgressValue")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowProgressValue([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowProgressValueNative((SDLWindow*)pwindow, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the value of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowProgressValue")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowProgressValueNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float>)funcTable[590])(window);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[590])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the value of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowProgressValue")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetWindowProgressValue([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			float ret = GetWindowProgressValueNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the value of the progress bar for the given window’s taskbar icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowProgressValue")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetWindowProgressValue([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				float ret = GetWindowProgressValueNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any child windows owned by the window will be recursively destroyed as<br/>
		/// well.<br/>
		/// Note that on some platforms, the visible window may not actually be removed<br/>
		/// from the screen until the SDL event loop is pumped again, even though the<br/>
		/// SDL_Window is no longer valid after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[591])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[591])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any child windows owned by the window will be recursively destroyed as<br/>
		/// well.<br/>
		/// Note that on some platforms, the visible window may not actually be removed<br/>
		/// from the screen until the SDL event loop is pumped again, even though the<br/>
		/// SDL_Window is no longer valid after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			DestroyWindowNative((SDLWindow*)window);
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any child windows owned by the window will be recursively destroyed as<br/>
		/// well.<br/>
		/// Note that on some platforms, the visible window may not actually be removed<br/>
		/// from the screen until the SDL event loop is pumped again, even though the<br/>
		/// SDL_Window is no longer valid after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				DestroyWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ScreenSaverEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[592])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[592])();
			#endif
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ScreenSaverEnabled()
		{
			byte ret = ScreenSaverEnabledNative();
			return ret != 0;
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EnableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[593])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[593])();
			#endif
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnableScreenSaver()
		{
			byte ret = EnableScreenSaverNative();
			return ret != 0;
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default, but this may by changed by<br/>
		/// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DisableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[594])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[594])();
			#endif
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default, but this may by changed by<br/>
		/// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DisableScreenSaver()
		{
			byte ret = DisableScreenSaverNative();
			return ret != 0;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLLoadLibraryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[595])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[595])((nint)path);
			#endif
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			byte ret = GLLoadLibraryNative(path);
			return ret != 0;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = GLLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				byte ret = GLLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GLLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> GLGetProcAddressNative([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[596])(proc);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[596])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			delegate*<void> ret = GLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] in byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				delegate*<void> ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				delegate*<void> ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = GLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> EGLGetProcAddressNative([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[597])(proc);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[597])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			delegate*<void> ret = EGLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] in byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				delegate*<void> ret = EGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				delegate*<void> ret = EGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = EGLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLUnloadLibraryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[598])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[598])();
			#endif
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GLUnloadLibrary()
		{
			GLUnloadLibraryNative();
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLExtensionSupportedNative([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[599])(extension);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[599])((nint)extension);
			#endif
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] byte* extension)
		{
			byte ret = GLExtensionSupportedNative(extension);
			return ret != 0;
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] in byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				byte ret = GLExtensionSupportedNative((byte*)pextension);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				byte ret = GLExtensionSupportedNative((byte*)pextension);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GLExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLResetAttributesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[600])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[600])();
			#endif
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GLResetAttributes()
		{
			GLResetAttributesNative();
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLAttr")] SDLGLAttr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLAttr, int, byte>)funcTable[601])(attr, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLAttr, int, byte>)funcTable[601])(attr, value);
			#endif
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLAttr")] SDLGLAttr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			byte ret = GLSetAttributeNative(attr, value);
			return ret != 0;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLGetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLAttr")] SDLGLAttr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int *")] int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLAttr, int*, byte>)funcTable[602])(attr, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLAttr, nint, byte>)funcTable[602])(attr, (nint)value);
			#endif
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLAttr")] SDLGLAttr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int *")] int* value)
		{
			byte ret = GLGetAttributeNative(attr, value);
			return ret != 0;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLAttr")] SDLGLAttr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int *")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				byte ret = GLGetAttributeNative(attr, (int*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// The OpenGL context will be created with the current states set through<br/>
		/// SDL_GL_SetAttribute().<br/>
		/// The SDL_Window specified must have been created with the SDL_WINDOW_OPENGL<br/>
		/// flag, or context creation will fail.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLCreateContextNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext>)funcTable[603])(window);
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<nint, SDLGLContext>)funcTable[603])((nint)window);
			#endif
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// The OpenGL context will be created with the current states set through<br/>
		/// SDL_GL_SetAttribute().<br/>
		/// The SDL_Window specified must have been created with the SDL_WINDOW_OPENGL<br/>
		/// flag, or context creation will fail.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext GLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			SDLGLContext ret = GLCreateContextNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// The OpenGL context will be created with the current states set through<br/>
		/// SDL_GL_SetAttribute().<br/>
		/// The SDL_Window specified must have been created with the SDL_WINDOW_OPENGL<br/>
		/// flag, or context creation will fail.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext GLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLContext ret = GLCreateContextNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLMakeCurrentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext, byte>)funcTable[604])(window, context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGLContext, byte>)funcTable[604])((nint)window, context);
			#endif
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			byte ret = GLMakeCurrentNative((SDLWindow*)window, context);
			return ret != 0;
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GLMakeCurrentNative((SDLWindow*)pwindow, context);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GLGetCurrentWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[605])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[605])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindowPtr GLGetCurrentWindow()
		{
			SDLWindowPtr ret = GLGetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLGetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[606])();
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[606])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext GLGetCurrentContext()
		{
			SDLGLContext ret = GLGetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active EGL display.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentDisplay")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLDisplay")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EGLGetCurrentDisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*>)funcTable[607])();
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint>)funcTable[607])();
			#endif
		}

		/// <summary>
		/// Get the currently active EGL display.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentDisplay")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLDisplay")]
		public static void* EGLGetCurrentDisplay()
		{
			void* ret = EGLGetCurrentDisplayNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active EGL config.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentConfig")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLConfig")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EGLGetCurrentConfigNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*>)funcTable[608])();
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint>)funcTable[608])();
			#endif
		}

		/// <summary>
		/// Get the currently active EGL config.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentConfig")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLConfig")]
		public static void* EGLGetCurrentConfig()
		{
			void* ret = EGLGetCurrentConfigNative();
			return ret;
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* EGLGetWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, void*>)funcTable[609])(window);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[609])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLSurface")]
		public static void* EGLGetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			void* ret = EGLGetWindowSurfaceNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLSurface")]
		public static void* EGLGetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = EGLGetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EGLSetAttributeCallbacksNative([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, nint*>, delegate*<void*, void*, void*, int*>, delegate*<void*, void*, void*, int*>, void*, void>)funcTable[610])(platformAttribCallback, surfaceAttribCallback, contextAttribCallback, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[610])((nint)platformAttribCallback, (nint)surfaceAttribCallback, (nint)contextAttribCallback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, surfaceAttribCallback, contextAttribCallback, userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), surfaceAttribCallback, contextAttribCallback, userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), contextAttribCallback, userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), contextAttribCallback, userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, surfaceAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), surfaceAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, surfaceAttribCallback, contextAttribCallback, (void*)userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), surfaceAttribCallback, contextAttribCallback, (void*)userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), contextAttribCallback, (void*)userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), contextAttribCallback, (void*)userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, surfaceAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), (void*)userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] delegate*<void*, void*, void*, int*> surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), surfaceAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), (void*)userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] delegate*<void*, nint*> platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), (void*)userdata);
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			EGLSetAttributeCallbacksNative((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (delegate*<void*, void*, void*, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), (void*)userdata);
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return false. In such a case, you should<br/>
		/// probably retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSetSwapIntervalNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[611])(interval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[611])(interval);
			#endif
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return false. In such a case, you should<br/>
		/// probably retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			byte ret = GLSetSwapIntervalNative(interval);
			return ret != 0;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLGetSwapIntervalNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int *")] int* interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte>)funcTable[612])(interval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[612])((nint)interval);
			#endif
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int *")] int* interval)
		{
			byte ret = GLGetSwapIntervalNative(interval);
			return ret != 0;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int *")] ref int interval)
		{
			fixed (int* pinterval = &interval)
			{
				byte ret = GLGetSwapIntervalNative((int*)pinterval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSwapWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[613])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[613])((nint)window);
			#endif
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = GLSwapWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GLSwapWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_DestroyContext")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLDestroyContextNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLContext, byte>)funcTable[614])(context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLContext, byte>)funcTable[614])(context);
			#endif
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_DestroyContext")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLDestroyContext([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			byte ret = GLDestroyContextNative(context);
			return ret != 0;
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFileDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] byte allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, byte, void>)funcTable[615])(callback, userdata, window, filters, nfilters, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, byte, void>)funcTable[615])((nint)callback, (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowOpenFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowOpenFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowSaveFileDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, void>)funcTable[616])(callback, userdata, window, filters, nfilters, defaultLocation);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, void>)funcTable[616])((nint)callback, (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
			}
		}
	}
}
