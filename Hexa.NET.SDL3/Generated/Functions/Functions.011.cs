// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMPIO(SDLSurface* surface, SDLIOStream* dst, bool closeio)
		{
			byte ret = SaveBMPIONative(surface, dst, closeio ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMPIO(ref SDLSurface surface, SDLIOStream* dst, bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveBMPIONative((SDLSurface*)psurface, dst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMPIO(SDLSurface* surface, ref SDLIOStream dst, bool closeio)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				byte ret = SaveBMPIONative(surface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMPIO(ref SDLSurface surface, ref SDLIOStream dst, bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLIOStream* pdst = &dst)
				{
					byte ret = SaveBMPIONative((SDLSurface*)psurface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveBMPNative(SDLSurface* surface, byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[406])(surface, file);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[406])((nint)surface, (nint)file);
			#endif
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(SDLSurface* surface, byte* file)
		{
			byte ret = SaveBMPNative(surface, file);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(ref SDLSurface surface, byte* file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveBMPNative((SDLSurface*)psurface, file);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(SDLSurface* surface, ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SaveBMPNative(surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(SDLSurface* surface, ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SaveBMPNative(surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(SDLSurface* surface, string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveBMPNative(surface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(ref SDLSurface surface, ref byte file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					byte ret = SaveBMPNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(ref SDLSurface surface, ReadOnlySpan<byte> file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					byte ret = SaveBMPNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SaveBMP(ref SDLSurface surface, string file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SaveBMPNative((SDLSurface*)psurface, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceRLENative(SDLSurface* surface, byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[407])(surface, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[407])((nint)surface, enabled);
			#endif
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceRLE(SDLSurface* surface, bool enabled)
		{
			byte ret = SetSurfaceRLENative(surface, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceRLE(ref SDLSurface surface, bool enabled)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceRLENative((SDLSurface*)psurface, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SurfaceHasRLENative(SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[408])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[408])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SurfaceHasRLE(SDLSurface* surface)
		{
			byte ret = SurfaceHasRLENative(surface);
			return ret != 0;
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SurfaceHasRLE(ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SurfaceHasRLENative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceColorKeyNative(SDLSurface* surface, byte enabled, uint key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, uint, byte>)funcTable[409])(surface, enabled, key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, uint, byte>)funcTable[409])((nint)surface, enabled, key);
			#endif
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceColorKey(SDLSurface* surface, bool enabled, uint key)
		{
			byte ret = SetSurfaceColorKeyNative(surface, enabled ? (byte)1 : (byte)0, key);
			return ret != 0;
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceColorKey(ref SDLSurface surface, bool enabled, uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceColorKeyNative((SDLSurface*)psurface, enabled ? (byte)1 : (byte)0, key);
				return ret != 0;
			}
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SurfaceHasColorKeyNative(SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[410])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[410])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SurfaceHasColorKey(SDLSurface* surface)
		{
			byte ret = SurfaceHasColorKeyNative(surface);
			return ret != 0;
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SurfaceHasColorKey(ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SurfaceHasColorKeyNative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceColorKeyNative(SDLSurface* surface, uint* key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint*, byte>)funcTable[411])(surface, key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[411])((nint)surface, (nint)key);
			#endif
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorKey(SDLSurface* surface, uint* key)
		{
			byte ret = GetSurfaceColorKeyNative(surface, key);
			return ret != 0;
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorKey(ref SDLSurface surface, uint* key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceColorKeyNative((SDLSurface*)psurface, key);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorKey(SDLSurface* surface, ref uint key)
		{
			fixed (uint* pkey = &key)
			{
				byte ret = GetSurfaceColorKeyNative(surface, (uint*)pkey);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorKey(ref SDLSurface surface, ref uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (uint* pkey = &key)
				{
					byte ret = GetSurfaceColorKeyNative((SDLSurface*)psurface, (uint*)pkey);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceColorModNative(SDLSurface* surface, byte r, byte g, byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte, byte, byte>)funcTable[412])(surface, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte>)funcTable[412])((nint)surface, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceColorMod(SDLSurface* surface, byte r, byte g, byte b)
		{
			byte ret = SetSurfaceColorModNative(surface, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceColorMod(ref SDLSurface surface, byte r, byte g, byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceColorModNative(SDLSurface* surface, byte* r, byte* g, byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte*, byte*, byte>)funcTable[413])(surface, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[413])((nint)surface, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, byte* r, byte* g, byte* b)
		{
			byte ret = GetSurfaceColorModNative(surface, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, byte* r, byte* g, byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, ref byte r, byte* g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				byte ret = GetSurfaceColorModNative(surface, (byte*)pr, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, ref byte r, byte* g, byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, byte* r, ref byte g, byte* b)
		{
			fixed (byte* pg = &g)
			{
				byte ret = GetSurfaceColorModNative(surface, r, (byte*)pg, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, byte* r, ref byte g, byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, ref byte r, ref byte g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, b);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, byte* r, byte* g, ref byte b)
		{
			fixed (byte* pb = &b)
			{
				byte ret = GetSurfaceColorModNative(surface, r, g, (byte*)pb);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, byte* r, byte* g, ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, ref byte r, byte* g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative(surface, (byte*)pr, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, byte* r, ref byte g, ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative(surface, r, (byte*)pg, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(SDLSurface* surface, ref byte r, ref byte g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceColorMod(ref SDLSurface surface, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceAlphaModNative(SDLSurface* surface, byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[414])(surface, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[414])((nint)surface, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceAlphaMod(SDLSurface* surface, byte alpha)
		{
			byte ret = SetSurfaceAlphaModNative(surface, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceAlphaMod(ref SDLSurface surface, byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceAlphaModNative(SDLSurface* surface, byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[415])(surface, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[415])((nint)surface, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceAlphaMod(SDLSurface* surface, byte* alpha)
		{
			byte ret = GetSurfaceAlphaModNative(surface, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceAlphaMod(ref SDLSurface surface, byte* alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceAlphaMod(SDLSurface* surface, ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				byte ret = GetSurfaceAlphaModNative(surface, (byte*)palpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceAlphaMod(ref SDLSurface surface, ref byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* palpha = &alpha)
				{
					byte ret = GetSurfaceAlphaModNative((SDLSurface*)psurface, (byte*)palpha);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceBlendModeNative(SDLSurface* surface, SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLBlendMode, byte>)funcTable[416])(surface, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, byte>)funcTable[416])((nint)surface, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceBlendMode(SDLSurface* surface, SDLBlendMode blendMode)
		{
			byte ret = SetSurfaceBlendModeNative(surface, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceBlendMode(ref SDLSurface surface, SDLBlendMode blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceBlendModeNative(SDLSurface* surface, SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLBlendMode*, byte>)funcTable[417])(surface, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[417])((nint)surface, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceBlendMode(SDLSurface* surface, SDLBlendMode* blendMode)
		{
			byte ret = GetSurfaceBlendModeNative(surface, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceBlendMode(ref SDLSurface surface, SDLBlendMode* blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceBlendMode(SDLSurface* surface, ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				byte ret = GetSurfaceBlendModeNative(surface, (SDLBlendMode*)pblendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceBlendMode(ref SDLSurface surface, ref SDLBlendMode blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					byte ret = GetSurfaceBlendModeNative((SDLSurface*)psurface, (SDLBlendMode*)pblendMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceClipRectNative(SDLSurface* surface, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, byte>)funcTable[418])(surface, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[418])((nint)surface, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceClipRect(SDLSurface* surface, SDLRect* rect)
		{
			byte ret = SetSurfaceClipRectNative(surface, rect);
			return ret != 0;
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceClipRect(ref SDLSurface surface, SDLRect* rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceClipRectNative((SDLSurface*)psurface, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceClipRect(SDLSurface* surface, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetSurfaceClipRectNative(surface, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetSurfaceClipRect(ref SDLSurface surface, ref SDLRect rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetSurfaceClipRectNative((SDLSurface*)psurface, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceClipRectNative(SDLSurface* surface, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, byte>)funcTable[419])(surface, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[419])((nint)surface, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceClipRect(SDLSurface* surface, SDLRect* rect)
		{
			byte ret = GetSurfaceClipRectNative(surface, rect);
			return ret != 0;
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceClipRect(ref SDLSurface surface, SDLRect* rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceClipRectNative((SDLSurface*)psurface, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceClipRect(SDLSurface* surface, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = GetSurfaceClipRectNative(surface, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSurfaceClipRect(ref SDLSurface surface, ref SDLRect rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = GetSurfaceClipRectNative((SDLSurface*)psurface, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Flip a surface vertically or horizontally.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FlipSurfaceNative(SDLSurface* surface, SDLFlipMode flip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLFlipMode, byte>)funcTable[420])(surface, flip);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLFlipMode, byte>)funcTable[420])((nint)surface, flip);
			#endif
		}

		/// <summary>
		/// Flip a surface vertically or horizontally.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		public static bool FlipSurface(SDLSurface* surface, SDLFlipMode flip)
		{
			byte ret = FlipSurfaceNative(surface, flip);
			return ret != 0;
		}

		/// <summary>
		/// Flip a surface vertically or horizontally.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		public static bool FlipSurface(ref SDLSurface surface, SDLFlipMode flip)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = FlipSurfaceNative((SDLSurface*)psurface, flip);
				return ret != 0;
			}
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* DuplicateSurfaceNative(SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLSurface*>)funcTable[421])(surface);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[421])((nint)surface);
			#endif
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* DuplicateSurface(SDLSurface* surface)
		{
			SDLSurface* ret = DuplicateSurfaceNative(surface);
			return ret;
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* DuplicateSurface(ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = DuplicateSurfaceNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface, scaled to the<br/>
		/// desired size.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ScaleSurfaceNative(SDLSurface* surface, int width, int height, SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, SDLScaleMode, SDLSurface*>)funcTable[422])(surface, width, height, scaleMode);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, int, SDLScaleMode, nint>)funcTable[422])((nint)surface, width, height, scaleMode);
			#endif
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface, scaled to the<br/>
		/// desired size.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ScaleSurface(SDLSurface* surface, int width, int height, SDLScaleMode scaleMode)
		{
			SDLSurface* ret = ScaleSurfaceNative(surface, width, height, scaleMode);
			return ret;
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface, scaled to the<br/>
		/// desired size.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ScaleSurface(ref SDLSurface surface, int width, int height, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = ScaleSurfaceNative((SDLSurface*)psurface, width, height, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// If you are converting to an indexed surface and want to map colors to a<br/>
		/// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ConvertSurfaceNative(SDLSurface* surface, SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPixelFormat, SDLSurface*>)funcTable[423])(surface, format);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, SDLPixelFormat, nint>)funcTable[423])((nint)surface, format);
			#endif
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// If you are converting to an indexed surface and want to map colors to a<br/>
		/// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ConvertSurface(SDLSurface* surface, SDLPixelFormat format)
		{
			SDLSurface* ret = ConvertSurfaceNative(surface, format);
			return ret;
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// If you are converting to an indexed surface and want to map colors to a<br/>
		/// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ConvertSurface(ref SDLSurface surface, SDLPixelFormat format)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = ConvertSurfaceNative((SDLSurface*)psurface, format);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ConvertSurfaceAndColorspaceNative(SDLSurface* surface, SDLPixelFormat format, SDLPalette* palette, SDLColorspace colorspace, uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPixelFormat, SDLPalette*, SDLColorspace, uint, SDLSurface*>)funcTable[424])(surface, format, palette, colorspace, props);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, SDLPixelFormat, nint, SDLColorspace, uint, nint>)funcTable[424])((nint)surface, format, (nint)palette, colorspace, props);
			#endif
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ConvertSurfaceAndColorspace(SDLSurface* surface, SDLPixelFormat format, SDLPalette* palette, SDLColorspace colorspace, uint props)
		{
			SDLSurface* ret = ConvertSurfaceAndColorspaceNative(surface, format, palette, colorspace, props);
			return ret;
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ConvertSurfaceAndColorspace(ref SDLSurface surface, SDLPixelFormat format, SDLPalette* palette, SDLColorspace colorspace, uint props)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = ConvertSurfaceAndColorspaceNative((SDLSurface*)psurface, format, palette, colorspace, props);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ConvertSurfaceAndColorspace(SDLSurface* surface, SDLPixelFormat format, ref SDLPalette palette, SDLColorspace colorspace, uint props)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				SDLSurface* ret = ConvertSurfaceAndColorspaceNative(surface, format, (SDLPalette*)ppalette, colorspace, props);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* ConvertSurfaceAndColorspace(ref SDLSurface surface, SDLPixelFormat format, ref SDLPalette palette, SDLColorspace colorspace, uint props)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					SDLSurface* ret = ConvertSurfaceAndColorspaceNative((SDLSurface*)psurface, format, (SDLPalette*)ppalette, colorspace, props);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a block of pixels of one format to another format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination pixels should not be used from two<br/>
		/// threads at once. It is safe to use the same source pixels<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ConvertPixelsNative(int width, int height, SDLPixelFormat srcFormat, void* src, int srcPitch, SDLPixelFormat dstFormat, void* dst, int dstPitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, void*, int, SDLPixelFormat, void*, int, byte>)funcTable[425])(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint, int, SDLPixelFormat, nint, int, byte>)funcTable[425])(width, height, srcFormat, (nint)src, srcPitch, dstFormat, (nint)dst, dstPitch);
			#endif
		}

		/// <summary>
		/// Copy a block of pixels of one format to another format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination pixels should not be used from two<br/>
		/// threads at once. It is safe to use the same source pixels<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ConvertPixels(int width, int height, SDLPixelFormat srcFormat, void* src, int srcPitch, SDLPixelFormat dstFormat, void* dst, int dstPitch)
		{
			byte ret = ConvertPixelsNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			return ret != 0;
		}

		/// <summary>
		/// Copy a block of pixels of one format and colorspace to another format and<br/>
		/// colorspace.<br/>
		/// <br/>
		/// <br/>
		/// The same destination pixels should not be used from two<br/>
		/// threads at once. It is safe to use the same source pixels<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ConvertPixelsAndColorspaceNative(int width, int height, SDLPixelFormat srcFormat, SDLColorspace srcColorspace, uint srcProperties, void* src, int srcPitch, SDLPixelFormat dstFormat, SDLColorspace dstColorspace, uint dstProperties, void* dst, int dstPitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, SDLColorspace, uint, void*, int, SDLPixelFormat, SDLColorspace, uint, void*, int, byte>)funcTable[426])(width, height, srcFormat, srcColorspace, srcProperties, src, srcPitch, dstFormat, dstColorspace, dstProperties, dst, dstPitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, SDLColorspace, uint, nint, int, SDLPixelFormat, SDLColorspace, uint, nint, int, byte>)funcTable[426])(width, height, srcFormat, srcColorspace, srcProperties, (nint)src, srcPitch, dstFormat, dstColorspace, dstProperties, (nint)dst, dstPitch);
			#endif
		}

		/// <summary>
		/// Copy a block of pixels of one format and colorspace to another format and<br/>
		/// colorspace.<br/>
		/// <br/>
		/// <br/>
		/// The same destination pixels should not be used from two<br/>
		/// threads at once. It is safe to use the same source pixels<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ConvertPixelsAndColorspace(int width, int height, SDLPixelFormat srcFormat, SDLColorspace srcColorspace, uint srcProperties, void* src, int srcPitch, SDLPixelFormat dstFormat, SDLColorspace dstColorspace, uint dstProperties, void* dst, int dstPitch)
		{
			byte ret = ConvertPixelsAndColorspaceNative(width, height, srcFormat, srcColorspace, srcProperties, src, srcPitch, dstFormat, dstColorspace, dstProperties, dst, dstPitch);
			return ret != 0;
		}

		/// <summary>
		/// Premultiply the alpha on a block of pixels.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// The same destination pixels should not be used from two<br/>
		/// threads at once. It is safe to use the same source pixels<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PremultiplyAlphaNative(int width, int height, SDLPixelFormat srcFormat, void* src, int srcPitch, SDLPixelFormat dstFormat, void* dst, int dstPitch, byte linear)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, void*, int, SDLPixelFormat, void*, int, byte, byte>)funcTable[427])(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch, linear);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint, int, SDLPixelFormat, nint, int, byte, byte>)funcTable[427])(width, height, srcFormat, (nint)src, srcPitch, dstFormat, (nint)dst, dstPitch, linear);
			#endif
		}

		/// <summary>
		/// Premultiply the alpha on a block of pixels.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// The same destination pixels should not be used from two<br/>
		/// threads at once. It is safe to use the same source pixels<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// </summary>
		public static bool PremultiplyAlpha(int width, int height, SDLPixelFormat srcFormat, void* src, int srcPitch, SDLPixelFormat dstFormat, void* dst, int dstPitch, bool linear)
		{
			byte ret = PremultiplyAlphaNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch, linear ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Premultiply the alpha in a surface.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PremultiplySurfaceAlphaNative(SDLSurface* surface, byte linear)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[428])(surface, linear);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[428])((nint)surface, linear);
			#endif
		}

		/// <summary>
		/// Premultiply the alpha in a surface.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		public static bool PremultiplySurfaceAlpha(SDLSurface* surface, bool linear)
		{
			byte ret = PremultiplySurfaceAlphaNative(surface, linear ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Premultiply the alpha in a surface.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		public static bool PremultiplySurfaceAlpha(ref SDLSurface surface, bool linear)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = PremultiplySurfaceAlphaNative((SDLSurface*)psurface, linear ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a surface with a specific color, with floating point precision.<br/>
		/// This function handles all surface formats, and ignores any clip rectangle.<br/>
		/// If the surface is YUV, the color is assumed to be in the sRGB colorspace,<br/>
		/// otherwise the color is assumed to be in the colorspace of the suface.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearSurfaceNative(SDLSurface* surface, float r, float g, float b, float a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, float, float, float, float, byte>)funcTable[429])(surface, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, byte>)funcTable[429])((nint)surface, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Clear a surface with a specific color, with floating point precision.<br/>
		/// This function handles all surface formats, and ignores any clip rectangle.<br/>
		/// If the surface is YUV, the color is assumed to be in the sRGB colorspace,<br/>
		/// otherwise the color is assumed to be in the colorspace of the suface.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		public static bool ClearSurface(SDLSurface* surface, float r, float g, float b, float a)
		{
			byte ret = ClearSurfaceNative(surface, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Clear a surface with a specific color, with floating point precision.<br/>
		/// This function handles all surface formats, and ignores any clip rectangle.<br/>
		/// If the surface is YUV, the color is assumed to be in the sRGB colorspace,<br/>
		/// otherwise the color is assumed to be in the colorspace of the suface.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		public static bool ClearSurface(ref SDLSurface surface, float r, float g, float b, float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = ClearSurfaceNative((SDLSurface*)psurface, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FillSurfaceRectNative(SDLSurface* dst, SDLRect* rect, uint color)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, uint, byte>)funcTable[430])(dst, rect, color);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, uint, byte>)funcTable[430])((nint)dst, (nint)rect, color);
			#endif
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRect(SDLSurface* dst, SDLRect* rect, uint color)
		{
			byte ret = FillSurfaceRectNative(dst, rect, color);
			return ret != 0;
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRect(ref SDLSurface dst, SDLRect* rect, uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = FillSurfaceRectNative((SDLSurface*)pdst, rect, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRect(SDLSurface* dst, ref SDLRect rect, uint color)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = FillSurfaceRectNative(dst, (SDLRect*)prect, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRect(ref SDLSurface dst, ref SDLRect rect, uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = FillSurfaceRectNative((SDLSurface*)pdst, (SDLRect*)prect, color);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FillSurfaceRectsNative(SDLSurface* dst, SDLRect* rects, int count, uint color)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, int, uint, byte>)funcTable[431])(dst, rects, count, color);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, uint, byte>)funcTable[431])((nint)dst, (nint)rects, count, color);
			#endif
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRects(SDLSurface* dst, SDLRect* rects, int count, uint color)
		{
			byte ret = FillSurfaceRectsNative(dst, rects, count, color);
			return ret != 0;
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRects(ref SDLSurface dst, SDLRect* rects, int count, uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = FillSurfaceRectsNative((SDLSurface*)pdst, rects, count, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRects(SDLSurface* dst, ref SDLRect rects, int count, uint color)
		{
			fixed (SDLRect* prects = &rects)
			{
				byte ret = FillSurfaceRectsNative(dst, (SDLRect*)prects, count, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool FillSurfaceRects(ref SDLSurface dst, ref SDLRect rects, int count, uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* prects = &rects)
				{
					byte ret = FillSurfaceRectsNative((SDLSurface*)pdst, (SDLRect*)prects, count, color);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceNative(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, byte>)funcTable[432])(src, srcrect, dst, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[432])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			byte ret = BlitSurfaceNative(src, srcrect, dst, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurfaceNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface<br/>
		/// with clipping.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied while ensuring clipping to `dst->clip_rect`.<br/>
		/// The final blit rectangles are saved in `srcrect` and `dstrect` after all<br/>
		/// clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurface(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceUncheckedNative(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, byte>)funcTable[433])(src, srcrect, dst, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[433])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			byte ret = BlitSurfaceUncheckedNative(src, srcrect, dst, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceUncheckedNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurfaceUncheckedNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUnchecked(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceScaledNative(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, SDLScaleMode, byte>)funcTable[434])(src, srcrect, dst, dstrect, scaleMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, SDLScaleMode, byte>)funcTable[434])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect, scaleMode);
			#endif
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			byte ret = BlitSurfaceScaledNative(src, srcrect, dst, dstrect, scaleMode);
			return ret != 0;
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurfaceScaledNative(src, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceUncheckedScaledNative(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, SDLScaleMode, byte>)funcTable[435])(src, srcrect, dst, dstrect, scaleMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, SDLScaleMode, byte>)funcTable[435])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect, scaleMode);
			#endif
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			byte ret = BlitSurfaceUncheckedScaledNative(src, srcrect, dst, dstrect, scaleMode);
			return ret != 0;
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, srcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceUncheckedScaledNative(src, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceUncheckedScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurfaceUncheckedScaledNative(src, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceUncheckedScaled(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StretchSurfaceNative(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, SDLScaleMode, byte>)funcTable[436])(src, srcrect, dst, dstrect, scaleMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, SDLScaleMode, byte>)funcTable[436])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect, scaleMode);
			#endif
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			byte ret = StretchSurfaceNative(src, srcrect, dst, dstrect, scaleMode);
			return ret != 0;
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = StretchSurfaceNative((SDLSurface*)psrc, srcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = StretchSurfaceNative(src, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = StretchSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = StretchSurfaceNative(src, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = StretchSurfaceNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = StretchSurfaceNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, SDLRect* dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = StretchSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = StretchSurfaceNative(src, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = StretchSurfaceNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = StretchSurfaceNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, ref SDLRect srcrect, SDLSurface* dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = StretchSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = StretchSurfaceNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, SDLRect* srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = StretchSurfaceNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(SDLSurface* src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = StretchSurfaceNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a stretched pixel copy from one surface to another.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool StretchSurface(ref SDLSurface src, ref SDLRect srcrect, ref SDLSurface dst, ref SDLRect dstrect, SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = StretchSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a tiled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceTiledNative(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, byte>)funcTable[437])(src, srcrect, dst, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[437])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Perform a tiled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceTiled(SDLSurface* src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			byte ret = BlitSurfaceTiledNative(src, srcrect, dst, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Perform a tiled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// Only one thread should be using the `src` and `dst` surfaces<br/>
		/// at any given time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool BlitSurfaceTiled(ref SDLSurface src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceTiledNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret != 0;
			}
		}
	}
}
