// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Convenience function for straightforward audio init for the common case.<br/>
		/// If all your app intends to do is provide a single source of PCM audio, this<br/>
		/// function allows you to do all your audio setup in a single call.<br/>
		/// This is also intended to be a clean means to migrate apps from SDL2.<br/>
		/// This function will open an audio device, create a stream and bind it.<br/>
		/// Unlike other methods of setup, the audio device will be closed when this<br/>
		/// stream is destroyed, so the app can treat the returned SDL_AudioStream as<br/>
		/// the only object needed to manage audio playback.<br/>
		/// Also unlike other functions, the audio device begins paused. This is to map<br/>
		/// more closely to SDL2-style behavior, since there is no extra step here to<br/>
		/// bind a stream to begin audio flowing. The audio device should be resumed<br/>
		/// with SDL_ResumeAudioStreamDevice().<br/>
		/// This function works with both playback and recording devices.<br/>
		/// The `spec` parameter represents the app's side of the audio stream. That<br/>
		/// is, for recording audio, this will be the output format, and for playing<br/>
		/// audio, this will be the input format. If spec is NULL, the system will<br/>
		/// choose the format, and the app can use SDL_GetAudioStreamFormat() to obtain<br/>
		/// this information later.<br/>
		/// If you don't care about opening a specific audio device, you can (and<br/>
		/// probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and<br/>
		/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING for recording.<br/>
		/// One can optionally provide a callback function; if NULL, the app is<br/>
		/// expected to queue audio data for playback (or unqueue audio data if<br/>
		/// capturing). Otherwise, the callback will begin to fire once the device is<br/>
		/// unpaused.<br/>
		/// Destroying the returned stream with SDL_DestroyAudioStream will also close<br/>
		/// the audio device associated with this stream.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDeviceStream")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStream *")]
		public static SDLAudioStreamPtr OpenAudioDeviceStream([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_AudioStreamCallback")] SDLAudioStreamCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SDLAudioStreamPtr ret = OpenAudioDeviceStreamNative(devid, (SDLAudioSpec*)spec, (delegate*<void*, SDLAudioStream*, int, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Convenience function for straightforward audio init for the common case.<br/>
		/// If all your app intends to do is provide a single source of PCM audio, this<br/>
		/// function allows you to do all your audio setup in a single call.<br/>
		/// This is also intended to be a clean means to migrate apps from SDL2.<br/>
		/// This function will open an audio device, create a stream and bind it.<br/>
		/// Unlike other methods of setup, the audio device will be closed when this<br/>
		/// stream is destroyed, so the app can treat the returned SDL_AudioStream as<br/>
		/// the only object needed to manage audio playback.<br/>
		/// Also unlike other functions, the audio device begins paused. This is to map<br/>
		/// more closely to SDL2-style behavior, since there is no extra step here to<br/>
		/// bind a stream to begin audio flowing. The audio device should be resumed<br/>
		/// with SDL_ResumeAudioStreamDevice().<br/>
		/// This function works with both playback and recording devices.<br/>
		/// The `spec` parameter represents the app's side of the audio stream. That<br/>
		/// is, for recording audio, this will be the output format, and for playing<br/>
		/// audio, this will be the input format. If spec is NULL, the system will<br/>
		/// choose the format, and the app can use SDL_GetAudioStreamFormat() to obtain<br/>
		/// this information later.<br/>
		/// If you don't care about opening a specific audio device, you can (and<br/>
		/// probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and<br/>
		/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING for recording.<br/>
		/// One can optionally provide a callback function; if NULL, the app is<br/>
		/// expected to queue audio data for playback (or unqueue audio data if<br/>
		/// capturing). Otherwise, the callback will begin to fire once the device is<br/>
		/// unpaused.<br/>
		/// Destroying the returned stream with SDL_DestroyAudioStream will also close<br/>
		/// the audio device associated with this stream.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDeviceStream")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStream *")]
		public static SDLAudioStreamPtr OpenAudioDeviceStream([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec spec, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_AudioStreamCallback")] SDLAudioStreamCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				SDLAudioStreamPtr ret = OpenAudioDeviceStreamNative(devid, (SDLAudioSpec*)pspec, (delegate*<void*, SDLAudioStream*, int, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
				return ret;
			}
		}

		/// <summary>
		/// Set a callback that fires when data is about to be fed to an audio device.<br/>
		/// This is useful for accessing the final mix, perhaps for writing a<br/>
		/// visualizer or applying a final effect to the audio data before playback.<br/>
		/// The buffer is the final mix of all bound audio streams on an opened device;<br/>
		/// this callback will fire regularly for any device that is both opened and<br/>
		/// unpaused. If there is no new data to mix, either because no streams are<br/>
		/// bound to the device or all the streams are empty, this callback will still<br/>
		/// fire with the entire buffer set to silence.<br/>
		/// This callback is allowed to make changes to the data; the contents of the<br/>
		/// buffer after this call is what is ultimately passed along to the hardware.<br/>
		/// The callback is always provided the data in float format (values from -1.0f<br/>
		/// to 1.0f), but the number of channels or sample rate may be different than<br/>
		/// the format the app requested when opening the device; SDL might have had to<br/>
		/// manage a conversion behind the scenes, or the playback might have jumped to<br/>
		/// new physical hardware when a system default changed, etc. These details may<br/>
		/// change between calls. Accordingly, the size of the buffer might change<br/>
		/// between calls as well.<br/>
		/// This callback can run at any time, and from any thread; if you need to<br/>
		/// serialize access to your app's data, you should provide and use a mutex or<br/>
		/// other synchronization device.<br/>
		/// All of this to say: there are specific needs this callback can fulfill, but<br/>
		/// it is not the simplest interface. Apps should generally provide audio in<br/>
		/// their preferred format through an SDL_AudioStream and let SDL handle the<br/>
		/// difference.<br/>
		/// This function is extremely time-sensitive; the callback should do the least<br/>
		/// amount of work possible and return as quickly as it can. The longer the<br/>
		/// callback runs, the higher the risk of audio dropouts or other problems.<br/>
		/// This function will block until the audio device is in between iterations,<br/>
		/// so any existing callback that might be running will finish before this<br/>
		/// function sets the new callback and returns.<br/>
		/// Setting a NULL callback function disables any previously-set callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAudioPostmixCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetAudioPostmixCallbackNative([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_AudioPostmixCallback")] delegate*<void*, SDLAudioSpec*, float*, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void*, SDLAudioSpec*, float*, int, void>, void*, byte>)funcTable[362])(devid, callback, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[362])(devid, (nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a callback that fires when data is about to be fed to an audio device.<br/>
		/// This is useful for accessing the final mix, perhaps for writing a<br/>
		/// visualizer or applying a final effect to the audio data before playback.<br/>
		/// The buffer is the final mix of all bound audio streams on an opened device;<br/>
		/// this callback will fire regularly for any device that is both opened and<br/>
		/// unpaused. If there is no new data to mix, either because no streams are<br/>
		/// bound to the device or all the streams are empty, this callback will still<br/>
		/// fire with the entire buffer set to silence.<br/>
		/// This callback is allowed to make changes to the data; the contents of the<br/>
		/// buffer after this call is what is ultimately passed along to the hardware.<br/>
		/// The callback is always provided the data in float format (values from -1.0f<br/>
		/// to 1.0f), but the number of channels or sample rate may be different than<br/>
		/// the format the app requested when opening the device; SDL might have had to<br/>
		/// manage a conversion behind the scenes, or the playback might have jumped to<br/>
		/// new physical hardware when a system default changed, etc. These details may<br/>
		/// change between calls. Accordingly, the size of the buffer might change<br/>
		/// between calls as well.<br/>
		/// This callback can run at any time, and from any thread; if you need to<br/>
		/// serialize access to your app's data, you should provide and use a mutex or<br/>
		/// other synchronization device.<br/>
		/// All of this to say: there are specific needs this callback can fulfill, but<br/>
		/// it is not the simplest interface. Apps should generally provide audio in<br/>
		/// their preferred format through an SDL_AudioStream and let SDL handle the<br/>
		/// difference.<br/>
		/// This function is extremely time-sensitive; the callback should do the least<br/>
		/// amount of work possible and return as quickly as it can. The longer the<br/>
		/// callback runs, the higher the risk of audio dropouts or other problems.<br/>
		/// This function will block until the audio device is in between iterations,<br/>
		/// so any existing callback that might be running will finish before this<br/>
		/// function sets the new callback and returns.<br/>
		/// Setting a NULL callback function disables any previously-set callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAudioPostmixCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAudioPostmixCallback([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_AudioPostmixCallback")] delegate*<void*, SDLAudioSpec*, float*, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetAudioPostmixCallbackNative(devid, callback, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a callback that fires when data is about to be fed to an audio device.<br/>
		/// This is useful for accessing the final mix, perhaps for writing a<br/>
		/// visualizer or applying a final effect to the audio data before playback.<br/>
		/// The buffer is the final mix of all bound audio streams on an opened device;<br/>
		/// this callback will fire regularly for any device that is both opened and<br/>
		/// unpaused. If there is no new data to mix, either because no streams are<br/>
		/// bound to the device or all the streams are empty, this callback will still<br/>
		/// fire with the entire buffer set to silence.<br/>
		/// This callback is allowed to make changes to the data; the contents of the<br/>
		/// buffer after this call is what is ultimately passed along to the hardware.<br/>
		/// The callback is always provided the data in float format (values from -1.0f<br/>
		/// to 1.0f), but the number of channels or sample rate may be different than<br/>
		/// the format the app requested when opening the device; SDL might have had to<br/>
		/// manage a conversion behind the scenes, or the playback might have jumped to<br/>
		/// new physical hardware when a system default changed, etc. These details may<br/>
		/// change between calls. Accordingly, the size of the buffer might change<br/>
		/// between calls as well.<br/>
		/// This callback can run at any time, and from any thread; if you need to<br/>
		/// serialize access to your app's data, you should provide and use a mutex or<br/>
		/// other synchronization device.<br/>
		/// All of this to say: there are specific needs this callback can fulfill, but<br/>
		/// it is not the simplest interface. Apps should generally provide audio in<br/>
		/// their preferred format through an SDL_AudioStream and let SDL handle the<br/>
		/// difference.<br/>
		/// This function is extremely time-sensitive; the callback should do the least<br/>
		/// amount of work possible and return as quickly as it can. The longer the<br/>
		/// callback runs, the higher the risk of audio dropouts or other problems.<br/>
		/// This function will block until the audio device is in between iterations,<br/>
		/// so any existing callback that might be running will finish before this<br/>
		/// function sets the new callback and returns.<br/>
		/// Setting a NULL callback function disables any previously-set callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAudioPostmixCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAudioPostmixCallback([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_AudioPostmixCallback")] SDLAudioPostmixCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetAudioPostmixCallbackNative(devid, (delegate*<void*, SDLAudioSpec*, float*, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a callback that fires when data is about to be fed to an audio device.<br/>
		/// This is useful for accessing the final mix, perhaps for writing a<br/>
		/// visualizer or applying a final effect to the audio data before playback.<br/>
		/// The buffer is the final mix of all bound audio streams on an opened device;<br/>
		/// this callback will fire regularly for any device that is both opened and<br/>
		/// unpaused. If there is no new data to mix, either because no streams are<br/>
		/// bound to the device or all the streams are empty, this callback will still<br/>
		/// fire with the entire buffer set to silence.<br/>
		/// This callback is allowed to make changes to the data; the contents of the<br/>
		/// buffer after this call is what is ultimately passed along to the hardware.<br/>
		/// The callback is always provided the data in float format (values from -1.0f<br/>
		/// to 1.0f), but the number of channels or sample rate may be different than<br/>
		/// the format the app requested when opening the device; SDL might have had to<br/>
		/// manage a conversion behind the scenes, or the playback might have jumped to<br/>
		/// new physical hardware when a system default changed, etc. These details may<br/>
		/// change between calls. Accordingly, the size of the buffer might change<br/>
		/// between calls as well.<br/>
		/// This callback can run at any time, and from any thread; if you need to<br/>
		/// serialize access to your app's data, you should provide and use a mutex or<br/>
		/// other synchronization device.<br/>
		/// All of this to say: there are specific needs this callback can fulfill, but<br/>
		/// it is not the simplest interface. Apps should generally provide audio in<br/>
		/// their preferred format through an SDL_AudioStream and let SDL handle the<br/>
		/// difference.<br/>
		/// This function is extremely time-sensitive; the callback should do the least<br/>
		/// amount of work possible and return as quickly as it can. The longer the<br/>
		/// callback runs, the higher the risk of audio dropouts or other problems.<br/>
		/// This function will block until the audio device is in between iterations,<br/>
		/// so any existing callback that might be running will finish before this<br/>
		/// function sets the new callback and returns.<br/>
		/// Setting a NULL callback function disables any previously-set callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAudioPostmixCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAudioPostmixCallback([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_AudioPostmixCallback")] delegate*<void*, SDLAudioSpec*, float*, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetAudioPostmixCallbackNative(devid, callback, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a callback that fires when data is about to be fed to an audio device.<br/>
		/// This is useful for accessing the final mix, perhaps for writing a<br/>
		/// visualizer or applying a final effect to the audio data before playback.<br/>
		/// The buffer is the final mix of all bound audio streams on an opened device;<br/>
		/// this callback will fire regularly for any device that is both opened and<br/>
		/// unpaused. If there is no new data to mix, either because no streams are<br/>
		/// bound to the device or all the streams are empty, this callback will still<br/>
		/// fire with the entire buffer set to silence.<br/>
		/// This callback is allowed to make changes to the data; the contents of the<br/>
		/// buffer after this call is what is ultimately passed along to the hardware.<br/>
		/// The callback is always provided the data in float format (values from -1.0f<br/>
		/// to 1.0f), but the number of channels or sample rate may be different than<br/>
		/// the format the app requested when opening the device; SDL might have had to<br/>
		/// manage a conversion behind the scenes, or the playback might have jumped to<br/>
		/// new physical hardware when a system default changed, etc. These details may<br/>
		/// change between calls. Accordingly, the size of the buffer might change<br/>
		/// between calls as well.<br/>
		/// This callback can run at any time, and from any thread; if you need to<br/>
		/// serialize access to your app's data, you should provide and use a mutex or<br/>
		/// other synchronization device.<br/>
		/// All of this to say: there are specific needs this callback can fulfill, but<br/>
		/// it is not the simplest interface. Apps should generally provide audio in<br/>
		/// their preferred format through an SDL_AudioStream and let SDL handle the<br/>
		/// difference.<br/>
		/// This function is extremely time-sensitive; the callback should do the least<br/>
		/// amount of work possible and return as quickly as it can. The longer the<br/>
		/// callback runs, the higher the risk of audio dropouts or other problems.<br/>
		/// This function will block until the audio device is in between iterations,<br/>
		/// so any existing callback that might be running will finish before this<br/>
		/// function sets the new callback and returns.<br/>
		/// Setting a NULL callback function disables any previously-set callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAudioPostmixCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAudioPostmixCallback([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_AudioPostmixCallback")] SDLAudioPostmixCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetAudioPostmixCallbackNative(devid, (delegate*<void*, SDLAudioSpec*, float*, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LoadWAVIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, SDLAudioSpec*, byte**, uint*, byte>)funcTable[363])(src, closeio, spec, audioBuf, audioLen);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, nint, nint, nint, byte>)funcTable[363])((nint)src, closeio, (nint)spec, (nint)audioBuf, (nint)audioLen);
			#endif
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, audioBuf, audioLen);
			return ret != 0;
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, audioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, audioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, audioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (uint* paudioLen = &audioLen)
			{
				byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the return value is zero and the pointer to the<br/>
		/// audio data allocated by the function is written to `audio_buf` and its<br/>
		/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
		/// `channels`, and `format` are set to the values of the audio data in the<br/>
		/// buffer.<br/>
		/// It's necessary to use SDL_free() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
		/// less messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							byte ret = LoadWAVIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LoadWAVNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLAudioSpec*, byte**, uint*, byte>)funcTable[364])(path, spec, audioBuf, audioLen);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[364])((nint)path, (nint)spec, (nint)audioBuf, (nint)audioLen);
			#endif
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			byte ret = LoadWAVNative(path, (SDLAudioSpec*)spec, audioBuf, audioLen);
			return ret != 0;
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, audioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = path)
			{
				byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, audioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)spec, audioBuf, audioLen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				byte ret = LoadWAVNative(path, (SDLAudioSpec*)pspec, audioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, audioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, audioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pspec = &spec)
			{
				byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)pspec, audioBuf, audioLen);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				byte ret = LoadWAVNative(path, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** paudioBuf = &audioBuf)
			{
				byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)spec, (byte**)paudioBuf, audioLen);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative(path, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (uint* paudioLen = &audioLen)
			{
				byte ret = LoadWAVNative(path, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* paudioLen = &audioLen)
			{
				byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)spec, audioBuf, (uint*)paudioLen);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(path, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(path, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpecPtr spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)spec, (byte**)paudioBuf, (uint*)paudioLen);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative(path, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadWAV([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MixAudioNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "float")] float volume)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLAudioFormat, uint, float, byte>)funcTable[365])(dst, src, format, len, volume);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLAudioFormat, uint, float, byte>)funcTable[365])((nint)dst, (nint)src, format, len, volume);
			#endif
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "float")] float volume)
		{
			byte ret = MixAudioNative(dst, src, format, len, volume);
			return ret != 0;
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "float")] float volume)
		{
			fixed (byte* pdst = &dst)
			{
				byte ret = MixAudioNative((byte*)pdst, src, format, len, volume);
				return ret != 0;
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "float")] float volume)
		{
			fixed (byte* psrc = &src)
			{
				byte ret = MixAudioNative(dst, (byte*)psrc, format, len, volume);
				return ret != 0;
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "float")] float volume)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					byte ret = MixAudioNative((byte*)pdst, (byte*)psrc, format, len, volume);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ConvertAudioSamplesNative([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpec* srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpec* dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioSpec*, byte*, int, SDLAudioSpec*, byte**, int*, byte>)funcTable[366])(srcSpec, srcData, srcLen, dstSpec, dstData, dstLen);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, nint, nint, byte>)funcTable[366])((nint)srcSpec, (nint)srcData, srcLen, (nint)dstSpec, (nint)dstData, (nint)dstLen);
			#endif
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, dstLen);
			return ret != 0;
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (byte** pdstData = &dstData)
			{
				byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (byte** pdstData = &dstData)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (byte** pdstData = &dstData)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						fixed (byte** pdstData = &dstData)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (int* pdstLen = &dstLen)
			{
				byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, (int*)pdstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, dstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] byte** dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (byte** pdstData = &dstData)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (byte** pdstData = &dstData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (byte** pdstData = &dstData)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)dstSpec, (byte**)pdstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpecPtr srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudioSamples")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertAudioSamples([NativeName(NativeNameType.Param, "src_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec srcSpec, [NativeName(NativeNameType.Param, "src_data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte srcData, [NativeName(NativeNameType.Param, "src_len")] [NativeName(NativeNameType.Type, "int")] int srcLen, [NativeName(NativeNameType.Param, "dst_spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] in SDLAudioSpec dstSpec, [NativeName(NativeNameType.Param, "dst_data")] [NativeName(NativeNameType.Type, "Uint8 * *")] ref byte* dstData, [NativeName(NativeNameType.Param, "dst_len")] [NativeName(NativeNameType.Type, "int *")] ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						fixed (byte** pdstData = &dstData)
						{
							fixed (int* pdstLen = &dstLen)
							{
								byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the human readable name of an audio format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioFormatName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioFormatNameNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioFormat, byte*>)funcTable[367])(format);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLAudioFormat, nint>)funcTable[367])(format);
			#endif
		}

		/// <summary>
		/// Get the human readable name of an audio format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioFormatName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetAudioFormatName([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format)
		{
			byte* ret = GetAudioFormatNameNative(format);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of an audio format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioFormatName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetAudioFormatNameS([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioFormatNameNative(format));
			return ret;
		}

		/// <summary>
		/// Get the appropriate memset value for silencing an audio format.<br/>
		/// The value returned by this function can be used as the second argument to<br/>
		/// memset (or SDL_memset) to set an audio buffer in a specific format to<br/>
		/// silence.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSilenceValueForFormat")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSilenceValueForFormatNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioFormat, int>)funcTable[368])(format);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLAudioFormat, int>)funcTable[368])(format);
			#endif
		}

		/// <summary>
		/// Get the appropriate memset value for silencing an audio format.<br/>
		/// The value returned by this function can be used as the second argument to<br/>
		/// memset (or SDL_memset) to set an audio buffer in a specific format to<br/>
		/// silence.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSilenceValueForFormat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSilenceValueForFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] SDLAudioFormat format)
		{
			int ret = GetSilenceValueForFormatNative(format);
			return ret;
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer.<br/>
		/// All renderers support the four blend modes listed in the SDL_BlendMode<br/>
		/// enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ComposeCustomBlendModeNative([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, uint>)funcTable[369])(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, uint>)funcTable[369])(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			#endif
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer.<br/>
		/// All renderers support the four blend modes listed in the SDL_BlendMode<br/>
		/// enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		public static uint ComposeCustomBlendMode([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation)
		{
			uint ret = ComposeCustomBlendModeNative(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPixelFormatNameNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat, byte*>)funcTable[370])(format);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLPixelFormat, nint>)funcTable[370])(format);
			#endif
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetPixelFormatName([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			byte* ret = GetPixelFormatNameNative(format);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetPixelFormatNameS([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			string ret = Utils.DecodeStringUTF8(GetPixelFormatNameNative(format));
			return ret;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetMasksForPixelFormatNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat, int*, uint*, uint*, uint*, uint*, byte>)funcTable[371])(format, bpp, rmask, gmask, bmask, amask);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLPixelFormat, nint, nint, nint, nint, nint, byte>)funcTable[371])(format, (nint)bpp, (nint)rmask, (nint)gmask, (nint)bmask, (nint)amask);
			#endif
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, bmask, amask);
			return ret != 0;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, bmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, bmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, bmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, (uint*)pbmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* pamask = &amask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, bmask, (uint*)pamask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, bmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMasksForPixelFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetMasksForPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int *")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							fixed (uint* pamask = &amask)
							{
								byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatForMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_PixelFormat")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPixelFormat GetPixelFormatForMasksNative([NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int")] int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, SDLPixelFormat>)funcTable[372])(bpp, rmask, gmask, bmask, amask);
			#else
			return (SDLPixelFormat)((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, SDLPixelFormat>)funcTable[372])(bpp, rmask, gmask, bmask, amask);
			#endif
		}
	}
}
