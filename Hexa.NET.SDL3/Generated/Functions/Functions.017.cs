// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = GetNumHapticAxesNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetNumHapticAxesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HapticEffectSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, int>)funcTable[805])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[805])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			int ret = HapticEffectSupportedNative(haptic, effect);
			return ret;
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				int ret = HapticEffectSupportedNative(haptic, (SDLHapticEffect*)peffect);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					int ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, int>)funcTable[806])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[806])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			int ret = CreateHapticEffectNative(haptic, effect);
			return ret;
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				int ret = CreateHapticEffectNative(haptic, (SDLHapticEffect*)peffect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, SDLHapticEffect*, int>)funcTable[807])(haptic, effect, data);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, int>)funcTable[807])((nint)haptic, effect, (nint)data);
			#endif
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			int ret = UpdateHapticEffectNative(haptic, effect, data);
			return ret;
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = UpdateHapticEffectNative((SDLHaptic*)phaptic, effect, data);
				return ret;
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect data)
		{
			fixed (SDLHapticEffect* pdata = &data)
			{
				int ret = UpdateHapticEffectNative(haptic, effect, (SDLHapticEffect*)pdata);
				return ret;
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* pdata = &data)
				{
					int ret = UpdateHapticEffectNative((SDLHaptic*)phaptic, effect, (SDLHapticEffect*)pdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RunHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, uint, int>)funcTable[808])(haptic, effect, iterations);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, uint, int>)funcTable[808])((nint)haptic, effect, iterations);
			#endif
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RunHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			int ret = RunHapticEffectNative(haptic, effect, iterations);
			return ret;
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RunHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = RunHapticEffectNative((SDLHaptic*)phaptic, effect, iterations);
				return ret;
			}
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StopHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, int>)funcTable[809])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[809])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			int ret = StopHapticEffectNative(haptic, effect);
			return ret;
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = StopHapticEffectNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHaptic*, int, void>)funcTable[810])(haptic, effect);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[810])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			DestroyHapticEffectNative(haptic, effect);
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				DestroyHapticEffectNative((SDLHaptic*)phaptic, effect);
			}
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetHapticEffectStatusNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, int>)funcTable[811])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[811])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetHapticEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			int ret = GetHapticEffectStatusNative(haptic, effect);
			return ret;
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetHapticEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetHapticEffectStatusNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetHapticGainNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, int>)funcTable[812])(haptic, gain);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[812])((nint)haptic, gain);
			#endif
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHapticGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			int ret = SetHapticGainNative(haptic, gain);
			return ret;
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHapticGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SetHapticGainNative((SDLHaptic*)phaptic, gain);
				return ret;
			}
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetHapticAutocenterNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, int>)funcTable[813])(haptic, autocenter);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[813])((nint)haptic, autocenter);
			#endif
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHapticAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			int ret = SetHapticAutocenterNative(haptic, autocenter);
			return ret;
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHapticAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SetHapticAutocenterNative((SDLHaptic*)phaptic, autocenter);
				return ret;
			}
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PauseHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[814])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[814])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PauseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = PauseHapticNative(haptic);
			return ret;
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PauseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = PauseHapticNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ResumeHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[815])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[815])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ResumeHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = ResumeHapticNative(haptic);
			return ret;
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ResumeHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = ResumeHapticNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StopHapticEffectsNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[816])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[816])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = StopHapticEffectsNative(haptic);
			return ret;
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = StopHapticEffectsNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HapticRumbleSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[817])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[817])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = HapticRumbleSupportedNative(haptic);
			return ret;
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = HapticRumbleSupportedNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InitHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[818])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[818])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int InitHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = InitHapticRumbleNative(haptic);
			return ret;
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int InitHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = InitHapticRumbleNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PlayHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, float, uint, int>)funcTable[819])(haptic, strength, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, uint, int>)funcTable[819])((nint)haptic, strength, length);
			#endif
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PlayHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			int ret = PlayHapticRumbleNative(haptic, strength, length);
			return ret;
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PlayHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = PlayHapticRumbleNative((SDLHaptic*)phaptic, strength, length);
				return ret;
			}
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StopHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[820])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[820])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = StopHapticRumbleNative(haptic);
			return ret;
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = StopHapticRumbleNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Initialize the HIDAPI library.<br/>
		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
		/// be called at the beginning of execution however, if there is a chance of<br/>
		/// HIDAPI handles being opened by different threads simultaneously.<br/>
		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidInitNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[821])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[821])();
			#endif
		}

		/// <summary>
		/// Initialize the HIDAPI library.<br/>
		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
		/// be called at the beginning of execution however, if there is a chance of<br/>
		/// HIDAPI handles being opened by different threads simultaneously.<br/>
		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidInit()
		{
			int ret = HidInitNative();
			return ret;
		}

		/// <summary>
		/// Finalize the HIDAPI library.<br/>
		/// This function frees all of the static data associated with HIDAPI. It<br/>
		/// should be called at the end of execution to avoid memory leaks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidExitNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[822])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[822])();
			#endif
		}

		/// <summary>
		/// Finalize the HIDAPI library.<br/>
		/// This function frees all of the static data associated with HIDAPI. It<br/>
		/// should be called at the end of execution to avoid memory leaks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidExit()
		{
			int ret = HidExitNative();
			return ret;
		}

		/// <summary>
		/// Check to see if devices may have been added or removed.<br/>
		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
		/// to see if there have been any system device changes since the last call to<br/>
		/// this function. A change in the counter returned doesn't necessarily mean<br/>
		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
		/// updated device list.<br/>
		/// Calling this function for the first time may cause a thread or other system<br/>
		/// resource to be allocated to track device change notifications.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint HidDeviceChangeCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[823])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[823])();
			#endif
		}

		/// <summary>
		/// Check to see if devices may have been added or removed.<br/>
		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
		/// to see if there have been any system device changes since the last call to<br/>
		/// this function. A change in the counter returned doesn't necessarily mean<br/>
		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
		/// updated device list.<br/>
		/// Calling this function for the first time may cause a thread or other system<br/>
		/// resource to be allocated to track device change notifications.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint HidDeviceChangeCount()
		{
			uint ret = HidDeviceChangeCountNative();
			return ret;
		}

		/// <summary>
		/// Enumerate the HID Devices.<br/>
		/// This function returns a linked list of all the HID devices attached to the<br/>
		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
		/// devices will be returned.<br/>
		/// By default SDL will only enumerate controllers, to reduce risk of hanging<br/>
		/// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS<br/>
		/// can be set to "0" to enumerate all HID devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDeviceInfo* HidEnumerateNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, SDLHidDeviceInfo*>)funcTable[824])(vendorId, productId);
			#else
			return (SDLHidDeviceInfo*)((delegate* unmanaged[Cdecl]<ushort, ushort, nint>)funcTable[824])(vendorId, productId);
			#endif
		}

		/// <summary>
		/// Enumerate the HID Devices.<br/>
		/// This function returns a linked list of all the HID devices attached to the<br/>
		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
		/// devices will be returned.<br/>
		/// By default SDL will only enumerate controllers, to reduce risk of hanging<br/>
		/// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS<br/>
		/// can be set to "0" to enumerate all HID devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		public static SDLHidDeviceInfo* HidEnumerate([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId)
		{
			SDLHidDeviceInfo* ret = HidEnumerateNative(vendorId, productId);
			return ret;
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HidFreeEnumerationNative([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] SDLHidDeviceInfo* devs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHidDeviceInfo*, void>)funcTable[825])(devs);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[825])((nint)devs);
			#endif
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] SDLHidDeviceInfo* devs)
		{
			HidFreeEnumerationNative(devs);
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] ref SDLHidDeviceInfo devs)
		{
			fixed (SDLHidDeviceInfo* pdevs = &devs)
			{
				HidFreeEnumerationNative((SDLHidDeviceInfo*)pdevs);
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDevice* HidOpenNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] char* serialNumber)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, char*, SDLHidDevice*>)funcTable[826])(vendorId, productId, serialNumber);
			#else
			return (SDLHidDevice*)((delegate* unmanaged[Cdecl]<ushort, ushort, nint, nint>)funcTable[826])(vendorId, productId, (nint)serialNumber);
			#endif
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] char* serialNumber)
		{
			SDLHidDevice* ret = HidOpenNative(vendorId, productId, serialNumber);
			return ret;
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] ref char serialNumber)
		{
			fixed (char* pserialNumber = &serialNumber)
			{
				SDLHidDevice* ret = HidOpenNative(vendorId, productId, (char*)pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> serialNumber)
		{
			fixed (char* pserialNumber = serialNumber)
			{
				SDLHidDevice* ret = HidOpenNative(vendorId, productId, (char*)pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] string serialNumber)
		{
			fixed (char* pserialNumber = serialNumber)
			{
				SDLHidDevice* ret = HidOpenNative(vendorId, productId, pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDevice* HidOpenPathNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLHidDevice*>)funcTable[827])(path);
			#else
			return (SDLHidDevice*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[827])((nint)path);
			#endif
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			SDLHidDevice* ret = HidOpenPathNative(path);
			return ret;
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				SDLHidDevice* ret = HidOpenPathNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				SDLHidDevice* ret = HidOpenPathNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLHidDevice* ret = HidOpenPathNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidWriteNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[828])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[828])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidWriteNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidWriteNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidWriteNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidWriteNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidReadTimeoutNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int, int>)funcTable[829])(dev, data, length, milliseconds);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int, int>)funcTable[829])((nint)dev, (nint)data, length, milliseconds);
			#endif
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			int ret = HidReadTimeoutNative(dev, data, length, milliseconds);
			return ret;
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidReadTimeoutNative((SDLHidDevice*)pdev, data, length, milliseconds);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidReadTimeoutNative(dev, (byte*)pdata, length, milliseconds);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidReadTimeoutNative((SDLHidDevice*)pdev, (byte*)pdata, length, milliseconds);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidReadNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[830])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[830])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidReadNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidReadNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidReadNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidReadNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidSetNonblockingNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int, int>)funcTable[831])(dev, nonblock);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[831])((nint)dev, nonblock);
			#endif
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			int ret = HidSetNonblockingNative(dev, nonblock);
			return ret;
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidSetNonblockingNative((SDLHidDevice*)pdev, nonblock);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidSendFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[832])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[832])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidSendFeatureReportNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidSendFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidSendFeatureReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidSendFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[833])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[833])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidGetFeatureReportNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidGetFeatureReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidGetFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetInputReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[834])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[834])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidGetInputReportNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetInputReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidGetInputReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidGetInputReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidCloseNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int>)funcTable[835])(dev);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[835])((nint)dev);
			#endif
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			int ret = HidCloseNative(dev);
			return ret;
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidCloseNative((SDLHidDevice*)pdev);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetManufacturerStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[836])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[836])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetManufacturerStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetManufacturerStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetManufacturerStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetProductStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[837])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[837])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetProductStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetProductStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetProductStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetProductStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetProductStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetProductStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetSerialNumberStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[838])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[838])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetSerialNumberStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetSerialNumberStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetSerialNumberStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetSerialNumberStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetSerialNumberStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetSerialNumberStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetIndexedStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int, char*, nuint, int>)funcTable[839])(dev, stringIndex, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nuint, int>)funcTable[839])((nint)dev, stringIndex, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetIndexedStringNative(dev, stringIndex, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetIndexedStringNative(dev, stringIndex, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetIndexedStringNative(dev, stringIndex, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get the device info from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_device_info")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDeviceInfo* HidGetDeviceInfoNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, SDLHidDeviceInfo*>)funcTable[840])(dev);
			#else
			return (SDLHidDeviceInfo*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[840])((nint)dev);
			#endif
		}

		/// <summary>
		/// Get the device info from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_device_info")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		public static SDLHidDeviceInfo* HidGetDeviceInfo([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			SDLHidDeviceInfo* ret = HidGetDeviceInfoNative(dev);
			return ret;
		}

		/// <summary>
		/// Get the device info from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_device_info")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		public static SDLHidDeviceInfo* HidGetDeviceInfo([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				SDLHidDeviceInfo* ret = HidGetDeviceInfoNative((SDLHidDevice*)pdev);
				return ret;
			}
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetReportDescriptorNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[841])(dev, buf, bufSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[841])((nint)dev, (nint)buf, bufSize);
			#endif
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			int ret = HidGetReportDescriptorNative(dev, buf, bufSize);
			return ret;
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetReportDescriptorNative((SDLHidDevice*)pdev, buf, bufSize);
				return ret;
			}
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = HidGetReportDescriptorNative(dev, (byte*)pbuf, bufSize);
				return ret;
			}
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pbuf = &buf)
				{
					int ret = HidGetReportDescriptorNative((SDLHidDevice*)pdev, (byte*)pbuf, bufSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_ble_scan")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HidBleScanNative([NativeName(NativeNameType.Param, "active")] [NativeName(NativeNameType.Type, "SDL_bool")] int active)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[842])(active);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[842])(active);
			#endif
		}

		/// <summary>
		/// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_ble_scan")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidBleScan([NativeName(NativeNameType.Param, "active")] [NativeName(NativeNameType.Type, "SDL_bool")] int active)
		{
			HidBleScanNative(active);
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetHintWithPriorityNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLHintPriority, int>)funcTable[843])(name, value, priority);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, SDLHintPriority, int>)funcTable[843])((nint)name, (nint)value, priority);
			#endif
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			int ret = SetHintWithPriorityNative(name, value, priority);
			return ret;
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetHintWithPriorityNative((byte*)pname, value, priority);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = name)
			{
				int ret = SetHintWithPriorityNative((byte*)pname, value, priority);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetHintWithPriorityNative(pStr0, value, priority);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pvalue = &value)
			{
				int ret = SetHintWithPriorityNative(name, (byte*)pvalue, priority);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pvalue = value)
			{
				int ret = SetHintWithPriorityNative(name, (byte*)pvalue, priority);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetHintWithPriorityNative(name, pStr0, priority);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					int ret = SetHintWithPriorityNative((byte*)pname, (byte*)pvalue, priority);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					int ret = SetHintWithPriorityNative((byte*)pname, (byte*)pvalue, priority);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SetHintWithPriorityNative(pStr0, pStr1, priority);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[844])(name, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[844])((nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			int ret = SetHintNative(name, value);
			return ret;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetHintNative((byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = name)
			{
				int ret = SetHintNative((byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetHintNative(pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				int ret = SetHintNative(name, (byte*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pvalue = value)
			{
				int ret = SetHintNative(name, (byte*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetHintNative(name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					int ret = SetHintNative((byte*)pname, (byte*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					int ret = SetHintNative((byte*)pname, (byte*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SetHintNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ResetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[845])(name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[845])((nint)name);
			#endif
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			int ret = ResetHintNative(name);
			return ret;
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = ResetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = ResetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ResetHintNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset all hints to the default values.<br/>
		/// This will reset all hints to the value of the associated environment<br/>
		/// variable, or NULL if the environment isn't set. Callbacks will be called<br/>
		/// normally with this change.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetHintsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[846])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[846])();
			#endif
		}

		/// <summary>
		/// Reset all hints to the default values.<br/>
		/// This will reset all hints to the value of the associated environment<br/>
		/// variable, or NULL if the environment isn't set. Callbacks will be called<br/>
		/// normally with this change.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetHints()
		{
			ResetHintsNative();
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[847])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[847])((nint)name);
			#endif
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte* ret = GetHintNative(name);
			return ret;
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(GetHintNative(name));
			return ret;
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetHintNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetHintNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetHintNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetHintNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetHintBooleanNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int>)funcTable[848])(name, defaultValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[848])((nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			int ret = GetHintBooleanNative(name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			fixed (byte* pname = &name)
			{
				int ret = GetHintBooleanNative((byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			fixed (byte* pname = name)
			{
				int ret = GetHintBooleanNative((byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetHintBooleanNative(pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddHintCallbackNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, byte*, byte*, byte*, void>, void*, int>)funcTable[849])(name, (delegate*<void*, byte*, byte*, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[849])((nint)name, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			int ret = AddHintCallbackNative(name, callback, userdata);
			return ret;
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				int ret = AddHintCallbackNative((byte*)pname, callback, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				int ret = AddHintCallbackNative((byte*)pname, callback, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AddHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DelHintCallbackNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, byte*, byte*, byte*, void>, void*, void>)funcTable[850])(name, (delegate*<void*, byte*, byte*, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[850])((nint)name, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DelHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			DelHintCallbackNative(name, callback, userdata);
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DelHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				DelHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DelHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				DelHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DelHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DelHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Initialize the SDL library.<br/>
		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
		/// two may be used interchangeably. Though for readability of your code<br/>
		/// SDL_InitSubSystem() might be preferred.<br/>
		/// The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)<br/>
		/// subsystems are initialized by default. Message boxes<br/>
		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
		/// use them in your application.<br/>
		/// Logging (such as SDL_Log) works without initialization, too.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_INIT_TIMER`: timer subsystem<br/>
		/// - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
		/// events subsystem<br/>
		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
		/// - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the<br/>
		/// joystick subsystem<br/>
		/// - `SDL_INIT_EVENTS`: events subsystem<br/>
		/// - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
		/// this call will increase the ref-count and return.<br/>
		/// Consider reporting some basic metadata about your application before<br/>
		/// calling SDL_Init, using either SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitFlags, int>)funcTable[851])(flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLInitFlags, int>)funcTable[851])(flags);
			#endif
		}

		/// <summary>
		/// Initialize the SDL library.<br/>
		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
		/// two may be used interchangeably. Though for readability of your code<br/>
		/// SDL_InitSubSystem() might be preferred.<br/>
		/// The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)<br/>
		/// subsystems are initialized by default. Message boxes<br/>
		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
		/// use them in your application.<br/>
		/// Logging (such as SDL_Log) works without initialization, too.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_INIT_TIMER`: timer subsystem<br/>
		/// - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
		/// events subsystem<br/>
		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
		/// - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the<br/>
		/// joystick subsystem<br/>
		/// - `SDL_INIT_EVENTS`: events subsystem<br/>
		/// - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
		/// this call will increase the ref-count and return.<br/>
		/// Consider reporting some basic metadata about your application before<br/>
		/// calling SDL_Init, using either SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Init([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			int ret = InitNative(flags);
			return ret;
		}

		/// <summary>
		/// Compatibility function to initialize the SDL library.<br/>
		/// This function and SDL_Init() are interchangeable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitSubSystem")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InitSubSystemNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitFlags, int>)funcTable[852])(flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLInitFlags, int>)funcTable[852])(flags);
			#endif
		}

		/// <summary>
		/// Compatibility function to initialize the SDL library.<br/>
		/// This function and SDL_Init() are interchangeable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitSubSystem")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int InitSubSystem([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			int ret = InitSubSystemNative(flags);
			return ret;
		}

		/// <summary>
		/// Shut down specific SDL subsystems.<br/>
		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
		/// with SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QuitSubSystem")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuitSubSystemNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLInitFlags, void>)funcTable[853])(flags);
			#else
			((delegate* unmanaged[Cdecl]<SDLInitFlags, void>)funcTable[853])(flags);
			#endif
		}

		/// <summary>
		/// Shut down specific SDL subsystems.<br/>
		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
		/// with SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QuitSubSystem")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuitSubSystem([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			QuitSubSystemNative(flags);
		}

		/// <summary>
		/// Get a mask of the specified subsystems which are currently initialized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WasInit")]
		[return: NativeName(NativeNameType.Type, "SDL_InitFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLInitFlags WasInitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitFlags, SDLInitFlags>)funcTable[854])(flags);
			#else
			return (SDLInitFlags)((delegate* unmanaged[Cdecl]<SDLInitFlags, SDLInitFlags>)funcTable[854])(flags);
			#endif
		}

		/// <summary>
		/// Get a mask of the specified subsystems which are currently initialized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WasInit")]
		[return: NativeName(NativeNameType.Type, "SDL_InitFlags")]
		public static SDLInitFlags WasInit([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			SDLInitFlags ret = WasInitNative(flags);
			return ret;
		}

		/// <summary>
		/// Clean up all initialized subsystems.<br/>
		/// You should call this function even if you have already shutdown each<br/>
		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
		/// function even in the case of errors in initialization.<br/>
		/// You can use this function with atexit() to ensure that it is run when your<br/>
		/// application is shutdown, but it is not wise to do this from a library or<br/>
		/// other dynamically loaded code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[855])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[855])();
			#endif
		}

		/// <summary>
		/// Clean up all initialized subsystems.<br/>
		/// You should call this function even if you have already shutdown each<br/>
		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
		/// function even in the case of errors in initialization.<br/>
		/// You can use this function with atexit() to ensure that it is run when your<br/>
		/// application is shutdown, but it is not wise to do this from a library or<br/>
		/// other dynamically loaded code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Quit()
		{
			QuitNative();
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetAppMetadataNative([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, int>)funcTable[856])(appname, appversion, appidentifier);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[856])((nint)appname, (nint)appversion, (nint)appidentifier);
			#endif
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			int ret = SetAppMetadataNative(appname, appversion, appidentifier);
			return ret;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ref byte appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = &appname)
			{
				int ret = SetAppMetadataNative((byte*)pappname, appversion, appidentifier);
				return ret;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = appname)
			{
				int ret = SetAppMetadataNative((byte*)pappname, appversion, appidentifier);
				return ret;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] string appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetAppMetadataNative(pStr0, appversion, appidentifier);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ref byte appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappversion = &appversion)
			{
				int ret = SetAppMetadataNative(appname, (byte*)pappversion, appidentifier);
				return ret;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappversion = appversion)
			{
				int ret = SetAppMetadataNative(appname, (byte*)pappversion, appidentifier);
				return ret;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] string appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appversion != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appversion);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appversion, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetAppMetadataNative(appname, pStr0, appidentifier);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ref byte appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ref byte appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = &appname)
			{
				fixed (byte* pappversion = &appversion)
				{
					int ret = SetAppMetadataNative((byte*)pappname, (byte*)pappversion, appidentifier);
					return ret;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = appname)
			{
				fixed (byte* pappversion = appversion)
				{
					int ret = SetAppMetadataNative((byte*)pappname, (byte*)pappversion, appidentifier);
					return ret;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] string appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] string appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (appversion != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(appversion);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(appversion, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SetAppMetadataNative(pStr0, pStr1, appidentifier);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
