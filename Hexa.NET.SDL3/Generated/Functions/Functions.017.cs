// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the safe area for this window.<br/>
		/// Some devices have portions of the screen which are partially obscured or<br/>
		/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
		/// notches, TV overscan, etc. This function provides the area of the window<br/>
		/// which is safe to have interactable content. You should continue rendering<br/>
		/// into the rest of the window, but it should not contain visually important<br/>
		/// or interactable content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSafeArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSafeArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = GetWindowSafeAreaNative((SDLWindow*)window, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the safe area for this window.<br/>
		/// Some devices have portions of the screen which are partially obscured or<br/>
		/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
		/// notches, TV overscan, etc. This function provides the area of the window<br/>
		/// which is safe to have interactable content. You should continue rendering<br/>
		/// into the rest of the window, but it should not contain visually important<br/>
		/// or interactable content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSafeArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSafeArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = GetWindowSafeAreaNative((SDLWindow*)pwindow, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Request that the aspect ratio of a window's client area be set.<br/>
		/// The aspect ratio is the ratio of width divided by height, e.g. 2560x1600<br/>
		/// would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are<br/>
		/// narrower.<br/>
		/// If, at the time of this request, the window in a fixed-size state, such as<br/>
		/// maximized or fullscreen, the request will be deferred until the window<br/>
		/// exits this state and becomes resizable again.<br/>
		/// On some windowing systems, this request is asynchronous and the new window<br/>
		/// aspect ratio may not have have been applied immediately upon the return of<br/>
		/// this function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be<br/>
		/// emitted with the new window dimensions. Note that the new dimensions may<br/>
		/// not match the exact aspect ratio requested, as some windowing systems can<br/>
		/// restrict the window size in certain scenarios (e.g. constraining the size<br/>
		/// of the content area to remain within the usable desktop bounds).<br/>
		/// Additionally, as this is just a request, it can be denied by the windowing<br/>
		/// system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowAspectRatioNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float")] float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float")] float maxAspect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, float, byte>)funcTable[544])(window, minAspect, maxAspect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, byte>)funcTable[544])((nint)window, minAspect, maxAspect);
			#endif
		}

		/// <summary>
		/// Request that the aspect ratio of a window's client area be set.<br/>
		/// The aspect ratio is the ratio of width divided by height, e.g. 2560x1600<br/>
		/// would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are<br/>
		/// narrower.<br/>
		/// If, at the time of this request, the window in a fixed-size state, such as<br/>
		/// maximized or fullscreen, the request will be deferred until the window<br/>
		/// exits this state and becomes resizable again.<br/>
		/// On some windowing systems, this request is asynchronous and the new window<br/>
		/// aspect ratio may not have have been applied immediately upon the return of<br/>
		/// this function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be<br/>
		/// emitted with the new window dimensions. Note that the new dimensions may<br/>
		/// not match the exact aspect ratio requested, as some windowing systems can<br/>
		/// restrict the window size in certain scenarios (e.g. constraining the size<br/>
		/// of the content area to remain within the usable desktop bounds).<br/>
		/// Additionally, as this is just a request, it can be denied by the windowing<br/>
		/// system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float")] float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float")] float maxAspect)
		{
			byte ret = SetWindowAspectRatioNative((SDLWindow*)window, minAspect, maxAspect);
			return ret != 0;
		}

		/// <summary>
		/// Request that the aspect ratio of a window's client area be set.<br/>
		/// The aspect ratio is the ratio of width divided by height, e.g. 2560x1600<br/>
		/// would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are<br/>
		/// narrower.<br/>
		/// If, at the time of this request, the window in a fixed-size state, such as<br/>
		/// maximized or fullscreen, the request will be deferred until the window<br/>
		/// exits this state and becomes resizable again.<br/>
		/// On some windowing systems, this request is asynchronous and the new window<br/>
		/// aspect ratio may not have have been applied immediately upon the return of<br/>
		/// this function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be<br/>
		/// emitted with the new window dimensions. Note that the new dimensions may<br/>
		/// not match the exact aspect ratio requested, as some windowing systems can<br/>
		/// restrict the window size in certain scenarios (e.g. constraining the size<br/>
		/// of the content area to remain within the usable desktop bounds).<br/>
		/// Additionally, as this is just a request, it can be denied by the windowing<br/>
		/// system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float")] float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float")] float maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowAspectRatioNative((SDLWindow*)pwindow, minAspect, maxAspect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowAspectRatioNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float*, float*, byte>)funcTable[545])(window, minAspect, maxAspect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[545])((nint)window, (nint)minAspect, (nint)maxAspect);
			#endif
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			byte ret = GetWindowAspectRatioNative((SDLWindow*)window, minAspect, maxAspect);
			return ret != 0;
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, minAspect, maxAspect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			fixed (float* pminAspect = &minAspect)
			{
				byte ret = GetWindowAspectRatioNative((SDLWindow*)window, (float*)pminAspect, maxAspect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pminAspect = &minAspect)
				{
					byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, (float*)pminAspect, maxAspect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (float* pmaxAspect = &maxAspect)
			{
				byte ret = GetWindowAspectRatioNative((SDLWindow*)window, minAspect, (float*)pmaxAspect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pmaxAspect = &maxAspect)
				{
					byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, minAspect, (float*)pmaxAspect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (float* pminAspect = &minAspect)
			{
				fixed (float* pmaxAspect = &maxAspect)
				{
					byte ret = GetWindowAspectRatioNative((SDLWindow*)window, (float*)pminAspect, (float*)pmaxAspect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the aspect ratio of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pminAspect = &minAspect)
				{
					fixed (float* pmaxAspect = &maxAspect)
					{
						byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, (float*)pminAspect, (float*)pmaxAspect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowBordersSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, int*, int*, byte>)funcTable[546])(window, top, left, bottom, right);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[546])((nint)window, (nint)top, (nint)left, (nint)bottom, (nint)right);
			#endif
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, bottom, right);
			return ret != 0;
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, bottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* pleft = &left)
			{
				byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, bottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, bottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* pbottom = &bottom)
			{
				byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, (int*)pbottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, right);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pright = &right)
			{
				byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, bottom, (int*)pright);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pbottom = &bottom)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, left, (int*)pbottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, left, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)window, top, (int*)pleft, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)window, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							fixed (int* pright = &right)
							{
								byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowSizeInPixelsNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[547])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[547])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			byte ret = GetWindowSizeInPixelsNative((SDLWindow*)window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowSizeInPixelsNative((SDLWindow*)window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowSizeInPixelsNative((SDLWindow*)window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowSizeInPixelsNative((SDLWindow*)window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMinimumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[548])(window, minW, minH);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[548])((nint)window, minW, minH);
			#endif
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			byte ret = SetWindowMinimumSizeNative((SDLWindow*)window, minW, minH);
			return ret != 0;
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMinimumSizeNative((SDLWindow*)pwindow, minW, minH);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMinimumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[549])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[549])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			byte ret = GetWindowMinimumSizeNative((SDLWindow*)window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowMinimumSizeNative((SDLWindow*)window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowMinimumSizeNative((SDLWindow*)window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMinimumSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMaximumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[550])(window, maxW, maxH);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[550])((nint)window, maxW, maxH);
			#endif
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			byte ret = SetWindowMaximumSizeNative((SDLWindow*)window, maxW, maxH);
			return ret != 0;
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMaximumSizeNative((SDLWindow*)pwindow, maxW, maxH);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMaximumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[551])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[551])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			byte ret = GetWindowMaximumSizeNative((SDLWindow*)window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowMaximumSizeNative((SDLWindow*)window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowMaximumSizeNative((SDLWindow*)window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMaximumSizeNative((SDLWindow*)window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowBorderedNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "bool")] byte bordered)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[552])(window, bordered);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[552])((nint)window, bordered);
			#endif
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowBordered([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "bool")] bool bordered)
		{
			byte ret = SetWindowBorderedNative((SDLWindow*)window, bordered ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowBordered([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "bool")] bool bordered)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowBorderedNative((SDLWindow*)pwindow, bordered ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowResizableNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "bool")] byte resizable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[553])(window, resizable);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[553])((nint)window, resizable);
			#endif
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowResizable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "bool")] bool resizable)
		{
			byte ret = SetWindowResizableNative((SDLWindow*)window, resizable ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowResizable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "bool")] bool resizable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowResizableNative((SDLWindow*)pwindow, resizable ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowAlwaysOnTopNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "bool")] byte onTop)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[554])(window, onTop);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[554])((nint)window, onTop);
			#endif
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowAlwaysOnTop([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "bool")] bool onTop)
		{
			byte ret = SetWindowAlwaysOnTopNative((SDLWindow*)window, onTop ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowAlwaysOnTop([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "bool")] bool onTop)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowAlwaysOnTopNative((SDLWindow*)pwindow, onTop ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window to fill the current document space (Emscripten only).<br/>
		/// This will add or remove the window's `SDL_WINDOW_FILL_DOCUMENT` flag.<br/>
		/// Currently this flag only applies to the Emscripten target.<br/>
		/// When enabled, the canvas element fills the entire document. Resize events<br/>
		/// will be generated as the browser window is resized, as that will adjust the<br/>
		/// canvas size as well. The canvas will cover anything else on the page,<br/>
		/// including any controls provided by Emscripten in its generated HTML file<br/>
		/// (in fact, any elements on the page that aren't the canvas will be moved<br/>
		/// into a hidden `div` element).<br/>
		/// Often times this is desirable for a browser-based game, but it means<br/>
		/// several things that we expect of an SDL window on other platforms might not<br/>
		/// work as expected, such as minimum window sizes and aspect ratios.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFillDocument")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowFillDocumentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "fill")] [NativeName(NativeNameType.Type, "bool")] byte fill)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[555])(window, fill);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[555])((nint)window, fill);
			#endif
		}

		/// <summary>
		/// Set the window to fill the current document space (Emscripten only).<br/>
		/// This will add or remove the window's `SDL_WINDOW_FILL_DOCUMENT` flag.<br/>
		/// Currently this flag only applies to the Emscripten target.<br/>
		/// When enabled, the canvas element fills the entire document. Resize events<br/>
		/// will be generated as the browser window is resized, as that will adjust the<br/>
		/// canvas size as well. The canvas will cover anything else on the page,<br/>
		/// including any controls provided by Emscripten in its generated HTML file<br/>
		/// (in fact, any elements on the page that aren't the canvas will be moved<br/>
		/// into a hidden `div` element).<br/>
		/// Often times this is desirable for a browser-based game, but it means<br/>
		/// several things that we expect of an SDL window on other platforms might not<br/>
		/// work as expected, such as minimum window sizes and aspect ratios.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFillDocument")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFillDocument([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "fill")] [NativeName(NativeNameType.Type, "bool")] bool fill)
		{
			byte ret = SetWindowFillDocumentNative((SDLWindow*)window, fill ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the window to fill the current document space (Emscripten only).<br/>
		/// This will add or remove the window's `SDL_WINDOW_FILL_DOCUMENT` flag.<br/>
		/// Currently this flag only applies to the Emscripten target.<br/>
		/// When enabled, the canvas element fills the entire document. Resize events<br/>
		/// will be generated as the browser window is resized, as that will adjust the<br/>
		/// canvas size as well. The canvas will cover anything else on the page,<br/>
		/// including any controls provided by Emscripten in its generated HTML file<br/>
		/// (in fact, any elements on the page that aren't the canvas will be moved<br/>
		/// into a hidden `div` element).<br/>
		/// Often times this is desirable for a browser-based game, but it means<br/>
		/// several things that we expect of an SDL window on other platforms might not<br/>
		/// work as expected, such as minimum window sizes and aspect ratios.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFillDocument")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFillDocument([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "fill")] [NativeName(NativeNameType.Type, "bool")] bool fill)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowFillDocumentNative((SDLWindow*)pwindow, fill ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[556])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[556])((nint)window);
			#endif
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = ShowWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ShowWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HideWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[557])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[557])((nint)window);
			#endif
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HideWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = HideWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HideWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = HideWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RaiseWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[558])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[558])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RaiseWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = RaiseWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RaiseWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = RaiseWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MaximizeWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[559])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[559])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MaximizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = MaximizeWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MaximizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = MaximizeWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MinimizeWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[560])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[560])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MinimizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = MinimizeWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MinimizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = MinimizeWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RestoreWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[561])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[561])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RestoreWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = RestoreWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RestoreWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = RestoreWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowFullscreenNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "fullscreen")] [NativeName(NativeNameType.Type, "bool")] byte fullscreen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[562])(window, fullscreen);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[562])((nint)window, fullscreen);
			#endif
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFullscreen([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "fullscreen")] [NativeName(NativeNameType.Type, "bool")] bool fullscreen)
		{
			byte ret = SetWindowFullscreenNative((SDLWindow*)window, fullscreen ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFullscreen([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "fullscreen")] [NativeName(NativeNameType.Type, "bool")] bool fullscreen)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowFullscreenNative((SDLWindow*)pwindow, fullscreen ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SyncWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SyncWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[563])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[563])((nint)window);
			#endif
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SyncWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SyncWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = SyncWindowNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SyncWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SyncWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SyncWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowHasSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowHasSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[564])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[564])((nint)window);
			#endif
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowHasSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowHasSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = WindowHasSurfaceNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowHasSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowHasSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowHasSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* GetWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*>)funcTable[565])(window);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[565])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr GetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			SDLSurfacePtr ret = GetWindowSurfaceNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr GetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSurfacePtr ret = GetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowSurfaceVSyncNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, byte>)funcTable[566])(window, vsync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[566])((nint)window, vsync);
			#endif
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			byte ret = SetWindowSurfaceVSyncNative((SDLWindow*)window, vsync);
			return ret != 0;
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowSurfaceVSyncNative((SDLWindow*)pwindow, vsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowSurfaceVSyncNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] int* vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, byte>)funcTable[567])(window, vsync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[567])((nint)window, (nint)vsync);
			#endif
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] int* vsync)
		{
			byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)window, vsync);
			return ret != 0;
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] int* vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)pwindow, vsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] ref int vsync)
		{
			fixed (int* pvsync = &vsync)
			{
				byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)window, (int*)pvsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] ref int vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pvsync = &vsync)
				{
					byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)pwindow, (int*)pvsync);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[568])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[568])((nint)window);
			#endif
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = UpdateWindowSurfaceNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = UpdateWindowSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateWindowSurfaceRectsNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int, byte>)funcTable[569])(window, rects, numrects);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[569])((nint)window, (nint)rects, numrects);
			#endif
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRectPtr rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)window, (SDLRect*)rects, numrects);
			return ret != 0;
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRectPtr rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)rects, numrects);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] in SDLRect rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLRect* prects = &rects)
			{
				byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)window, (SDLRect*)prects, numrects);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] in SDLRect rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prects = &rects)
				{
					byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)prects, numrects);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DestroyWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[570])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[570])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DestroyWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = DestroyWindowSurfaceNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DestroyWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = DestroyWindowSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowKeyboardGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] byte grabbed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[571])(window, grabbed);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[571])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			byte ret = SetWindowKeyboardGrabNative((SDLWindow*)window, grabbed ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowKeyboardGrabNative((SDLWindow*)pwindow, grabbed ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMouseGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] byte grabbed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[572])(window, grabbed);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[572])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			byte ret = SetWindowMouseGrabNative((SDLWindow*)window, grabbed ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMouseGrabNative((SDLWindow*)pwindow, grabbed ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowKeyboardGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[573])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[573])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = GetWindowKeyboardGrabNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowKeyboardGrabNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMouseGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[574])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[574])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = GetWindowMouseGrabNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMouseGrabNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGrabbedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetGrabbedWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[575])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[575])();
			#endif
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGrabbedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindowPtr GetGrabbedWindow()
		{
			SDLWindowPtr ret = GetGrabbedWindowNative();
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMouseRectNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, byte>)funcTable[576])(window, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[576])((nint)window, (nint)rect);
			#endif
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRectPtr rect)
		{
			byte ret = SetWindowMouseRectNative((SDLWindow*)window, (SDLRect*)rect);
			return ret != 0;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRectPtr rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] in SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetWindowMouseRectNative((SDLWindow*)window, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] in SDLRect rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "SDL_Rect const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRect* GetWindowMouseRectNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*>)funcTable[577])(window);
			#else
			return (SDLRect*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[577])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "SDL_Rect const *")]
		public static SDLRectPtr GetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			SDLRectPtr ret = GetWindowMouseRectNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "SDL_Rect const *")]
		public static SDLRectPtr GetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRectPtr ret = GetWindowMouseRectNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowOpacityNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, byte>)funcTable[578])(window, opacity);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, byte>)funcTable[578])((nint)window, opacity);
			#endif
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			byte ret = SetWindowOpacityNative((SDLWindow*)window, opacity);
			return ret != 0;
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowOpacityNative((SDLWindow*)pwindow, opacity);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowOpacityNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float>)funcTable[579])(window);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[579])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			float ret = GetWindowOpacityNative((SDLWindow*)window);
			return ret;
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				float ret = GetWindowOpacityNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowParentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLWindow*, byte>)funcTable[580])(window, parent);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[580])((nint)window, (nint)parent);
			#endif
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr parent)
		{
			byte ret = SetWindowParentNative((SDLWindow*)window, (SDLWindow*)parent);
			return ret != 0;
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr parent)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowParentNative((SDLWindow*)pwindow, (SDLWindow*)parent);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow parent)
		{
			fixed (SDLWindow* pparent = &parent)
			{
				byte ret = SetWindowParentNative((SDLWindow*)window, (SDLWindow*)pparent);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow parent)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindow* pparent = &parent)
				{
					byte ret = SetWindowParentNative((SDLWindow*)pwindow, (SDLWindow*)pparent);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowModal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowModalNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "modal")] [NativeName(NativeNameType.Type, "bool")] byte modal)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[581])(window, modal);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[581])((nint)window, modal);
			#endif
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowModal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowModal([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "modal")] [NativeName(NativeNameType.Type, "bool")] bool modal)
		{
			byte ret = SetWindowModalNative((SDLWindow*)window, modal ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowModal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowModal([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "modal")] [NativeName(NativeNameType.Type, "bool")] bool modal)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowModalNative((SDLWindow*)pwindow, modal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFocusable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowFocusableNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "focusable")] [NativeName(NativeNameType.Type, "bool")] byte focusable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[582])(window, focusable);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[582])((nint)window, focusable);
			#endif
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFocusable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFocusable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "focusable")] [NativeName(NativeNameType.Type, "bool")] bool focusable)
		{
			byte ret = SetWindowFocusableNative((SDLWindow*)window, focusable ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFocusable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFocusable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "focusable")] [NativeName(NativeNameType.Type, "bool")] bool focusable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowFocusableNative((SDLWindow*)pwindow, focusable ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindowSystemMenu")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowWindowSystemMenuNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[583])(window, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[583])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindowSystemMenu")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindowSystemMenu([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			byte ret = ShowWindowSystemMenuNative((SDLWindow*)window, x, y);
			return ret != 0;
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindowSystemMenu")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindowSystemMenu([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ShowWindowSystemMenuNative((SDLWindow*)pwindow, x, y);
				return ret != 0;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowHitTestNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>, void*, byte>)funcTable[584])(window, callback, callbackData);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[584])((nint)window, (nint)callback, (nint)callbackData);
			#endif
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			byte ret = SetWindowHitTestNative((SDLWindow*)window, callback, callbackData);
			return ret != 0;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowHitTestNative((SDLWindow*)pwindow, callback, callbackData);
				return ret != 0;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			byte ret = SetWindowHitTestNative((SDLWindow*)window, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), callbackData);
			return ret != 0;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowHitTestNative((SDLWindow*)pwindow, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), callbackData);
				return ret != 0;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] nint callbackData)
		{
			byte ret = SetWindowHitTestNative((SDLWindow*)window, callback, (void*)callbackData);
			return ret != 0;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] nint callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowHitTestNative((SDLWindow*)pwindow, callback, (void*)callbackData);
				return ret != 0;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] nint callbackData)
		{
			byte ret = SetWindowHitTestNative((SDLWindow*)window, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)callbackData);
			return ret != 0;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] nint callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowHitTestNative((SDLWindow*)pwindow, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)callbackData);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowShapeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*, byte>)funcTable[585])(window, shape);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[585])((nint)window, (nint)shape);
			#endif
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr shape)
		{
			byte ret = SetWindowShapeNative((SDLWindow*)window, (SDLSurface*)shape);
			return ret != 0;
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr shape)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)shape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface shape)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				byte ret = SetWindowShapeNative((SDLWindow*)window, (SDLSurface*)pshape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface shape)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					byte ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FlashWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLFlashOperation, byte>)funcTable[586])(window, operation);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLFlashOperation, byte>)funcTable[586])((nint)window, operation);
			#endif
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			byte ret = FlashWindowNative((SDLWindow*)window, operation);
			return ret != 0;
		}
	}
}
