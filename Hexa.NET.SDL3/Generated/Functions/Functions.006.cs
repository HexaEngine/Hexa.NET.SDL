// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					fixed (byte* pinbuf = inbuf)
					{
						byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					fixed (byte* pinbuf = inbuf)
					{
						string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = IconvStringNative(pStr0, pStr1, pStr2, inbytesleft);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, pStr1, pStr2, inbytesleft));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugbreakNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[164])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[164])();
			#endif
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Debugbreak()
		{
			DebugbreakNative();
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAssertionHandlerNative([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] delegate*<SDLAssertData*, void*, SDLAssertState> handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<SDLAssertData*, void*, SDLAssertState>, void*, void>)funcTable[165])(handler, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[165])((nint)handler, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAssertionHandler([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] delegate*<SDLAssertData*, void*, SDLAssertState> handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetAssertionHandlerNative(handler, userdata);
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAssertionHandler([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SDLAssertionHandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetAssertionHandlerNative((delegate*<SDLAssertData*, void*, SDLAssertState>)Utils.GetFunctionPointerForDelegate(handler), userdata);
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAssertionHandler([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] delegate*<SDLAssertData*, void*, SDLAssertState> handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetAssertionHandlerNative(handler, (void*)userdata);
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAssertionHandler([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SDLAssertionHandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetAssertionHandlerNative((delegate*<SDLAssertData*, void*, SDLAssertState>)Utils.GetFunctionPointerForDelegate(handler), (void*)userdata);
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<SDLAssertData*, void*, SDLAssertState> GetDefaultAssertionHandlerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<SDLAssertData*, void*, SDLAssertState>>)funcTable[166])();
			#else
			return (delegate*<SDLAssertData*, void*, SDLAssertState>)((delegate* unmanaged[Cdecl]<nint>)funcTable[166])();
			#endif
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetDefaultAssertionHandler()
		{
			delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetDefaultAssertionHandlerNative();
			return ret;
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandlerNative([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void * *")] void** puserdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, delegate*<SDLAssertData*, void*, SDLAssertState>>)funcTable[167])(puserdata);
			#else
			return (delegate*<SDLAssertData*, void*, SDLAssertState>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[167])((nint)puserdata);
			#endif
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandler([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void * *")] void** puserdata)
		{
			delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetAssertionHandlerNative(puserdata);
			return ret;
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandler([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void * *")] ref nint puserdata)
		{
			fixed (nint* ppuserdata = &puserdata)
			{
				delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetAssertionHandlerNative((void**)ppuserdata);
				return ret;
			}
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe. Other threads calling<br/>
		/// SDL_ResetAssertionReport() simultaneously, may render the<br/>
		/// returned pointer invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertData const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAssertData* GetAssertionReportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAssertData*>)funcTable[168])();
			#else
			return (SDLAssertData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[168])();
			#endif
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe. Other threads calling<br/>
		/// SDL_ResetAssertionReport() simultaneously, may render the<br/>
		/// returned pointer invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertData const *")]
		public static SDLAssertDataPtr GetAssertionReport()
		{
			SDLAssertDataPtr ret = GetAssertionReportNative();
			return ret;
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// This function is not thread safe. Other threads triggering an<br/>
		/// assertion, or simultaneously calling this function may cause<br/>
		/// memory leaks or crashes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetAssertionReportNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[169])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[169])();
			#endif
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// This function is not thread safe. Other threads triggering an<br/>
		/// assertion, or simultaneously calling this function may cause<br/>
		/// memory leaks or crashes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetAssertionReport()
		{
			ResetAssertionReportNative();
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAsyncIO* AsyncIOFromFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLAsyncIO*>)funcTable[170])(file, mode);
			#else
			return (SDLAsyncIO*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[170])((nint)file, (nint)mode);
			#endif
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			SDLAsyncIOPtr ret = AsyncIOFromFileNative(file, mode);
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLAsyncIOPtr ret = AsyncIOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = file)
			{
				SDLAsyncIOPtr ret = AsyncIOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLAsyncIOPtr ret = AsyncIOFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] in byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLAsyncIOPtr ret = AsyncIOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				SDLAsyncIOPtr ret = AsyncIOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLAsyncIOPtr ret = AsyncIOFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] in byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLAsyncIOPtr ret = AsyncIOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfile = file)
			{
				fixed (byte* pmode = mode)
				{
					SDLAsyncIOPtr ret = AsyncIOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIOPtr AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLAsyncIOPtr ret = AsyncIOFromFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_AsyncIO.<br/>
		/// This call is _not_ asynchronous; it assumes that obtaining this info is a<br/>
		/// non-blocking operation in most reasonable cases.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetAsyncIOSizeNative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, long>)funcTable[171])(asyncio);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[171])((nint)asyncio);
			#endif
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_AsyncIO.<br/>
		/// This call is _not_ asynchronous; it assumes that obtaining this info is a<br/>
		/// non-blocking operation in most reasonable cases.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetAsyncIOSize([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio)
		{
			long ret = GetAsyncIOSizeNative((SDLAsyncIO*)asyncio);
			return ret;
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_AsyncIO.<br/>
		/// This call is _not_ asynchronous; it assumes that obtaining this info is a<br/>
		/// non-blocking operation in most reasonable cases.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetAsyncIOSize([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				long ret = GetAsyncIOSizeNative((SDLAsyncIO*)pasyncio);
				return ret;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadAsyncIONative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, void*, ulong, ulong, SDLAsyncIOQueue*, void*, byte>)funcTable[172])(asyncio, ptr, offset, size, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ulong, ulong, nint, nint, byte>)funcTable[172])((nint)asyncio, (nint)ptr, offset, size, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WriteAsyncIONative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, void*, ulong, ulong, SDLAsyncIOQueue*, void*, byte>)funcTable[173])(asyncio, ptr, offset, size, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ulong, ulong, nint, nint, byte>)funcTable[173])((nint)asyncio, (nint)ptr, offset, size, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)queue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)asyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] nint ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, (void*)ptr, offset, size, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CloseAsyncIONative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] byte flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, byte, SDLAsyncIOQueue*, void*, byte>)funcTable[174])(asyncio, flush, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, nint, nint, byte>)funcTable[174])((nint)asyncio, flush, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = CloseAsyncIONative((SDLAsyncIO*)asyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = CloseAsyncIONative((SDLAsyncIO*)pasyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = CloseAsyncIONative((SDLAsyncIO*)asyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = CloseAsyncIONative((SDLAsyncIO*)pasyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = CloseAsyncIONative((SDLAsyncIO*)asyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)queue, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = CloseAsyncIONative((SDLAsyncIO*)pasyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)queue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIOPtr asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = CloseAsyncIONative((SDLAsyncIO*)asyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = CloseAsyncIONative((SDLAsyncIO*)pasyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a task queue for tracking multiple I/O operations.<br/>
		/// Async I/O operations are assigned to a queue when started. The queue can be<br/>
		/// checked for completed tasks thereafter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAsyncIOQueue* CreateAsyncIOQueueNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*>)funcTable[175])();
			#else
			return (SDLAsyncIOQueue*)((delegate* unmanaged[Cdecl]<nint>)funcTable[175])();
			#endif
		}

		/// <summary>
		/// Create a task queue for tracking multiple I/O operations.<br/>
		/// Async I/O operations are assigned to a queue when started. The queue can be<br/>
		/// checked for completed tasks thereafter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")]
		public static SDLAsyncIOQueuePtr CreateAsyncIOQueue()
		{
			SDLAsyncIOQueuePtr ret = CreateAsyncIOQueueNative();
			return ret;
		}

		/// <summary>
		/// Destroy a previously-created async I/O task queue.<br/>
		/// If there are still tasks pending for this queue, this call will block until<br/>
		/// those tasks are finished. All those tasks will be deallocated. Their<br/>
		/// results will be lost to the app.<br/>
		/// Any pending reads from SDL_LoadFileAsync() that are still in this queue<br/>
		/// will have their buffers deallocated by this function, to prevent a memory<br/>
		/// leak.<br/>
		/// Once this function is called, the queue is no longer valid and should not<br/>
		/// be used, including by other threads that might access it while destruction<br/>
		/// is blocking on pending tasks.<br/>
		/// Do not destroy a queue that still has threads waiting on it through<br/>
		/// SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to<br/>
		/// unblock those threads, and take measures (such as SDL_WaitThread()) to make<br/>
		/// sure they have finished their wait and won't wait on the queue again.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, so long as<br/>
		/// no other thread is waiting on the queue with<br/>
		/// SDL_WaitAsyncIOResult.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyAsyncIOQueueNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, void>)funcTable[176])(queue);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[176])((nint)queue);
			#endif
		}

		/// <summary>
		/// Destroy a previously-created async I/O task queue.<br/>
		/// If there are still tasks pending for this queue, this call will block until<br/>
		/// those tasks are finished. All those tasks will be deallocated. Their<br/>
		/// results will be lost to the app.<br/>
		/// Any pending reads from SDL_LoadFileAsync() that are still in this queue<br/>
		/// will have their buffers deallocated by this function, to prevent a memory<br/>
		/// leak.<br/>
		/// Once this function is called, the queue is no longer valid and should not<br/>
		/// be used, including by other threads that might access it while destruction<br/>
		/// is blocking on pending tasks.<br/>
		/// Do not destroy a queue that still has threads waiting on it through<br/>
		/// SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to<br/>
		/// unblock those threads, and take measures (such as SDL_WaitThread()) to make<br/>
		/// sure they have finished their wait and won't wait on the queue again.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, so long as<br/>
		/// no other thread is waiting on the queue with<br/>
		/// SDL_WaitAsyncIOResult.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue)
		{
			DestroyAsyncIOQueueNative((SDLAsyncIOQueue*)queue);
		}

		/// <summary>
		/// Destroy a previously-created async I/O task queue.<br/>
		/// If there are still tasks pending for this queue, this call will block until<br/>
		/// those tasks are finished. All those tasks will be deallocated. Their<br/>
		/// results will be lost to the app.<br/>
		/// Any pending reads from SDL_LoadFileAsync() that are still in this queue<br/>
		/// will have their buffers deallocated by this function, to prevent a memory<br/>
		/// leak.<br/>
		/// Once this function is called, the queue is no longer valid and should not<br/>
		/// be used, including by other threads that might access it while destruction<br/>
		/// is blocking on pending tasks.<br/>
		/// Do not destroy a queue that still has threads waiting on it through<br/>
		/// SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to<br/>
		/// unblock those threads, and take measures (such as SDL_WaitThread()) to make<br/>
		/// sure they have finished their wait and won't wait on the queue again.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, so long as<br/>
		/// no other thread is waiting on the queue with<br/>
		/// SDL_WaitAsyncIOResult.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				DestroyAsyncIOQueueNative((SDLAsyncIOQueue*)pqueue);
			}
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetAsyncIOResultNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, SDLAsyncIOOutcome*, byte>)funcTable[177])(queue, outcome);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[177])((nint)queue, (nint)outcome);
			#endif
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcomePtr outcome)
		{
			byte ret = GetAsyncIOResultNative((SDLAsyncIOQueue*)queue, (SDLAsyncIOOutcome*)outcome);
			return ret != 0;
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcomePtr outcome)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = GetAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, (SDLAsyncIOOutcome*)outcome);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome)
		{
			fixed (SDLAsyncIOOutcome* poutcome = &outcome)
			{
				byte ret = GetAsyncIOResultNative((SDLAsyncIOQueue*)queue, (SDLAsyncIOOutcome*)poutcome);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				fixed (SDLAsyncIOOutcome* poutcome = &outcome)
				{
					byte ret = GetAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, (SDLAsyncIOOutcome*)poutcome);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitAsyncIOResultNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, SDLAsyncIOOutcome*, int, byte>)funcTable[178])(queue, outcome, timeoutMS);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[178])((nint)queue, (nint)outcome, timeoutMS);
			#endif
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcomePtr outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			byte ret = WaitAsyncIOResultNative((SDLAsyncIOQueue*)queue, (SDLAsyncIOOutcome*)outcome, timeoutMS);
			return ret != 0;
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcomePtr outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = WaitAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, (SDLAsyncIOOutcome*)outcome, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLAsyncIOOutcome* poutcome = &outcome)
			{
				byte ret = WaitAsyncIOResultNative((SDLAsyncIOQueue*)queue, (SDLAsyncIOOutcome*)poutcome, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				fixed (SDLAsyncIOOutcome* poutcome = &outcome)
				{
					byte ret = WaitAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, (SDLAsyncIOOutcome*)poutcome, timeoutMS);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Wake up any threads that are blocking in SDL_WaitAsyncIOResult().<br/>
		/// This will unblock any threads that are sleeping in a call to<br/>
		/// SDL_WaitAsyncIOResult for the specified queue, and cause them to return<br/>
		/// from that function.<br/>
		/// This can be useful when destroying a queue to make sure nothing is touching<br/>
		/// it indefinitely. In this case, once this call completes, the caller should<br/>
		/// take measures to make sure any previously-blocked threads have returned<br/>
		/// from their wait and will not touch the queue again (perhaps by setting a<br/>
		/// flag to tell the threads to terminate and then using SDL_WaitThread() to<br/>
		/// make sure they've done so).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalAsyncIOQueueNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, void>)funcTable[179])(queue);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[179])((nint)queue);
			#endif
		}

		/// <summary>
		/// Wake up any threads that are blocking in SDL_WaitAsyncIOResult().<br/>
		/// This will unblock any threads that are sleeping in a call to<br/>
		/// SDL_WaitAsyncIOResult for the specified queue, and cause them to return<br/>
		/// from that function.<br/>
		/// This can be useful when destroying a queue to make sure nothing is touching<br/>
		/// it indefinitely. In this case, once this call completes, the caller should<br/>
		/// take measures to make sure any previously-blocked threads have returned<br/>
		/// from their wait and will not touch the queue again (perhaps by setting a<br/>
		/// flag to tell the threads to terminate and then using SDL_WaitThread() to<br/>
		/// make sure they've done so).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue)
		{
			SignalAsyncIOQueueNative((SDLAsyncIOQueue*)queue);
		}

		/// <summary>
		/// Wake up any threads that are blocking in SDL_WaitAsyncIOResult().<br/>
		/// This will unblock any threads that are sleeping in a call to<br/>
		/// SDL_WaitAsyncIOResult for the specified queue, and cause them to return<br/>
		/// from that function.<br/>
		/// This can be useful when destroying a queue to make sure nothing is touching<br/>
		/// it indefinitely. In this case, once this call completes, the caller should<br/>
		/// take measures to make sure any previously-blocked threads have returned<br/>
		/// from their wait and will not touch the queue again (perhaps by setting a<br/>
		/// flag to tell the threads to terminate and then using SDL_WaitThread() to<br/>
		/// make sure they've done so).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				SignalAsyncIOQueueNative((SDLAsyncIOQueue*)pqueue);
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LoadFileAsyncNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLAsyncIOQueue*, void*, byte>)funcTable[180])(file, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[180])((nint)file, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = LoadFileAsyncNative(file, (SDLAsyncIOQueue*)queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = file)
			{
				byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = LoadFileAsyncNative(pStr0, (SDLAsyncIOQueue*)queue, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = LoadFileAsyncNative(file, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = &file)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = file)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = LoadFileAsyncNative(pStr0, (SDLAsyncIOQueue*)pqueue, userdata);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = LoadFileAsyncNative(file, (SDLAsyncIOQueue*)queue, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)queue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pfile = file)
			{
				byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)queue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueuePtr queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = LoadFileAsyncNative(pStr0, (SDLAsyncIOQueue*)queue, (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = LoadFileAsyncNative(file, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pfile = &file)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pfile = file)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = LoadFileAsyncNative(pStr0, (SDLAsyncIOQueue*)pqueue, (void*)userdata);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockSpinlock")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockSpinlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte>)funcTable[181])(lock0);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[181])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockSpinlock")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			byte ret = TryLockSpinlockNative(lock0);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockSpinlock")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				byte ret = TryLockSpinlockNative((int*)plock0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockSpinlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[182])(lock0);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[182])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			LockSpinlockNative(lock0);
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				LockSpinlockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockSpinlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[183])(lock0);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[183])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			UnlockSpinlockNative(lock0);
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				UnlockSpinlockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Insert a memory release barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierReleaseFunctionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[184])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[184])();
			#endif
		}

		/// <summary>
		/// Insert a memory release barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MemoryBarrierReleaseFunction()
		{
			MemoryBarrierReleaseFunctionNative();
		}

		/// <summary>
		/// Insert a memory acquire barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierAcquireFunctionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[185])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[185])();
			#endif
		}

		/// <summary>
		/// Insert a memory acquire barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MemoryBarrierAcquireFunction()
		{
			MemoryBarrierAcquireFunctionNative();
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicInt")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompareAndSwapAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int, int, byte>)funcTable[186])(a, oldval, newval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[186])((nint)a, oldval, newval);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicInt")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicIntPtr a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			byte ret = CompareAndSwapAtomicIntNative((SDLAtomicInt*)a, oldval, newval);
			return ret != 0;
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicInt")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				byte ret = CompareAndSwapAtomicIntNative((SDLAtomicInt*)pa, oldval, newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int, int>)funcTable[187])(a, v);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[187])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicIntPtr a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = SetAtomicIntNative((SDLAtomicInt*)a, v);
			return ret;
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				int ret = SetAtomicIntNative((SDLAtomicInt*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int>)funcTable[188])(a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[188])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicIntPtr a)
		{
			int ret = GetAtomicIntNative((SDLAtomicInt*)a);
			return ret;
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				int ret = GetAtomicIntNative((SDLAtomicInt*)pa);
				return ret;
			}
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int, int>)funcTable[189])(a, v);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[189])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicIntPtr a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = AddAtomicIntNative((SDLAtomicInt*)a, v);
			return ret;
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				int ret = AddAtomicIntNative((SDLAtomicInt*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicU32")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompareAndSwapAtomicU32Native([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "Uint32")] uint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "Uint32")] uint newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicU32*, uint, uint, byte>)funcTable[190])(a, oldval, newval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, uint, byte>)funcTable[190])((nint)a, oldval, newval);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicU32")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32Ptr a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "Uint32")] uint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "Uint32")] uint newval)
		{
			byte ret = CompareAndSwapAtomicU32Native((SDLAtomicU32*)a, oldval, newval);
			return ret != 0;
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicU32")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] ref SDLAtomicU32 a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "Uint32")] uint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "Uint32")] uint newval)
		{
			fixed (SDLAtomicU32* pa = &a)
			{
				byte ret = CompareAndSwapAtomicU32Native((SDLAtomicU32*)pa, oldval, newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint SetAtomicU32Native([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "Uint32")] uint v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicU32*, uint, uint>)funcTable[191])(a, v);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint, uint>)funcTable[191])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32Ptr a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "Uint32")] uint v)
		{
			uint ret = SetAtomicU32Native((SDLAtomicU32*)a, v);
			return ret;
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] ref SDLAtomicU32 a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "Uint32")] uint v)
		{
			fixed (SDLAtomicU32* pa = &a)
			{
				uint ret = SetAtomicU32Native((SDLAtomicU32*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetAtomicU32Native([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicU32*, uint>)funcTable[192])(a);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[192])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32Ptr a)
		{
			uint ret = GetAtomicU32Native((SDLAtomicU32*)a);
			return ret;
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] ref SDLAtomicU32 a)
		{
			fixed (SDLAtomicU32* pa = &a)
			{
				uint ret = GetAtomicU32Native((SDLAtomicU32*)pa);
				return ret;
			}
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint AddAtomicU32Native([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicU32*, int, uint>)funcTable[193])(a, v);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[193])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint AddAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32Ptr a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			uint ret = AddAtomicU32Native((SDLAtomicU32*)a, v);
			return ret;
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint AddAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] ref SDLAtomicU32 a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			fixed (SDLAtomicU32* pa = &a)
			{
				uint ret = AddAtomicU32Native((SDLAtomicU32*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompareAndSwapAtomicPointerNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] void* newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*, void*, byte>)funcTable[194])(a, oldval, newval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[194])((nint)a, (nint)oldval, (nint)newval);
			#endif
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] void* newval)
		{
			byte ret = CompareAndSwapAtomicPointerNative(a, oldval, newval);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] ref nint a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] void* newval)
		{
			fixed (nint* pa = &a)
			{
				byte ret = CompareAndSwapAtomicPointerNative((void**)pa, oldval, newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] nint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] void* newval)
		{
			byte ret = CompareAndSwapAtomicPointerNative(a, (void*)oldval, newval);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] ref nint a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] nint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] void* newval)
		{
			fixed (nint* pa = &a)
			{
				byte ret = CompareAndSwapAtomicPointerNative((void**)pa, (void*)oldval, newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] nint newval)
		{
			byte ret = CompareAndSwapAtomicPointerNative(a, oldval, (void*)newval);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] ref nint a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] nint newval)
		{
			fixed (nint* pa = &a)
			{
				byte ret = CompareAndSwapAtomicPointerNative((void**)pa, oldval, (void*)newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] nint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] nint newval)
		{
			byte ret = CompareAndSwapAtomicPointerNative(a, (void*)oldval, (void*)newval);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] ref nint a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] nint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] nint newval)
		{
			fixed (nint* pa = &a)
			{
				byte ret = CompareAndSwapAtomicPointerNative((void**)pa, (void*)oldval, (void*)newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SetAtomicPointerNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void *")] void* v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*, void*>)funcTable[195])(a, v);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[195])((nint)a, (nint)v);
			#endif
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* SetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void *")] void* v)
		{
			void* ret = SetAtomicPointerNative(a, v);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* SetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] ref nint a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void *")] void* v)
		{
			fixed (nint* pa = &a)
			{
				void* ret = SetAtomicPointerNative((void**)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* SetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void *")] nint v)
		{
			void* ret = SetAtomicPointerNative(a, (void*)v);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* SetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] ref nint a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void *")] nint v)
		{
			fixed (nint* pa = &a)
			{
				void* ret = SetAtomicPointerNative((void**)pa, (void*)v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetAtomicPointerNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*>)funcTable[196])(a);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[196])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a)
		{
			void* ret = GetAtomicPointerNative(a);
			return ret;
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] ref nint a)
		{
			fixed (nint* pa = &a)
			{
				void* ret = GetAtomicPointerNative((void**)pa);
				return ret;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetErrorNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[197])(fmt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[197])((nint)fmt);
			#endif
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			byte ret = SetErrorNative(fmt);
			return ret != 0;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = SetErrorNative((byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = SetErrorNative((byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetErrorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetErrorVNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nint, byte>)funcTable[198])(fmt, ap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[198])((nint)fmt, ap);
			#endif
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte ret = SetErrorVNative(fmt, ap);
			return ret != 0;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] in byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = SetErrorVNative((byte*)pfmt, ap);
				return ret != 0;
			}
		}
	}
}
