// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetStringProperty(uint props, ReadOnlySpan<byte> name, ReadOnlySpan<byte> value)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetStringPropertyNative(props, (byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetStringProperty(uint props, string name, string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetNumberPropertyNative(uint props, byte* name, long value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, byte>)funcTable[209])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, long, byte>)funcTable[209])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetNumberProperty(uint props, byte* name, long value)
		{
			byte ret = SetNumberPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetNumberProperty(uint props, ref byte name, long value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetNumberProperty(uint props, ReadOnlySpan<byte> name, long value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetNumberProperty(uint props, string name, long value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetNumberPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetFloatPropertyNative(uint props, byte* name, float value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, byte>)funcTable[210])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, float, byte>)funcTable[210])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetFloatProperty(uint props, byte* name, float value)
		{
			byte ret = SetFloatPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetFloatProperty(uint props, ref byte name, float value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetFloatProperty(uint props, ReadOnlySpan<byte> name, float value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetFloatProperty(uint props, string name, float value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetFloatPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetBooleanPropertyNative(uint props, byte* name, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte, byte>)funcTable[211])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte, byte>)funcTable[211])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetBooleanProperty(uint props, byte* name, bool value)
		{
			byte ret = SetBooleanPropertyNative(props, name, value ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetBooleanProperty(uint props, ref byte name, bool value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetBooleanPropertyNative(props, (byte*)pname, value ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetBooleanProperty(uint props, ReadOnlySpan<byte> name, bool value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetBooleanPropertyNative(props, (byte*)pname, value ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetBooleanProperty(uint props, string name, bool value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetBooleanPropertyNative(props, pStr0, value ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasPropertyNative(uint props, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte>)funcTable[212])(props, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte>)funcTable[212])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HasProperty(uint props, byte* name)
		{
			byte ret = HasPropertyNative(props, name);
			return ret != 0;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HasProperty(uint props, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = HasPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HasProperty(uint props, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = HasPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HasProperty(uint props, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = HasPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPropertyType GetPropertyTypeNative(uint props, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, SDLPropertyType>)funcTable[213])(props, name);
			#else
			return (SDLPropertyType)((delegate* unmanaged[Cdecl]<uint, nint, SDLPropertyType>)funcTable[213])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPropertyType GetPropertyType(uint props, byte* name)
		{
			SDLPropertyType ret = GetPropertyTypeNative(props, name);
			return ret;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPropertyType GetPropertyType(uint props, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPropertyType GetPropertyType(uint props, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPropertyType GetPropertyType(uint props, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLPropertyType ret = GetPropertyTypeNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetPointerPropertyNative(uint props, byte* name, void* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, void*>)funcTable[214])(props, name, defaultValue);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[214])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetPointerProperty(uint props, byte* name, void* defaultValue)
		{
			void* ret = GetPointerPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetPointerProperty(uint props, ref byte name, void* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetPointerProperty(uint props, ReadOnlySpan<byte> name, void* defaultValue)
		{
			fixed (byte* pname = name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetPointerProperty(uint props, string name, void* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetPointerPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringPropertyNative(uint props, byte* name, byte* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, byte*>)funcTable[215])(props, name, defaultValue);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[215])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, byte* name, byte* defaultValue)
		{
			byte* ret = GetStringPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, byte* name, byte* defaultValue)
		{
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, defaultValue));
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, ref byte name, byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, ref byte name, byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, ReadOnlySpan<byte> name, byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, ReadOnlySpan<byte> name, byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, string name, byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, string name, byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, defaultValue));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, byte* name, ref byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, byte* name, ref byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, byte* name, ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, byte* name, ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, byte* name, string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, byte* name, string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, ref byte name, ref byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, ref byte name, ref byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, ReadOnlySpan<byte> name, ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, ReadOnlySpan<byte> name, ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetStringProperty(uint props, string name, string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetStringPropertyS(uint props, string name, string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetNumberPropertyNative(uint props, byte* name, long defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, long>)funcTable[216])(props, name, defaultValue);
			#else
			return (long)((delegate* unmanaged[Cdecl]<uint, nint, long, long>)funcTable[216])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long GetNumberProperty(uint props, byte* name, long defaultValue)
		{
			long ret = GetNumberPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long GetNumberProperty(uint props, ref byte name, long defaultValue)
		{
			fixed (byte* pname = &name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long GetNumberProperty(uint props, ReadOnlySpan<byte> name, long defaultValue)
		{
			fixed (byte* pname = name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static long GetNumberProperty(uint props, string name, long defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = GetNumberPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFloatPropertyNative(uint props, byte* name, float defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, float>)funcTable[217])(props, name, defaultValue);
			#else
			return (float)((delegate* unmanaged[Cdecl]<uint, nint, float, float>)funcTable[217])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetFloatProperty(uint props, byte* name, float defaultValue)
		{
			float ret = GetFloatPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetFloatProperty(uint props, ref byte name, float defaultValue)
		{
			fixed (byte* pname = &name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetFloatProperty(uint props, ReadOnlySpan<byte> name, float defaultValue)
		{
			fixed (byte* pname = name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetFloatProperty(uint props, string name, float defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			float ret = GetFloatPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetBooleanPropertyNative(uint props, byte* name, byte defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte, byte>)funcTable[218])(props, name, defaultValue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte, byte>)funcTable[218])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetBooleanProperty(uint props, byte* name, bool defaultValue)
		{
			byte ret = GetBooleanPropertyNative(props, name, defaultValue ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetBooleanProperty(uint props, ref byte name, bool defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetBooleanProperty(uint props, ReadOnlySpan<byte> name, bool defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetBooleanProperty(uint props, string name, bool defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GetBooleanPropertyNative(props, pStr0, defaultValue ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearPropertyNative(uint props, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte>)funcTable[219])(props, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte>)funcTable[219])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ClearProperty(uint props, byte* name)
		{
			byte ret = ClearPropertyNative(props, name);
			return ret != 0;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ClearProperty(uint props, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ClearPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ClearProperty(uint props, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = ClearPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ClearProperty(uint props, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ClearPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EnumeratePropertiesNative(uint props, SDLEnumeratePropertiesCallback callback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void*, uint, byte*, void>, void*, byte>)funcTable[220])(props, (delegate*<void*, uint, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[220])(props, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool EnumerateProperties(uint props, SDLEnumeratePropertiesCallback callback, void* userdata)
		{
			byte ret = EnumeratePropertiesNative(props, callback, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPropertiesNative(uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[221])(props);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[221])(props);
			#endif
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyProperties(uint props)
		{
			DestroyPropertiesNative(props);
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadRuntimeNative(SDLThreadFunction fn, byte* name, void* data, SDLFunctionPointer pfnBeginThread, SDLFunctionPointer pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, int>, byte*, void*, delegate*<void>, delegate*<void>, SDLThread*>)funcTable[222])((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint>)funcTable[222])((nint)Utils.GetFunctionPointerForDelegate(fn), (nint)name, (nint)data, (nint)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (nint)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#endif
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLThread* CreateThreadRuntime(SDLThreadFunction fn, byte* name, void* data, SDLFunctionPointer pfnBeginThread, SDLFunctionPointer pfnEndThread)
		{
			SDLThread* ret = CreateThreadRuntimeNative(fn, name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLThread* CreateThreadRuntime(SDLThreadFunction fn, ref byte name, void* data, SDLFunctionPointer pfnBeginThread, SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLThread* CreateThreadRuntime(SDLThreadFunction fn, ReadOnlySpan<byte> name, void* data, SDLFunctionPointer pfnBeginThread, SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThread* ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLThread* CreateThreadRuntime(SDLThreadFunction fn, string name, void* data, SDLFunctionPointer pfnBeginThread, SDLFunctionPointer pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = CreateThreadRuntimeNative(fn, pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// The actual entry point for SDL_CreateThreadWithProperties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadWithPropertiesRuntimeNative(uint props, SDLFunctionPointer pfnBeginThread, SDLFunctionPointer pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void>, delegate*<void>, SDLThread*>)funcTable[223])(props, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[223])(props, (nint)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (nint)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#endif
		}

		/// <summary>
		/// The actual entry point for SDL_CreateThreadWithProperties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLThread* CreateThreadWithPropertiesRuntime(uint props, SDLFunctionPointer pfnBeginThread, SDLFunctionPointer pfnEndThread)
		{
			SDLThread* ret = CreateThreadWithPropertiesRuntimeNative(props, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetThreadNameNative(SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, byte*>)funcTable[224])(thread);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[224])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetThreadName(SDLThread* thread)
		{
			byte* ret = GetThreadNameNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetThreadNameS(SDLThread* thread)
		{
			string ret = Utils.DecodeStringUTF8(GetThreadNameNative(thread));
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetThreadName(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				byte* ret = GetThreadNameNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetThreadNameS(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				string ret = Utils.DecodeStringUTF8(GetThreadNameNative((SDLThread*)pthread));
				return ret;
			}
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetCurrentThreadIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[225])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[225])();
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetCurrentThreadID()
		{
			ulong ret = GetCurrentThreadIDNative();
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetThreadIDNative(SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, ulong>)funcTable[226])(thread);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[226])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetThreadID(SDLThread* thread)
		{
			ulong ret = GetThreadIDNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetThreadID(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				ulong ret = GetThreadIDNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetCurrentThreadPriorityNative(SDLThreadPriority priority)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThreadPriority, byte>)funcTable[227])(priority);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLThreadPriority, byte>)funcTable[227])(priority);
			#endif
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetCurrentThreadPriority(SDLThreadPriority priority)
		{
			byte ret = SetCurrentThreadPriorityNative(priority);
			return ret != 0;
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitThreadNative(SDLThread* thread, int* status)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, int*, void>)funcTable[228])(thread, status);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[228])((nint)thread, (nint)status);
			#endif
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(SDLThread* thread, int* status)
		{
			WaitThreadNative(thread, status);
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(ref SDLThread thread, int* status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				WaitThreadNative((SDLThread*)pthread, status);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(SDLThread* thread, ref int status)
		{
			fixed (int* pstatus = &status)
			{
				WaitThreadNative(thread, (int*)pstatus);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitThread(ref SDLThread thread, ref int status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				fixed (int* pstatus = &status)
				{
					WaitThreadNative((SDLThread*)pthread, (int*)pstatus);
				}
			}
		}

		/// <summary>
		/// Get the current state of a thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThreadState GetThreadStateNative(SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, SDLThreadState>)funcTable[229])(thread);
			#else
			return (SDLThreadState)((delegate* unmanaged[Cdecl]<nint, SDLThreadState>)funcTable[229])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the current state of a thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLThreadState GetThreadState(SDLThread* thread)
		{
			SDLThreadState ret = GetThreadStateNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the current state of a thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLThreadState GetThreadState(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				SDLThreadState ret = GetThreadStateNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachThreadNative(SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, void>)funcTable[230])(thread);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[230])((nint)thread);
			#endif
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DetachThread(SDLThread* thread)
		{
			DetachThreadNative(thread);
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DetachThread(ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				DetachThreadNative((SDLThread*)pthread);
			}
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetTLSNative(uint* id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, void*>)funcTable[231])(id);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[231])((nint)id);
			#endif
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetTLS(uint* id)
		{
			void* ret = GetTLSNative(id);
			return ret;
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetTLS(ref uint id)
		{
			fixed (uint* pid = &id)
			{
				void* ret = GetTLSNative((uint*)pid);
				return ret;
			}
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTLSNative(uint* id, void* value, SDLTLSDestructorCallback destructor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, void*, delegate*<void*, void>, byte>)funcTable[232])(id, value, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(destructor));
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[232])((nint)id, (nint)value, (nint)Utils.GetFunctionPointerForDelegate(destructor));
			#endif
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTLS(uint* id, void* value, SDLTLSDestructorCallback destructor)
		{
			byte ret = SetTLSNative(id, value, destructor);
			return ret != 0;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTLS(ref uint id, void* value, SDLTLSDestructorCallback destructor)
		{
			fixed (uint* pid = &id)
			{
				byte ret = SetTLSNative((uint*)pid, value, destructor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// If you are creating your threads outside of SDL and then calling SDL<br/>
		/// functions, you should call this function before your thread exits, to<br/>
		/// properly clean up SDL memory.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CleanupTLSNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[233])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[233])();
			#endif
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// If you are creating your threads outside of SDL and then calling SDL<br/>
		/// functions, you should call this function before your thread exits, to<br/>
		/// properly clean up SDL memory.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static void CleanupTLS()
		{
			CleanupTLSNative();
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLMutex* CreateMutexNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*>)funcTable[234])();
			#else
			return (SDLMutex*)((delegate* unmanaged[Cdecl]<nint>)funcTable[234])();
			#endif
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLMutex* CreateMutex()
		{
			SDLMutex* ret = CreateMutexNative();
			return ret;
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// This function does not fail; if mutex is NULL, it will return immediately<br/>
		/// having locked nothing. If the mutex is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMutex*, void>)funcTable[235])(mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[235])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// This function does not fail; if mutex is NULL, it will return immediately<br/>
		/// having locked nothing. If the mutex is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockMutex(SDLMutex* mutex)
		{
			LockMutexNative(mutex);
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// This function does not fail; if mutex is NULL, it will return immediately<br/>
		/// having locked nothing. If the mutex is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				LockMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// This function returns true if passed a NULL mutex.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*, byte>)funcTable[236])(mutex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[236])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// This function returns true if passed a NULL mutex.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryLockMutex(SDLMutex* mutex)
		{
			byte ret = TryLockMutexNative(mutex);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// This function returns true if passed a NULL mutex.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryLockMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				byte ret = TryLockMutexNative((SDLMutex*)pmutex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is illegal to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMutex*, void>)funcTable[237])(mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[237])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is illegal to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockMutex(SDLMutex* mutex)
		{
			UnlockMutexNative(mutex);
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is illegal to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				UnlockMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyMutexNative(SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMutex*, void>)funcTable[238])(mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[238])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyMutex(SDLMutex* mutex)
		{
			DestroyMutexNative(mutex);
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyMutex(ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				DestroyMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Create a new read/write lock.<br/>
		/// A read/write lock is useful for situations where you have multiple threads<br/>
		/// trying to access a resource that is rarely updated. All threads requesting<br/>
		/// a read-only lock will be allowed to run in parallel; if a thread requests a<br/>
		/// write lock, it will be provided exclusive access. This makes it safe for<br/>
		/// multiple threads to use a resource at the same time if they promise not to<br/>
		/// change it, and when it has to be changed, the rwlock will serve as a<br/>
		/// gateway to make sure those changes can be made safely.<br/>
		/// In the right situation, a rwlock can be more efficient than a mutex, which<br/>
		/// only lets a single thread proceed at a time, even if it won't be modifying<br/>
		/// the data.<br/>
		/// All newly-created read/write locks begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not<br/>
		/// return while the rwlock is locked _for writing_ by another thread. See<br/>
		/// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt<br/>
		/// to lock without blocking.<br/>
		/// SDL read/write locks are only recursive for read-only locks! They are not<br/>
		/// guaranteed to be fair, or provide access in a FIFO manner! They are not<br/>
		/// guaranteed to favor writers. You may not lock a rwlock for both read-only<br/>
		/// and write access at the same time from the same thread (so you can't<br/>
		/// promote your read-only lock to a write lock without unlocking first).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWLock* CreateRWLockNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*>)funcTable[239])();
			#else
			return (SDLRWLock*)((delegate* unmanaged[Cdecl]<nint>)funcTable[239])();
			#endif
		}

		/// <summary>
		/// Create a new read/write lock.<br/>
		/// A read/write lock is useful for situations where you have multiple threads<br/>
		/// trying to access a resource that is rarely updated. All threads requesting<br/>
		/// a read-only lock will be allowed to run in parallel; if a thread requests a<br/>
		/// write lock, it will be provided exclusive access. This makes it safe for<br/>
		/// multiple threads to use a resource at the same time if they promise not to<br/>
		/// change it, and when it has to be changed, the rwlock will serve as a<br/>
		/// gateway to make sure those changes can be made safely.<br/>
		/// In the right situation, a rwlock can be more efficient than a mutex, which<br/>
		/// only lets a single thread proceed at a time, even if it won't be modifying<br/>
		/// the data.<br/>
		/// All newly-created read/write locks begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not<br/>
		/// return while the rwlock is locked _for writing_ by another thread. See<br/>
		/// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt<br/>
		/// to lock without blocking.<br/>
		/// SDL read/write locks are only recursive for read-only locks! They are not<br/>
		/// guaranteed to be fair, or provide access in a FIFO manner! They are not<br/>
		/// guaranteed to favor writers. You may not lock a rwlock for both read-only<br/>
		/// and write access at the same time from the same thread (so you can't<br/>
		/// promote your read-only lock to a write lock without unlocking first).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRWLock* CreateRWLock()
		{
			SDLRWLock* ret = CreateRWLockNative();
			return ret;
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockRWLockForReadingNative(SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[240])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[240])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockRWLockForReading(SDLRWLock* rwlock)
		{
			LockRWLockForReadingNative(rwlock);
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockRWLockForReading(ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				LockRWLockForReadingNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockRWLockForWritingNative(SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[241])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[241])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockRWLockForWriting(SDLRWLock* rwlock)
		{
			LockRWLockForWritingNative(rwlock);
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void LockRWLockForWriting(ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				LockRWLockForWritingNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockRWLockForReadingNative(SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*, byte>)funcTable[242])(rwlock);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[242])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryLockRWLockForReading(SDLRWLock* rwlock)
		{
			byte ret = TryLockRWLockForReadingNative(rwlock);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryLockRWLockForReading(ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				byte ret = TryLockRWLockForReadingNative((SDLRWLock*)prwlock);
				return ret != 0;
			}
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockRWLockForWritingNative(SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*, byte>)funcTable[243])(rwlock);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[243])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryLockRWLockForWriting(SDLRWLock* rwlock)
		{
			byte ret = TryLockRWLockForWritingNative(rwlock);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryLockRWLockForWriting(ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				byte ret = TryLockRWLockForWritingNative((SDLRWLock*)prwlock);
				return ret != 0;
			}
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockRWLockNative(SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[244])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[244])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockRWLock(SDLRWLock* rwlock)
		{
			UnlockRWLockNative(rwlock);
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockRWLock(ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				UnlockRWLockNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyRWLockNative(SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[245])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[245])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyRWLock(SDLRWLock* rwlock)
		{
			DestroyRWLockNative(rwlock);
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyRWLock(ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				DestroyRWLockNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSemaphore* CreateSemaphoreNative(uint initialValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLSemaphore*>)funcTable[246])(initialValue);
			#else
			return (SDLSemaphore*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[246])(initialValue);
			#endif
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSemaphore* CreateSemaphore(uint initialValue)
		{
			SDLSemaphore* ret = CreateSemaphoreNative(initialValue);
			return ret;
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroySemaphoreNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[247])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[247])((nint)sem);
			#endif
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroySemaphore(SDLSemaphore* sem)
		{
			DestroySemaphoreNative(sem);
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroySemaphore(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				DestroySemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until the semaphore pointed to by<br/>
		/// `sem` has a positive value, and then atomically decrement the semaphore<br/>
		/// value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitSemaphoreNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[248])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[248])((nint)sem);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until the semaphore pointed to by<br/>
		/// `sem` has a positive value, and then atomically decrement the semaphore<br/>
		/// value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitSemaphore(SDLSemaphore* sem)
		{
			WaitSemaphoreNative(sem);
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until the semaphore pointed to by<br/>
		/// `sem` has a positive value, and then atomically decrement the semaphore<br/>
		/// value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitSemaphore(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				WaitSemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryWaitSemaphoreNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, byte>)funcTable[249])(sem);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[249])((nint)sem);
			#endif
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryWaitSemaphore(SDLSemaphore* sem)
		{
			byte ret = TryWaitSemaphoreNative(sem);
			return ret != 0;
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool TryWaitSemaphore(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				byte ret = TryWaitSemaphoreNative((SDLSemaphore*)psem);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the specified time has elapsed.<br/>
		/// If the call is successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitSemaphoreTimeoutNative(SDLSemaphore* sem, int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int, byte>)funcTable[250])(sem, timeoutMS);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[250])((nint)sem, timeoutMS);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the specified time has elapsed.<br/>
		/// If the call is successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitSemaphoreTimeout(SDLSemaphore* sem, int timeoutMS)
		{
			byte ret = WaitSemaphoreTimeoutNative(sem, timeoutMS);
			return ret != 0;
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the specified time has elapsed.<br/>
		/// If the call is successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitSemaphoreTimeout(ref SDLSemaphore sem, int timeoutMS)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				byte ret = WaitSemaphoreTimeoutNative((SDLSemaphore*)psem, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalSemaphoreNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[251])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[251])((nint)sem);
			#endif
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SignalSemaphore(SDLSemaphore* sem)
		{
			SignalSemaphoreNative(sem);
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SignalSemaphore(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				SignalSemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSemaphoreValueNative(SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, uint>)funcTable[252])(sem);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[252])((nint)sem);
			#endif
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetSemaphoreValue(SDLSemaphore* sem)
		{
			uint ret = GetSemaphoreValueNative(sem);
			return ret;
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetSemaphoreValue(ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				uint ret = GetSemaphoreValueNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCondition* CreateConditionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*>)funcTable[253])();
			#else
			return (SDLCondition*)((delegate* unmanaged[Cdecl]<nint>)funcTable[253])();
			#endif
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLCondition* CreateCondition()
		{
			SDLCondition* ret = CreateConditionNative();
			return ret;
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyConditionNative(SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, void>)funcTable[254])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[254])((nint)cond);
			#endif
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyCondition(SDLCondition* cond)
		{
			DestroyConditionNative(cond);
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyCondition(ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				DestroyConditionNative((SDLCondition*)pcond);
			}
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalConditionNative(SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, void>)funcTable[255])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[255])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SignalCondition(SDLCondition* cond)
		{
			SignalConditionNative(cond);
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SignalCondition(ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				SignalConditionNative((SDLCondition*)pcond);
			}
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BroadcastConditionNative(SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, void>)funcTable[256])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[256])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void BroadcastCondition(SDLCondition* cond)
		{
			BroadcastConditionNative(cond);
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void BroadcastCondition(ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				BroadcastConditionNative((SDLCondition*)pcond);
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitConditionNative(SDLCondition* cond, SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, SDLMutex*, void>)funcTable[257])(cond, mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[257])((nint)cond, (nint)mutex);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitCondition(SDLCondition* cond, SDLMutex* mutex)
		{
			WaitConditionNative(cond, mutex);
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitCondition(ref SDLCondition cond, SDLMutex* mutex)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				WaitConditionNative((SDLCondition*)pcond, mutex);
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitCondition(SDLCondition* cond, ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				WaitConditionNative(cond, (SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void WaitCondition(ref SDLCondition cond, ref SDLMutex mutex)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					WaitConditionNative((SDLCondition*)pcond, (SDLMutex*)pmutex);
				}
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitConditionTimeoutNative(SDLCondition* cond, SDLMutex* mutex, int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*, SDLMutex*, int, byte>)funcTable[258])(cond, mutex, timeoutMS);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[258])((nint)cond, (nint)mutex, timeoutMS);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitConditionTimeout(SDLCondition* cond, SDLMutex* mutex, int timeoutMS)
		{
			byte ret = WaitConditionTimeoutNative(cond, mutex, timeoutMS);
			return ret != 0;
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitConditionTimeout(ref SDLCondition cond, SDLMutex* mutex, int timeoutMS)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				byte ret = WaitConditionTimeoutNative((SDLCondition*)pcond, mutex, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitConditionTimeout(SDLCondition* cond, ref SDLMutex mutex, int timeoutMS)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				byte ret = WaitConditionTimeoutNative(cond, (SDLMutex*)pmutex, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitConditionTimeout(ref SDLCondition cond, ref SDLMutex mutex, int timeoutMS)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					byte ret = WaitConditionTimeoutNative((SDLCondition*)pcond, (SDLMutex*)pmutex, timeoutMS);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Return whether initialization should be done.<br/>
		/// This function checks the passed in state and if initialization should be<br/>
		/// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.<br/>
		/// If another thread is already modifying this state, it will wait until<br/>
		/// that's done before returning.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShouldInitNative(SDLInitState* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitState*, byte>)funcTable[259])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[259])((nint)state);
			#endif
		}

		/// <summary>
		/// Return whether initialization should be done.<br/>
		/// This function checks the passed in state and if initialization should be<br/>
		/// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.<br/>
		/// If another thread is already modifying this state, it will wait until<br/>
		/// that's done before returning.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ShouldInit(SDLInitState* state)
		{
			byte ret = ShouldInitNative(state);
			return ret != 0;
		}

		/// <summary>
		/// Return whether initialization should be done.<br/>
		/// This function checks the passed in state and if initialization should be<br/>
		/// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.<br/>
		/// If another thread is already modifying this state, it will wait until<br/>
		/// that's done before returning.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ShouldInit(ref SDLInitState state)
		{
			fixed (SDLInitState* pstate = &state)
			{
				byte ret = ShouldInitNative((SDLInitState*)pstate);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether cleanup should be done.<br/>
		/// This function checks the passed in state and if cleanup should be done,<br/>
		/// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the cleanup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShouldQuitNative(SDLInitState* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitState*, byte>)funcTable[260])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[260])((nint)state);
			#endif
		}

		/// <summary>
		/// Return whether cleanup should be done.<br/>
		/// This function checks the passed in state and if cleanup should be done,<br/>
		/// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the cleanup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ShouldQuit(SDLInitState* state)
		{
			byte ret = ShouldQuitNative(state);
			return ret != 0;
		}

		/// <summary>
		/// Return whether cleanup should be done.<br/>
		/// This function checks the passed in state and if cleanup should be done,<br/>
		/// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the cleanup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ShouldQuit(ref SDLInitState state)
		{
			fixed (SDLInitState* pstate = &state)
			{
				byte ret = ShouldQuitNative((SDLInitState*)pstate);
				return ret != 0;
			}
		}

		/// <summary>
		/// Finish an initialization state transition.<br/>
		/// This function sets the status of the passed in state to<br/>
		/// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows<br/>
		/// any threads waiting for the status to proceed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetInitializedNative(SDLInitState* state, byte initialized)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLInitState*, byte, void>)funcTable[261])(state, initialized);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[261])((nint)state, initialized);
			#endif
		}

		/// <summary>
		/// Finish an initialization state transition.<br/>
		/// This function sets the status of the passed in state to<br/>
		/// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows<br/>
		/// any threads waiting for the status to proceed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetInitialized(SDLInitState* state, bool initialized)
		{
			SetInitializedNative(state, initialized ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Finish an initialization state transition.<br/>
		/// This function sets the status of the passed in state to<br/>
		/// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows<br/>
		/// any threads waiting for the status to proceed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetInitialized(ref SDLInitState state, bool initialized)
		{
			fixed (SDLInitState* pstate = &state)
			{
				SetInitializedNative((SDLInitState*)pstate, initialized ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromFileNative(byte* file, byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLIOStream*>)funcTable[262])(file, mode);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[262])((nint)file, (nint)mode);
			#endif
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(byte* file, byte* mode)
		{
			SDLIOStream* ret = IOFromFileNative(file, mode);
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(ref byte file, byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLIOStream* ret = IOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(ReadOnlySpan<byte> file, byte* mode)
		{
			fixed (byte* pfile = file)
			{
				SDLIOStream* ret = IOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(string file, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(byte* file, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLIOStream* ret = IOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(byte* file, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				SDLIOStream* ret = IOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(byte* file, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(ref byte file, ref byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLIOStream* ret = IOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLIOStream* IOFromFile(ReadOnlySpan<byte> file, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfile = file)
			{
				fixed (byte* pmode = mode)
				{
					SDLIOStream* ret = IOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}
	}
}
