// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = LoadFileAsyncNative(pStr0, queue, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = LoadFileAsyncNative(file, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = &file)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = file)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = LoadFileAsyncNative((byte*)pfile, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = LoadFileAsyncNative(pStr0, (SDLAsyncIOQueue*)pqueue, userdata);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockSpinlock")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockSpinlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte>)funcTable[181])(lock0);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[181])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockSpinlock")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			byte ret = TryLockSpinlockNative(lock0);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockSpinlock")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				byte ret = TryLockSpinlockNative((int*)plock0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockSpinlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[182])(lock0);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[182])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			LockSpinlockNative(lock0);
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				LockSpinlockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockSpinlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[183])(lock0);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[183])((nint)lock0);
			#endif
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] int* lock0)
		{
			UnlockSpinlockNative(lock0);
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSpinlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSpinlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock *")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				UnlockSpinlockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Insert a memory release barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierReleaseFunctionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[184])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[184])();
			#endif
		}

		/// <summary>
		/// Insert a memory release barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MemoryBarrierReleaseFunction()
		{
			MemoryBarrierReleaseFunctionNative();
		}

		/// <summary>
		/// Insert a memory acquire barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierAcquireFunctionNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[185])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[185])();
			#endif
		}

		/// <summary>
		/// Insert a memory acquire barrier (function version).<br/>
		/// Please refer to SDL_MemoryBarrierRelease for details. This is a function<br/>
		/// version, which might be useful if you need to use this functionality from a<br/>
		/// scripting language, etc. Also, some of the macro versions call this<br/>
		/// function behind the scenes, where more heavy lifting can happen inside of<br/>
		/// SDL. Generally, though, an app written in C/C++/etc should use the macro<br/>
		/// version, as it will be more efficient.<br/>
		/// <br/>
		/// Obviously this function is safe to use from any thread at any<br/>
		/// time, but if you find yourself needing this, you are probably<br/>
		/// dealing with some very sensitive code; be careful!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MemoryBarrierAcquireFunction()
		{
			MemoryBarrierAcquireFunctionNative();
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicInt")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompareAndSwapAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int, int, byte>)funcTable[186])(a, oldval, newval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[186])((nint)a, oldval, newval);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicInt")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			byte ret = CompareAndSwapAtomicIntNative(a, oldval, newval);
			return ret != 0;
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicInt")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				byte ret = CompareAndSwapAtomicIntNative((SDLAtomicInt*)pa, oldval, newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int, int>)funcTable[187])(a, v);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[187])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = SetAtomicIntNative(a, v);
			return ret;
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				int ret = SetAtomicIntNative((SDLAtomicInt*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int>)funcTable[188])(a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[188])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a)
		{
			int ret = GetAtomicIntNative(a);
			return ret;
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				int ret = GetAtomicIntNative((SDLAtomicInt*)pa);
				return ret;
			}
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddAtomicIntNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicInt*, int, int>)funcTable[189])(a, v);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[189])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] SDLAtomicInt* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = AddAtomicIntNative(a, v);
			return ret;
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddAtomicInt")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int AddAtomicInt([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicInt *")] ref SDLAtomicInt a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			fixed (SDLAtomicInt* pa = &a)
			{
				int ret = AddAtomicIntNative((SDLAtomicInt*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicU32")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompareAndSwapAtomicU32Native([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "Uint32")] uint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "Uint32")] uint newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicU32*, uint, uint, byte>)funcTable[190])(a, oldval, newval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, uint, byte>)funcTable[190])((nint)a, oldval, newval);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicU32")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "Uint32")] uint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "Uint32")] uint newval)
		{
			byte ret = CompareAndSwapAtomicU32Native(a, oldval, newval);
			return ret != 0;
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicU32")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] ref SDLAtomicU32 a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "Uint32")] uint oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "Uint32")] uint newval)
		{
			fixed (SDLAtomicU32* pa = &a)
			{
				byte ret = CompareAndSwapAtomicU32Native((SDLAtomicU32*)pa, oldval, newval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint SetAtomicU32Native([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "Uint32")] uint v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicU32*, uint, uint>)funcTable[191])(a, v);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint, uint>)funcTable[191])((nint)a, v);
			#endif
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "Uint32")] uint v)
		{
			uint ret = SetAtomicU32Native(a, v);
			return ret;
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] ref SDLAtomicU32 a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "Uint32")] uint v)
		{
			fixed (SDLAtomicU32* pa = &a)
			{
				uint ret = SetAtomicU32Native((SDLAtomicU32*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetAtomicU32Native([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAtomicU32*, uint>)funcTable[192])(a);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[192])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] SDLAtomicU32* a)
		{
			uint ret = GetAtomicU32Native(a);
			return ret;
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicU32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetAtomicU32([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_AtomicU32 *")] ref SDLAtomicU32 a)
		{
			fixed (SDLAtomicU32* pa = &a)
			{
				uint ret = GetAtomicU32Native((SDLAtomicU32*)pa);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompareAndSwapAtomicPointerNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] void* newval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*, void*, byte>)funcTable[193])(a, oldval, newval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[193])((nint)a, (nint)oldval, (nint)newval);
			#endif
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CompareAndSwapAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CompareAndSwapAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void *")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void *")] void* newval)
		{
			byte ret = CompareAndSwapAtomicPointerNative(a, oldval, newval);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* SetAtomicPointerNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void *")] void* v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*, void*>)funcTable[194])(a, v);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[194])((nint)a, (nint)v);
			#endif
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* SetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void *")] void* v)
		{
			void* ret = SetAtomicPointerNative(a, v);
			return ret;
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetAtomicPointerNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, void*>)funcTable[195])(a);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[195])((nint)a);
			#endif
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAtomicPointer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetAtomicPointer([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void * *")] void** a)
		{
			void* ret = GetAtomicPointerNative(a);
			return ret;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetErrorNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[196])(fmt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[196])((nint)fmt);
			#endif
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			byte ret = SetErrorNative(fmt);
			return ret != 0;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = SetErrorNative((byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = SetErrorNative((byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns false, since SDL frequently uses false to<br/>
		/// signify a failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetErrorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetErrorVNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nint, byte>)funcTable[197])(fmt, ap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[197])((nint)fmt, ap);
			#endif
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte ret = SetErrorVNative(fmt, ap);
			return ret != 0;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = SetErrorVNative((byte*)pfmt, ap);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = SetErrorVNative((byte*)pfmt, ap);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetErrorVNative(pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set an error indicating that memory allocation failed.<br/>
		/// This function does not do any memory allocation.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OutOfMemory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte OutOfMemoryNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[198])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[198])();
			#endif
		}

		/// <summary>
		/// Set an error indicating that memory allocation failed.<br/>
		/// This function does not do any memory allocation.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OutOfMemory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool OutOfMemory()
		{
			byte ret = OutOfMemoryNative();
			return ret != 0;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned value is a thread-local string which will remain valid until<br/>
		/// the current thread's error string is changed. The caller should make a copy<br/>
		/// if the value is needed after the next SDL API call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[199])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[199])();
			#endif
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned value is a thread-local string which will remain valid until<br/>
		/// the current thread's error string is changed. The caller should make a copy<br/>
		/// if the value is needed after the next SDL API call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetError()
		{
			byte* ret = GetErrorNative();
			return ret;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned value is a thread-local string which will remain valid until<br/>
		/// the current thread's error string is changed. The caller should make a copy<br/>
		/// if the value is needed after the next SDL API call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetErrorS()
		{
			string ret = Utils.DecodeStringUTF8(GetErrorNative());
			return ret;
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[200])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[200])();
			#endif
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearError()
		{
			byte ret = ClearErrorNative();
			return ret != 0;
		}

		/// <summary>
		/// Get the global SDL properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGlobalPropertiesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[201])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[201])();
			#endif
		}

		/// <summary>
		/// Get the global SDL properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetGlobalProperties()
		{
			uint ret = GetGlobalPropertiesNative();
			return ret;
		}

		/// <summary>
		/// Create a group of properties.<br/>
		/// All properties are automatically destroyed when SDL_Quit() is called.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreatePropertiesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[202])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[202])();
			#endif
		}

		/// <summary>
		/// Create a group of properties.<br/>
		/// All properties are automatically destroyed when SDL_Quit() is called.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint CreateProperties()
		{
			uint ret = CreatePropertiesNative();
			return ret;
		}

		/// <summary>
		/// Copy a group of properties.<br/>
		/// Copy all the properties from one group of properties to another, with the<br/>
		/// exception of properties requiring cleanup (set using<br/>
		/// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any<br/>
		/// property that already exists on `dst` will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CopyPropertiesNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint src, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, byte>)funcTable[203])(src, dst);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, uint, byte>)funcTable[203])(src, dst);
			#endif
		}

		/// <summary>
		/// Copy a group of properties.<br/>
		/// Copy all the properties from one group of properties to another, with the<br/>
		/// exception of properties requiring cleanup (set using<br/>
		/// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any<br/>
		/// property that already exists on `dst` will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyProperties([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint src, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dst)
		{
			byte ret = CopyPropertiesNative(src, dst);
			return ret != 0;
		}

		/// <summary>
		/// Lock a group of properties.<br/>
		/// Obtain a multi-threaded lock for these properties. Other threads will wait<br/>
		/// while trying to lock these properties until they are unlocked. Properties<br/>
		/// must be unlocked before they are destroyed.<br/>
		/// The lock is automatically taken when setting individual properties, this<br/>
		/// function is only needed when you want to set several properties atomically<br/>
		/// or want to guarantee that properties being queried aren't freed in another<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LockPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[204])(props);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[204])(props);
			#endif
		}

		/// <summary>
		/// Lock a group of properties.<br/>
		/// Obtain a multi-threaded lock for these properties. Other threads will wait<br/>
		/// while trying to lock these properties until they are unlocked. Properties<br/>
		/// must be unlocked before they are destroyed.<br/>
		/// The lock is automatically taken when setting individual properties, this<br/>
		/// function is only needed when you want to set several properties atomically<br/>
		/// or want to guarantee that properties being queried aren't freed in another<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LockProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			byte ret = LockPropertiesNative(props);
			return ret != 0;
		}

		/// <summary>
		/// Unlock a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[205])(props);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[205])(props);
			#endif
		}

		/// <summary>
		/// Unlock a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			UnlockPropertiesNative(props);
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetPointerPropertyWithCleanupNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, delegate*<void*, void*, void>, void*, byte>)funcTable[206])(props, name, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, byte>)funcTable[206])(props, (nint)name, (nint)value, (nint)Utils.GetFunctionPointerForDelegate(cleanup), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, value, cleanup, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, value, cleanup, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetPointerPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, byte>)funcTable[207])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[207])(props, (nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			byte ret = SetPointerPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetStringPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, byte>)funcTable[208])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[208])(props, (nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte ret = SetStringPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetStringPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetStringPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetStringPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				byte ret = SetStringPropertyNative(props, name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pvalue = value)
			{
				byte ret = SetStringPropertyNative(props, name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetStringPropertyNative(props, name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = SetStringPropertyNative(props, (byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetStringPropertyNative(props, (byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetNumberPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, byte>)funcTable[209])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, long, byte>)funcTable[209])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			byte ret = SetNumberPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetNumberPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetFloatPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, byte>)funcTable[210])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, float, byte>)funcTable[210])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			byte ret = SetFloatPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetFloatPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetBooleanPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte, byte>)funcTable[211])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte, byte>)funcTable[211])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			byte ret = SetBooleanPropertyNative(props, name, value ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetBooleanPropertyNative(props, (byte*)pname, value ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetBooleanPropertyNative(props, (byte*)pname, value ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetBooleanPropertyNative(props, pStr0, value ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte>)funcTable[212])(props, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte>)funcTable[212])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = HasPropertyNative(props, name);
			return ret != 0;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = HasPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = HasPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = HasPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPropertyType GetPropertyTypeNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, SDLPropertyType>)funcTable[213])(props, name);
			#else
			return (SDLPropertyType)((delegate* unmanaged[Cdecl]<uint, nint, SDLPropertyType>)funcTable[213])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			SDLPropertyType ret = GetPropertyTypeNative(props, name);
			return ret;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLPropertyType ret = GetPropertyTypeNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetPointerPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, void*>)funcTable[214])(props, name, defaultValue);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[214])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			void* ret = GetPointerPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			fixed (byte* pname = name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetPointerPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, byte*>)funcTable[215])(props, name, defaultValue);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[215])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* ret = GetStringPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, defaultValue));
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, defaultValue));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetNumberPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, long>)funcTable[216])(props, name, defaultValue);
			#else
			return (long)((delegate* unmanaged[Cdecl]<uint, nint, long, long>)funcTable[216])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			long ret = GetNumberPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			fixed (byte* pname = &name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			fixed (byte* pname = name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = GetNumberPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFloatPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, float>)funcTable[217])(props, name, defaultValue);
			#else
			return (float)((delegate* unmanaged[Cdecl]<uint, nint, float, float>)funcTable[217])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			float ret = GetFloatPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			fixed (byte* pname = &name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			fixed (byte* pname = name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			float ret = GetFloatPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetBooleanPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] byte defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte, byte>)funcTable[218])(props, name, defaultValue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte, byte>)funcTable[218])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			byte ret = GetBooleanPropertyNative(props, name, defaultValue ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GetBooleanPropertyNative(props, pStr0, defaultValue ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte>)funcTable[219])(props, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte>)funcTable[219])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = ClearPropertyNative(props, name);
			return ret != 0;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ClearPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = ClearPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ClearPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EnumeratePropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] SDLEnumeratePropertiesCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void*, uint, byte*, void>, void*, byte>)funcTable[220])(props, (delegate*<void*, uint, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[220])(props, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] SDLEnumeratePropertiesCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = EnumeratePropertiesNative(props, callback, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[221])(props);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[221])(props);
			#endif
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			DestroyPropertiesNative(props);
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadRuntimeNative([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, int>, byte*, void*, delegate*<void>, delegate*<void>, SDLThread*>)funcTable[222])((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint>)funcTable[222])((nint)Utils.GetFunctionPointerForDelegate(fn), (nint)name, (nint)data, (nint)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (nint)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#endif
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThread* ret = CreateThreadRuntimeNative(fn, name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThread* ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = CreateThreadRuntimeNative(fn, pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// The actual entry point for SDL_CreateThreadWithProperties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithPropertiesRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadWithPropertiesRuntimeNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void>, delegate*<void>, SDLThread*>)funcTable[223])(props, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[223])(props, (nint)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (nint)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#endif
		}

		/// <summary>
		/// The actual entry point for SDL_CreateThreadWithProperties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithPropertiesRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadWithPropertiesRuntime([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThread* ret = CreateThreadWithPropertiesRuntimeNative(props, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetThreadNameNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, byte*>)funcTable[224])(thread);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[224])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetThreadName([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			byte* ret = GetThreadNameNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetThreadNameS([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			string ret = Utils.DecodeStringUTF8(GetThreadNameNative(thread));
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetThreadName([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				byte* ret = GetThreadNameNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetThreadNameS([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				string ret = Utils.DecodeStringUTF8(GetThreadNameNative((SDLThread*)pthread));
				return ret;
			}
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetCurrentThreadIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[225])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[225])();
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		public static ulong GetCurrentThreadID()
		{
			ulong ret = GetCurrentThreadIDNative();
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetThreadIDNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, ulong>)funcTable[226])(thread);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[226])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		public static ulong GetThreadID([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			ulong ret = GetThreadIDNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		public static ulong GetThreadID([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				ulong ret = GetThreadIDNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCurrentThreadPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetCurrentThreadPriorityNative([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThreadPriority, byte>)funcTable[227])(priority);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLThreadPriority, byte>)funcTable[227])(priority);
			#endif
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCurrentThreadPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetCurrentThreadPriority([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority)
		{
			byte ret = SetCurrentThreadPriorityNative(priority);
			return ret != 0;
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] int* status)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, int*, void>)funcTable[228])(thread, status);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[228])((nint)thread, (nint)status);
			#endif
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] int* status)
		{
			WaitThreadNative(thread, status);
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] int* status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				WaitThreadNative((SDLThread*)pthread, status);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] ref int status)
		{
			fixed (int* pstatus = &status)
			{
				WaitThreadNative(thread, (int*)pstatus);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain until this function cleans<br/>
		/// them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code from the thread function is placed in the area pointed to<br/>
		/// by `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] ref int status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				fixed (int* pstatus = &status)
				{
					WaitThreadNative((SDLThread*)pthread, (int*)pstatus);
				}
			}
		}

		/// <summary>
		/// Get the current state of a thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadState")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadState")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThreadState GetThreadStateNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, SDLThreadState>)funcTable[229])(thread);
			#else
			return (SDLThreadState)((delegate* unmanaged[Cdecl]<nint, SDLThreadState>)funcTable[229])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the current state of a thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadState")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadState")]
		public static SDLThreadState GetThreadState([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			SDLThreadState ret = GetThreadStateNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the current state of a thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadState")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadState")]
		public static SDLThreadState GetThreadState([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				SDLThreadState ret = GetThreadStateNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, void>)funcTable[230])(thread);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[230])((nint)thread);
			#endif
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			DetachThreadNative(thread);
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				DetachThreadNative((SDLThread*)pthread);
			}
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTLS")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetTLSNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, void*>)funcTable[231])(id);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[231])((nint)id);
			#endif
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTLS")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id)
		{
			void* ret = GetTLSNative(id);
			return ret;
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTLS")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] ref uint id)
		{
			fixed (uint* pid = &id)
			{
				void* ret = GetTLSNative((uint*)pid);
				return ret;
			}
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTLS")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTLSNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "SDL_TLSDestructorCallback")] SDLTLSDestructorCallback destructor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, void*, delegate*<void*, void>, byte>)funcTable[232])(id, value, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(destructor));
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[232])((nint)id, (nint)value, (nint)Utils.GetFunctionPointerForDelegate(destructor));
			#endif
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTLS")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "SDL_TLSDestructorCallback")] SDLTLSDestructorCallback destructor)
		{
			byte ret = SetTLSNative(id, value, destructor);
			return ret != 0;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTLS")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] ref uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "SDL_TLSDestructorCallback")] SDLTLSDestructorCallback destructor)
		{
			fixed (uint* pid = &id)
			{
				byte ret = SetTLSNative((uint*)pid, value, destructor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// If you are creating your threads outside of SDL and then calling SDL<br/>
		/// functions, you should call this function before your thread exits, to<br/>
		/// properly clean up SDL memory.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CleanupTLS")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CleanupTLSNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[233])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[233])();
			#endif
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// If you are creating your threads outside of SDL and then calling SDL<br/>
		/// functions, you should call this function before your thread exits, to<br/>
		/// properly clean up SDL memory.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CleanupTLS")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CleanupTLS()
		{
			CleanupTLSNative();
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateMutex")]
		[return: NativeName(NativeNameType.Type, "SDL_Mutex *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLMutex* CreateMutexNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*>)funcTable[234])();
			#else
			return (SDLMutex*)((delegate* unmanaged[Cdecl]<nint>)funcTable[234])();
			#endif
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateMutex")]
		[return: NativeName(NativeNameType.Type, "SDL_Mutex *")]
		public static SDLMutex* CreateMutex()
		{
			SDLMutex* ret = CreateMutexNative();
			return ret;
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// This function does not fail; if mutex is NULL, it will return immediately<br/>
		/// having locked nothing. If the mutex is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMutex*, void>)funcTable[235])(mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[235])((nint)mutex);
			#endif
		}
	}
}
