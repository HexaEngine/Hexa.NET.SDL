// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
							{
								byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUSwapchain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUSwapchainNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, byte>)funcTable[910])(device, window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[910])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUSwapchain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUSwapchain([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = WaitForGPUSwapchainNative(device, window);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUSwapchain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUSwapchain([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUSwapchainNative((SDLGPUDevice*)pdevice, window);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUSwapchain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUSwapchain([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WaitForGPUSwapchainNative(device, (SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUSwapchain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUSwapchain([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WaitForGPUSwapchainNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitAndAcquireGPUSwapchainTextureNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLWindow*, SDLGPUTexture**, uint*, uint*, byte>)funcTable[911])(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[911])((nint)commandBuffer, (nint)window, (nint)swapchainTexture, (nint)swapchainTextureWidth, (nint)swapchainTextureHeight);
			#endif
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
							{
								byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SubmitGPUCommandBufferNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte>)funcTable[912])(commandBuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[912])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SubmitGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			byte ret = SubmitGPUCommandBufferNative(commandBuffer);
			return ret != 0;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SubmitGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = SubmitGPUCommandBufferNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFenceNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUFence*>)funcTable[913])(commandBuffer);
			#else
			return (SDLGPUFence*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[913])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		public static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFence([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			SDLGPUFence* ret = SubmitGPUCommandBufferAndAcquireFenceNative(commandBuffer);
			return ret;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		public static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFence([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUFence* ret = SubmitGPUCommandBufferAndAcquireFenceNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret;
			}
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CancelGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CancelGPUCommandBufferNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte>)funcTable[914])(commandBuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[914])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CancelGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CancelGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			byte ret = CancelGPUCommandBufferNative(commandBuffer);
			return ret != 0;
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CancelGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CancelGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = CancelGPUCommandBufferNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUIdleNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte>)funcTable[915])(device);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[915])((nint)device);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUIdle([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			byte ret = WaitForGPUIdleNative(device);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUIdle([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUIdleNative((SDLGPUDevice*)pdevice);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUFencesNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] byte waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte, SDLGPUFence**, uint, byte>)funcTable[916])(device, waitAll, fences, numFences);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, nint, uint, byte>)funcTable[916])((nint)device, waitAll, (nint)fences, numFences);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			byte ret = WaitForGPUFencesNative(device, waitAll ? (byte)1 : (byte)0, fences, numFences);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, fences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] ref SDLGPUFence* fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUFence** pfences = &fences)
			{
				byte ret = WaitForGPUFencesNative(device, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] ref SDLGPUFence* fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence** pfences = &fences)
				{
					byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte QueryGPUFenceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, byte>)funcTable[917])(device, fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[917])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			byte ret = QueryGPUFenceNative(device, fence);
			return ret != 0;
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, fence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				byte ret = QueryGPUFenceNative(device, (SDLGPUFence*)pfence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUFenceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, void>)funcTable[918])(device, fence);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[918])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			ReleaseGPUFenceNative(device, fence);
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, fence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				ReleaseGPUFenceNative(device, (SDLGPUFence*)pfence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
				}
			}
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureFormatTexelBlockSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GPUTextureFormatTexelBlockSizeNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[919])(format);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[919])(format);
			#endif
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureFormatTexelBlockSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GPUTextureFormatTexelBlockSize([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			uint ret = GPUTextureFormatTexelBlockSizeNative(format);
			return ret;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsFormatNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] SDLGPUTextureUsageFlags usage)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUTextureType, SDLGPUTextureUsageFlags, byte>)funcTable[920])(device, format, type, usage);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUTextureType, SDLGPUTextureUsageFlags, byte>)funcTable[920])((nint)device, format, type, usage);
			#endif
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] SDLGPUTextureUsageFlags usage)
		{
			byte ret = GPUTextureSupportsFormatNative(device, format, type, usage);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] SDLGPUTextureUsageFlags usage)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsFormatNative((SDLGPUDevice*)pdevice, format, type, usage);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsSampleCountNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[921])(device, format, sampleCount);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[921])((nint)device, format, sampleCount);
			#endif
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsSampleCount([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			byte ret = GPUTextureSupportsSampleCountNative(device, format, sampleCount);
			return ret != 0;
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsSampleCount([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsSampleCountNative((SDLGPUDevice*)pdevice, format, sampleCount);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the size in bytes of a texture format with dimensions.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGPUTextureFormatSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalculateGPUTextureFormatSizeNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "Uint32")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "Uint32")] uint height, [NativeName(NativeNameType.Param, "depth_or_layer_count")] [NativeName(NativeNameType.Type, "Uint32")] uint depthOrLayerCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint, uint, uint, uint>)funcTable[922])(format, width, height, depthOrLayerCount);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint, uint, uint, uint>)funcTable[922])(format, width, height, depthOrLayerCount);
			#endif
		}

		/// <summary>
		/// Calculate the size in bytes of a texture format with dimensions.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGPUTextureFormatSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint CalculateGPUTextureFormatSize([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "Uint32")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "Uint32")] uint height, [NativeName(NativeNameType.Param, "depth_or_layer_count")] [NativeName(NativeNameType.Type, "Uint32")] uint depthOrLayerCount)
		{
			uint ret = CalculateGPUTextureFormatSizeNative(format, width, height, depthOrLayerCount);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetHapticsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[923])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[923])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		public static uint* GetHaptics([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetHapticsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		public static uint* GetHaptics([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetHapticsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[924])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[924])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			byte* ret = GetHapticNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHaptic")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[925])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[925])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHaptic")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHaptic([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			SDLHaptic* ret = OpenHapticNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* GetHapticFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[926])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[926])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* GetHapticFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			SDLHaptic* ret = GetHapticFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticIDNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[927])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[927])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		public static uint GetHapticID([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			uint ret = GetHapticIDNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		public static uint GetHapticID([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticIDNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte*>)funcTable[928])(haptic);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[928])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticName([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte* ret = GetHapticNameNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameS([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameNative(haptic));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticName([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte* ret = GetHapticNameNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameS([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				string ret = Utils.DecodeStringUTF8(GetHapticNameNative((SDLHaptic*)phaptic));
				return ret;
			}
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMouseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseHapticNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[929])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[929])();
			#endif
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMouseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseHaptic()
		{
			byte ret = IsMouseHapticNative();
			return ret != 0;
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromMouseNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*>)funcTable[930])();
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint>)funcTable[930])();
			#endif
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHapticFromMouse()
		{
			SDLHaptic* ret = OpenHapticFromMouseNative();
			return ret;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJoystickHapticNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte>)funcTable[931])(joystick);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[931])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJoystickHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte ret = IsJoystickHapticNative(joystick);
			return ret != 0;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJoystickHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = IsJoystickHapticNative((SDLJoystick*)pjoystick);
				return ret != 0;
			}
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromJoystickNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLHaptic*>)funcTable[932])(joystick);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[932])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHapticFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			SDLHaptic* ret = OpenHapticFromJoystickNative(joystick);
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHapticFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLHaptic* ret = OpenHapticFromJoystickNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHaptic*, void>)funcTable[933])(haptic);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[933])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			CloseHapticNative(haptic);
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				CloseHapticNative((SDLHaptic*)phaptic);
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[934])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[934])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = GetMaxHapticEffectsNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsPlayingNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[935])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[935])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = GetMaxHapticEffectsPlayingNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsPlayingNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticFeaturesNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[936])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[936])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetHapticFeatures([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			uint ret = GetHapticFeaturesNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetHapticFeatures([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticFeaturesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumHapticAxesNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[937])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[937])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = GetNumHapticAxesNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetNumHapticAxesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HapticEffectSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, byte>)funcTable[938])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[938])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			byte ret = HapticEffectSupportedNative(haptic, effect);
			return ret != 0;
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				byte ret = HapticEffectSupportedNative(haptic, (SDLHapticEffect*)peffect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, int>)funcTable[939])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[939])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			int ret = CreateHapticEffectNative(haptic, effect);
			return ret;
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				int ret = CreateHapticEffectNative(haptic, (SDLHapticEffect*)peffect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, SDLHapticEffect*, byte>)funcTable[940])(haptic, effect, data);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, byte>)funcTable[940])((nint)haptic, effect, (nint)data);
			#endif
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			byte ret = UpdateHapticEffectNative(haptic, effect, data);
			return ret != 0;
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = UpdateHapticEffectNative((SDLHaptic*)phaptic, effect, data);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect data)
		{
			fixed (SDLHapticEffect* pdata = &data)
			{
				byte ret = UpdateHapticEffectNative(haptic, effect, (SDLHapticEffect*)pdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* pdata = &data)
				{
					byte ret = UpdateHapticEffectNative((SDLHaptic*)phaptic, effect, (SDLHapticEffect*)pdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RunHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, uint, byte>)funcTable[941])(haptic, effect, iterations);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, uint, byte>)funcTable[941])((nint)haptic, effect, iterations);
			#endif
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RunHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			byte ret = RunHapticEffectNative(haptic, effect, iterations);
			return ret != 0;
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RunHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = RunHapticEffectNative((SDLHaptic*)phaptic, effect, iterations);
				return ret != 0;
			}
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StopHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[942])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[942])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			byte ret = StopHapticEffectNative(haptic, effect);
			return ret != 0;
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = StopHapticEffectNative((SDLHaptic*)phaptic, effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHaptic*, int, void>)funcTable[943])(haptic, effect);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[943])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			DestroyHapticEffectNative(haptic, effect);
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				DestroyHapticEffectNative((SDLHaptic*)phaptic, effect);
			}
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetHapticEffectStatusNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[944])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[944])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHapticEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			byte ret = GetHapticEffectStatusNative(haptic, effect);
			return ret != 0;
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHapticEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = GetHapticEffectStatusNative((SDLHaptic*)phaptic, effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetHapticGainNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[945])(haptic, gain);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[945])((nint)haptic, gain);
			#endif
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			byte ret = SetHapticGainNative(haptic, gain);
			return ret != 0;
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = SetHapticGainNative((SDLHaptic*)phaptic, gain);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetHapticAutocenterNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[946])(haptic, autocenter);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[946])((nint)haptic, autocenter);
			#endif
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			byte ret = SetHapticAutocenterNative(haptic, autocenter);
			return ret != 0;
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = SetHapticAutocenterNative((SDLHaptic*)phaptic, autocenter);
				return ret != 0;
			}
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PauseHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[947])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[947])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PauseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte ret = PauseHapticNative(haptic);
			return ret != 0;
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PauseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = PauseHapticNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ResumeHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[948])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[948])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResumeHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte ret = ResumeHapticNative(haptic);
			return ret != 0;
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResumeHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = ResumeHapticNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StopHapticEffectsNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[949])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[949])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte ret = StopHapticEffectsNative(haptic);
			return ret != 0;
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = StopHapticEffectsNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HapticRumbleSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[950])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[950])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte ret = HapticRumbleSupportedNative(haptic);
			return ret != 0;
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = HapticRumbleSupportedNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[951])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[951])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool InitHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte ret = InitHapticRumbleNative(haptic);
			return ret != 0;
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool InitHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = InitHapticRumbleNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PlayHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, float, uint, byte>)funcTable[952])(haptic, strength, length);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, uint, byte>)funcTable[952])((nint)haptic, strength, length);
			#endif
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PlayHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			byte ret = PlayHapticRumbleNative(haptic, strength, length);
			return ret != 0;
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PlayHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = PlayHapticRumbleNative((SDLHaptic*)phaptic, strength, length);
				return ret != 0;
			}
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StopHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[953])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[953])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte ret = StopHapticRumbleNative(haptic);
			return ret != 0;
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = StopHapticRumbleNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Initialize the HIDAPI library.<br/>
		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
		/// be called at the beginning of execution however, if there is a chance of<br/>
		/// HIDAPI handles being opened by different threads simultaneously.<br/>
		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidInitNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[954])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[954])();
			#endif
		}

		/// <summary>
		/// Initialize the HIDAPI library.<br/>
		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
		/// be called at the beginning of execution however, if there is a chance of<br/>
		/// HIDAPI handles being opened by different threads simultaneously.<br/>
		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidInit()
		{
			int ret = HidInitNative();
			return ret;
		}

		/// <summary>
		/// Finalize the HIDAPI library.<br/>
		/// This function frees all of the static data associated with HIDAPI. It<br/>
		/// should be called at the end of execution to avoid memory leaks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidExitNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[955])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[955])();
			#endif
		}

		/// <summary>
		/// Finalize the HIDAPI library.<br/>
		/// This function frees all of the static data associated with HIDAPI. It<br/>
		/// should be called at the end of execution to avoid memory leaks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidExit()
		{
			int ret = HidExitNative();
			return ret;
		}

		/// <summary>
		/// Check to see if devices may have been added or removed.<br/>
		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
		/// to see if there have been any system device changes since the last call to<br/>
		/// this function. A change in the counter returned doesn't necessarily mean<br/>
		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
		/// updated device list.<br/>
		/// Calling this function for the first time may cause a thread or other system<br/>
		/// resource to be allocated to track device change notifications.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint HidDeviceChangeCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[956])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[956])();
			#endif
		}

		/// <summary>
		/// Check to see if devices may have been added or removed.<br/>
		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
		/// to see if there have been any system device changes since the last call to<br/>
		/// this function. A change in the counter returned doesn't necessarily mean<br/>
		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
		/// updated device list.<br/>
		/// Calling this function for the first time may cause a thread or other system<br/>
		/// resource to be allocated to track device change notifications.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint HidDeviceChangeCount()
		{
			uint ret = HidDeviceChangeCountNative();
			return ret;
		}

		/// <summary>
		/// Enumerate the HID Devices.<br/>
		/// This function returns a linked list of all the HID devices attached to the<br/>
		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
		/// devices will be returned.<br/>
		/// By default SDL will only enumerate controllers, to reduce risk of hanging<br/>
		/// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS<br/>
		/// can be set to "0" to enumerate all HID devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDeviceInfo* HidEnumerateNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, SDLHidDeviceInfo*>)funcTable[957])(vendorId, productId);
			#else
			return (SDLHidDeviceInfo*)((delegate* unmanaged[Cdecl]<ushort, ushort, nint>)funcTable[957])(vendorId, productId);
			#endif
		}

		/// <summary>
		/// Enumerate the HID Devices.<br/>
		/// This function returns a linked list of all the HID devices attached to the<br/>
		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
		/// devices will be returned.<br/>
		/// By default SDL will only enumerate controllers, to reduce risk of hanging<br/>
		/// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS<br/>
		/// can be set to "0" to enumerate all HID devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		public static SDLHidDeviceInfo* HidEnumerate([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId)
		{
			SDLHidDeviceInfo* ret = HidEnumerateNative(vendorId, productId);
			return ret;
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HidFreeEnumerationNative([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] SDLHidDeviceInfo* devs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHidDeviceInfo*, void>)funcTable[958])(devs);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[958])((nint)devs);
			#endif
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] SDLHidDeviceInfo* devs)
		{
			HidFreeEnumerationNative(devs);
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] ref SDLHidDeviceInfo devs)
		{
			fixed (SDLHidDeviceInfo* pdevs = &devs)
			{
				HidFreeEnumerationNative((SDLHidDeviceInfo*)pdevs);
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDevice* HidOpenNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] char* serialNumber)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, char*, SDLHidDevice*>)funcTable[959])(vendorId, productId, serialNumber);
			#else
			return (SDLHidDevice*)((delegate* unmanaged[Cdecl]<ushort, ushort, nint, nint>)funcTable[959])(vendorId, productId, (nint)serialNumber);
			#endif
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] char* serialNumber)
		{
			SDLHidDevice* ret = HidOpenNative(vendorId, productId, serialNumber);
			return ret;
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] ref char serialNumber)
		{
			fixed (char* pserialNumber = &serialNumber)
			{
				SDLHidDevice* ret = HidOpenNative(vendorId, productId, (char*)pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] ReadOnlySpan<char> serialNumber)
		{
			fixed (char* pserialNumber = serialNumber)
			{
				SDLHidDevice* ret = HidOpenNative(vendorId, productId, (char*)pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar const *")] string serialNumber)
		{
			fixed (char* pserialNumber = serialNumber)
			{
				SDLHidDevice* ret = HidOpenNative(vendorId, productId, pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDevice* HidOpenPathNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLHidDevice*>)funcTable[960])(path);
			#else
			return (SDLHidDevice*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[960])((nint)path);
			#endif
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			SDLHidDevice* ret = HidOpenPathNative(path);
			return ret;
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				SDLHidDevice* ret = HidOpenPathNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				SDLHidDevice* ret = HidOpenPathNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevice* HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLHidDevice* ret = HidOpenPathNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidWriteNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[961])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[961])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidWriteNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidWriteNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidWriteNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidWriteNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidReadTimeoutNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int, int>)funcTable[962])(dev, data, length, milliseconds);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int, int>)funcTable[962])((nint)dev, (nint)data, length, milliseconds);
			#endif
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			int ret = HidReadTimeoutNative(dev, data, length, milliseconds);
			return ret;
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidReadTimeoutNative((SDLHidDevice*)pdev, data, length, milliseconds);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidReadTimeoutNative(dev, (byte*)pdata, length, milliseconds);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidReadTimeoutNative((SDLHidDevice*)pdev, (byte*)pdata, length, milliseconds);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidReadNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[963])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[963])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidReadNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidReadNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidReadNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidReadNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidSetNonblockingNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int, int>)funcTable[964])(dev, nonblock);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[964])((nint)dev, nonblock);
			#endif
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			int ret = HidSetNonblockingNative(dev, nonblock);
			return ret;
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidSetNonblockingNative((SDLHidDevice*)pdev, nonblock);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidSendFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[965])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[965])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidSendFeatureReportNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidSendFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidSendFeatureReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidSendFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}
	}
}
