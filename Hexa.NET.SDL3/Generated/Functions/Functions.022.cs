// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Start accepting Unicode text input events in a window, with properties<br/>
		/// describing the input.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard and/or<br/>
		/// activates an IME, which can prevent some key press events from being passed<br/>
		/// through.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that<br/>
		/// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.<br/>
		/// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value<br/>
		/// that describes how text should be capitalized, defaults to<br/>
		/// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for<br/>
		/// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail<br/>
		/// addresses, usernames, and passwords.<br/>
		/// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion<br/>
		/// and auto correction, defaults to true.<br/>
		/// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text<br/>
		/// are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is<br/>
		/// "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME<br/>
		/// is "1".<br/>
		/// On Android you can directly specify the input type:<br/>
		/// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to<br/>
		/// use, overriding other properties. This is documented at<br/>
		/// https://developer.android.com/reference/android/text/InputType<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInputWithProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StartTextInputWithPropertiesNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint, byte>)funcTable[783])(window, props);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, byte>)funcTable[783])((nint)window, props);
			#endif
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window, with properties<br/>
		/// describing the input.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard and/or<br/>
		/// activates an IME, which can prevent some key press events from being passed<br/>
		/// through.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that<br/>
		/// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.<br/>
		/// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value<br/>
		/// that describes how text should be capitalized, defaults to<br/>
		/// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for<br/>
		/// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail<br/>
		/// addresses, usernames, and passwords.<br/>
		/// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion<br/>
		/// and auto correction, defaults to true.<br/>
		/// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text<br/>
		/// are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is<br/>
		/// "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME<br/>
		/// is "1".<br/>
		/// On Android you can directly specify the input type:<br/>
		/// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to<br/>
		/// use, overriding other properties. This is documented at<br/>
		/// https://developer.android.com/reference/android/text/InputType<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInputWithProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StartTextInputWithProperties([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			byte ret = StartTextInputWithPropertiesNative((SDLWindow*)window, props);
			return ret != 0;
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window, with properties<br/>
		/// describing the input.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard and/or<br/>
		/// activates an IME, which can prevent some key press events from being passed<br/>
		/// through.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that<br/>
		/// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.<br/>
		/// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value<br/>
		/// that describes how text should be capitalized, defaults to<br/>
		/// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for<br/>
		/// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail<br/>
		/// addresses, usernames, and passwords.<br/>
		/// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion<br/>
		/// and auto correction, defaults to true.<br/>
		/// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text<br/>
		/// are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is<br/>
		/// "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME<br/>
		/// is "1".<br/>
		/// On Android you can directly specify the input type:<br/>
		/// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to<br/>
		/// use, overriding other properties. This is documented at<br/>
		/// https://developer.android.com/reference/android/text/InputType<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInputWithProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StartTextInputWithProperties([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = StartTextInputWithPropertiesNative((SDLWindow*)pwindow, props);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TextInputActive")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TextInputActiveNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[784])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[784])((nint)window);
			#endif
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TextInputActive")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextInputActive([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = TextInputActiveNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TextInputActive")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextInputActive([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = TextInputActiveNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Stop receiving any text input events in a window.<br/>
		/// If SDL_StartTextInput() showed the screen keyboard, this function will hide<br/>
		/// it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StopTextInputNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[785])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[785])((nint)window);
			#endif
		}

		/// <summary>
		/// Stop receiving any text input events in a window.<br/>
		/// If SDL_StartTextInput() showed the screen keyboard, this function will hide<br/>
		/// it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = StopTextInputNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Stop receiving any text input events in a window.<br/>
		/// If SDL_StartTextInput() showed the screen keyboard, this function will hide<br/>
		/// it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = StopTextInputNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearCompositionNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[786])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[786])((nint)window);
			#endif
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearComposition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = ClearCompositionNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearComposition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ClearCompositionNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTextInputAreaNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int, byte>)funcTable[787])(window, rect, cursor);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[787])((nint)window, (nint)rect, cursor);
			#endif
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRectPtr rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			byte ret = SetTextInputAreaNative((SDLWindow*)window, (SDLRect*)rect, cursor);
			return ret != 0;
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRectPtr rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)rect, cursor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] in SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetTextInputAreaNative((SDLWindow*)window, (SDLRect*)prect, cursor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] in SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)prect, cursor);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextInputAreaNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int*, byte>)funcTable[788])(window, rect, cursor);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[788])((nint)window, (nint)rect, (nint)cursor);
			#endif
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRectPtr rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			byte ret = GetTextInputAreaNative((SDLWindow*)window, (SDLRect*)rect, cursor);
			return ret != 0;
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRectPtr rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)rect, cursor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = GetTextInputAreaNative((SDLWindow*)window, (SDLRect*)prect, cursor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = GetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)prect, cursor);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRectPtr rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (int* pcursor = &cursor)
			{
				byte ret = GetTextInputAreaNative((SDLWindow*)window, (SDLRect*)rect, (int*)pcursor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRectPtr rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pcursor = &cursor)
				{
					byte ret = GetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)rect, (int*)pcursor);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* pcursor = &cursor)
				{
					byte ret = GetTextInputAreaNative((SDLWindow*)window, (SDLRect*)prect, (int*)pcursor);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (int* pcursor = &cursor)
					{
						byte ret = GetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)prect, (int*)pcursor);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasScreenKeyboardSupportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[789])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[789])();
			#endif
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasScreenKeyboardSupport()
		{
			byte ret = HasScreenKeyboardSupportNative();
			return ret != 0;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ScreenKeyboardShownNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[790])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[790])((nint)window);
			#endif
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = ScreenKeyboardShownNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ScreenKeyboardShownNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether a mouse is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMouse")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasMouseNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[791])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[791])();
			#endif
		}

		/// <summary>
		/// Return whether a mouse is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMouse")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasMouse()
		{
			byte ret = HasMouseNative();
			return ret != 0;
		}

		/// <summary>
		/// Get a list of currently connected mice.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// mouse functionality, including some game controllers, KVM switches, etc.<br/>
		/// You should wait for input from a device before you consider it actively in<br/>
		/// use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMice")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetMiceNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[792])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[792])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected mice.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// mouse functionality, including some game controllers, KVM switches, etc.<br/>
		/// You should wait for input from a device before you consider it actively in<br/>
		/// use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMice")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseID *")]
		public static uint* GetMice([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetMiceNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected mice.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// mouse functionality, including some game controllers, KVM switches, etc.<br/>
		/// You should wait for input from a device before you consider it actively in<br/>
		/// use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMice")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseID *")]
		public static uint* GetMice([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetMiceNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the name of a mouse.<br/>
		/// This function returns "" if the mouse doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetMouseNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_MouseID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[793])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[793])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the name of a mouse.<br/>
		/// This function returns "" if the mouse doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetMouseNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_MouseID")] uint instanceId)
		{
			byte* ret = GetMouseNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the name of a mouse.<br/>
		/// This function returns "" if the mouse doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetMouseNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_MouseID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetMouseNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetMouseFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[794])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[794])();
			#endif
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindowPtr GetMouseFocus()
		{
			SDLWindowPtr ret = GetMouseFocusNative();
			return ret;
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and the<br/>
		/// window-relative SDL-cursor position.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the focused window.<br/>
		/// In Relative Mode, the SDL-cursor's position usually contradicts the<br/>
		/// platform-cursor's position as manually calculated from<br/>
		/// SDL_GetGlobalMouseState() and SDL_GetWindowPosition.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, float*, uint>)funcTable[795])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[795])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and the<br/>
		/// window-relative SDL-cursor position.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the focused window.<br/>
		/// In Relative Mode, the SDL-cursor's position usually contradicts the<br/>
		/// platform-cursor's position as manually calculated from<br/>
		/// SDL_GetGlobalMouseState() and SDL_GetWindowPosition.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			uint ret = GetMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and the<br/>
		/// window-relative SDL-cursor position.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the focused window.<br/>
		/// In Relative Mode, the SDL-cursor's position usually contradicts the<br/>
		/// platform-cursor's position as manually calculated from<br/>
		/// SDL_GetGlobalMouseState() and SDL_GetWindowPosition.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			fixed (float* px = &x)
			{
				uint ret = GetMouseStateNative((float*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and the<br/>
		/// window-relative SDL-cursor position.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the focused window.<br/>
		/// In Relative Mode, the SDL-cursor's position usually contradicts the<br/>
		/// platform-cursor's position as manually calculated from<br/>
		/// SDL_GetGlobalMouseState() and SDL_GetWindowPosition.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* py = &y)
			{
				uint ret = GetMouseStateNative(x, (float*)py);
				return ret;
			}
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and the<br/>
		/// window-relative SDL-cursor position.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the focused window.<br/>
		/// In Relative Mode, the SDL-cursor's position usually contradicts the<br/>
		/// platform-cursor's position as manually calculated from<br/>
		/// SDL_GetGlobalMouseState() and SDL_GetWindowPosition.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					uint ret = GetMouseStateNative((float*)px, (float*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the platform for the asynchronous mouse button state and the<br/>
		/// desktop-relative platform-cursor position.<br/>
		/// This function immediately queries the platform for the most recent<br/>
		/// asynchronous state, more costly than retrieving SDL's cached state in<br/>
		/// SDL_GetMouseState().<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the desktop.<br/>
		/// In Relative Mode, the platform-cursor's position usually contradicts the<br/>
		/// SDL-cursor's position as manually calculated from SDL_GetMouseState() and<br/>
		/// SDL_GetWindowPosition.<br/>
		/// This function can be useful if you need to track the mouse outside of a<br/>
		/// specific window and SDL_CaptureMouse() doesn't fit your needs. For example,<br/>
		/// it could be useful if you need to track the mouse while dragging a window,<br/>
		/// where coordinates relative to a window might not be in sync at all times.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGlobalMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, float*, uint>)funcTable[796])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[796])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Query the platform for the asynchronous mouse button state and the<br/>
		/// desktop-relative platform-cursor position.<br/>
		/// This function immediately queries the platform for the most recent<br/>
		/// asynchronous state, more costly than retrieving SDL's cached state in<br/>
		/// SDL_GetMouseState().<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the desktop.<br/>
		/// In Relative Mode, the platform-cursor's position usually contradicts the<br/>
		/// SDL-cursor's position as manually calculated from SDL_GetMouseState() and<br/>
		/// SDL_GetWindowPosition.<br/>
		/// This function can be useful if you need to track the mouse outside of a<br/>
		/// specific window and SDL_CaptureMouse() doesn't fit your needs. For example,<br/>
		/// it could be useful if you need to track the mouse while dragging a window,<br/>
		/// where coordinates relative to a window might not be in sync at all times.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			uint ret = GetGlobalMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Query the platform for the asynchronous mouse button state and the<br/>
		/// desktop-relative platform-cursor position.<br/>
		/// This function immediately queries the platform for the most recent<br/>
		/// asynchronous state, more costly than retrieving SDL's cached state in<br/>
		/// SDL_GetMouseState().<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the desktop.<br/>
		/// In Relative Mode, the platform-cursor's position usually contradicts the<br/>
		/// SDL-cursor's position as manually calculated from SDL_GetMouseState() and<br/>
		/// SDL_GetWindowPosition.<br/>
		/// This function can be useful if you need to track the mouse outside of a<br/>
		/// specific window and SDL_CaptureMouse() doesn't fit your needs. For example,<br/>
		/// it could be useful if you need to track the mouse while dragging a window,<br/>
		/// where coordinates relative to a window might not be in sync at all times.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			fixed (float* px = &x)
			{
				uint ret = GetGlobalMouseStateNative((float*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Query the platform for the asynchronous mouse button state and the<br/>
		/// desktop-relative platform-cursor position.<br/>
		/// This function immediately queries the platform for the most recent<br/>
		/// asynchronous state, more costly than retrieving SDL's cached state in<br/>
		/// SDL_GetMouseState().<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the desktop.<br/>
		/// In Relative Mode, the platform-cursor's position usually contradicts the<br/>
		/// SDL-cursor's position as manually calculated from SDL_GetMouseState() and<br/>
		/// SDL_GetWindowPosition.<br/>
		/// This function can be useful if you need to track the mouse outside of a<br/>
		/// specific window and SDL_CaptureMouse() doesn't fit your needs. For example,<br/>
		/// it could be useful if you need to track the mouse while dragging a window,<br/>
		/// where coordinates relative to a window might not be in sync at all times.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* py = &y)
			{
				uint ret = GetGlobalMouseStateNative(x, (float*)py);
				return ret;
			}
		}

		/// <summary>
		/// Query the platform for the asynchronous mouse button state and the<br/>
		/// desktop-relative platform-cursor position.<br/>
		/// This function immediately queries the platform for the most recent<br/>
		/// asynchronous state, more costly than retrieving SDL's cached state in<br/>
		/// SDL_GetMouseState().<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y coordinates relative to the desktop.<br/>
		/// In Relative Mode, the platform-cursor's position usually contradicts the<br/>
		/// SDL-cursor's position as manually calculated from SDL_GetMouseState() and<br/>
		/// SDL_GetWindowPosition.<br/>
		/// This function can be useful if you need to track the mouse outside of a<br/>
		/// specific window and SDL_CaptureMouse() doesn't fit your needs. For example,<br/>
		/// it could be useful if you need to track the mouse while dragging a window,<br/>
		/// where coordinates relative to a window might not be in sync at all times.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					uint ret = GetGlobalMouseStateNative((float*)px, (float*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and accumulated<br/>
		/// mouse delta since last call.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y deltas accumulated since the last call to this function<br/>
		/// (or since event initialization).<br/>
		/// This function is useful for reducing overhead by processing relative mouse<br/>
		/// inputs in one go per-frame instead of individually per-event, at the<br/>
		/// expense of losing the order between events within the frame (e.g. quickly<br/>
		/// pressing and releasing a button within the same frame).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetRelativeMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, float*, uint>)funcTable[797])(x, y);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[797])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and accumulated<br/>
		/// mouse delta since last call.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y deltas accumulated since the last call to this function<br/>
		/// (or since event initialization).<br/>
		/// This function is useful for reducing overhead by processing relative mouse<br/>
		/// inputs in one go per-frame instead of individually per-event, at the<br/>
		/// expense of losing the order between events within the frame (e.g. quickly<br/>
		/// pressing and releasing a button within the same frame).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			uint ret = GetRelativeMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and accumulated<br/>
		/// mouse delta since last call.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y deltas accumulated since the last call to this function<br/>
		/// (or since event initialization).<br/>
		/// This function is useful for reducing overhead by processing relative mouse<br/>
		/// inputs in one go per-frame instead of individually per-event, at the<br/>
		/// expense of losing the order between events within the frame (e.g. quickly<br/>
		/// pressing and releasing a button within the same frame).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			fixed (float* px = &x)
			{
				uint ret = GetRelativeMouseStateNative((float*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and accumulated<br/>
		/// mouse delta since last call.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y deltas accumulated since the last call to this function<br/>
		/// (or since event initialization).<br/>
		/// This function is useful for reducing overhead by processing relative mouse<br/>
		/// inputs in one go per-frame instead of individually per-event, at the<br/>
		/// expense of losing the order between events within the frame (e.g. quickly<br/>
		/// pressing and releasing a button within the same frame).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* py = &y)
			{
				uint ret = GetRelativeMouseStateNative(x, (float*)py);
				return ret;
			}
		}

		/// <summary>
		/// Query SDL's cache for the synchronous mouse button state and accumulated<br/>
		/// mouse delta since last call.<br/>
		/// This function returns the cached synchronous state as SDL understands it<br/>
		/// from the last pump of the event queue.<br/>
		/// To query the platform for immediate asynchronous state, use<br/>
		/// SDL_GetGlobalMouseState.<br/>
		/// Passing non-NULL pointers to `x` or `y` will write the destination with<br/>
		/// respective x or y deltas accumulated since the last call to this function<br/>
		/// (or since event initialization).<br/>
		/// This function is useful for reducing overhead by processing relative mouse<br/>
		/// inputs in one go per-frame instead of individually per-event, at the<br/>
		/// expense of losing the order between events within the frame (e.g. quickly<br/>
		/// pressing and releasing a button within the same frame).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static uint GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					uint ret = GetRelativeMouseStateNative((float*)px, (float*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarpMouseInWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, float, float, void>)funcTable[798])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, void>)funcTable[798])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			WarpMouseInWindowNative((SDLWindow*)window, x, y);
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				WarpMouseInWindowNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WarpMouseGlobalNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, byte>)funcTable[799])(x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<float, float, byte>)funcTable[799])(x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WarpMouseGlobal([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			byte ret = WarpMouseGlobalNative(x, y);
			return ret != 0;
		}

		/// <summary>
		/// Set a user-defined function by which to transform relative mouse inputs.<br/>
		/// This overrides the relative system scale and relative speed scale hints.<br/>
		/// Should be called prior to enabling relative mouse mode, fails otherwise.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseTransform")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRelativeMouseTransformNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_MouseMotionTransformCallback")] delegate*<void*, ulong, SDLWindow*, uint, float*, float*, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, ulong, SDLWindow*, uint, float*, float*, void>, void*, byte>)funcTable[800])(callback, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[800])((nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a user-defined function by which to transform relative mouse inputs.<br/>
		/// This overrides the relative system scale and relative speed scale hints.<br/>
		/// Should be called prior to enabling relative mouse mode, fails otherwise.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseTransform")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetRelativeMouseTransform([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_MouseMotionTransformCallback")] delegate*<void*, ulong, SDLWindow*, uint, float*, float*, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetRelativeMouseTransformNative(callback, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a user-defined function by which to transform relative mouse inputs.<br/>
		/// This overrides the relative system scale and relative speed scale hints.<br/>
		/// Should be called prior to enabling relative mouse mode, fails otherwise.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseTransform")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetRelativeMouseTransform([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_MouseMotionTransformCallback")] SDLMouseMotionTransformCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetRelativeMouseTransformNative((delegate*<void*, ulong, SDLWindow*, uint, float*, float*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a user-defined function by which to transform relative mouse inputs.<br/>
		/// This overrides the relative system scale and relative speed scale hints.<br/>
		/// Should be called prior to enabling relative mouse mode, fails otherwise.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseTransform")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetRelativeMouseTransform([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_MouseMotionTransformCallback")] delegate*<void*, ulong, SDLWindow*, uint, float*, float*, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetRelativeMouseTransformNative(callback, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a user-defined function by which to transform relative mouse inputs.<br/>
		/// This overrides the relative system scale and relative speed scale hints.<br/>
		/// Should be called prior to enabling relative mouse mode, fails otherwise.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseTransform")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetRelativeMouseTransform([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_MouseMotionTransformCallback")] SDLMouseMotionTransformCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetRelativeMouseTransformNative((delegate*<void*, ulong, SDLWindow*, uint, float*, float*, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set relative mouse mode for a window.<br/>
		/// While the window has focus and relative mouse mode is enabled, the cursor<br/>
		/// is hidden, the mouse position is constrained to the window, and SDL will<br/>
		/// report continuous relative mouse motion even if the mouse is at the edge of<br/>
		/// the window.<br/>
		/// If you'd like to keep the mouse position fixed while in relative mode you<br/>
		/// can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a<br/>
		/// specific location when relative mode ends, you should use<br/>
		/// SDL_WarpMouseInWindow() before disabling relative mode.<br/>
		/// This function will flush any pending mouse motion for this window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowRelativeMouseModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[801])(window, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[801])((nint)window, enabled);
			#endif
		}

		/// <summary>
		/// Set relative mouse mode for a window.<br/>
		/// While the window has focus and relative mouse mode is enabled, the cursor<br/>
		/// is hidden, the mouse position is constrained to the window, and SDL will<br/>
		/// report continuous relative mouse motion even if the mouse is at the edge of<br/>
		/// the window.<br/>
		/// If you'd like to keep the mouse position fixed while in relative mode you<br/>
		/// can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a<br/>
		/// specific location when relative mode ends, you should use<br/>
		/// SDL_WarpMouseInWindow() before disabling relative mode.<br/>
		/// This function will flush any pending mouse motion for this window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			byte ret = SetWindowRelativeMouseModeNative((SDLWindow*)window, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set relative mouse mode for a window.<br/>
		/// While the window has focus and relative mouse mode is enabled, the cursor<br/>
		/// is hidden, the mouse position is constrained to the window, and SDL will<br/>
		/// report continuous relative mouse motion even if the mouse is at the edge of<br/>
		/// the window.<br/>
		/// If you'd like to keep the mouse position fixed while in relative mode you<br/>
		/// can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a<br/>
		/// specific location when relative mode ends, you should use<br/>
		/// SDL_WarpMouseInWindow() before disabling relative mode.<br/>
		/// This function will flush any pending mouse motion for this window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowRelativeMouseModeNative((SDLWindow*)pwindow, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowRelativeMouseModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[802])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[802])((nint)window);
			#endif
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = GetWindowRelativeMouseModeNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowRelativeMouseModeNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),<br/>
		/// depending on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that SDL will attempt to "auto capture" the mouse while the<br/>
		/// user is pressing a button; this is to try and make mouse behavior more<br/>
		/// consistent between platforms, and deal with the common case of a user<br/>
		/// dragging the mouse outside of the window. This means that if you are<br/>
		/// calling SDL_CaptureMouse() only to deal with this situation, you do not<br/>
		/// have to (although it is safe to do so). If this causes problems for your<br/>
		/// app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CaptureMouseNative([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte>)funcTable[803])(enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte>)funcTable[803])(enabled);
			#endif
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),<br/>
		/// depending on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that SDL will attempt to "auto capture" the mouse while the<br/>
		/// user is pressing a button; this is to try and make mouse behavior more<br/>
		/// consistent between platforms, and deal with the common case of a user<br/>
		/// dragging the mouse outside of the window. This means that if you are<br/>
		/// calling SDL_CaptureMouse() only to deal with this situation, you do not<br/>
		/// have to (although it is safe to do so). If this causes problems for your<br/>
		/// app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CaptureMouse([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			byte ret = CaptureMouseNative(enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateCursorNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int, int, int, SDLCursor*>)funcTable[804])(data, mask, w, h, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int, nint>)funcTable[804])((nint)data, (nint)mask, w, h, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursorPtr ret = CreateCursorNative(data, mask, w, h, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				SDLCursorPtr ret = CreateCursorNative((byte*)pdata, mask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pmask = &mask)
			{
				SDLCursorPtr ret = CreateCursorNative(data, (byte*)pmask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] in byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pmask = &mask)
				{
					SDLCursorPtr ret = CreateCursorNative((byte*)pdata, (byte*)pmask, w, h, hotX, hotY);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// If this function is passed a surface with alternate representations added<br/>
		/// with SDL_AddSurfaceAlternateImage(), the surface will be interpreted as the<br/>
		/// content to be used for 100% display scale, and the alternate<br/>
		/// representations will be used for high DPI situations if<br/>
		/// SDL_HINT_MOUSE_DPI_SCALE_CURSORS is enabled. For example, if the original<br/>
		/// surface is 32x32, then on a 2x macOS display or 200% display scale on<br/>
		/// Windows, a 64x64 version of the image will be used, if available. If a<br/>
		/// matching version of the image isn't available, the closest larger size<br/>
		/// image will be downscaled to the appropriate size and be used instead, if<br/>
		/// available. Otherwise, the closest smaller image will be upscaled and be<br/>
		/// used instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateColorCursorNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, SDLCursor*>)funcTable[805])(surface, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)funcTable[805])((nint)surface, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// If this function is passed a surface with alternate representations added<br/>
		/// with SDL_AddSurfaceAlternateImage(), the surface will be interpreted as the<br/>
		/// content to be used for 100% display scale, and the alternate<br/>
		/// representations will be used for high DPI situations if<br/>
		/// SDL_HINT_MOUSE_DPI_SCALE_CURSORS is enabled. For example, if the original<br/>
		/// surface is 32x32, then on a 2x macOS display or 200% display scale on<br/>
		/// Windows, a 64x64 version of the image will be used, if available. If a<br/>
		/// matching version of the image isn't available, the closest larger size<br/>
		/// image will be downscaled to the appropriate size and be used instead, if<br/>
		/// available. Otherwise, the closest smaller image will be upscaled and be<br/>
		/// used instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursorPtr ret = CreateColorCursorNative((SDLSurface*)surface, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// If this function is passed a surface with alternate representations added<br/>
		/// with SDL_AddSurfaceAlternateImage(), the surface will be interpreted as the<br/>
		/// content to be used for 100% display scale, and the alternate<br/>
		/// representations will be used for high DPI situations if<br/>
		/// SDL_HINT_MOUSE_DPI_SCALE_CURSORS is enabled. For example, if the original<br/>
		/// surface is 32x32, then on a 2x macOS display or 200% display scale on<br/>
		/// Windows, a 64x64 version of the image will be used, if available. If a<br/>
		/// matching version of the image isn't available, the closest larger size<br/>
		/// image will be downscaled to the appropriate size and be used instead, if<br/>
		/// available. Otherwise, the closest smaller image will be upscaled and be<br/>
		/// used instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLCursorPtr ret = CreateColorCursorNative((SDLSurface*)psurface, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create an animated color cursor.<br/>
		/// Animated cursors are composed of a sequential array of frames, specified as<br/>
		/// surfaces and durations in an array of SDL_CursorFrameInfo structs. The hot<br/>
		/// spot coordinates are universal to all frames, and all frames must have the<br/>
		/// same dimensions.<br/>
		/// Frame durations are specified in milliseconds. A duration of 0 implies an<br/>
		/// infinite frame time, and the animation will stop on that frame. To create a<br/>
		/// one-shot animation, set the duration of the last frame in the sequence to<br/>
		/// 0.<br/>
		/// If this function is passed surfaces with alternate representations added<br/>
		/// with SDL_AddSurfaceAlternateImage(), the surfaces will be interpreted as<br/>
		/// the content to be used for 100% display scale, and the alternate<br/>
		/// representations will be used for high DPI situations. For example, if the<br/>
		/// original surfaces are 32x32, then on a 2x macOS display or 200% display<br/>
		/// scale on Windows, a 64x64 version of the image will be used, if available.<br/>
		/// If a matching version of the image isn't available, the closest larger size<br/>
		/// image will be downscaled to the appropriate size and be used instead, if<br/>
		/// available. Otherwise, the closest smaller image will be upscaled and be<br/>
		/// used instead.<br/>
		/// If the underlying platform does not support animated cursors, this function<br/>
		/// will fall back to creating a static color cursor using the first frame in<br/>
		/// the sequence.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateAnimatedCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateAnimatedCursorNative([NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "SDL_CursorFrameInfo *")] SDLCursorFrameInfo* frames, [NativeName(NativeNameType.Param, "frame_count")] [NativeName(NativeNameType.Type, "int")] int frameCount, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursorFrameInfo*, int, int, int, SDLCursor*>)funcTable[806])(frames, frameCount, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, int, int, int, nint>)funcTable[806])((nint)frames, frameCount, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create an animated color cursor.<br/>
		/// Animated cursors are composed of a sequential array of frames, specified as<br/>
		/// surfaces and durations in an array of SDL_CursorFrameInfo structs. The hot<br/>
		/// spot coordinates are universal to all frames, and all frames must have the<br/>
		/// same dimensions.<br/>
		/// Frame durations are specified in milliseconds. A duration of 0 implies an<br/>
		/// infinite frame time, and the animation will stop on that frame. To create a<br/>
		/// one-shot animation, set the duration of the last frame in the sequence to<br/>
		/// 0.<br/>
		/// If this function is passed surfaces with alternate representations added<br/>
		/// with SDL_AddSurfaceAlternateImage(), the surfaces will be interpreted as<br/>
		/// the content to be used for 100% display scale, and the alternate<br/>
		/// representations will be used for high DPI situations. For example, if the<br/>
		/// original surfaces are 32x32, then on a 2x macOS display or 200% display<br/>
		/// scale on Windows, a 64x64 version of the image will be used, if available.<br/>
		/// If a matching version of the image isn't available, the closest larger size<br/>
		/// image will be downscaled to the appropriate size and be used instead, if<br/>
		/// available. Otherwise, the closest smaller image will be upscaled and be<br/>
		/// used instead.<br/>
		/// If the underlying platform does not support animated cursors, this function<br/>
		/// will fall back to creating a static color cursor using the first frame in<br/>
		/// the sequence.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateAnimatedCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateAnimatedCursor([NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "SDL_CursorFrameInfo *")] SDLCursorFrameInfoPtr frames, [NativeName(NativeNameType.Param, "frame_count")] [NativeName(NativeNameType.Type, "int")] int frameCount, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursorPtr ret = CreateAnimatedCursorNative((SDLCursorFrameInfo*)frames, frameCount, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create an animated color cursor.<br/>
		/// Animated cursors are composed of a sequential array of frames, specified as<br/>
		/// surfaces and durations in an array of SDL_CursorFrameInfo structs. The hot<br/>
		/// spot coordinates are universal to all frames, and all frames must have the<br/>
		/// same dimensions.<br/>
		/// Frame durations are specified in milliseconds. A duration of 0 implies an<br/>
		/// infinite frame time, and the animation will stop on that frame. To create a<br/>
		/// one-shot animation, set the duration of the last frame in the sequence to<br/>
		/// 0.<br/>
		/// If this function is passed surfaces with alternate representations added<br/>
		/// with SDL_AddSurfaceAlternateImage(), the surfaces will be interpreted as<br/>
		/// the content to be used for 100% display scale, and the alternate<br/>
		/// representations will be used for high DPI situations. For example, if the<br/>
		/// original surfaces are 32x32, then on a 2x macOS display or 200% display<br/>
		/// scale on Windows, a 64x64 version of the image will be used, if available.<br/>
		/// If a matching version of the image isn't available, the closest larger size<br/>
		/// image will be downscaled to the appropriate size and be used instead, if<br/>
		/// available. Otherwise, the closest smaller image will be upscaled and be<br/>
		/// used instead.<br/>
		/// If the underlying platform does not support animated cursors, this function<br/>
		/// will fall back to creating a static color cursor using the first frame in<br/>
		/// the sequence.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateAnimatedCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateAnimatedCursor([NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "SDL_CursorFrameInfo *")] ref SDLCursorFrameInfo frames, [NativeName(NativeNameType.Param, "frame_count")] [NativeName(NativeNameType.Type, "int")] int frameCount, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (SDLCursorFrameInfo* pframes = &frames)
			{
				SDLCursorPtr ret = CreateAnimatedCursorNative((SDLCursorFrameInfo*)pframes, frameCount, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateSystemCursorNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSystemCursor, SDLCursor*>)funcTable[807])(id);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<SDLSystemCursor, nint>)funcTable[807])(id);
			#endif
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr CreateSystemCursor([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id)
		{
			SDLCursorPtr ret = CreateSystemCursorNative(id);
			return ret;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*, byte>)funcTable[808])(cursor);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[808])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursorPtr cursor)
		{
			byte ret = SetCursorNative((SDLCursor*)cursor);
			return ret != 0;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				byte ret = SetCursorNative((SDLCursor*)pcursor);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_DestroyCursor().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[809])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[809])();
			#endif
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_DestroyCursor().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr GetCursor()
		{
			SDLCursorPtr ret = GetCursorNative();
			return ret;
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_DestroyCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetDefaultCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[810])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[810])();
			#endif
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_DestroyCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursorPtr GetDefaultCursor()
		{
			SDLCursorPtr ret = GetDefaultCursorNative();
			return ret;
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)funcTable[811])(cursor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[811])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursorPtr cursor)
		{
			DestroyCursorNative((SDLCursor*)cursor);
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				DestroyCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Show the cursor.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[812])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[812])();
			#endif
		}

		/// <summary>
		/// Show the cursor.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowCursor()
		{
			byte ret = ShowCursorNative();
			return ret != 0;
		}

		/// <summary>
		/// Hide the cursor.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideCursor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HideCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[813])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[813])();
			#endif
		}

		/// <summary>
		/// Hide the cursor.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideCursor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HideCursor()
		{
			byte ret = HideCursorNative();
			return ret != 0;
		}

		/// <summary>
		/// Return whether the cursor is currently being shown.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CursorVisible")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CursorVisibleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[814])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[814])();
			#endif
		}

		/// <summary>
		/// Return whether the cursor is currently being shown.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CursorVisible")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CursorVisible()
		{
			byte ret = CursorVisibleNative();
			return ret != 0;
		}

		/// <summary>
		/// Get a list of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore the returned list might be empty, although devices are available.<br/>
		/// After using all devices at least once the number will be correct.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long* GetTouchDevicesNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, long*>)funcTable[815])(count);
			#else
			return (long*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[815])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore the returned list might be empty, although devices are available.<br/>
		/// After using all devices at least once the number will be correct.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID *")]
		public static long* GetTouchDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			long* ret = GetTouchDevicesNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore the returned list might be empty, although devices are available.<br/>
		/// After using all devices at least once the number will be correct.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID *")]
		public static long* GetTouchDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				long* ret = GetTouchDevicesNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the touch device name as reported from the driver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTouchDeviceNameNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, byte*>)funcTable[816])(touchID);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<long, nint>)funcTable[816])(touchID);
			#endif
		}

		/// <summary>
		/// Get the touch device name as reported from the driver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetTouchDeviceName([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			byte* ret = GetTouchDeviceNameNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get the touch device name as reported from the driver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetTouchDeviceNameS([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			string ret = Utils.DecodeStringUTF8(GetTouchDeviceNameNative(touchID));
			return ret;
		}

		/// <summary>
		/// Get the type of the given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTouchDeviceType GetTouchDeviceTypeNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, SDLTouchDeviceType>)funcTable[817])(touchID);
			#else
			return (SDLTouchDeviceType)((delegate* unmanaged[Cdecl]<long, SDLTouchDeviceType>)funcTable[817])(touchID);
			#endif
		}

		/// <summary>
		/// Get the type of the given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		public static SDLTouchDeviceType GetTouchDeviceType([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			SDLTouchDeviceType ret = GetTouchDeviceTypeNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get a list of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFingers")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLFinger** GetTouchFingersNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, int*, SDLFinger**>)funcTable[818])(touchID, count);
			#else
			return (SDLFinger**)((delegate* unmanaged[Cdecl]<long, nint, nint>)funcTable[818])(touchID, (nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFingers")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger * *")]
		public static SDLFingerPtrPtr GetTouchFingers([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			SDLFingerPtrPtr ret = GetTouchFingersNative(touchID, count);
			return ret;
		}

		/// <summary>
		/// Get a list of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFingers")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger * *")]
		public static SDLFingerPtrPtr GetTouchFingers([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLFingerPtrPtr ret = GetTouchFingersNative(touchID, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the device type of the given pen.<br/>
		/// Many platforms do not supply this information, so an app must always be<br/>
		/// prepared to get an SDL_PEN_DEVICE_TYPE_UNKNOWN result.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPenDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_PenDeviceType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPenDeviceType GetPenDeviceTypeNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_PenID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLPenDeviceType>)funcTable[819])(instanceId);
			#else
			return (SDLPenDeviceType)((delegate* unmanaged[Cdecl]<uint, SDLPenDeviceType>)funcTable[819])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the device type of the given pen.<br/>
		/// Many platforms do not supply this information, so an app must always be<br/>
		/// prepared to get an SDL_PEN_DEVICE_TYPE_UNKNOWN result.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPenDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_PenDeviceType")]
		public static SDLPenDeviceType GetPenDeviceType([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_PenID")] uint instanceId)
		{
			SDLPenDeviceType ret = GetPenDeviceTypeNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Pump the event loop, gathering events from the input devices.<br/>
		/// This function updates the event queue and internal input device state.<br/>
		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
		/// would ever be placed on the queue. Often the need for calls to<br/>
		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
		/// call SDL_PumpEvents() to force an event queue update.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PumpEventsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[820])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[820])();
			#endif
		}

		/// <summary>
		/// Pump the event loop, gathering events from the input devices.<br/>
		/// This function updates the event queue and internal input device state.<br/>
		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
		/// would ever be placed on the queue. Often the need for calls to<br/>
		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
		/// call SDL_PumpEvents() to force an event queue update.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PumpEvents()
		{
			PumpEventsNative();
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue. If you pass NULL for<br/>
		/// `events`, then `numevents` is ignored and the total number of matching<br/>
		/// events will be returned.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PeepEventsNative([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_EventAction")] SDLEventAction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int, SDLEventAction, uint, uint, int>)funcTable[821])(events, numevents, action, minType, maxType);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, SDLEventAction, uint, uint, int>)funcTable[821])((nint)events, numevents, action, minType, maxType);
			#endif
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue. If you pass NULL for<br/>
		/// `events`, then `numevents` is ignored and the total number of matching<br/>
		/// events will be returned.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_EventAction")] SDLEventAction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			int ret = PeepEventsNative((SDLEvent*)events, numevents, action, minType, maxType);
			return ret;
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue. If you pass NULL for<br/>
		/// `events`, then `numevents` is ignored and the total number of matching<br/>
		/// events will be returned.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_EventAction")] SDLEventAction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			fixed (SDLEvent* pevents = &events)
			{
				int ret = PeepEventsNative((SDLEvent*)pevents, numevents, action, minType, maxType);
				return ret;
			}
		}

		/// <summary>
		/// Check for the existence of a certain event type in the event queue.<br/>
		/// If you need to check for a range of event types, use SDL_HasEvents()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasEventNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[822])(type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[822])(type);
			#endif
		}

		/// <summary>
		/// Check for the existence of a certain event type in the event queue.<br/>
		/// If you need to check for a range of event types, use SDL_HasEvents()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasEvent([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			byte ret = HasEventNative(type);
			return ret != 0;
		}

		/// <summary>
		/// Check for the existence of certain event types in the event queue.<br/>
		/// If you need to check for a single event type, use SDL_HasEvent() instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvents")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasEventsNative([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, byte>)funcTable[823])(minType, maxType);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, uint, byte>)funcTable[823])(minType, maxType);
			#endif
		}

		/// <summary>
		/// Check for the existence of certain event types in the event queue.<br/>
		/// If you need to check for a single event type, use SDL_HasEvent() instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvents")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasEvents([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			byte ret = HasEventsNative(minType, maxType);
			return ret != 0;
		}

		/// <summary>
		/// Clear events of a specific type from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that match<br/>
		/// `type`. If you need to remove a range of event types, use SDL_FlushEvents()<br/>
		/// instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// If you have user events with custom data that needs to be freed, you should<br/>
		/// use SDL_PeepEvents() to remove and clean up those events before calling<br/>
		/// this function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushEventNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[824])(type);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[824])(type);
			#endif
		}

		/// <summary>
		/// Clear events of a specific type from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that match<br/>
		/// `type`. If you need to remove a range of event types, use SDL_FlushEvents()<br/>
		/// instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// If you have user events with custom data that needs to be freed, you should<br/>
		/// use SDL_PeepEvents() to remove and clean up those events before calling<br/>
		/// this function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FlushEvent([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			FlushEventNative(type);
		}

		/// <summary>
		/// Clear events of a range of types from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that are in the<br/>
		/// range of `minType` to `maxType`, inclusive. If you need to remove a single<br/>
		/// event type, use SDL_FlushEvent() instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushEventsNative([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[825])(minType, maxType);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[825])(minType, maxType);
			#endif
		}

		/// <summary>
		/// Clear events of a range of types from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that are in the<br/>
		/// range of `minType` to `maxType`, inclusive. If you need to remove a single<br/>
		/// event type, use SDL_FlushEvent() instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FlushEvents([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			FlushEventsNative(minType, maxType);
		}

		/// <summary>
		/// Poll for currently pending events.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
		/// this event, immediately stored in the SDL Event structure -- not an event<br/>
		/// to follow.<br/>
		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
		/// but will not remove it from the queue.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that set the video mode.<br/>
		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
		/// be done from the main loop and does not suspend the main loop while waiting<br/>
		/// on an event to be posted.<br/>
		/// The common practice is to fully process the event queue once every frame,<br/>
		/// usually as a first step before updating the game's state:<br/>
		/// ```c<br/>
		/// while (game_is_still_running) {<br/>
		/// SDL_Event event;<br/>
		/// while (SDL_PollEvent(<br/>
		/// &event<br/>
		/// )) {  // poll until all events are handled!<br/>
		/// // decide what to do with this event.<br/>
		/// }<br/>
		/// // update game state, draw the current frame<br/>
		/// }<br/>
		/// ```<br/>
		/// Note that Windows (and possibly other platforms) has a quirk about how it<br/>
		/// handles events while dragging/resizing a window, which can cause this<br/>
		/// function to block for significant amounts of time. Technical explanations<br/>
		/// and solutions are discussed on the wiki:<br/>
		/// https://wiki.libsdl.org/SDL3/AppFreezeDuringDrag<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PollEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, byte>)funcTable[826])(evnt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[826])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Poll for currently pending events.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
		/// this event, immediately stored in the SDL Event structure -- not an event<br/>
		/// to follow.<br/>
		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
		/// but will not remove it from the queue.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that set the video mode.<br/>
		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
		/// be done from the main loop and does not suspend the main loop while waiting<br/>
		/// on an event to be posted.<br/>
		/// The common practice is to fully process the event queue once every frame,<br/>
		/// usually as a first step before updating the game's state:<br/>
		/// ```c<br/>
		/// while (game_is_still_running) {<br/>
		/// SDL_Event event;<br/>
		/// while (SDL_PollEvent(<br/>
		/// &event<br/>
		/// )) {  // poll until all events are handled!<br/>
		/// // decide what to do with this event.<br/>
		/// }<br/>
		/// // update game state, draw the current frame<br/>
		/// }<br/>
		/// ```<br/>
		/// Note that Windows (and possibly other platforms) has a quirk about how it<br/>
		/// handles events while dragging/resizing a window, which can cause this<br/>
		/// function to block for significant amounts of time. Technical explanations<br/>
		/// and solutions are discussed on the wiki:<br/>
		/// https://wiki.libsdl.org/SDL3/AppFreezeDuringDrag<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PollEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt)
		{
			byte ret = PollEventNative((SDLEvent*)evnt);
			return ret != 0;
		}

		/// <summary>
		/// Poll for currently pending events.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
		/// this event, immediately stored in the SDL Event structure -- not an event<br/>
		/// to follow.<br/>
		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
		/// but will not remove it from the queue.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that set the video mode.<br/>
		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
		/// be done from the main loop and does not suspend the main loop while waiting<br/>
		/// on an event to be posted.<br/>
		/// The common practice is to fully process the event queue once every frame,<br/>
		/// usually as a first step before updating the game's state:<br/>
		/// ```c<br/>
		/// while (game_is_still_running) {<br/>
		/// SDL_Event event;<br/>
		/// while (SDL_PollEvent(<br/>
		/// &event<br/>
		/// )) {  // poll until all events are handled!<br/>
		/// // decide what to do with this event.<br/>
		/// }<br/>
		/// // update game state, draw the current frame<br/>
		/// }<br/>
		/// ```<br/>
		/// Note that Windows (and possibly other platforms) has a quirk about how it<br/>
		/// handles events while dragging/resizing a window, which can cause this<br/>
		/// function to block for significant amounts of time. Technical explanations<br/>
		/// and solutions are discussed on the wiki:<br/>
		/// https://wiki.libsdl.org/SDL3/AppFreezeDuringDrag<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PollEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte ret = PollEventNative((SDLEvent*)pevnt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait indefinitely for the next available event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, byte>)funcTable[827])(evnt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[827])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Wait indefinitely for the next available event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt)
		{
			byte ret = WaitEventNative((SDLEvent*)evnt);
			return ret != 0;
		}

		/// <summary>
		/// Wait indefinitely for the next available event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte ret = WaitEventNative((SDLEvent*)pevnt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait until the specified timeout (in milliseconds) for the next available<br/>
		/// event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// The timeout is not guaranteed, the actual wait time could be longer due to<br/>
		/// system scheduling.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitEventTimeoutNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int, byte>)funcTable[828])(evnt, timeoutMS);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[828])((nint)evnt, timeoutMS);
			#endif
		}

		/// <summary>
		/// Wait until the specified timeout (in milliseconds) for the next available<br/>
		/// event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// The timeout is not guaranteed, the actual wait time could be longer due to<br/>
		/// system scheduling.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitEventTimeout([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			byte ret = WaitEventTimeoutNative((SDLEvent*)evnt, timeoutMS);
			return ret != 0;
		}

		/// <summary>
		/// Wait until the specified timeout (in milliseconds) for the next available<br/>
		/// event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// The timeout is not guaranteed, the actual wait time could be longer due to<br/>
		/// system scheduling.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitEventTimeout([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte ret = WaitEventTimeoutNative((SDLEvent*)pevnt, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Add an event to the event queue.<br/>
		/// The event queue can actually be used as a two way communication channel.<br/>
		/// Not only can events be read from the queue, but the user can also push<br/>
		/// their own events onto it. `event` is a pointer to the event structure you<br/>
		/// wish to push onto the queue. The event is copied into the queue, and the<br/>
		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
		/// of the device within SDL.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter but events added with SDL_PeepEvents() do not.<br/>
		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
		/// get an event type that does not conflict with other code that also wants<br/>
		/// its own custom event types.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PushEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, byte>)funcTable[829])(evnt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[829])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Add an event to the event queue.<br/>
		/// The event queue can actually be used as a two way communication channel.<br/>
		/// Not only can events be read from the queue, but the user can also push<br/>
		/// their own events onto it. `event` is a pointer to the event structure you<br/>
		/// wish to push onto the queue. The event is copied into the queue, and the<br/>
		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
		/// of the device within SDL.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter but events added with SDL_PeepEvents() do not.<br/>
		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
		/// get an event type that does not conflict with other code that also wants<br/>
		/// its own custom event types.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PushEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt)
		{
			byte ret = PushEventNative((SDLEvent*)evnt);
			return ret != 0;
		}

		/// <summary>
		/// Add an event to the event queue.<br/>
		/// The event queue can actually be used as a two way communication channel.<br/>
		/// Not only can events be read from the queue, but the user can also push<br/>
		/// their own events onto it. `event` is a pointer to the event structure you<br/>
		/// wish to push onto the queue. The event is copied into the queue, and the<br/>
		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
		/// of the device within SDL.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter but events added with SDL_PeepEvents() do not.<br/>
		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
		/// get an event type that does not conflict with other code that also wants<br/>
		/// its own custom event types.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PushEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte ret = PushEventNative((SDLEvent*)pevnt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set up a filter to process all events before they are added to the internal<br/>
		/// event queue.<br/>
		/// If you just want to see events without modifying them or preventing them<br/>
		/// from being queued, you should use SDL_AddEventWatch() instead.<br/>
		/// If the filter function returns true when called, then the event will be<br/>
		/// added to the internal queue. If it returns false, then the event will be<br/>
		/// dropped from the queue, but the internal state will still be updated. This<br/>
		/// allows selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread! The exception is handling of<br/>
		/// SDL_EVENT_WINDOW_EXPOSED, which is guaranteed to be sent from the OS on the<br/>
		/// main thread and you are expected to redraw your window in response to this<br/>
		/// event.<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_SetEventEnabled().<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetEventFilterNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, bool>, void*, void>)funcTable[830])(filter, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[830])((nint)filter, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set up a filter to process all events before they are added to the internal<br/>
		/// event queue.<br/>
		/// If you just want to see events without modifying them or preventing them<br/>
		/// from being queued, you should use SDL_AddEventWatch() instead.<br/>
		/// If the filter function returns true when called, then the event will be<br/>
		/// added to the internal queue. If it returns false, then the event will be<br/>
		/// dropped from the queue, but the internal state will still be updated. This<br/>
		/// allows selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread! The exception is handling of<br/>
		/// SDL_EVENT_WINDOW_EXPOSED, which is guaranteed to be sent from the OS on the<br/>
		/// main thread and you are expected to redraw your window in response to this<br/>
		/// event.<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_SetEventEnabled().<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetEventFilterNative(filter, userdata);
		}

		/// <summary>
		/// Set up a filter to process all events before they are added to the internal<br/>
		/// event queue.<br/>
		/// If you just want to see events without modifying them or preventing them<br/>
		/// from being queued, you should use SDL_AddEventWatch() instead.<br/>
		/// If the filter function returns true when called, then the event will be<br/>
		/// added to the internal queue. If it returns false, then the event will be<br/>
		/// dropped from the queue, but the internal state will still be updated. This<br/>
		/// allows selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread! The exception is handling of<br/>
		/// SDL_EVENT_WINDOW_EXPOSED, which is guaranteed to be sent from the OS on the<br/>
		/// main thread and you are expected to redraw your window in response to this<br/>
		/// event.<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_SetEventEnabled().<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetEventFilterNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), userdata);
		}

		/// <summary>
		/// Set up a filter to process all events before they are added to the internal<br/>
		/// event queue.<br/>
		/// If you just want to see events without modifying them or preventing them<br/>
		/// from being queued, you should use SDL_AddEventWatch() instead.<br/>
		/// If the filter function returns true when called, then the event will be<br/>
		/// added to the internal queue. If it returns false, then the event will be<br/>
		/// dropped from the queue, but the internal state will still be updated. This<br/>
		/// allows selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread! The exception is handling of<br/>
		/// SDL_EVENT_WINDOW_EXPOSED, which is guaranteed to be sent from the OS on the<br/>
		/// main thread and you are expected to redraw your window in response to this<br/>
		/// event.<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_SetEventEnabled().<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetEventFilterNative(filter, (void*)userdata);
		}

		/// <summary>
		/// Set up a filter to process all events before they are added to the internal<br/>
		/// event queue.<br/>
		/// If you just want to see events without modifying them or preventing them<br/>
		/// from being queued, you should use SDL_AddEventWatch() instead.<br/>
		/// If the filter function returns true when called, then the event will be<br/>
		/// added to the internal queue. If it returns false, then the event will be<br/>
		/// dropped from the queue, but the internal state will still be updated. This<br/>
		/// allows selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread! The exception is handling of<br/>
		/// SDL_EVENT_WINDOW_EXPOSED, which is guaranteed to be sent from the OS on the<br/>
		/// main thread and you are expected to redraw your window in response to this<br/>
		/// event.<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_SetEventEnabled().<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetEventFilterNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), (void*)userdata);
		}

		/// <summary>
		/// Query the current event filter.<br/>
		/// This function can be used to "chain" filters, by saving the existing filter<br/>
		/// before replacing it with a function that will call that saved filter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventFilter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetEventFilterNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter *")] delegate*<void*, SDLEvent*, bool>* filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void * *")] void** userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, bool>*, void**, byte>)funcTable[831])(filter, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[831])((nint)filter, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Query the current event filter.<br/>
		/// This function can be used to "chain" filters, by saving the existing filter<br/>
		/// before replacing it with a function that will call that saved filter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventFilter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter *")] delegate*<void*, SDLEvent*, bool>* filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void * *")] void** userdata)
		{
			byte ret = GetEventFilterNative(filter, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Query the current event filter.<br/>
		/// This function can be used to "chain" filters, by saving the existing filter<br/>
		/// before replacing it with a function that will call that saved filter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventFilter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter *")] delegate*<void*, SDLEvent*, bool>* filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void * *")] ref nint userdata)
		{
			fixed (nint* puserdata = &userdata)
			{
				byte ret = GetEventFilterNative(filter, (void**)puserdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AddEventWatchNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, bool>, void*, byte>)funcTable[832])(filter, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[832])((nint)filter, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = AddEventWatchNative(filter, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = AddEventWatchNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), userdata);
			return ret != 0;
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = AddEventWatchNative(filter, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = AddEventWatchNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveEventWatchNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, bool>, void*, void>)funcTable[833])(filter, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[833])((nint)filter, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			RemoveEventWatchNative(filter, userdata);
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			RemoveEventWatchNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), userdata);
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			RemoveEventWatchNative(filter, (void*)userdata);
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			RemoveEventWatchNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), (void*)userdata);
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns false.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FilterEventsNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, bool>, void*, void>)funcTable[834])(filter, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[834])((nint)filter, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns false.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FilterEvents([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			FilterEventsNative(filter, userdata);
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns false.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FilterEvents([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			FilterEventsNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), userdata);
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns false.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FilterEvents([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] delegate*<void*, SDLEvent*, bool> filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			FilterEventsNative(filter, (void*)userdata);
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns false.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FilterEvents([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			FilterEventsNative((delegate*<void*, SDLEvent*, bool>)Utils.GetFunctionPointerForDelegate(filter), (void*)userdata);
		}

		/// <summary>
		/// Set the state of processing events by type.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetEventEnabledNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[835])(type, enabled);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[835])(type, enabled);
			#endif
		}

		/// <summary>
		/// Set the state of processing events by type.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetEventEnabled([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			SetEventEnabledNative(type, enabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Query the state of processing events by type.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EventEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EventEnabledNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[836])(type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[836])(type);
			#endif
		}

		/// <summary>
		/// Query the state of processing events by type.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EventEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EventEnabled([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			byte ret = EventEnabledNative(type);
			return ret != 0;
		}

		/// <summary>
		/// Allocate a set of user-defined events, and return the beginning event<br/>
		/// number for that set of events.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterEvents")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint RegisterEventsNative([NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[837])(numevents);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[837])(numevents);
			#endif
		}

		/// <summary>
		/// Allocate a set of user-defined events, and return the beginning event<br/>
		/// number for that set of events.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterEvents")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint RegisterEvents([NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents)
		{
			uint ret = RegisterEventsNative(numevents);
			return ret;
		}

		/// <summary>
		/// Get window associated with an event.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowFromEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetWindowFromEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, SDLWindow*>)funcTable[838])(evnt);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[838])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Get window associated with an event.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowFromEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindowPtr GetWindowFromEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEventPtr evnt)
		{
			SDLWindowPtr ret = GetWindowFromEventNative((SDLEvent*)evnt);
			return ret;
		}

		/// <summary>
		/// Get window associated with an event.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowFromEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindowPtr GetWindowFromEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] in SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				SDLWindowPtr ret = GetWindowFromEventNative((SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Generate an English description of an event.<br/>
		/// This will fill `buf` with a null-terminated string that might look<br/>
		/// something like this:<br/>
		/// ```<br/>
		/// SDL_EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99 y=139.09 xrel=52 yrel=6)<br/>
		/// ```<br/>
		/// The exact format of the string is not guaranteed; it is intended for<br/>
		/// logging purposes, to be read by a human, and not parsed by a computer.<br/>
		/// The returned value follows the same rules as SDL_snprintf(): `buf` will<br/>
		/// always be NULL-terminated (unless `buflen` is zero), and will be truncated<br/>
		/// if `buflen` is too small. The return code is the number of bytes needed for<br/>
		/// the complete string, not counting the NULL-terminator, whether the string<br/>
		/// was truncated or not. Unlike SDL_snprintf(), though, this function never<br/>
		/// returns -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventDescription")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetEventDescriptionNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "char *")] byte* buf, [NativeName(NativeNameType.Param, "buflen")] [NativeName(NativeNameType.Type, "int")] int buflen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, byte*, int, int>)funcTable[839])(evnt, buf, buflen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[839])((nint)evnt, (nint)buf, buflen);
			#endif
		}

		/// <summary>
		/// Generate an English description of an event.<br/>
		/// This will fill `buf` with a null-terminated string that might look<br/>
		/// something like this:<br/>
		/// ```<br/>
		/// SDL_EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99 y=139.09 xrel=52 yrel=6)<br/>
		/// ```<br/>
		/// The exact format of the string is not guaranteed; it is intended for<br/>
		/// logging purposes, to be read by a human, and not parsed by a computer.<br/>
		/// The returned value follows the same rules as SDL_snprintf(): `buf` will<br/>
		/// always be NULL-terminated (unless `buflen` is zero), and will be truncated<br/>
		/// if `buflen` is too small. The return code is the number of bytes needed for<br/>
		/// the complete string, not counting the NULL-terminator, whether the string<br/>
		/// was truncated or not. Unlike SDL_snprintf(), though, this function never<br/>
		/// returns -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventDescription")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetEventDescription([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "char *")] byte* buf, [NativeName(NativeNameType.Param, "buflen")] [NativeName(NativeNameType.Type, "int")] int buflen)
		{
			int ret = GetEventDescriptionNative((SDLEvent*)evnt, buf, buflen);
			return ret;
		}

		/// <summary>
		/// Generate an English description of an event.<br/>
		/// This will fill `buf` with a null-terminated string that might look<br/>
		/// something like this:<br/>
		/// ```<br/>
		/// SDL_EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99 y=139.09 xrel=52 yrel=6)<br/>
		/// ```<br/>
		/// The exact format of the string is not guaranteed; it is intended for<br/>
		/// logging purposes, to be read by a human, and not parsed by a computer.<br/>
		/// The returned value follows the same rules as SDL_snprintf(): `buf` will<br/>
		/// always be NULL-terminated (unless `buflen` is zero), and will be truncated<br/>
		/// if `buflen` is too small. The return code is the number of bytes needed for<br/>
		/// the complete string, not counting the NULL-terminator, whether the string<br/>
		/// was truncated or not. Unlike SDL_snprintf(), though, this function never<br/>
		/// returns -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventDescription")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetEventDescription([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] in SDLEvent evnt, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "char *")] byte* buf, [NativeName(NativeNameType.Param, "buflen")] [NativeName(NativeNameType.Type, "int")] int buflen)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = GetEventDescriptionNative((SDLEvent*)pevnt, buf, buflen);
				return ret;
			}
		}

		/// <summary>
		/// Generate an English description of an event.<br/>
		/// This will fill `buf` with a null-terminated string that might look<br/>
		/// something like this:<br/>
		/// ```<br/>
		/// SDL_EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99 y=139.09 xrel=52 yrel=6)<br/>
		/// ```<br/>
		/// The exact format of the string is not guaranteed; it is intended for<br/>
		/// logging purposes, to be read by a human, and not parsed by a computer.<br/>
		/// The returned value follows the same rules as SDL_snprintf(): `buf` will<br/>
		/// always be NULL-terminated (unless `buflen` is zero), and will be truncated<br/>
		/// if `buflen` is too small. The return code is the number of bytes needed for<br/>
		/// the complete string, not counting the NULL-terminator, whether the string<br/>
		/// was truncated or not. Unlike SDL_snprintf(), though, this function never<br/>
		/// returns -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventDescription")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetEventDescription([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "char *")] ref byte buf, [NativeName(NativeNameType.Param, "buflen")] [NativeName(NativeNameType.Type, "int")] int buflen)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = GetEventDescriptionNative((SDLEvent*)evnt, (byte*)pbuf, buflen);
				return ret;
			}
		}

		/// <summary>
		/// Generate an English description of an event.<br/>
		/// This will fill `buf` with a null-terminated string that might look<br/>
		/// something like this:<br/>
		/// ```<br/>
		/// SDL_EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99 y=139.09 xrel=52 yrel=6)<br/>
		/// ```<br/>
		/// The exact format of the string is not guaranteed; it is intended for<br/>
		/// logging purposes, to be read by a human, and not parsed by a computer.<br/>
		/// The returned value follows the same rules as SDL_snprintf(): `buf` will<br/>
		/// always be NULL-terminated (unless `buflen` is zero), and will be truncated<br/>
		/// if `buflen` is too small. The return code is the number of bytes needed for<br/>
		/// the complete string, not counting the NULL-terminator, whether the string<br/>
		/// was truncated or not. Unlike SDL_snprintf(), though, this function never<br/>
		/// returns -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventDescription")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetEventDescription([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "char *")] ref string buf, [NativeName(NativeNameType.Param, "buflen")] [NativeName(NativeNameType.Type, "int")] int buflen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetEventDescriptionNative((SDLEvent*)evnt, pStr0, buflen);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Generate an English description of an event.<br/>
		/// This will fill `buf` with a null-terminated string that might look<br/>
		/// something like this:<br/>
		/// ```<br/>
		/// SDL_EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99 y=139.09 xrel=52 yrel=6)<br/>
		/// ```<br/>
		/// The exact format of the string is not guaranteed; it is intended for<br/>
		/// logging purposes, to be read by a human, and not parsed by a computer.<br/>
		/// The returned value follows the same rules as SDL_snprintf(): `buf` will<br/>
		/// always be NULL-terminated (unless `buflen` is zero), and will be truncated<br/>
		/// if `buflen` is too small. The return code is the number of bytes needed for<br/>
		/// the complete string, not counting the NULL-terminator, whether the string<br/>
		/// was truncated or not. Unlike SDL_snprintf(), though, this function never<br/>
		/// returns -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventDescription")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetEventDescription([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] in SDLEvent evnt, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "char *")] ref byte buf, [NativeName(NativeNameType.Param, "buflen")] [NativeName(NativeNameType.Type, "int")] int buflen)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				fixed (byte* pbuf = &buf)
				{
					int ret = GetEventDescriptionNative((SDLEvent*)pevnt, (byte*)pbuf, buflen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Generate an English description of an event.<br/>
		/// This will fill `buf` with a null-terminated string that might look<br/>
		/// something like this:<br/>
		/// ```<br/>
		/// SDL_EVENT_MOUSE_MOTION (timestamp=1140256324 windowid=2 which=0 state=0 x=492.99 y=139.09 xrel=52 yrel=6)<br/>
		/// ```<br/>
		/// The exact format of the string is not guaranteed; it is intended for<br/>
		/// logging purposes, to be read by a human, and not parsed by a computer.<br/>
		/// The returned value follows the same rules as SDL_snprintf(): `buf` will<br/>
		/// always be NULL-terminated (unless `buflen` is zero), and will be truncated<br/>
		/// if `buflen` is too small. The return code is the number of bytes needed for<br/>
		/// the complete string, not counting the NULL-terminator, whether the string<br/>
		/// was truncated or not. Unlike SDL_snprintf(), though, this function never<br/>
		/// returns -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventDescription")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetEventDescription([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] in SDLEvent evnt, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "char *")] ref string buf, [NativeName(NativeNameType.Param, "buflen")] [NativeName(NativeNameType.Type, "int")] int buflen)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (buf != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(buf);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = GetEventDescriptionNative((SDLEvent*)pevnt, pStr0, buflen);
				buf = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get the directory where the application was run from.<br/>
		/// SDL caches the result of this call internally, but the first call to this<br/>
		/// function is not necessarily fast, so plan accordingly.<br/>
		/// **macOS and iOS Specific Functionality**: If the application is in a ".app"<br/>
		/// bundle, this function returns the Resource directory (e.g.<br/>
		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
		/// a property to the Info.plist file. Adding a string key with the name<br/>
		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
		/// behaviour.<br/>
		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
		/// application in /Applications/SDLApp/MyApp.app):<br/>
		/// - `resource`: bundle resource directory (the default). For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
		/// - `bundle`: the Bundle directory. For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/`<br/>
		/// - `parent`: the containing directory of the bundle. For example:<br/>
		/// `/Applications/SDLApp/`<br/>
		/// **Android Specific Functionality**: This function returns "./", which<br/>
		/// allows filesystem operations to use internal storage and the asset system.<br/>
		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
		/// directory of the application as it is uncommon to store resources outside<br/>
		/// the executable. As such it is not a writable directory.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetBasePathNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[840])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[840])();
			#endif
		}

		/// <summary>
		/// Get the directory where the application was run from.<br/>
		/// SDL caches the result of this call internally, but the first call to this<br/>
		/// function is not necessarily fast, so plan accordingly.<br/>
		/// **macOS and iOS Specific Functionality**: If the application is in a ".app"<br/>
		/// bundle, this function returns the Resource directory (e.g.<br/>
		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
		/// a property to the Info.plist file. Adding a string key with the name<br/>
		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
		/// behaviour.<br/>
		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
		/// application in /Applications/SDLApp/MyApp.app):<br/>
		/// - `resource`: bundle resource directory (the default). For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
		/// - `bundle`: the Bundle directory. For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/`<br/>
		/// - `parent`: the containing directory of the bundle. For example:<br/>
		/// `/Applications/SDLApp/`<br/>
		/// **Android Specific Functionality**: This function returns "./", which<br/>
		/// allows filesystem operations to use internal storage and the asset system.<br/>
		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
		/// directory of the application as it is uncommon to store resources outside<br/>
		/// the executable. As such it is not a writable directory.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetBasePath()
		{
			byte* ret = GetBasePathNative();
			return ret;
		}

		/// <summary>
		/// Get the directory where the application was run from.<br/>
		/// SDL caches the result of this call internally, but the first call to this<br/>
		/// function is not necessarily fast, so plan accordingly.<br/>
		/// **macOS and iOS Specific Functionality**: If the application is in a ".app"<br/>
		/// bundle, this function returns the Resource directory (e.g.<br/>
		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
		/// a property to the Info.plist file. Adding a string key with the name<br/>
		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
		/// behaviour.<br/>
		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
		/// application in /Applications/SDLApp/MyApp.app):<br/>
		/// - `resource`: bundle resource directory (the default). For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
		/// - `bundle`: the Bundle directory. For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/`<br/>
		/// - `parent`: the containing directory of the bundle. For example:<br/>
		/// `/Applications/SDLApp/`<br/>
		/// **Android Specific Functionality**: This function returns "./", which<br/>
		/// allows filesystem operations to use internal storage and the asset system.<br/>
		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
		/// directory of the application as it is uncommon to store resources outside<br/>
		/// the executable. As such it is not a writable directory.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetBasePathS()
		{
			string ret = Utils.DecodeStringUTF8(GetBasePathNative());
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPrefPathNative([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)funcTable[841])(org, app);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[841])((nint)org, (nint)app);
			#endif
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			byte* ret = GetPrefPathNative(org, app);
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			string ret = Utils.DecodeStringUTF8(GetPrefPathNative(org, app));
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] in byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			fixed (byte* porg = &org)
			{
				byte* ret = GetPrefPathNative((byte*)porg, app);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] in byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			fixed (byte* porg = &org)
			{
				string ret = Utils.DecodeStringUTF8(GetPrefPathNative((byte*)porg, app));
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			fixed (byte* porg = org)
			{
				byte* ret = GetPrefPathNative((byte*)porg, app);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			fixed (byte* porg = org)
			{
				string ret = Utils.DecodeStringUTF8(GetPrefPathNative((byte*)porg, app));
				return ret;
			}
		}
	}
}
