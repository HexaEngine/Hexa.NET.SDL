// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfoPtr info)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = &path)
				{
					byte ret = GetStoragePathInfoNative((SDLStorage*)pstorage, (byte*)ppath, (SDLPathInfo*)info);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfoPtr info)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = path)
				{
					byte ret = GetStoragePathInfoNative((SDLStorage*)pstorage, (byte*)ppath, (SDLPathInfo*)info);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfoPtr info)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (path != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(path);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = GetStoragePathInfoNative((SDLStorage*)pstorage, pStr0, (SDLPathInfo*)info);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (SDLPathInfo* pinfo = &info)
			{
				byte ret = GetStoragePathInfoNative((SDLStorage*)storage, path, (SDLPathInfo*)pinfo);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (SDLPathInfo* pinfo = &info)
				{
					byte ret = GetStoragePathInfoNative((SDLStorage*)pstorage, path, (SDLPathInfo*)pinfo);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLPathInfo* pinfo = &info)
				{
					byte ret = GetStoragePathInfoNative((SDLStorage*)storage, (byte*)ppath, (SDLPathInfo*)pinfo);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLPathInfo* pinfo = &info)
				{
					byte ret = GetStoragePathInfoNative((SDLStorage*)storage, (byte*)ppath, (SDLPathInfo*)pinfo);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLPathInfo* pinfo = &info)
			{
				byte ret = GetStoragePathInfoNative((SDLStorage*)storage, pStr0, (SDLPathInfo*)pinfo);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = &path)
				{
					fixed (SDLPathInfo* pinfo = &info)
					{
						byte ret = GetStoragePathInfoNative((SDLStorage*)pstorage, (byte*)ppath, (SDLPathInfo*)pinfo);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = path)
				{
					fixed (SDLPathInfo* pinfo = &info)
					{
						byte ret = GetStoragePathInfoNative((SDLStorage*)pstorage, (byte*)ppath, (SDLPathInfo*)pinfo);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStoragePathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetStoragePathInfo([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (path != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(path);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (SDLPathInfo* pinfo = &info)
				{
					byte ret = GetStoragePathInfoNative((SDLStorage*)pstorage, pStr0, (SDLPathInfo*)pinfo);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Queries the remaining space in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStorageSpaceRemaining")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetStorageSpaceRemainingNative([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStorage* storage)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLStorage*, ulong>)funcTable[1173])(storage);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[1173])((nint)storage);
			#endif
		}

		/// <summary>
		/// Queries the remaining space in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStorageSpaceRemaining")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetStorageSpaceRemaining([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage)
		{
			ulong ret = GetStorageSpaceRemainingNative((SDLStorage*)storage);
			return ret;
		}

		/// <summary>
		/// Queries the remaining space in a storage container.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStorageSpaceRemaining")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetStorageSpaceRemaining([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				ulong ret = GetStorageSpaceRemainingNative((SDLStorage*)pstorage);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GlobStorageDirectoryNative([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStorage* storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLStorage*, byte*, byte*, uint, int*, byte**>)funcTable[1174])(storage, path, pattern, flags, count);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, nint, nint>)funcTable[1174])((nint)storage, (nint)path, (nint)pattern, flags, (nint)count);
			#endif
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, pattern, flags, count);
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, pattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = &path)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, pattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = path)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, pattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, pStr0, pattern, flags, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = &path)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, pattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = path)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, pattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (path != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(path);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, pStr0, pattern, flags, count);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppattern = &pattern)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, (byte*)ppattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppattern = pattern)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, (byte*)ppattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, pStr0, flags, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppattern = &pattern)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, (byte*)ppattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppattern = pattern)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, (byte*)ppattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pattern != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pattern);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, pStr0, flags, count);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte* ppattern = &pattern)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, (byte*)ppattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte* ppattern = pattern)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, (byte*)ppattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pattern != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pattern, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, pStr0, pStr1, flags, count);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = &path)
				{
					fixed (byte* ppattern = &pattern)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, (byte*)ppattern, flags, count);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = path)
				{
					fixed (byte* ppattern = pattern)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, (byte*)ppattern, flags, count);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (path != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(path);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pattern != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pattern);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pattern, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, pStr0, pStr1, flags, count);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, pattern, flags, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, pattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = &path)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, pattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = path)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, pattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, pStr0, pattern, flags, (int*)pcount);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = &path)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, pattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = path)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, pattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (path != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(path);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, pStr0, pattern, flags, (int*)pcount);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppattern = &pattern)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, (byte*)ppattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppattern = pattern)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, (byte*)ppattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, path, pStr0, flags, (int*)pcount);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppattern = &pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppattern = pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pattern != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pattern);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, path, pStr0, flags, (int*)pcount);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte* ppattern = &pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte* ppattern = pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, (byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] SDLStoragePtr storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pattern != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pattern, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobStorageDirectoryNative((SDLStorage*)storage, pStr0, pStr1, flags, (int*)pcount);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = &path)
				{
					fixed (byte* ppattern = &pattern)
					{
						fixed (int* pcount = &count)
						{
							byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				fixed (byte* ppath = path)
				{
					fixed (byte* ppattern = pattern)
					{
						fixed (int* pcount = &count)
						{
							byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, (byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// If `path` is NULL, this is treated as a request to enumerate the root of<br/>
		/// the storage container's tree. An empty string also works for this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, assuming<br/>
		/// the `storage` object is thread-safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobStorageDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobStorageDirectory([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "SDL_Storage *")] ref SDLStorage storage, [NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (path != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(path);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pattern != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pattern);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pattern, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (int* pcount = &count)
				{
					byte** ret = GlobStorageDirectoryNative((SDLStorage*)pstorage, pStr0, pStr1, flags, (int*)pcount);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// The callback may modify the message, and should return true if the message<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowsMessageHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowsMessageHookNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_WindowsMessageHook")] delegate*<void*, TagMSG*, bool> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, TagMSG*, bool>, void*, void>)funcTable[1175])(callback, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1175])((nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// The callback may modify the message, and should return true if the message<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowsMessageHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowsMessageHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_WindowsMessageHook")] delegate*<void*, TagMSG*, bool> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetWindowsMessageHookNative(callback, userdata);
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// The callback may modify the message, and should return true if the message<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowsMessageHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowsMessageHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_WindowsMessageHook")] SDLWindowsMessageHook callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetWindowsMessageHookNative((delegate*<void*, TagMSG*, bool>)Utils.GetFunctionPointerForDelegate(callback), userdata);
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// The callback may modify the message, and should return true if the message<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowsMessageHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowsMessageHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_WindowsMessageHook")] delegate*<void*, TagMSG*, bool> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetWindowsMessageHookNative(callback, (void*)userdata);
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// The callback may modify the message, and should return true if the message<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowsMessageHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowsMessageHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_WindowsMessageHook")] SDLWindowsMessageHook callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetWindowsMessageHookNative((delegate*<void*, TagMSG*, bool>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
		}

		/// <summary>
		/// Get the D3D9 adapter index that matches the specified display.<br/>
		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
		/// controls on which monitor a full screen application will appear.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDirect3D9AdapterIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDirect3D9AdapterIndexNative([NativeName(NativeNameType.Param, "displayID")] [NativeName(NativeNameType.Type, "SDL_DisplayID")] uint displayID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int>)funcTable[1176])(displayID);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, int>)funcTable[1176])(displayID);
			#endif
		}

		/// <summary>
		/// Get the D3D9 adapter index that matches the specified display.<br/>
		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
		/// controls on which monitor a full screen application will appear.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDirect3D9AdapterIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetDirect3D9AdapterIndex([NativeName(NativeNameType.Param, "displayID")] [NativeName(NativeNameType.Type, "SDL_DisplayID")] uint displayID)
		{
			int ret = GetDirect3D9AdapterIndexNative(displayID);
			return ret;
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDXGIOutputInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetDXGIOutputInfoNative([NativeName(NativeNameType.Param, "displayID")] [NativeName(NativeNameType.Type, "SDL_DisplayID")] uint displayID, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int *")] int* adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int *")] int* outputIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int*, int*, byte>)funcTable[1177])(displayID, adapterIndex, outputIndex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[1177])(displayID, (nint)adapterIndex, (nint)outputIndex);
			#endif
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDXGIOutputInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDXGIOutputInfo([NativeName(NativeNameType.Param, "displayID")] [NativeName(NativeNameType.Type, "SDL_DisplayID")] uint displayID, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int *")] int* adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int *")] int* outputIndex)
		{
			byte ret = GetDXGIOutputInfoNative(displayID, adapterIndex, outputIndex);
			return ret != 0;
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDXGIOutputInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDXGIOutputInfo([NativeName(NativeNameType.Param, "displayID")] [NativeName(NativeNameType.Type, "SDL_DisplayID")] uint displayID, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int *")] ref int adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int *")] int* outputIndex)
		{
			fixed (int* padapterIndex = &adapterIndex)
			{
				byte ret = GetDXGIOutputInfoNative(displayID, (int*)padapterIndex, outputIndex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDXGIOutputInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDXGIOutputInfo([NativeName(NativeNameType.Param, "displayID")] [NativeName(NativeNameType.Type, "SDL_DisplayID")] uint displayID, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int *")] int* adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int *")] ref int outputIndex)
		{
			fixed (int* poutputIndex = &outputIndex)
			{
				byte ret = GetDXGIOutputInfoNative(displayID, adapterIndex, (int*)poutputIndex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDXGIOutputInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDXGIOutputInfo([NativeName(NativeNameType.Param, "displayID")] [NativeName(NativeNameType.Type, "SDL_DisplayID")] uint displayID, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int *")] ref int adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int *")] ref int outputIndex)
		{
			fixed (int* padapterIndex = &adapterIndex)
			{
				fixed (int* poutputIndex = &outputIndex)
				{
					byte ret = GetDXGIOutputInfoNative(displayID, (int*)padapterIndex, (int*)poutputIndex);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a callback for every X11 event.<br/>
		/// The callback may modify the event, and should return true if the event<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetX11EventHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetX11EventHookNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_X11EventHook")] delegate*<void*, XEvent*, bool> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, XEvent*, bool>, void*, void>)funcTable[1178])(callback, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1178])((nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a callback for every X11 event.<br/>
		/// The callback may modify the event, and should return true if the event<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetX11EventHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetX11EventHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_X11EventHook")] delegate*<void*, XEvent*, bool> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetX11EventHookNative(callback, userdata);
		}

		/// <summary>
		/// Set a callback for every X11 event.<br/>
		/// The callback may modify the event, and should return true if the event<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetX11EventHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetX11EventHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_X11EventHook")] SDLX11EventHook callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetX11EventHookNative((delegate*<void*, XEvent*, bool>)Utils.GetFunctionPointerForDelegate(callback), userdata);
		}

		/// <summary>
		/// Set a callback for every X11 event.<br/>
		/// The callback may modify the event, and should return true if the event<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetX11EventHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetX11EventHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_X11EventHook")] delegate*<void*, XEvent*, bool> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetX11EventHookNative(callback, (void*)userdata);
		}

		/// <summary>
		/// Set a callback for every X11 event.<br/>
		/// The callback may modify the event, and should return true if the event<br/>
		/// should continue to be processed, or false to prevent further processing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetX11EventHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetX11EventHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_X11EventHook")] SDLX11EventHook callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			SetX11EventHookNative((delegate*<void*, XEvent*, bool>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
		}

		/// <summary>
		/// Query if the current device is a tablet.<br/>
		/// If SDL can't determine this, it will return false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTablet")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTabletNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1179])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1179])();
			#endif
		}

		/// <summary>
		/// Query if the current device is a tablet.<br/>
		/// If SDL can't determine this, it will return false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTablet")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsTablet()
		{
			byte ret = IsTabletNative();
			return ret != 0;
		}

		/// <summary>
		/// Query if the current device is a TV.<br/>
		/// If SDL can't determine this, it will return false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTVNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1180])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1180])();
			#endif
		}

		/// <summary>
		/// Query if the current device is a TV.<br/>
		/// If SDL can't determine this, it will return false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsTV()
		{
			byte ret = IsTVNative();
			return ret != 0;
		}

		/// <summary>
		/// Get the application sandbox environment, if any.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSandbox")]
		[return: NativeName(NativeNameType.Type, "SDL_Sandbox")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSandbox GetSandboxNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSandbox>)funcTable[1181])();
			#else
			return (SDLSandbox)((delegate* unmanaged[Cdecl]<SDLSandbox>)funcTable[1181])();
			#endif
		}

		/// <summary>
		/// Get the application sandbox environment, if any.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSandbox")]
		[return: NativeName(NativeNameType.Type, "SDL_Sandbox")]
		public static SDLSandbox GetSandbox()
		{
			SDLSandbox ret = GetSandboxNative();
			return ret;
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationWillTerminate.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillTerminate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationWillTerminateNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1182])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1182])();
			#endif
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationWillTerminate.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillTerminate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OnApplicationWillTerminate()
		{
			OnApplicationWillTerminateNative();
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationDidReceiveMemoryWarning.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidReceiveMemoryWarning")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationDidReceiveMemoryWarningNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1183])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1183])();
			#endif
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationDidReceiveMemoryWarning.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidReceiveMemoryWarning")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OnApplicationDidReceiveMemoryWarning()
		{
			OnApplicationDidReceiveMemoryWarningNative();
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationWillResignActive.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillEnterBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationWillEnterBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1184])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1184])();
			#endif
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationWillResignActive.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillEnterBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OnApplicationWillEnterBackground()
		{
			OnApplicationWillEnterBackgroundNative();
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationDidEnterBackground.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidEnterBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationDidEnterBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1185])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1185])();
			#endif
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationDidEnterBackground.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidEnterBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OnApplicationDidEnterBackground()
		{
			OnApplicationDidEnterBackgroundNative();
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationWillEnterForeground.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillEnterForeground")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationWillEnterForegroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1186])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1186])();
			#endif
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationWillEnterForeground.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillEnterForeground")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OnApplicationWillEnterForeground()
		{
			OnApplicationWillEnterForegroundNative();
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationDidBecomeActive.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidEnterForeground")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnApplicationDidEnterForegroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1187])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1187])();
			#endif
		}

		/// <summary>
		/// Let iOS apps with external event handling report<br/>
		/// onApplicationDidBecomeActive.<br/>
		/// This functions allows iOS apps that have their own event handling to hook<br/>
		/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
		/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
		/// available on all platforms, in case it might be useful for some specific<br/>
		/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
		/// code will handle all this for windows created by SDL_CreateWindow!<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidEnterForeground")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OnApplicationDidEnterForeground()
		{
			OnApplicationDidEnterForegroundNative();
		}

		/// <summary>
		/// Gets the current preferred date and time format for the system locale.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, the preferred<br/>
		/// formats can change, usually because the user has changed a system<br/>
		/// preference outside of your program.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDateTimeLocalePreferences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetDateTimeLocalePreferencesNative([NativeName(NativeNameType.Param, "dateFormat")] [NativeName(NativeNameType.Type, "SDL_DateFormat *")] SDLDateFormat* dateFormat, [NativeName(NativeNameType.Param, "timeFormat")] [NativeName(NativeNameType.Type, "SDL_TimeFormat *")] SDLTimeFormat* timeFormat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLDateFormat*, SDLTimeFormat*, byte>)funcTable[1188])(dateFormat, timeFormat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1188])((nint)dateFormat, (nint)timeFormat);
			#endif
		}

		/// <summary>
		/// Gets the current preferred date and time format for the system locale.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, the preferred<br/>
		/// formats can change, usually because the user has changed a system<br/>
		/// preference outside of your program.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDateTimeLocalePreferences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDateTimeLocalePreferences([NativeName(NativeNameType.Param, "dateFormat")] [NativeName(NativeNameType.Type, "SDL_DateFormat *")] SDLDateFormat* dateFormat, [NativeName(NativeNameType.Param, "timeFormat")] [NativeName(NativeNameType.Type, "SDL_TimeFormat *")] SDLTimeFormat* timeFormat)
		{
			byte ret = GetDateTimeLocalePreferencesNative(dateFormat, timeFormat);
			return ret != 0;
		}

		/// <summary>
		/// Gets the current preferred date and time format for the system locale.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, the preferred<br/>
		/// formats can change, usually because the user has changed a system<br/>
		/// preference outside of your program.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDateTimeLocalePreferences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDateTimeLocalePreferences([NativeName(NativeNameType.Param, "dateFormat")] [NativeName(NativeNameType.Type, "SDL_DateFormat *")] ref SDLDateFormat dateFormat, [NativeName(NativeNameType.Param, "timeFormat")] [NativeName(NativeNameType.Type, "SDL_TimeFormat *")] SDLTimeFormat* timeFormat)
		{
			fixed (SDLDateFormat* pdateFormat = &dateFormat)
			{
				byte ret = GetDateTimeLocalePreferencesNative((SDLDateFormat*)pdateFormat, timeFormat);
				return ret != 0;
			}
		}

		/// <summary>
		/// Gets the current preferred date and time format for the system locale.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, the preferred<br/>
		/// formats can change, usually because the user has changed a system<br/>
		/// preference outside of your program.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDateTimeLocalePreferences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDateTimeLocalePreferences([NativeName(NativeNameType.Param, "dateFormat")] [NativeName(NativeNameType.Type, "SDL_DateFormat *")] SDLDateFormat* dateFormat, [NativeName(NativeNameType.Param, "timeFormat")] [NativeName(NativeNameType.Type, "SDL_TimeFormat *")] ref SDLTimeFormat timeFormat)
		{
			fixed (SDLTimeFormat* ptimeFormat = &timeFormat)
			{
				byte ret = GetDateTimeLocalePreferencesNative(dateFormat, (SDLTimeFormat*)ptimeFormat);
				return ret != 0;
			}
		}

		/// <summary>
		/// Gets the current preferred date and time format for the system locale.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, the preferred<br/>
		/// formats can change, usually because the user has changed a system<br/>
		/// preference outside of your program.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDateTimeLocalePreferences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetDateTimeLocalePreferences([NativeName(NativeNameType.Param, "dateFormat")] [NativeName(NativeNameType.Type, "SDL_DateFormat *")] ref SDLDateFormat dateFormat, [NativeName(NativeNameType.Param, "timeFormat")] [NativeName(NativeNameType.Type, "SDL_TimeFormat *")] ref SDLTimeFormat timeFormat)
		{
			fixed (SDLDateFormat* pdateFormat = &dateFormat)
			{
				fixed (SDLTimeFormat* ptimeFormat = &timeFormat)
				{
					byte ret = GetDateTimeLocalePreferencesNative((SDLDateFormat*)pdateFormat, (SDLTimeFormat*)ptimeFormat);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Gets the current value of the system realtime clock in nanoseconds since<br/>
		/// Jan 1, 1970 in Universal Coordinated Time (UTC).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetCurrentTimeNative([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] long* ticks)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, byte>)funcTable[1189])(ticks);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1189])((nint)ticks);
			#endif
		}

		/// <summary>
		/// Gets the current value of the system realtime clock in nanoseconds since<br/>
		/// Jan 1, 1970 in Universal Coordinated Time (UTC).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetCurrentTime([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] long* ticks)
		{
			byte ret = GetCurrentTimeNative(ticks);
			return ret != 0;
		}

		/// <summary>
		/// Gets the current value of the system realtime clock in nanoseconds since<br/>
		/// Jan 1, 1970 in Universal Coordinated Time (UTC).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetCurrentTime([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] ref long ticks)
		{
			fixed (long* pticks = &ticks)
			{
				byte ret = GetCurrentTimeNative((long*)pticks);
				return ret != 0;
			}
		}

		/// <summary>
		/// Converts an SDL_Time in nanoseconds since the epoch to a calendar time in<br/>
		/// the SDL_DateTime format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToDateTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TimeToDateTimeNative([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime *")] SDLDateTime* dt, [NativeName(NativeNameType.Param, "localTime")] [NativeName(NativeNameType.Type, "bool")] byte localTime)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, SDLDateTime*, byte, byte>)funcTable[1190])(ticks, dt, localTime);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<long, nint, byte, byte>)funcTable[1190])(ticks, (nint)dt, localTime);
			#endif
		}

		/// <summary>
		/// Converts an SDL_Time in nanoseconds since the epoch to a calendar time in<br/>
		/// the SDL_DateTime format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToDateTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TimeToDateTime([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime *")] SDLDateTimePtr dt, [NativeName(NativeNameType.Param, "localTime")] [NativeName(NativeNameType.Type, "bool")] bool localTime)
		{
			byte ret = TimeToDateTimeNative(ticks, (SDLDateTime*)dt, localTime ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Converts an SDL_Time in nanoseconds since the epoch to a calendar time in<br/>
		/// the SDL_DateTime format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToDateTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TimeToDateTime([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime *")] ref SDLDateTime dt, [NativeName(NativeNameType.Param, "localTime")] [NativeName(NativeNameType.Type, "bool")] bool localTime)
		{
			fixed (SDLDateTime* pdt = &dt)
			{
				byte ret = TimeToDateTimeNative(ticks, (SDLDateTime*)pdt, localTime ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Converts a calendar time to an SDL_Time in nanoseconds since the epoch.<br/>
		/// This function ignores the day_of_week member of the SDL_DateTime struct, so<br/>
		/// it may remain unset.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DateTimeToTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DateTimeToTimeNative([NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime const *")] SDLDateTime* dt, [NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] long* ticks)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLDateTime*, long*, byte>)funcTable[1191])(dt, ticks);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1191])((nint)dt, (nint)ticks);
			#endif
		}

		/// <summary>
		/// Converts a calendar time to an SDL_Time in nanoseconds since the epoch.<br/>
		/// This function ignores the day_of_week member of the SDL_DateTime struct, so<br/>
		/// it may remain unset.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DateTimeToTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DateTimeToTime([NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime const *")] SDLDateTimePtr dt, [NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] long* ticks)
		{
			byte ret = DateTimeToTimeNative((SDLDateTime*)dt, ticks);
			return ret != 0;
		}

		/// <summary>
		/// Converts a calendar time to an SDL_Time in nanoseconds since the epoch.<br/>
		/// This function ignores the day_of_week member of the SDL_DateTime struct, so<br/>
		/// it may remain unset.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DateTimeToTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DateTimeToTime([NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime const *")] in SDLDateTime dt, [NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] long* ticks)
		{
			fixed (SDLDateTime* pdt = &dt)
			{
				byte ret = DateTimeToTimeNative((SDLDateTime*)pdt, ticks);
				return ret != 0;
			}
		}

		/// <summary>
		/// Converts a calendar time to an SDL_Time in nanoseconds since the epoch.<br/>
		/// This function ignores the day_of_week member of the SDL_DateTime struct, so<br/>
		/// it may remain unset.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DateTimeToTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DateTimeToTime([NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime const *")] SDLDateTimePtr dt, [NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] ref long ticks)
		{
			fixed (long* pticks = &ticks)
			{
				byte ret = DateTimeToTimeNative((SDLDateTime*)dt, (long*)pticks);
				return ret != 0;
			}
		}

		/// <summary>
		/// Converts a calendar time to an SDL_Time in nanoseconds since the epoch.<br/>
		/// This function ignores the day_of_week member of the SDL_DateTime struct, so<br/>
		/// it may remain unset.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DateTimeToTime")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DateTimeToTime([NativeName(NativeNameType.Param, "dt")] [NativeName(NativeNameType.Type, "SDL_DateTime const *")] in SDLDateTime dt, [NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time *")] ref long ticks)
		{
			fixed (SDLDateTime* pdt = &dt)
			{
				fixed (long* pticks = &ticks)
				{
					byte ret = DateTimeToTimeNative((SDLDateTime*)pdt, (long*)pticks);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Converts an SDL time into a Windows FILETIME (100-nanosecond intervals<br/>
		/// since January 1, 1601).<br/>
		/// This function fills in the two 32-bit values of the FILETIME structure.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToWindows")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TimeToWindowsNative([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dwLowDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* dwLowDateTime, [NativeName(NativeNameType.Param, "dwHighDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* dwHighDateTime)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<long, uint*, uint*, void>)funcTable[1192])(ticks, dwLowDateTime, dwHighDateTime);
			#else
			((delegate* unmanaged[Cdecl]<long, nint, nint, void>)funcTable[1192])(ticks, (nint)dwLowDateTime, (nint)dwHighDateTime);
			#endif
		}

		/// <summary>
		/// Converts an SDL time into a Windows FILETIME (100-nanosecond intervals<br/>
		/// since January 1, 1601).<br/>
		/// This function fills in the two 32-bit values of the FILETIME structure.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToWindows")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TimeToWindows([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dwLowDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* dwLowDateTime, [NativeName(NativeNameType.Param, "dwHighDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* dwHighDateTime)
		{
			TimeToWindowsNative(ticks, dwLowDateTime, dwHighDateTime);
		}

		/// <summary>
		/// Converts an SDL time into a Windows FILETIME (100-nanosecond intervals<br/>
		/// since January 1, 1601).<br/>
		/// This function fills in the two 32-bit values of the FILETIME structure.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToWindows")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TimeToWindows([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dwLowDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint dwLowDateTime, [NativeName(NativeNameType.Param, "dwHighDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* dwHighDateTime)
		{
			fixed (uint* pdwLowDateTime = &dwLowDateTime)
			{
				TimeToWindowsNative(ticks, (uint*)pdwLowDateTime, dwHighDateTime);
			}
		}

		/// <summary>
		/// Converts an SDL time into a Windows FILETIME (100-nanosecond intervals<br/>
		/// since January 1, 1601).<br/>
		/// This function fills in the two 32-bit values of the FILETIME structure.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToWindows")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TimeToWindows([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dwLowDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* dwLowDateTime, [NativeName(NativeNameType.Param, "dwHighDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint dwHighDateTime)
		{
			fixed (uint* pdwHighDateTime = &dwHighDateTime)
			{
				TimeToWindowsNative(ticks, dwLowDateTime, (uint*)pdwHighDateTime);
			}
		}

		/// <summary>
		/// Converts an SDL time into a Windows FILETIME (100-nanosecond intervals<br/>
		/// since January 1, 1601).<br/>
		/// This function fills in the two 32-bit values of the FILETIME structure.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeToWindows")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TimeToWindows([NativeName(NativeNameType.Param, "ticks")] [NativeName(NativeNameType.Type, "SDL_Time")] long ticks, [NativeName(NativeNameType.Param, "dwLowDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint dwLowDateTime, [NativeName(NativeNameType.Param, "dwHighDateTime")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint dwHighDateTime)
		{
			fixed (uint* pdwLowDateTime = &dwLowDateTime)
			{
				fixed (uint* pdwHighDateTime = &dwHighDateTime)
				{
					TimeToWindowsNative(ticks, (uint*)pdwLowDateTime, (uint*)pdwHighDateTime);
				}
			}
		}

		/// <summary>
		/// Converts a Windows FILETIME (100-nanosecond intervals since January 1,<br/>
		/// 1601) to an SDL time.<br/>
		/// This function takes the two 32-bit values of the FILETIME structure as<br/>
		/// parameters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeFromWindows")]
		[return: NativeName(NativeNameType.Type, "SDL_Time")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long TimeFromWindowsNative([NativeName(NativeNameType.Param, "dwLowDateTime")] [NativeName(NativeNameType.Type, "Uint32")] uint dwLowDateTime, [NativeName(NativeNameType.Param, "dwHighDateTime")] [NativeName(NativeNameType.Type, "Uint32")] uint dwHighDateTime)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, long>)funcTable[1193])(dwLowDateTime, dwHighDateTime);
			#else
			return (long)((delegate* unmanaged[Cdecl]<uint, uint, long>)funcTable[1193])(dwLowDateTime, dwHighDateTime);
			#endif
		}

		/// <summary>
		/// Converts a Windows FILETIME (100-nanosecond intervals since January 1,<br/>
		/// 1601) to an SDL time.<br/>
		/// This function takes the two 32-bit values of the FILETIME structure as<br/>
		/// parameters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TimeFromWindows")]
		[return: NativeName(NativeNameType.Type, "SDL_Time")]
		public static long TimeFromWindows([NativeName(NativeNameType.Param, "dwLowDateTime")] [NativeName(NativeNameType.Type, "Uint32")] uint dwLowDateTime, [NativeName(NativeNameType.Param, "dwHighDateTime")] [NativeName(NativeNameType.Type, "Uint32")] uint dwHighDateTime)
		{
			long ret = TimeFromWindowsNative(dwLowDateTime, dwHighDateTime);
			return ret;
		}

		/// <summary>
		/// Get the number of days in a month for a given year.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDaysInMonth")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDaysInMonthNative([NativeName(NativeNameType.Param, "year")] [NativeName(NativeNameType.Type, "int")] int year, [NativeName(NativeNameType.Param, "month")] [NativeName(NativeNameType.Type, "int")] int month)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[1194])(year, month);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[1194])(year, month);
			#endif
		}

		/// <summary>
		/// Get the number of days in a month for a given year.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDaysInMonth")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetDaysInMonth([NativeName(NativeNameType.Param, "year")] [NativeName(NativeNameType.Type, "int")] int year, [NativeName(NativeNameType.Param, "month")] [NativeName(NativeNameType.Type, "int")] int month)
		{
			int ret = GetDaysInMonthNative(year, month);
			return ret;
		}

		/// <summary>
		/// Get the day of year for a calendar date.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDayOfYear")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDayOfYearNative([NativeName(NativeNameType.Param, "year")] [NativeName(NativeNameType.Type, "int")] int year, [NativeName(NativeNameType.Param, "month")] [NativeName(NativeNameType.Type, "int")] int month, [NativeName(NativeNameType.Param, "day")] [NativeName(NativeNameType.Type, "int")] int day)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[1195])(year, month, day);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[1195])(year, month, day);
			#endif
		}

		/// <summary>
		/// Get the day of year for a calendar date.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDayOfYear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetDayOfYear([NativeName(NativeNameType.Param, "year")] [NativeName(NativeNameType.Type, "int")] int year, [NativeName(NativeNameType.Param, "month")] [NativeName(NativeNameType.Type, "int")] int month, [NativeName(NativeNameType.Param, "day")] [NativeName(NativeNameType.Type, "int")] int day)
		{
			int ret = GetDayOfYearNative(year, month, day);
			return ret;
		}

		/// <summary>
		/// Get the day of week for a calendar date.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDayOfWeek")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDayOfWeekNative([NativeName(NativeNameType.Param, "year")] [NativeName(NativeNameType.Type, "int")] int year, [NativeName(NativeNameType.Param, "month")] [NativeName(NativeNameType.Type, "int")] int month, [NativeName(NativeNameType.Param, "day")] [NativeName(NativeNameType.Type, "int")] int day)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[1196])(year, month, day);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[1196])(year, month, day);
			#endif
		}

		/// <summary>
		/// Get the day of week for a calendar date.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDayOfWeek")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetDayOfWeek([NativeName(NativeNameType.Param, "year")] [NativeName(NativeNameType.Type, "int")] int year, [NativeName(NativeNameType.Param, "month")] [NativeName(NativeNameType.Type, "int")] int month, [NativeName(NativeNameType.Param, "day")] [NativeName(NativeNameType.Type, "int")] int day)
		{
			int ret = GetDayOfWeekNative(year, month, day);
			return ret;
		}

		/// <summary>
		/// Get the number of milliseconds that have elapsed since the SDL library<br/>
		/// initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTicks")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTicksNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[1197])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[1197])();
			#endif
		}

		/// <summary>
		/// Get the number of milliseconds that have elapsed since the SDL library<br/>
		/// initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTicks")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetTicks()
		{
			ulong ret = GetTicksNative();
			return ret;
		}

		/// <summary>
		/// Get the number of nanoseconds since SDL library initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTicksNS")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTicksNSNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[1198])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[1198])();
			#endif
		}

		/// <summary>
		/// Get the number of nanoseconds since SDL library initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTicksNS")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetTicksNS()
		{
			ulong ret = GetTicksNSNative();
			return ret;
		}

		/// <summary>
		/// Get the current value of the high resolution counter.<br/>
		/// This function is typically used for profiling.<br/>
		/// The counter values are only meaningful relative to each other. Differences<br/>
		/// between values can be converted to times by using<br/>
		/// SDL_GetPerformanceFrequency().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPerformanceCounter")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetPerformanceCounterNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[1199])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[1199])();
			#endif
		}

		/// <summary>
		/// Get the current value of the high resolution counter.<br/>
		/// This function is typically used for profiling.<br/>
		/// The counter values are only meaningful relative to each other. Differences<br/>
		/// between values can be converted to times by using<br/>
		/// SDL_GetPerformanceFrequency().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPerformanceCounter")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetPerformanceCounter()
		{
			ulong ret = GetPerformanceCounterNative();
			return ret;
		}

		/// <summary>
		/// Get the count per second of the high resolution counter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPerformanceFrequency")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetPerformanceFrequencyNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[1200])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[1200])();
			#endif
		}

		/// <summary>
		/// Get the count per second of the high resolution counter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPerformanceFrequency")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetPerformanceFrequency()
		{
			ulong ret = GetPerformanceFrequencyNative();
			return ret;
		}

		/// <summary>
		/// Wait a specified number of milliseconds before returning.<br/>
		/// This function waits a specified number of milliseconds before returning. It<br/>
		/// waits at least the specified time, but possibly longer due to OS<br/>
		/// scheduling.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Delay")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DelayNative([NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1201])(ms);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1201])(ms);
			#endif
		}

		/// <summary>
		/// Wait a specified number of milliseconds before returning.<br/>
		/// This function waits a specified number of milliseconds before returning. It<br/>
		/// waits at least the specified time, but possibly longer due to OS<br/>
		/// scheduling.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Delay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Delay([NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			DelayNative(ms);
		}

		/// <summary>
		/// Wait a specified number of nanoseconds before returning.<br/>
		/// This function waits a specified number of nanoseconds before returning. It<br/>
		/// waits at least the specified time, but possibly longer due to OS<br/>
		/// scheduling.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelayNS")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DelayNSNative([NativeName(NativeNameType.Param, "ns")] [NativeName(NativeNameType.Type, "Uint64")] ulong ns)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1202])(ns);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1202])(ns);
			#endif
		}

		/// <summary>
		/// Wait a specified number of nanoseconds before returning.<br/>
		/// This function waits a specified number of nanoseconds before returning. It<br/>
		/// waits at least the specified time, but possibly longer due to OS<br/>
		/// scheduling.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelayNS")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DelayNS([NativeName(NativeNameType.Param, "ns")] [NativeName(NativeNameType.Type, "Uint64")] ulong ns)
		{
			DelayNSNative(ns);
		}

		/// <summary>
		/// Wait a specified number of nanoseconds before returning.<br/>
		/// This function waits a specified number of nanoseconds before returning. It<br/>
		/// will attempt to wait as close to the requested time as possible, busy<br/>
		/// waiting if necessary, but could return later due to OS scheduling.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelayPrecise")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DelayPreciseNative([NativeName(NativeNameType.Param, "ns")] [NativeName(NativeNameType.Type, "Uint64")] ulong ns)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1203])(ns);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1203])(ns);
			#endif
		}

		/// <summary>
		/// Wait a specified number of nanoseconds before returning.<br/>
		/// This function waits a specified number of nanoseconds before returning. It<br/>
		/// will attempt to wait as close to the requested time as possible, busy<br/>
		/// waiting if necessary, but could return later due to OS scheduling.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelayPrecise")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DelayPrecise([NativeName(NativeNameType.Param, "ns")] [NativeName(NativeNameType.Type, "Uint64")] ulong ns)
		{
			DelayPreciseNative(ns);
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddTimerNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint32")] uint interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TimerCallback")] delegate*<void*, int, uint, uint> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void*, int, uint, uint>, void*, int>)funcTable[1204])(interval, callback, userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, int>)funcTable[1204])(interval, (nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimer([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint32")] uint interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TimerCallback")] delegate*<void*, int, uint, uint> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			int ret = AddTimerNative(interval, callback, userdata);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimer([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint32")] uint interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TimerCallback")] SDLTimerCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			int ret = AddTimerNative(interval, (delegate*<void*, int, uint, uint>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimer([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint32")] uint interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TimerCallback")] delegate*<void*, int, uint, uint> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			int ret = AddTimerNative(interval, callback, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimer([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint32")] uint interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TimerCallback")] SDLTimerCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			int ret = AddTimerNative(interval, (delegate*<void*, int, uint, uint>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimerNS() call and should return the<br/>
		/// next timer interval. If the value returned from the callback is 0, the<br/>
		/// timer is canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ns to execute and returned<br/>
		/// 1000 (ns), the timer would only wait another 750 ns before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimerNS")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddTimerNSNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint64")] ulong interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_NSTimerCallback")] delegate*<void*, int, ulong, ulong> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, delegate*<void*, int, ulong, ulong>, void*, int>)funcTable[1205])(interval, callback, userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ulong, nint, nint, int>)funcTable[1205])(interval, (nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimerNS() call and should return the<br/>
		/// next timer interval. If the value returned from the callback is 0, the<br/>
		/// timer is canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ns to execute and returned<br/>
		/// 1000 (ns), the timer would only wait another 750 ns before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimerNS")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimerNS([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint64")] ulong interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_NSTimerCallback")] delegate*<void*, int, ulong, ulong> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			int ret = AddTimerNSNative(interval, callback, userdata);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimerNS() call and should return the<br/>
		/// next timer interval. If the value returned from the callback is 0, the<br/>
		/// timer is canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ns to execute and returned<br/>
		/// 1000 (ns), the timer would only wait another 750 ns before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimerNS")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimerNS([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint64")] ulong interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_NSTimerCallback")] SDLNSTimerCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			int ret = AddTimerNSNative(interval, (delegate*<void*, int, ulong, ulong>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimerNS() call and should return the<br/>
		/// next timer interval. If the value returned from the callback is 0, the<br/>
		/// timer is canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ns to execute and returned<br/>
		/// 1000 (ns), the timer would only wait another 750 ns before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimerNS")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimerNS([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint64")] ulong interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_NSTimerCallback")] delegate*<void*, int, ulong, ulong> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			int ret = AddTimerNSNative(interval, callback, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimerNS() call and should return the<br/>
		/// next timer interval. If the value returned from the callback is 0, the<br/>
		/// timer is canceled and will be removed.<br/>
		/// The callback is run on a separate thread, and for short timeouts can<br/>
		/// potentially be called before this function returns.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ns to execute and returned<br/>
		/// 1000 (ns), the timer would only wait another 750 ns before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimerNS")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int AddTimerNS([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint64")] ulong interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_NSTimerCallback")] SDLNSTimerCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			int ret = AddTimerNSNative(interval, (delegate*<void*, int, ulong, ulong>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Remove a timer created with SDL_AddTimer().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTimer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RemoveTimerNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TimerID")] int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[1206])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[1206])(id);
			#endif
		}

		/// <summary>
		/// Remove a timer created with SDL_AddTimer().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTimer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RemoveTimer([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TimerID")] int id)
		{
			byte ret = RemoveTimerNative(id);
			return ret != 0;
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTray* CreateTrayNative([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] byte* tooltip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, SDLTray*>)funcTable[1207])(icon, tooltip);
			#else
			return (SDLTray*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[1207])((nint)icon, (nint)tooltip);
			#endif
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] byte* tooltip)
		{
			SDLTrayPtr ret = CreateTrayNative((SDLSurface*)icon, tooltip);
			return ret;
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] byte* tooltip)
		{
			fixed (SDLSurface* picon = &icon)
			{
				SDLTrayPtr ret = CreateTrayNative((SDLSurface*)picon, tooltip);
				return ret;
			}
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] in byte tooltip)
		{
			fixed (byte* ptooltip = &tooltip)
			{
				SDLTrayPtr ret = CreateTrayNative((SDLSurface*)icon, (byte*)ptooltip);
				return ret;
			}
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tooltip)
		{
			fixed (byte* ptooltip = tooltip)
			{
				SDLTrayPtr ret = CreateTrayNative((SDLSurface*)icon, (byte*)ptooltip);
				return ret;
			}
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] string tooltip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tooltip != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tooltip);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tooltip, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTrayPtr ret = CreateTrayNative((SDLSurface*)icon, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] in byte tooltip)
		{
			fixed (SDLSurface* picon = &icon)
			{
				fixed (byte* ptooltip = &tooltip)
				{
					SDLTrayPtr ret = CreateTrayNative((SDLSurface*)picon, (byte*)ptooltip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tooltip)
		{
			fixed (SDLSurface* picon = &icon)
			{
				fixed (byte* ptooltip = tooltip)
				{
					SDLTrayPtr ret = CreateTrayNative((SDLSurface*)picon, (byte*)ptooltip);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create an icon to be placed in the operating system's tray, or equivalent.<br/>
		/// Many platforms advise not using a system tray unless persistence is a<br/>
		/// necessary feature. Avoid needlessly creating a tray icon, as the user may<br/>
		/// feel like it clutters their interface.<br/>
		/// Using tray icons require the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTrayPtr CreateTray([NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface icon, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] string tooltip)
		{
			fixed (SDLSurface* picon = &icon)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (tooltip != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(tooltip);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(tooltip, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTrayPtr ret = CreateTrayNative((SDLSurface*)picon, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Updates the system tray icon's icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTrayIconNative([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTray* tray, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* icon)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTray*, SDLSurface*, void>)funcTable[1208])(tray, icon);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1208])((nint)tray, (nint)icon);
			#endif
		}

		/// <summary>
		/// Updates the system tray icon's icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayIcon([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr icon)
		{
			SetTrayIconNative((SDLTray*)tray, (SDLSurface*)icon);
		}

		/// <summary>
		/// Updates the system tray icon's icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayIcon([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr icon)
		{
			fixed (SDLTray* ptray = &tray)
			{
				SetTrayIconNative((SDLTray*)ptray, (SDLSurface*)icon);
			}
		}

		/// <summary>
		/// Updates the system tray icon's icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayIcon([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface icon)
		{
			fixed (SDLSurface* picon = &icon)
			{
				SetTrayIconNative((SDLTray*)tray, (SDLSurface*)picon);
			}
		}

		/// <summary>
		/// Updates the system tray icon's icon.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayIcon([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface icon)
		{
			fixed (SDLTray* ptray = &tray)
			{
				fixed (SDLSurface* picon = &icon)
				{
					SetTrayIconNative((SDLTray*)ptray, (SDLSurface*)picon);
				}
			}
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTrayTooltipNative([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTray* tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] byte* tooltip)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTray*, byte*, void>)funcTable[1209])(tray, tooltip);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1209])((nint)tray, (nint)tooltip);
			#endif
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] byte* tooltip)
		{
			SetTrayTooltipNative((SDLTray*)tray, tooltip);
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] byte* tooltip)
		{
			fixed (SDLTray* ptray = &tray)
			{
				SetTrayTooltipNative((SDLTray*)ptray, tooltip);
			}
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] in byte tooltip)
		{
			fixed (byte* ptooltip = &tooltip)
			{
				SetTrayTooltipNative((SDLTray*)tray, (byte*)ptooltip);
			}
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tooltip)
		{
			fixed (byte* ptooltip = tooltip)
			{
				SetTrayTooltipNative((SDLTray*)tray, (byte*)ptooltip);
			}
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] string tooltip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tooltip != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tooltip);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tooltip, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTrayTooltipNative((SDLTray*)tray, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] in byte tooltip)
		{
			fixed (SDLTray* ptray = &tray)
			{
				fixed (byte* ptooltip = &tooltip)
				{
					SetTrayTooltipNative((SDLTray*)ptray, (byte*)ptooltip);
				}
			}
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tooltip)
		{
			fixed (SDLTray* ptray = &tray)
			{
				fixed (byte* ptooltip = tooltip)
				{
					SetTrayTooltipNative((SDLTray*)ptray, (byte*)ptooltip);
				}
			}
		}

		/// <summary>
		/// Updates the system tray icon's tooltip.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayTooltip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayTooltip([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray, [NativeName(NativeNameType.Param, "tooltip")] [NativeName(NativeNameType.Type, "char const *")] string tooltip)
		{
			fixed (SDLTray* ptray = &tray)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (tooltip != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(tooltip);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(tooltip, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetTrayTooltipNative((SDLTray*)ptray, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Create a menu for a system tray.<br/>
		/// This should be called at most once per tray icon.<br/>
		/// This function does the same thing as SDL_CreateTraySubmenu(), except that<br/>
		/// it takes a SDL_Tray instead of a SDL_TrayEntry.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTrayMenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayMenu* CreateTrayMenuNative([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTray* tray)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTray*, SDLTrayMenu*>)funcTable[1210])(tray);
			#else
			return (SDLTrayMenu*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1210])((nint)tray);
			#endif
		}

		/// <summary>
		/// Create a menu for a system tray.<br/>
		/// This should be called at most once per tray icon.<br/>
		/// This function does the same thing as SDL_CreateTraySubmenu(), except that<br/>
		/// it takes a SDL_Tray instead of a SDL_TrayEntry.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTrayMenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr CreateTrayMenu([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray)
		{
			SDLTrayMenuPtr ret = CreateTrayMenuNative((SDLTray*)tray);
			return ret;
		}

		/// <summary>
		/// Create a menu for a system tray.<br/>
		/// This should be called at most once per tray icon.<br/>
		/// This function does the same thing as SDL_CreateTraySubmenu(), except that<br/>
		/// it takes a SDL_Tray instead of a SDL_TrayEntry.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTrayMenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr CreateTrayMenu([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray)
		{
			fixed (SDLTray* ptray = &tray)
			{
				SDLTrayMenuPtr ret = CreateTrayMenuNative((SDLTray*)ptray);
				return ret;
			}
		}

		/// <summary>
		/// Create a submenu for a system tray entry.<br/>
		/// This should be called at most once per tray entry.<br/>
		/// This function does the same thing as SDL_CreateTrayMenu, except that it<br/>
		/// takes a SDL_TrayEntry instead of a SDL_Tray.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTraySubmenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayMenu* CreateTraySubmenuNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayEntry*, SDLTrayMenu*>)funcTable[1211])(entry);
			#else
			return (SDLTrayMenu*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1211])((nint)entry);
			#endif
		}

		/// <summary>
		/// Create a submenu for a system tray entry.<br/>
		/// This should be called at most once per tray entry.<br/>
		/// This function does the same thing as SDL_CreateTrayMenu, except that it<br/>
		/// takes a SDL_TrayEntry instead of a SDL_Tray.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTraySubmenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr CreateTraySubmenu([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntryPtr entry)
		{
			SDLTrayMenuPtr ret = CreateTraySubmenuNative((SDLTrayEntry*)entry);
			return ret;
		}

		/// <summary>
		/// Create a submenu for a system tray entry.<br/>
		/// This should be called at most once per tray entry.<br/>
		/// This function does the same thing as SDL_CreateTrayMenu, except that it<br/>
		/// takes a SDL_TrayEntry instead of a SDL_Tray.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTraySubmenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr CreateTraySubmenu([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				SDLTrayMenuPtr ret = CreateTraySubmenuNative((SDLTrayEntry*)pentry);
				return ret;
			}
		}

		/// <summary>
		/// Gets a previously created tray menu.<br/>
		/// You should have called SDL_CreateTrayMenu() on the tray object. This<br/>
		/// function allows you to fetch it again later.<br/>
		/// This function does the same thing as SDL_GetTraySubmenu(), except that it<br/>
		/// takes a SDL_Tray instead of a SDL_TrayEntry.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayMenu* GetTrayMenuNative([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTray* tray)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTray*, SDLTrayMenu*>)funcTable[1212])(tray);
			#else
			return (SDLTrayMenu*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1212])((nint)tray);
			#endif
		}

		/// <summary>
		/// Gets a previously created tray menu.<br/>
		/// You should have called SDL_CreateTrayMenu() on the tray object. This<br/>
		/// function allows you to fetch it again later.<br/>
		/// This function does the same thing as SDL_GetTraySubmenu(), except that it<br/>
		/// takes a SDL_Tray instead of a SDL_TrayEntry.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr GetTrayMenu([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTrayPtr tray)
		{
			SDLTrayMenuPtr ret = GetTrayMenuNative((SDLTray*)tray);
			return ret;
		}

		/// <summary>
		/// Gets a previously created tray menu.<br/>
		/// You should have called SDL_CreateTrayMenu() on the tray object. This<br/>
		/// function allows you to fetch it again later.<br/>
		/// This function does the same thing as SDL_GetTraySubmenu(), except that it<br/>
		/// takes a SDL_Tray instead of a SDL_TrayEntry.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr GetTrayMenu([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray)
		{
			fixed (SDLTray* ptray = &tray)
			{
				SDLTrayMenuPtr ret = GetTrayMenuNative((SDLTray*)ptray);
				return ret;
			}
		}

		/// <summary>
		/// Gets a previously created tray entry submenu.<br/>
		/// You should have called SDL_CreateTraySubmenu() on the entry object. This<br/>
		/// function allows you to fetch it again later.<br/>
		/// This function does the same thing as SDL_GetTrayMenu(), except that it<br/>
		/// takes a SDL_TrayEntry instead of a SDL_Tray.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTraySubmenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayMenu* GetTraySubmenuNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayEntry*, SDLTrayMenu*>)funcTable[1213])(entry);
			#else
			return (SDLTrayMenu*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1213])((nint)entry);
			#endif
		}

		/// <summary>
		/// Gets a previously created tray entry submenu.<br/>
		/// You should have called SDL_CreateTraySubmenu() on the entry object. This<br/>
		/// function allows you to fetch it again later.<br/>
		/// This function does the same thing as SDL_GetTrayMenu(), except that it<br/>
		/// takes a SDL_TrayEntry instead of a SDL_Tray.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTraySubmenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr GetTraySubmenu([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntryPtr entry)
		{
			SDLTrayMenuPtr ret = GetTraySubmenuNative((SDLTrayEntry*)entry);
			return ret;
		}

		/// <summary>
		/// Gets a previously created tray entry submenu.<br/>
		/// You should have called SDL_CreateTraySubmenu() on the entry object. This<br/>
		/// function allows you to fetch it again later.<br/>
		/// This function does the same thing as SDL_GetTrayMenu(), except that it<br/>
		/// takes a SDL_TrayEntry instead of a SDL_Tray.<br/>
		/// A menu does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTraySubmenu")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenuPtr GetTraySubmenu([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				SDLTrayMenuPtr ret = GetTraySubmenuNative((SDLTrayEntry*)pentry);
				return ret;
			}
		}

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayEntry** GetTrayEntriesNative([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayMenu*, int*, SDLTrayEntry**>)funcTable[1214])(menu, count);
			#else
			return (SDLTrayEntry**)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[1214])((nint)menu, (nint)count);
			#endif
		}

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		public static SDLTrayEntryPtrPtr GetTrayEntries([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenuPtr menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			SDLTrayEntryPtrPtr ret = GetTrayEntriesNative((SDLTrayMenu*)menu, count);
			return ret;
		}

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		public static SDLTrayEntryPtrPtr GetTrayEntries([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				SDLTrayEntryPtrPtr ret = GetTrayEntriesNative((SDLTrayMenu*)pmenu, count);
				return ret;
			}
		}

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		public static SDLTrayEntryPtrPtr GetTrayEntries([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenuPtr menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLTrayEntryPtrPtr ret = GetTrayEntriesNative((SDLTrayMenu*)menu, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		public static SDLTrayEntryPtrPtr GetTrayEntries([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				fixed (int* pcount = &count)
				{
					SDLTrayEntryPtrPtr ret = GetTrayEntriesNative((SDLTrayMenu*)pmenu, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Removes a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveTrayEntryNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTrayEntry*, void>)funcTable[1215])(entry);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1215])((nint)entry);
			#endif
		}

		/// <summary>
		/// Removes a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveTrayEntry([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntryPtr entry)
		{
			RemoveTrayEntryNative((SDLTrayEntry*)entry);
		}

		/// <summary>
		/// Removes a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveTrayEntry([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				RemoveTrayEntryNative((SDLTrayEntry*)pentry);
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayEntry* InsertTrayEntryAtNative([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayMenu*, int, byte*, uint, SDLTrayEntry*>)funcTable[1216])(menu, pos, label, flags);
			#else
			return (SDLTrayEntry*)((delegate* unmanaged[Cdecl]<nint, int, nint, uint, nint>)funcTable[1216])((nint)menu, pos, (nint)label, flags);
			#endif
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntryPtr InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenuPtr menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] uint flags)
		{
			SDLTrayEntryPtr ret = InsertTrayEntryAtNative((SDLTrayMenu*)menu, pos, label, flags);
			return ret;
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntryPtr InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] uint flags)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				SDLTrayEntryPtr ret = InsertTrayEntryAtNative((SDLTrayMenu*)pmenu, pos, label, flags);
				return ret;
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntryPtr InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenuPtr menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] in byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] uint flags)
		{
			fixed (byte* plabel = &label)
			{
				SDLTrayEntryPtr ret = InsertTrayEntryAtNative((SDLTrayMenu*)menu, pos, (byte*)plabel, flags);
				return ret;
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntryPtr InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenuPtr menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] uint flags)
		{
			fixed (byte* plabel = label)
			{
				SDLTrayEntryPtr ret = InsertTrayEntryAtNative((SDLTrayMenu*)menu, pos, (byte*)plabel, flags);
				return ret;
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntryPtr InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenuPtr menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] string label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] uint flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTrayEntryPtr ret = InsertTrayEntryAtNative((SDLTrayMenu*)menu, pos, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntryPtr InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] in byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] uint flags)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				fixed (byte* plabel = &label)
				{
					SDLTrayEntryPtr ret = InsertTrayEntryAtNative((SDLTrayMenu*)pmenu, pos, (byte*)plabel, flags);
					return ret;
				}
			}
		}
	}
}
