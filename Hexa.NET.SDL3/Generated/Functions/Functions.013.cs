// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Perform a scaled and tiled blit to a destination surface, which may be of a<br/>
		/// different format.<br/>
		/// The pixels in `srcrect` will be scaled and repeated as many times as needed<br/>
		/// to completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceTiledWithScale")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceTiledWithScale([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceTiledWithScaleNative(src, srcrect, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled and tiled blit to a destination surface, which may be of a<br/>
		/// different format.<br/>
		/// The pixels in `srcrect` will be scaled and repeated as many times as needed<br/>
		/// to completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceTiledWithScale")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceTiledWithScale([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceTiledWithScaleNative((SDLSurface*)psrc, srcrect, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled and tiled blit to a destination surface, which may be of a<br/>
		/// different format.<br/>
		/// The pixels in `srcrect` will be scaled and repeated as many times as needed<br/>
		/// to completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceTiledWithScale")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceTiledWithScale([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceTiledWithScaleNative(src, (SDLRect*)psrcrect, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled and tiled blit to a destination surface, which may be of a<br/>
		/// different format.<br/>
		/// The pixels in `srcrect` will be scaled and repeated as many times as needed<br/>
		/// to completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceTiledWithScale")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceTiledWithScale([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceTiledWithScaleNative((SDLSurface*)psrc, (SDLRect*)psrcrect, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurface9GridNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, int, int, int, int, float, SDLScaleMode, SDLSurface*, SDLRect*, byte>)funcTable[439])(src, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int, float, SDLScaleMode, nint, nint, byte>)funcTable[439])((nint)src, (nint)srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (nint)dst, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			byte ret = BlitSurface9GridNative(src, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurface9GridNative((SDLSurface*)psrc, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurface9GridNative(src, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurface9GridNative((SDLSurface*)psrc, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurface9GridNative(src, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurface9GridNative((SDLSurface*)psrc, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurface9GridNative(src, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurface9GridNative((SDLSurface*)psrc, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurface9GridNative(src, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, (SDLRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurface9GridNative((SDLSurface*)psrc, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurface9GridNative(src, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurface9GridNative((SDLSurface*)psrc, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, dst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurface9GridNative(src, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurface9GridNative((SDLSurface*)psrc, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurface9GridNative(src, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
		/// which may be of a different format.<br/>
		/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
		/// different corner sizes for each corner, and the sides and center making up<br/>
		/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
		/// into the corners of the destination rectangle. The sides and center are<br/>
		/// then stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface9Grid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface9Grid([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "left_width")] [NativeName(NativeNameType.Type, "int")] int leftWidth, [NativeName(NativeNameType.Param, "right_width")] [NativeName(NativeNameType.Type, "int")] int rightWidth, [NativeName(NativeNameType.Param, "top_height")] [NativeName(NativeNameType.Type, "int")] int topHeight, [NativeName(NativeNameType.Param, "bottom_height")] [NativeName(NativeNameType.Type, "int")] int bottomHeight, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurface9GridNative((SDLSurface*)psrc, (SDLRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, scaleMode, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a surface.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the surface has a palette, the index of the closest matching color in<br/>
		/// the palette will be returned.<br/>
		/// If the surface pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapSurfaceRGB")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapSurfaceRGBNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte, byte, uint>)funcTable[440])(surface, r, g, b);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, uint>)funcTable[440])((nint)surface, r, g, b);
			#endif
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a surface.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the surface has a palette, the index of the closest matching color in<br/>
		/// the palette will be returned.<br/>
		/// If the surface pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapSurfaceRGB")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint MapSurfaceRGB([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			uint ret = MapSurfaceRGBNative(surface, r, g, b);
			return ret;
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a surface.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the surface has a palette, the index of the closest matching color in<br/>
		/// the palette will be returned.<br/>
		/// If the surface pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapSurfaceRGB")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint MapSurfaceRGB([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				uint ret = MapSurfaceRGBNative((SDLSurface*)psurface, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a surface.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the surface pixel format has no alpha component the alpha value will be<br/>
		/// ignored (as it will be in formats with a palette).<br/>
		/// If the surface has a palette, the index of the closest matching color in<br/>
		/// the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapSurfaceRGBA")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapSurfaceRGBANative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte, byte, byte, uint>)funcTable[441])(surface, r, g, b, a);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte, uint>)funcTable[441])((nint)surface, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a surface.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the surface pixel format has no alpha component the alpha value will be<br/>
		/// ignored (as it will be in formats with a palette).<br/>
		/// If the surface has a palette, the index of the closest matching color in<br/>
		/// the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapSurfaceRGBA")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint MapSurfaceRGBA([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			uint ret = MapSurfaceRGBANative(surface, r, g, b, a);
			return ret;
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a surface.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the surface pixel format has no alpha component the alpha value will be<br/>
		/// ignored (as it will be in formats with a palette).<br/>
		/// If the surface has a palette, the index of the closest matching color in<br/>
		/// the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapSurfaceRGBA")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint MapSurfaceRGBA([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				uint ret = MapSurfaceRGBANative((SDLSurface*)psurface, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadSurfacePixelNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, byte*, byte*, byte*, byte*, byte>)funcTable[442])(surface, x, y, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, nint, nint, byte>)funcTable[442])((nint)surface, x, y, (nint)r, (nint)g, (nint)b, (nint)a);
			#endif
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			byte ret = ReadSurfacePixelNative(surface, x, y, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, g, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				byte ret = ReadSurfacePixelNative(surface, x, y, r, (byte*)pg, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, (byte*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, (byte*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, (byte*)pg, b, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pb = &b)
			{
				byte ret = ReadSurfacePixelNative(surface, x, y, r, g, (byte*)pb, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pb = &b)
				{
					byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, g, (byte*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, g, (byte*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, g, (byte*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					byte ret = ReadSurfacePixelNative(surface, x, y, r, (byte*)pg, (byte*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, (byte*)pg, (byte*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, (byte*)pg, (byte*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, (byte*)pg, (byte*)pb, a);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pa = &a)
			{
				byte ret = ReadSurfacePixelNative(surface, x, y, r, g, b, (byte*)pa);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pa = &a)
				{
					byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, g, b, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, g, b, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, g, b, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					byte ret = ReadSurfacePixelNative(surface, x, y, r, (byte*)pg, b, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, (byte*)pg, b, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, (byte*)pg, b, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, (byte*)pg, b, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pa = &a)
				{
					byte ret = ReadSurfacePixelNative(surface, x, y, r, g, (byte*)pb, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, g, (byte*)pb, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, g, (byte*)pb, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, g, (byte*)pb, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						byte ret = ReadSurfacePixelNative(surface, x, y, r, (byte*)pg, (byte*)pb, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, r, (byte*)pg, (byte*)pb, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							byte ret = ReadSurfacePixelNative(surface, x, y, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								byte ret = ReadSurfacePixelNative((SDLSurface*)psurface, x, y, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadSurfacePixelFloatNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, float*, float*, float*, float*, byte>)funcTable[443])(surface, x, y, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, nint, nint, byte>)funcTable[443])((nint)surface, x, y, (nint)r, (nint)g, (nint)b, (nint)a);
			#endif
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (float* pr = &r)
			{
				byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, g, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (float* pg = &g)
			{
				byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, (float*)pg, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pg = &g)
				{
					byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, (float*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, (float*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, (float*)pg, b, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (float* pb = &b)
			{
				byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, g, (float*)pb, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pb = &b)
				{
					byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, g, (float*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pb = &b)
				{
					byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, g, (float*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pb = &b)
					{
						byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, g, (float*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (float* pg = &g)
			{
				fixed (float* pb = &b)
				{
					byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, (float*)pg, (float*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, (float*)pg, (float*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, (float*)pg, (float*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] float* a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						fixed (float* pb = &b)
						{
							byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, (float*)pg, (float*)pb, a);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pa = &a)
			{
				byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, g, b, (float*)pa);
				return ret != 0;
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pa = &a)
				{
					byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, g, b, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pa = &a)
				{
					byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, g, b, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pa = &a)
					{
						byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, g, b, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pg = &g)
			{
				fixed (float* pa = &a)
				{
					byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, (float*)pg, b, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pa = &a)
					{
						byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, (float*)pg, b, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pa = &a)
					{
						byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, (float*)pg, b, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] float* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						fixed (float* pa = &a)
						{
							byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, (float*)pg, b, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pb = &b)
			{
				fixed (float* pa = &a)
				{
					byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, g, (float*)pb, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pb = &b)
				{
					fixed (float* pa = &a)
					{
						byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, g, (float*)pb, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pb = &b)
				{
					fixed (float* pa = &a)
					{
						byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, g, (float*)pb, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] float* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pb = &b)
					{
						fixed (float* pa = &a)
						{
							byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, g, (float*)pb, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pg = &g)
			{
				fixed (float* pb = &b)
				{
					fixed (float* pa = &a)
					{
						byte ret = ReadSurfacePixelFloatNative(surface, x, y, r, (float*)pg, (float*)pb, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] float* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						fixed (float* pa = &a)
						{
							byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, (float*)pg, (float*)pb, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						fixed (float* pa = &a)
						{
							byte ret = ReadSurfacePixelFloatNative(surface, x, y, (float*)pr, (float*)pg, (float*)pb, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Retrieves a single pixel from a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float *")] ref float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float *")] ref float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float *")] ref float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float *")] ref float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						fixed (float* pb = &b)
						{
							fixed (float* pa = &a)
							{
								byte ret = ReadSurfacePixelFloatNative((SDLSurface*)psurface, x, y, (float*)pr, (float*)pg, (float*)pb, (float*)pa);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Writes a single pixel to a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_MapRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WriteSurfacePixelNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, byte, byte, byte, byte, byte>)funcTable[444])(surface, x, y, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte, byte, byte, byte, byte>)funcTable[444])((nint)surface, x, y, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Writes a single pixel to a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_MapRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			byte ret = WriteSurfacePixelNative(surface, x, y, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Writes a single pixel to a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// Like SDL_MapRGBA, this uses the entire 0..255 range when converting color<br/>
		/// components from pixel formats with less than 8 bits per RGB component.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteSurfacePixel")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteSurfacePixel([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = WriteSurfacePixelNative((SDLSurface*)psurface, x, y, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Writes a single pixel to a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WriteSurfacePixelFloatNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, float, float, float, float, byte>)funcTable[445])(surface, x, y, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, float, float, float, float, byte>)funcTable[445])((nint)surface, x, y, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Writes a single pixel to a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			byte ret = WriteSurfacePixelFloatNative(surface, x, y, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Writes a single pixel to a surface.<br/>
		/// This function prioritizes correctness over speed: it is suitable for unit<br/>
		/// tests, but is not intended for use in a game engine.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteSurfacePixelFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteSurfacePixelFloat([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = WriteSurfacePixelFloatNative((SDLSurface*)psurface, x, y, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to get the number of built-in camera drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have v4l2 support, but if<br/>
		/// there's no kernel support available, SDL's v4l2 driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumCameraDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumCameraDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[446])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[446])();
			#endif
		}

		/// <summary>
		/// Use this function to get the number of built-in camera drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have v4l2 support, but if<br/>
		/// there's no kernel support available, SDL's v4l2 driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumCameraDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumCameraDrivers()
		{
			int ret = GetNumCameraDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in camera driver.<br/>
		/// The list of camera drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
		/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCameraDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[447])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[447])(index);
			#endif
		}

		/// <summary>
		/// Use this function to get the name of a built in camera driver.<br/>
		/// The list of camera drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
		/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetCameraDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = GetCameraDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in camera driver.<br/>
		/// The list of camera drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
		/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetCameraDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(GetCameraDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Get the name of the current camera driver.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
		/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentCameraDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCurrentCameraDriverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[448])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[448])();
			#endif
		}

		/// <summary>
		/// Get the name of the current camera driver.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
		/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentCameraDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetCurrentCameraDriver()
		{
			byte* ret = GetCurrentCameraDriverNative();
			return ret;
		}

		/// <summary>
		/// Get the name of the current camera driver.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
		/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentCameraDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetCurrentCameraDriverS()
		{
			string ret = Utils.DecodeStringUTF8(GetCurrentCameraDriverNative());
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected camera devices.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameras")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetCamerasNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[449])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[449])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected camera devices.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameras")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraID *")]
		public static uint* GetCameras([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetCamerasNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected camera devices.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameras")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraID *")]
		public static uint* GetCameras([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetCamerasNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the list of native formats/sizes a camera supports.<br/>
		/// This returns a list of all formats and frame sizes that a specific camera<br/>
		/// can offer. This is useful if your app can accept a variety of image formats<br/>
		/// and sizes and so want to find the optimal spec that doesn't require<br/>
		/// conversion.<br/>
		/// This function isn't strictly required; if you call SDL_OpenCamera with a<br/>
		/// NULL spec, SDL will choose a native format for you, and if you instead<br/>
		/// specify a desired format, it will transparently convert to the requested<br/>
		/// format on your behalf.<br/>
		/// If `count` is not NULL, it will be filled with the number of elements in<br/>
		/// the returned array.<br/>
		/// Note that it's legal for a camera to supply an empty list. This is what<br/>
		/// will happen on Emscripten builds, since that platform won't tell _anything_<br/>
		/// about available cameras until you've opened one, and won't even tell if<br/>
		/// there _is_ a camera until the user has given you permission to check<br/>
		/// through a scary warning popup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraSupportedFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraSpec * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCameraSpec** GetCameraSupportedFormatsNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int*, SDLCameraSpec**>)funcTable[450])(instanceId, count);
			#else
			return (SDLCameraSpec**)((delegate* unmanaged[Cdecl]<uint, nint, nint>)funcTable[450])(instanceId, (nint)count);
			#endif
		}

		/// <summary>
		/// Get the list of native formats/sizes a camera supports.<br/>
		/// This returns a list of all formats and frame sizes that a specific camera<br/>
		/// can offer. This is useful if your app can accept a variety of image formats<br/>
		/// and sizes and so want to find the optimal spec that doesn't require<br/>
		/// conversion.<br/>
		/// This function isn't strictly required; if you call SDL_OpenCamera with a<br/>
		/// NULL spec, SDL will choose a native format for you, and if you instead<br/>
		/// specify a desired format, it will transparently convert to the requested<br/>
		/// format on your behalf.<br/>
		/// If `count` is not NULL, it will be filled with the number of elements in<br/>
		/// the returned array.<br/>
		/// Note that it's legal for a camera to supply an empty list. This is what<br/>
		/// will happen on Emscripten builds, since that platform won't tell _anything_<br/>
		/// about available cameras until you've opened one, and won't even tell if<br/>
		/// there _is_ a camera until the user has given you permission to check<br/>
		/// through a scary warning popup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraSupportedFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraSpec * *")]
		public static SDLCameraSpec** GetCameraSupportedFormats([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			SDLCameraSpec** ret = GetCameraSupportedFormatsNative(instanceId, count);
			return ret;
		}

		/// <summary>
		/// Get the list of native formats/sizes a camera supports.<br/>
		/// This returns a list of all formats and frame sizes that a specific camera<br/>
		/// can offer. This is useful if your app can accept a variety of image formats<br/>
		/// and sizes and so want to find the optimal spec that doesn't require<br/>
		/// conversion.<br/>
		/// This function isn't strictly required; if you call SDL_OpenCamera with a<br/>
		/// NULL spec, SDL will choose a native format for you, and if you instead<br/>
		/// specify a desired format, it will transparently convert to the requested<br/>
		/// format on your behalf.<br/>
		/// If `count` is not NULL, it will be filled with the number of elements in<br/>
		/// the returned array.<br/>
		/// Note that it's legal for a camera to supply an empty list. This is what<br/>
		/// will happen on Emscripten builds, since that platform won't tell _anything_<br/>
		/// about available cameras until you've opened one, and won't even tell if<br/>
		/// there _is_ a camera until the user has given you permission to check<br/>
		/// through a scary warning popup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraSupportedFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraSpec * *")]
		public static SDLCameraSpec** GetCameraSupportedFormats([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLCameraSpec** ret = GetCameraSupportedFormatsNative(instanceId, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the human-readable device name for a camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCameraNameNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[451])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[451])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the human-readable device name for a camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetCameraName([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId)
		{
			byte* ret = GetCameraNameNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the human-readable device name for a camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetCameraNameS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetCameraNameNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the position of the camera in relation to the system.<br/>
		/// Most platforms will report UNKNOWN, but mobile devices, like phones, can<br/>
		/// often make a distinction between cameras on the front of the device (that<br/>
		/// points towards the user, for taking "selfies") and cameras on the back (for<br/>
		/// filming in the direction the user is facing).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraPosition")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraPosition")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCameraPosition GetCameraPositionNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLCameraPosition>)funcTable[452])(instanceId);
			#else
			return (SDLCameraPosition)((delegate* unmanaged[Cdecl]<uint, SDLCameraPosition>)funcTable[452])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the position of the camera in relation to the system.<br/>
		/// Most platforms will report UNKNOWN, but mobile devices, like phones, can<br/>
		/// often make a distinction between cameras on the front of the device (that<br/>
		/// points towards the user, for taking "selfies") and cameras on the back (for<br/>
		/// filming in the direction the user is facing).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraPosition")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraPosition")]
		public static SDLCameraPosition GetCameraPosition([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId)
		{
			SDLCameraPosition ret = GetCameraPositionNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a video recording device (a "camera").<br/>
		/// You can open the device with any reasonable spec, and if the hardware can't<br/>
		/// directly support it, it will convert data seamlessly to the requested<br/>
		/// format. This might incur overhead, including scaling of image data.<br/>
		/// If you would rather accept whatever format the device offers, you can pass<br/>
		/// a NULL spec here and it will choose one for you (and you can use<br/>
		/// SDL_Surface's conversion/scaling functions directly if necessary).<br/>
		/// You can call SDL_GetCameraFormat() to get the actual data format if passing<br/>
		/// a NULL spec here. You can see the exact specs a device can support without<br/>
		/// conversion with SDL_GetCameraSupportedFormats().<br/>
		/// SDL will not attempt to emulate framerate; it will try to set the hardware<br/>
		/// to the rate closest to the requested speed, but it won't attempt to limit<br/>
		/// or duplicate frames artificially; call SDL_GetCameraFormat() to see the<br/>
		/// actual framerate of the opened the device, and check your timestamps if<br/>
		/// this is crucial to your app!<br/>
		/// Note that the camera is not usable until the user approves its use! On some<br/>
		/// platforms, the operating system will prompt the user to permit access to<br/>
		/// the camera, and they can choose Yes or No at that point. Until they do, the<br/>
		/// camera will not be usable. The app should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero. On platforms that don't require explicit user approval (and<br/>
		/// perhaps in places where the user previously permitted access), the approval<br/>
		/// event might come immediately, but it might come seconds, minutes, or hours<br/>
		/// later!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenCamera")]
		[return: NativeName(NativeNameType.Type, "SDL_Camera *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCamera* OpenCameraNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec const *")] SDLCameraSpec* spec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLCameraSpec*, SDLCamera*>)funcTable[453])(instanceId, spec);
			#else
			return (SDLCamera*)((delegate* unmanaged[Cdecl]<uint, nint, nint>)funcTable[453])(instanceId, (nint)spec);
			#endif
		}

		/// <summary>
		/// Open a video recording device (a "camera").<br/>
		/// You can open the device with any reasonable spec, and if the hardware can't<br/>
		/// directly support it, it will convert data seamlessly to the requested<br/>
		/// format. This might incur overhead, including scaling of image data.<br/>
		/// If you would rather accept whatever format the device offers, you can pass<br/>
		/// a NULL spec here and it will choose one for you (and you can use<br/>
		/// SDL_Surface's conversion/scaling functions directly if necessary).<br/>
		/// You can call SDL_GetCameraFormat() to get the actual data format if passing<br/>
		/// a NULL spec here. You can see the exact specs a device can support without<br/>
		/// conversion with SDL_GetCameraSupportedFormats().<br/>
		/// SDL will not attempt to emulate framerate; it will try to set the hardware<br/>
		/// to the rate closest to the requested speed, but it won't attempt to limit<br/>
		/// or duplicate frames artificially; call SDL_GetCameraFormat() to see the<br/>
		/// actual framerate of the opened the device, and check your timestamps if<br/>
		/// this is crucial to your app!<br/>
		/// Note that the camera is not usable until the user approves its use! On some<br/>
		/// platforms, the operating system will prompt the user to permit access to<br/>
		/// the camera, and they can choose Yes or No at that point. Until they do, the<br/>
		/// camera will not be usable. The app should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero. On platforms that don't require explicit user approval (and<br/>
		/// perhaps in places where the user previously permitted access), the approval<br/>
		/// event might come immediately, but it might come seconds, minutes, or hours<br/>
		/// later!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenCamera")]
		[return: NativeName(NativeNameType.Type, "SDL_Camera *")]
		public static SDLCamera* OpenCamera([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec const *")] SDLCameraSpec* spec)
		{
			SDLCamera* ret = OpenCameraNative(instanceId, spec);
			return ret;
		}

		/// <summary>
		/// Open a video recording device (a "camera").<br/>
		/// You can open the device with any reasonable spec, and if the hardware can't<br/>
		/// directly support it, it will convert data seamlessly to the requested<br/>
		/// format. This might incur overhead, including scaling of image data.<br/>
		/// If you would rather accept whatever format the device offers, you can pass<br/>
		/// a NULL spec here and it will choose one for you (and you can use<br/>
		/// SDL_Surface's conversion/scaling functions directly if necessary).<br/>
		/// You can call SDL_GetCameraFormat() to get the actual data format if passing<br/>
		/// a NULL spec here. You can see the exact specs a device can support without<br/>
		/// conversion with SDL_GetCameraSupportedFormats().<br/>
		/// SDL will not attempt to emulate framerate; it will try to set the hardware<br/>
		/// to the rate closest to the requested speed, but it won't attempt to limit<br/>
		/// or duplicate frames artificially; call SDL_GetCameraFormat() to see the<br/>
		/// actual framerate of the opened the device, and check your timestamps if<br/>
		/// this is crucial to your app!<br/>
		/// Note that the camera is not usable until the user approves its use! On some<br/>
		/// platforms, the operating system will prompt the user to permit access to<br/>
		/// the camera, and they can choose Yes or No at that point. Until they do, the<br/>
		/// camera will not be usable. The app should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero. On platforms that don't require explicit user approval (and<br/>
		/// perhaps in places where the user previously permitted access), the approval<br/>
		/// event might come immediately, but it might come seconds, minutes, or hours<br/>
		/// later!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenCamera")]
		[return: NativeName(NativeNameType.Type, "SDL_Camera *")]
		public static SDLCamera* OpenCamera([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_CameraID")] uint instanceId, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec const *")] ref SDLCameraSpec spec)
		{
			fixed (SDLCameraSpec* pspec = &spec)
			{
				SDLCamera* ret = OpenCameraNative(instanceId, (SDLCameraSpec*)pspec);
				return ret;
			}
		}

		/// <summary>
		/// Query if camera access has been approved by the user.<br/>
		/// Cameras will not function between when the device is opened by the app and<br/>
		/// when the user permits access to the hardware. On some platforms, this<br/>
		/// presents as a popup dialog where the user has to explicitly approve access;<br/>
		/// on others the approval might be implicit and not alert the user at all.<br/>
		/// This function can be used to check the status of that approval. It will<br/>
		/// return 0 if still waiting for user response, 1 if the camera is approved<br/>
		/// for use, and -1 if the user denied access.<br/>
		/// Instead of polling with this function, you can wait for a<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event<br/>
		/// in the standard SDL event loop, which is guaranteed to be sent once when<br/>
		/// permission to use the camera is decided.<br/>
		/// If a camera is declined, there's nothing to be done but call<br/>
		/// SDL_CloseCamera() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraPermissionState")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCameraPermissionStateNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCamera*, int>)funcTable[454])(camera);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[454])((nint)camera);
			#endif
		}

		/// <summary>
		/// Query if camera access has been approved by the user.<br/>
		/// Cameras will not function between when the device is opened by the app and<br/>
		/// when the user permits access to the hardware. On some platforms, this<br/>
		/// presents as a popup dialog where the user has to explicitly approve access;<br/>
		/// on others the approval might be implicit and not alert the user at all.<br/>
		/// This function can be used to check the status of that approval. It will<br/>
		/// return 0 if still waiting for user response, 1 if the camera is approved<br/>
		/// for use, and -1 if the user denied access.<br/>
		/// Instead of polling with this function, you can wait for a<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event<br/>
		/// in the standard SDL event loop, which is guaranteed to be sent once when<br/>
		/// permission to use the camera is decided.<br/>
		/// If a camera is declined, there's nothing to be done but call<br/>
		/// SDL_CloseCamera() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraPermissionState")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCameraPermissionState([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			int ret = GetCameraPermissionStateNative(camera);
			return ret;
		}

		/// <summary>
		/// Query if camera access has been approved by the user.<br/>
		/// Cameras will not function between when the device is opened by the app and<br/>
		/// when the user permits access to the hardware. On some platforms, this<br/>
		/// presents as a popup dialog where the user has to explicitly approve access;<br/>
		/// on others the approval might be implicit and not alert the user at all.<br/>
		/// This function can be used to check the status of that approval. It will<br/>
		/// return 0 if still waiting for user response, 1 if the camera is approved<br/>
		/// for use, and -1 if the user denied access.<br/>
		/// Instead of polling with this function, you can wait for a<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event<br/>
		/// in the standard SDL event loop, which is guaranteed to be sent once when<br/>
		/// permission to use the camera is decided.<br/>
		/// If a camera is declined, there's nothing to be done but call<br/>
		/// SDL_CloseCamera() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraPermissionState")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCameraPermissionState([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				int ret = GetCameraPermissionStateNative((SDLCamera*)pcamera);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of an opened camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraID")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCameraIDNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCamera*, uint>)funcTable[455])(camera);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[455])((nint)camera);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraID")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraID")]
		public static uint GetCameraID([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			uint ret = GetCameraIDNative(camera);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraID")]
		[return: NativeName(NativeNameType.Type, "SDL_CameraID")]
		public static uint GetCameraID([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				uint ret = GetCameraIDNative((SDLCamera*)pcamera);
				return ret;
			}
		}

		/// <summary>
		/// Get the properties associated with an opened camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCameraPropertiesNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCamera*, uint>)funcTable[456])(camera);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[456])((nint)camera);
			#endif
		}

		/// <summary>
		/// Get the properties associated with an opened camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetCameraProperties([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			uint ret = GetCameraPropertiesNative(camera);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with an opened camera.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetCameraProperties([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				uint ret = GetCameraPropertiesNative((SDLCamera*)pcamera);
				return ret;
			}
		}

		/// <summary>
		/// Get the spec that a camera is using when generating images.<br/>
		/// Note that this might not be the native format of the hardware, as SDL might<br/>
		/// be converting to this format behind the scenes.<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return false, but this isn't necessarily<br/>
		/// a fatal error; you should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetCameraFormatNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec *")] SDLCameraSpec* spec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCamera*, SDLCameraSpec*, byte>)funcTable[457])(camera, spec);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[457])((nint)camera, (nint)spec);
			#endif
		}

		/// <summary>
		/// Get the spec that a camera is using when generating images.<br/>
		/// Note that this might not be the native format of the hardware, as SDL might<br/>
		/// be converting to this format behind the scenes.<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return false, but this isn't necessarily<br/>
		/// a fatal error; you should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetCameraFormat([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec *")] SDLCameraSpec* spec)
		{
			byte ret = GetCameraFormatNative(camera, spec);
			return ret != 0;
		}

		/// <summary>
		/// Get the spec that a camera is using when generating images.<br/>
		/// Note that this might not be the native format of the hardware, as SDL might<br/>
		/// be converting to this format behind the scenes.<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return false, but this isn't necessarily<br/>
		/// a fatal error; you should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetCameraFormat([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec *")] SDLCameraSpec* spec)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				byte ret = GetCameraFormatNative((SDLCamera*)pcamera, spec);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the spec that a camera is using when generating images.<br/>
		/// Note that this might not be the native format of the hardware, as SDL might<br/>
		/// be converting to this format behind the scenes.<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return false, but this isn't necessarily<br/>
		/// a fatal error; you should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetCameraFormat([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec *")] ref SDLCameraSpec spec)
		{
			fixed (SDLCameraSpec* pspec = &spec)
			{
				byte ret = GetCameraFormatNative(camera, (SDLCameraSpec*)pspec);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the spec that a camera is using when generating images.<br/>
		/// Note that this might not be the native format of the hardware, as SDL might<br/>
		/// be converting to this format behind the scenes.<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return false, but this isn't necessarily<br/>
		/// a fatal error; you should either wait for an<br/>
		/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
		/// or poll SDL_GetCameraPermissionState() occasionally until it returns<br/>
		/// non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCameraFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetCameraFormat([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_CameraSpec *")] ref SDLCameraSpec spec)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				fixed (SDLCameraSpec* pspec = &spec)
				{
					byte ret = GetCameraFormatNative((SDLCamera*)pcamera, (SDLCameraSpec*)pspec);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a frame.<br/>
		/// The frame is a memory pointer to the image data, whose size and format are<br/>
		/// given by the spec requested when opening the device.<br/>
		/// This is a non blocking API. If there is a frame available, a non-NULL<br/>
		/// surface is returned, and timestampNS will be filled with a non-zero value.<br/>
		/// Note that an error case can also return NULL, but a NULL by itself is<br/>
		/// normal and just signifies that a new frame is not yet available. Note that<br/>
		/// even if a camera device fails outright (a USB camera is unplugged while in<br/>
		/// use, etc), SDL will send an event separately to notify the app, but<br/>
		/// continue to provide blank frames at ongoing intervals until<br/>
		/// SDL_CloseCamera() is called, so real failure here is almost always an out<br/>
		/// of memory condition.<br/>
		/// After use, the frame should be released with SDL_ReleaseCameraFrame(). If<br/>
		/// you don't do this, the system may stop providing more video!<br/>
		/// Do not call SDL_DestroySurface() on the returned surface! It must be given<br/>
		/// back to the camera subsystem with SDL_ReleaseCameraFrame!<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return NULL (no frames available); you<br/>
		/// should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or<br/>
		/// SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll<br/>
		/// SDL_GetCameraPermissionState() occasionally until it returns non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireCameraFrame")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* AcquireCameraFrameNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "timestampNS")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* timestampNS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCamera*, ulong*, SDLSurface*>)funcTable[458])(camera, timestampNS);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[458])((nint)camera, (nint)timestampNS);
			#endif
		}

		/// <summary>
		/// Acquire a frame.<br/>
		/// The frame is a memory pointer to the image data, whose size and format are<br/>
		/// given by the spec requested when opening the device.<br/>
		/// This is a non blocking API. If there is a frame available, a non-NULL<br/>
		/// surface is returned, and timestampNS will be filled with a non-zero value.<br/>
		/// Note that an error case can also return NULL, but a NULL by itself is<br/>
		/// normal and just signifies that a new frame is not yet available. Note that<br/>
		/// even if a camera device fails outright (a USB camera is unplugged while in<br/>
		/// use, etc), SDL will send an event separately to notify the app, but<br/>
		/// continue to provide blank frames at ongoing intervals until<br/>
		/// SDL_CloseCamera() is called, so real failure here is almost always an out<br/>
		/// of memory condition.<br/>
		/// After use, the frame should be released with SDL_ReleaseCameraFrame(). If<br/>
		/// you don't do this, the system may stop providing more video!<br/>
		/// Do not call SDL_DestroySurface() on the returned surface! It must be given<br/>
		/// back to the camera subsystem with SDL_ReleaseCameraFrame!<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return NULL (no frames available); you<br/>
		/// should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or<br/>
		/// SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll<br/>
		/// SDL_GetCameraPermissionState() occasionally until it returns non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireCameraFrame")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* AcquireCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "timestampNS")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* timestampNS)
		{
			SDLSurface* ret = AcquireCameraFrameNative(camera, timestampNS);
			return ret;
		}

		/// <summary>
		/// Acquire a frame.<br/>
		/// The frame is a memory pointer to the image data, whose size and format are<br/>
		/// given by the spec requested when opening the device.<br/>
		/// This is a non blocking API. If there is a frame available, a non-NULL<br/>
		/// surface is returned, and timestampNS will be filled with a non-zero value.<br/>
		/// Note that an error case can also return NULL, but a NULL by itself is<br/>
		/// normal and just signifies that a new frame is not yet available. Note that<br/>
		/// even if a camera device fails outright (a USB camera is unplugged while in<br/>
		/// use, etc), SDL will send an event separately to notify the app, but<br/>
		/// continue to provide blank frames at ongoing intervals until<br/>
		/// SDL_CloseCamera() is called, so real failure here is almost always an out<br/>
		/// of memory condition.<br/>
		/// After use, the frame should be released with SDL_ReleaseCameraFrame(). If<br/>
		/// you don't do this, the system may stop providing more video!<br/>
		/// Do not call SDL_DestroySurface() on the returned surface! It must be given<br/>
		/// back to the camera subsystem with SDL_ReleaseCameraFrame!<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return NULL (no frames available); you<br/>
		/// should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or<br/>
		/// SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll<br/>
		/// SDL_GetCameraPermissionState() occasionally until it returns non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireCameraFrame")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* AcquireCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera, [NativeName(NativeNameType.Param, "timestampNS")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* timestampNS)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				SDLSurface* ret = AcquireCameraFrameNative((SDLCamera*)pcamera, timestampNS);
				return ret;
			}
		}

		/// <summary>
		/// Acquire a frame.<br/>
		/// The frame is a memory pointer to the image data, whose size and format are<br/>
		/// given by the spec requested when opening the device.<br/>
		/// This is a non blocking API. If there is a frame available, a non-NULL<br/>
		/// surface is returned, and timestampNS will be filled with a non-zero value.<br/>
		/// Note that an error case can also return NULL, but a NULL by itself is<br/>
		/// normal and just signifies that a new frame is not yet available. Note that<br/>
		/// even if a camera device fails outright (a USB camera is unplugged while in<br/>
		/// use, etc), SDL will send an event separately to notify the app, but<br/>
		/// continue to provide blank frames at ongoing intervals until<br/>
		/// SDL_CloseCamera() is called, so real failure here is almost always an out<br/>
		/// of memory condition.<br/>
		/// After use, the frame should be released with SDL_ReleaseCameraFrame(). If<br/>
		/// you don't do this, the system may stop providing more video!<br/>
		/// Do not call SDL_DestroySurface() on the returned surface! It must be given<br/>
		/// back to the camera subsystem with SDL_ReleaseCameraFrame!<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return NULL (no frames available); you<br/>
		/// should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or<br/>
		/// SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll<br/>
		/// SDL_GetCameraPermissionState() occasionally until it returns non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireCameraFrame")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* AcquireCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "timestampNS")] [NativeName(NativeNameType.Type, "Uint64 *")] ref ulong timestampNS)
		{
			fixed (ulong* ptimestampNS = &timestampNS)
			{
				SDLSurface* ret = AcquireCameraFrameNative(camera, (ulong*)ptimestampNS);
				return ret;
			}
		}

		/// <summary>
		/// Acquire a frame.<br/>
		/// The frame is a memory pointer to the image data, whose size and format are<br/>
		/// given by the spec requested when opening the device.<br/>
		/// This is a non blocking API. If there is a frame available, a non-NULL<br/>
		/// surface is returned, and timestampNS will be filled with a non-zero value.<br/>
		/// Note that an error case can also return NULL, but a NULL by itself is<br/>
		/// normal and just signifies that a new frame is not yet available. Note that<br/>
		/// even if a camera device fails outright (a USB camera is unplugged while in<br/>
		/// use, etc), SDL will send an event separately to notify the app, but<br/>
		/// continue to provide blank frames at ongoing intervals until<br/>
		/// SDL_CloseCamera() is called, so real failure here is almost always an out<br/>
		/// of memory condition.<br/>
		/// After use, the frame should be released with SDL_ReleaseCameraFrame(). If<br/>
		/// you don't do this, the system may stop providing more video!<br/>
		/// Do not call SDL_DestroySurface() on the returned surface! It must be given<br/>
		/// back to the camera subsystem with SDL_ReleaseCameraFrame!<br/>
		/// If the system is waiting for the user to approve access to the camera, as<br/>
		/// some platforms require, this will return NULL (no frames available); you<br/>
		/// should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or<br/>
		/// SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll<br/>
		/// SDL_GetCameraPermissionState() occasionally until it returns non-zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireCameraFrame")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* AcquireCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera, [NativeName(NativeNameType.Param, "timestampNS")] [NativeName(NativeNameType.Type, "Uint64 *")] ref ulong timestampNS)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				fixed (ulong* ptimestampNS = &timestampNS)
				{
					SDLSurface* ret = AcquireCameraFrameNative((SDLCamera*)pcamera, (ulong*)ptimestampNS);
					return ret;
				}
			}
		}

		/// <summary>
		/// Release a frame of video acquired from a camera.<br/>
		/// Let the back-end re-use the internal buffer for camera.<br/>
		/// This function _must_ be called only on surface objects returned by<br/>
		/// SDL_AcquireCameraFrame(). This function should be called as quickly as<br/>
		/// possible after acquisition, as SDL keeps a small FIFO queue of surfaces for<br/>
		/// video frames; if surfaces aren't released in a timely manner, SDL may drop<br/>
		/// upcoming video frames from the camera.<br/>
		/// If the app needs to keep the surface for a significant time, they should<br/>
		/// make a copy of it and release the original.<br/>
		/// The app should not use the surface again after calling this function;<br/>
		/// assume the surface is freed and the pointer is invalid.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseCameraFrame")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseCameraFrameNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "frame")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* frame)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCamera*, SDLSurface*, void>)funcTable[459])(camera, frame);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[459])((nint)camera, (nint)frame);
			#endif
		}

		/// <summary>
		/// Release a frame of video acquired from a camera.<br/>
		/// Let the back-end re-use the internal buffer for camera.<br/>
		/// This function _must_ be called only on surface objects returned by<br/>
		/// SDL_AcquireCameraFrame(). This function should be called as quickly as<br/>
		/// possible after acquisition, as SDL keeps a small FIFO queue of surfaces for<br/>
		/// video frames; if surfaces aren't released in a timely manner, SDL may drop<br/>
		/// upcoming video frames from the camera.<br/>
		/// If the app needs to keep the surface for a significant time, they should<br/>
		/// make a copy of it and release the original.<br/>
		/// The app should not use the surface again after calling this function;<br/>
		/// assume the surface is freed and the pointer is invalid.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseCameraFrame")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "frame")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* frame)
		{
			ReleaseCameraFrameNative(camera, frame);
		}

		/// <summary>
		/// Release a frame of video acquired from a camera.<br/>
		/// Let the back-end re-use the internal buffer for camera.<br/>
		/// This function _must_ be called only on surface objects returned by<br/>
		/// SDL_AcquireCameraFrame(). This function should be called as quickly as<br/>
		/// possible after acquisition, as SDL keeps a small FIFO queue of surfaces for<br/>
		/// video frames; if surfaces aren't released in a timely manner, SDL may drop<br/>
		/// upcoming video frames from the camera.<br/>
		/// If the app needs to keep the surface for a significant time, they should<br/>
		/// make a copy of it and release the original.<br/>
		/// The app should not use the surface again after calling this function;<br/>
		/// assume the surface is freed and the pointer is invalid.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseCameraFrame")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera, [NativeName(NativeNameType.Param, "frame")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* frame)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				ReleaseCameraFrameNative((SDLCamera*)pcamera, frame);
			}
		}

		/// <summary>
		/// Release a frame of video acquired from a camera.<br/>
		/// Let the back-end re-use the internal buffer for camera.<br/>
		/// This function _must_ be called only on surface objects returned by<br/>
		/// SDL_AcquireCameraFrame(). This function should be called as quickly as<br/>
		/// possible after acquisition, as SDL keeps a small FIFO queue of surfaces for<br/>
		/// video frames; if surfaces aren't released in a timely manner, SDL may drop<br/>
		/// upcoming video frames from the camera.<br/>
		/// If the app needs to keep the surface for a significant time, they should<br/>
		/// make a copy of it and release the original.<br/>
		/// The app should not use the surface again after calling this function;<br/>
		/// assume the surface is freed and the pointer is invalid.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseCameraFrame")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera, [NativeName(NativeNameType.Param, "frame")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface frame)
		{
			fixed (SDLSurface* pframe = &frame)
			{
				ReleaseCameraFrameNative(camera, (SDLSurface*)pframe);
			}
		}

		/// <summary>
		/// Release a frame of video acquired from a camera.<br/>
		/// Let the back-end re-use the internal buffer for camera.<br/>
		/// This function _must_ be called only on surface objects returned by<br/>
		/// SDL_AcquireCameraFrame(). This function should be called as quickly as<br/>
		/// possible after acquisition, as SDL keeps a small FIFO queue of surfaces for<br/>
		/// video frames; if surfaces aren't released in a timely manner, SDL may drop<br/>
		/// upcoming video frames from the camera.<br/>
		/// If the app needs to keep the surface for a significant time, they should<br/>
		/// make a copy of it and release the original.<br/>
		/// The app should not use the surface again after calling this function;<br/>
		/// assume the surface is freed and the pointer is invalid.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseCameraFrame")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseCameraFrame([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera, [NativeName(NativeNameType.Param, "frame")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface frame)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				fixed (SDLSurface* pframe = &frame)
				{
					ReleaseCameraFrameNative((SDLCamera*)pcamera, (SDLSurface*)pframe);
				}
			}
		}

		/// <summary>
		/// Use this function to shut down camera processing and close the camera<br/>
		/// device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but no<br/>
		/// thread may reference `device` once this function is called.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseCamera")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseCameraNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCamera*, void>)funcTable[460])(camera);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[460])((nint)camera);
			#endif
		}

		/// <summary>
		/// Use this function to shut down camera processing and close the camera<br/>
		/// device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but no<br/>
		/// thread may reference `device` once this function is called.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseCamera")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseCamera([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] SDLCamera* camera)
		{
			CloseCameraNative(camera);
		}

		/// <summary>
		/// Use this function to shut down camera processing and close the camera<br/>
		/// device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but no<br/>
		/// thread may reference `device` once this function is called.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseCamera")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseCamera([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "SDL_Camera *")] ref SDLCamera camera)
		{
			fixed (SDLCamera* pcamera = &camera)
			{
				CloseCameraNative((SDLCamera*)pcamera);
			}
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetClipboardTextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[461])(text);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[461])((nint)text);
			#endif
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte ret = SetClipboardTextNative(text);
			return ret != 0;
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = SetClipboardTextNative((byte*)ptext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte ret = SetClipboardTextNative((byte*)ptext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetClipboardTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard.<br/>
		/// This functions returns an empty string if there was not enough memory left<br/>
		/// for a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[462])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[462])();
			#endif
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard.<br/>
		/// This functions returns an empty string if there was not enough memory left<br/>
		/// for a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard.<br/>
		/// This functions returns an empty string if there was not enough memory left<br/>
		/// for a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the clipboard exists and contains a non-empty text string.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[463])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[463])();
			#endif
		}

		/// <summary>
		/// Query whether the clipboard exists and contains a non-empty text string.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasClipboardText()
		{
			byte ret = HasClipboardTextNative();
			return ret != 0;
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetPrimarySelectionTextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[464])(text);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[464])((nint)text);
			#endif
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPrimarySelectionText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte ret = SetPrimarySelectionTextNative(text);
			return ret != 0;
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPrimarySelectionText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = SetPrimarySelectionTextNative((byte*)ptext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPrimarySelectionText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte ret = SetPrimarySelectionTextNative((byte*)ptext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPrimarySelectionText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPrimarySelectionTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection.<br/>
		/// This functions returns an empty string if there was not enough memory left<br/>
		/// for a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPrimarySelectionTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[465])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[465])();
			#endif
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection.<br/>
		/// This functions returns an empty string if there was not enough memory left<br/>
		/// for a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrimarySelectionText()
		{
			byte* ret = GetPrimarySelectionTextNative();
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection.<br/>
		/// This functions returns an empty string if there was not enough memory left<br/>
		/// for a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrimarySelectionTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetPrimarySelectionTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the primary selection exists and contains a non-empty text<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasPrimarySelectionTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[466])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[466])();
			#endif
		}

		/// <summary>
		/// Query whether the primary selection exists and contains a non-empty text<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasPrimarySelectionText()
		{
			byte ret = HasPrimarySelectionTextNative();
			return ret != 0;
		}

		/// <summary>
		/// Offer clipboard data to the OS.<br/>
		/// Tell the operating system that the application is offering clipboard data<br/>
		/// for each of the provided mime-types. Once another application requests the<br/>
		/// data the callback function will be called, allowing it to generate and<br/>
		/// respond with the data for the requested mime-type.<br/>
		/// The size of text data does not include any terminator, and the text does<br/>
		/// not need to be null terminated (e.g. you can directly copy a portion of a<br/>
		/// document).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetClipboardDataNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_ClipboardDataCallback")] SDLClipboardDataCallback callback, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_ClipboardCleanupCallback")] SDLClipboardCleanupCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "mime_types")] [NativeName(NativeNameType.Type, "char const * *")] byte** mimeTypes, [NativeName(NativeNameType.Param, "num_mime_types")] [NativeName(NativeNameType.Type, "size_t")] nuint numMimeTypes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, byte*, nuint*, void*>, delegate*<void*, void>, void*, byte**, nuint, byte>)funcTable[467])((delegate*<void*, byte*, nuint*, void*>)Utils.GetFunctionPointerForDelegate(callback), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata, mimeTypes, numMimeTypes);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nuint, byte>)funcTable[467])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)Utils.GetFunctionPointerForDelegate(cleanup), (nint)userdata, (nint)mimeTypes, numMimeTypes);
			#endif
		}

		/// <summary>
		/// Offer clipboard data to the OS.<br/>
		/// Tell the operating system that the application is offering clipboard data<br/>
		/// for each of the provided mime-types. Once another application requests the<br/>
		/// data the callback function will be called, allowing it to generate and<br/>
		/// respond with the data for the requested mime-type.<br/>
		/// The size of text data does not include any terminator, and the text does<br/>
		/// not need to be null terminated (e.g. you can directly copy a portion of a<br/>
		/// document).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetClipboardData([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_ClipboardDataCallback")] SDLClipboardDataCallback callback, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_ClipboardCleanupCallback")] SDLClipboardCleanupCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "mime_types")] [NativeName(NativeNameType.Type, "char const * *")] byte** mimeTypes, [NativeName(NativeNameType.Param, "num_mime_types")] [NativeName(NativeNameType.Type, "size_t")] nuint numMimeTypes)
		{
			byte ret = SetClipboardDataNative(callback, cleanup, userdata, mimeTypes, numMimeTypes);
			return ret != 0;
		}

		/// <summary>
		/// Offer clipboard data to the OS.<br/>
		/// Tell the operating system that the application is offering clipboard data<br/>
		/// for each of the provided mime-types. Once another application requests the<br/>
		/// data the callback function will be called, allowing it to generate and<br/>
		/// respond with the data for the requested mime-type.<br/>
		/// The size of text data does not include any terminator, and the text does<br/>
		/// not need to be null terminated (e.g. you can directly copy a portion of a<br/>
		/// document).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetClipboardData([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_ClipboardDataCallback")] SDLClipboardDataCallback callback, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_ClipboardCleanupCallback")] SDLClipboardCleanupCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "mime_types")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* mimeTypes, [NativeName(NativeNameType.Param, "num_mime_types")] [NativeName(NativeNameType.Type, "size_t")] nuint numMimeTypes)
		{
			fixed (byte** pmimeTypes = &mimeTypes)
			{
				byte ret = SetClipboardDataNative(callback, cleanup, userdata, (byte**)pmimeTypes, numMimeTypes);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear the clipboard data.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearClipboardDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[468])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[468])();
			#endif
		}

		/// <summary>
		/// Clear the clipboard data.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearClipboardData()
		{
			byte ret = ClearClipboardDataNative();
			return ret != 0;
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetClipboardDataNative([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] nuint* size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint*, void*>)funcTable[469])(mimeType, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[469])((nint)mimeType, (nint)size);
			#endif
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] nuint* size)
		{
			void* ret = GetClipboardDataNative(mimeType, size);
			return ret;
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ref byte mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] nuint* size)
		{
			fixed (byte* pmimeType = &mimeType)
			{
				void* ret = GetClipboardDataNative((byte*)pmimeType, size);
				return ret;
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] nuint* size)
		{
			fixed (byte* pmimeType = mimeType)
			{
				void* ret = GetClipboardDataNative((byte*)pmimeType, size);
				return ret;
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] string mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] nuint* size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mimeType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mimeType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mimeType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetClipboardDataNative(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				void* ret = GetClipboardDataNative(mimeType, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ref byte mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			fixed (byte* pmimeType = &mimeType)
			{
				fixed (nuint* psize = &size)
				{
					void* ret = GetClipboardDataNative((byte*)pmimeType, (nuint*)psize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			fixed (byte* pmimeType = mimeType)
			{
				fixed (nuint* psize = &size)
				{
					void* ret = GetClipboardDataNative((byte*)pmimeType, (nuint*)psize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] string mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mimeType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mimeType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mimeType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* psize = &size)
			{
				void* ret = GetClipboardDataNative(pStr0, (nuint*)psize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasClipboardDataNative([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[470])(mimeType);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[470])((nint)mimeType);
			#endif
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType)
		{
			byte ret = HasClipboardDataNative(mimeType);
			return ret != 0;
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ref byte mimeType)
		{
			fixed (byte* pmimeType = &mimeType)
			{
				byte ret = HasClipboardDataNative((byte*)pmimeType);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mimeType)
		{
			fixed (byte* pmimeType = mimeType)
			{
				byte ret = HasClipboardDataNative((byte*)pmimeType);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] string mimeType)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mimeType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mimeType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mimeType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = HasClipboardDataNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Retrieve the list of mime types available in the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardMimeTypes")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GetClipboardMimeTypesNative([NativeName(NativeNameType.Param, "num_mime_types")] [NativeName(NativeNameType.Type, "size_t *")] nuint* numMimeTypes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint*, byte**>)funcTable[471])(numMimeTypes);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[471])((nint)numMimeTypes);
			#endif
		}

		/// <summary>
		/// Retrieve the list of mime types available in the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardMimeTypes")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GetClipboardMimeTypes([NativeName(NativeNameType.Param, "num_mime_types")] [NativeName(NativeNameType.Type, "size_t *")] nuint* numMimeTypes)
		{
			byte** ret = GetClipboardMimeTypesNative(numMimeTypes);
			return ret;
		}

		/// <summary>
		/// Retrieve the list of mime types available in the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardMimeTypes")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GetClipboardMimeTypes([NativeName(NativeNameType.Param, "num_mime_types")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint numMimeTypes)
		{
			fixed (nuint* pnumMimeTypes = &numMimeTypes)
			{
				byte** ret = GetClipboardMimeTypesNative((nuint*)pnumMimeTypes);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of logical CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumLogicalCPUCores")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumLogicalCPUCoresNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[472])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[472])();
			#endif
		}

		/// <summary>
		/// Get the number of logical CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumLogicalCPUCores")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumLogicalCPUCores()
		{
			int ret = GetNumLogicalCPUCoresNative();
			return ret;
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCacheLineSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCPUCacheLineSizeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[473])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[473])();
			#endif
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCacheLineSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCPUCacheLineSize()
		{
			int ret = GetCPUCacheLineSizeNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAltiVec")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasAltiVecNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[474])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[474])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAltiVec")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasAltiVec()
		{
			byte ret = HasAltiVecNative();
			return ret != 0;
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMMX")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasMMXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[475])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[475])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMMX")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasMMX()
		{
			byte ret = HasMMXNative();
			return ret != 0;
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasSSENative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[476])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[476])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasSSE()
		{
			byte ret = HasSSENative();
			return ret != 0;
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE2")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasSSE2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[477])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[477])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE2")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasSSE2()
		{
			byte ret = HasSSE2Native();
			return ret != 0;
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE3")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasSSE3Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[478])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[478])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE3")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasSSE3()
		{
			byte ret = HasSSE3Native();
			return ret != 0;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE41")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasSSE41Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[479])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[479])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE41")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasSSE41()
		{
			byte ret = HasSSE41Native();
			return ret != 0;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE42")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasSSE42Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[480])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[480])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE42")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasSSE42()
		{
			byte ret = HasSSE42Native();
			return ret != 0;
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasAVXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[481])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[481])();
			#endif
		}
	}
}
