// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRectIntersectionFloatNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLFRect*, byte>)funcTable[387])(a, b, result);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[387])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			byte ret = GetRectIntersectionFloatNative((SDLFRect*)a, (SDLFRect*)b, (SDLFRect*)result);
			return ret != 0;
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFRect* pa = &a)
			{
				byte ret = GetRectIntersectionFloatNative((SDLFRect*)pa, (SDLFRect*)b, (SDLFRect*)result);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFRect* pb = &b)
			{
				byte ret = GetRectIntersectionFloatNative((SDLFRect*)a, (SDLFRect*)pb, (SDLFRect*)result);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					byte ret = GetRectIntersectionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)result);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				byte ret = GetRectIntersectionFloatNative((SDLFRect*)a, (SDLFRect*)b, (SDLFRect*)presult);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					byte ret = GetRectIntersectionFloatNative((SDLFRect*)pa, (SDLFRect*)b, (SDLFRect*)presult);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					byte ret = GetRectIntersectionFloatNative((SDLFRect*)a, (SDLFRect*)pb, (SDLFRect*)presult);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						byte ret = GetRectIntersectionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRectUnionFloatNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLFRect*, byte>)funcTable[388])(a, b, result);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[388])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			byte ret = GetRectUnionFloatNative((SDLFRect*)a, (SDLFRect*)b, (SDLFRect*)result);
			return ret != 0;
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFRect* pa = &a)
			{
				byte ret = GetRectUnionFloatNative((SDLFRect*)pa, (SDLFRect*)b, (SDLFRect*)result);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFRect* pb = &b)
			{
				byte ret = GetRectUnionFloatNative((SDLFRect*)a, (SDLFRect*)pb, (SDLFRect*)result);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					byte ret = GetRectUnionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)result);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				byte ret = GetRectUnionFloatNative((SDLFRect*)a, (SDLFRect*)b, (SDLFRect*)presult);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					byte ret = GetRectUnionFloatNative((SDLFRect*)pa, (SDLFRect*)b, (SDLFRect*)presult);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					byte ret = GetRectUnionFloatNative((SDLFRect*)a, (SDLFRect*)pb, (SDLFRect*)presult);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						byte ret = GetRectUnionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRectEnclosingPointsFloatNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFPoint*, int, SDLFRect*, SDLFRect*, byte>)funcTable[389])(points, count, clip, result);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, byte>)funcTable[389])((nint)points, count, (nint)clip, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPointPtr points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)points, count, (SDLFRect*)clip, (SDLFRect*)result);
			return ret != 0;
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] in SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, (SDLFRect*)clip, (SDLFRect*)result);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPointPtr points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)points, count, (SDLFRect*)pclip, (SDLFRect*)result);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] in SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRectPtr result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, (SDLFRect*)result);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPointPtr points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)points, count, (SDLFRect*)clip, (SDLFRect*)presult);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] in SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* presult = &result)
				{
					byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, (SDLFRect*)clip, (SDLFRect*)presult);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPointPtr points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				fixed (SDLFRect* presult = &result)
				{
					byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)points, count, (SDLFRect*)pclip, (SDLFRect*)presult);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] in SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					fixed (SDLFRect* presult = &result)
					{
						byte ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, (SDLFRect*)presult);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRectAndLineIntersectionFloatNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, float*, float*, float*, float*, byte>)funcTable[390])(rect, x1, y1, x2, y2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[390])((nint)rect, (nint)x1, (nint)y1, (nint)x2, (nint)y2);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, y1, x2, y2);
			return ret != 0;
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, x2, y2);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, y1, x2, y2);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, x2, y2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, (float*)py1, x2, y2);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, x2, y2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, (float*)py1, x2, y2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, y2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px2 = &x2)
			{
				byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, y1, (float*)px2, y2);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, (float*)px2, y2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, y1, (float*)px2, y2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, y2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, (float*)py1, (float*)px2, y2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, y2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, (float*)py1, (float*)px2, y2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, y2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* py2 = &y2)
			{
				byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, y1, x2, (float*)py2);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py2 = &y2)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, x2, (float*)py2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py2 = &y2)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, y1, x2, (float*)py2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py2 = &y2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, x2, (float*)py2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* py2 = &y2)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, (float*)py1, x2, (float*)py2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, x2, (float*)py2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, (float*)py1, x2, (float*)py2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* py2 = &y2)
						{
							byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, (float*)py2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px2 = &x2)
			{
				fixed (float* py2 = &y2)
				{
					byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, y1, (float*)px2, (float*)py2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, (float*)px2, (float*)py2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, y1, (float*)px2, (float*)py2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, (float*)py2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, x1, (float*)py1, (float*)px2, (float*)py2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, (float*)py2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRectPtr rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)rect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] in SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							fixed (float* py2 = &y2)
							{
								byte ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format.<br/>
		/// The pixels of the new surface are initialized to zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateSurfaceNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, SDLSurface*>)funcTable[391])(width, height, format);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint>)funcTable[391])(width, height, format);
			#endif
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format.<br/>
		/// The pixels of the new surface are initialized to zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr CreateSurface([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			SDLSurfacePtr ret = CreateSurfaceNative(width, height, format);
			return ret;
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format and existing pixel<br/>
		/// data.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// Pitch is the offset in bytes from one row of pixels to the next, e.g.<br/>
		/// `width*4` for `SDL_PIXELFORMAT_RGBA8888`.<br/>
		/// You may pass NULL for pixels and 0 for pitch to create a surface that you<br/>
		/// will fill in with valid values later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateSurfaceFromNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void *")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, void*, int, SDLSurface*>)funcTable[392])(width, height, format, pixels, pitch);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint, int, nint>)funcTable[392])(width, height, format, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format and existing pixel<br/>
		/// data.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// Pitch is the offset in bytes from one row of pixels to the next, e.g.<br/>
		/// `width*4` for `SDL_PIXELFORMAT_RGBA8888`.<br/>
		/// You may pass NULL for pixels and 0 for pitch to create a surface that you<br/>
		/// will fill in with valid values later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr CreateSurfaceFrom([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void *")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			SDLSurfacePtr ret = CreateSurfaceFromNative(width, height, format, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format and existing pixel<br/>
		/// data.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// Pitch is the offset in bytes from one row of pixels to the next, e.g.<br/>
		/// `width*4` for `SDL_PIXELFORMAT_RGBA8888`.<br/>
		/// You may pass NULL for pixels and 0 for pitch to create a surface that you<br/>
		/// will fill in with valid values later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr CreateSurfaceFrom([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void *")] nint pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			SDLSurfacePtr ret = CreateSurfaceFromNative(width, height, format, (void*)pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Free a surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// No other thread should be using the surface when it is freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroySurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[393])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[393])((nint)surface);
			#endif
		}

		/// <summary>
		/// Free a surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// No other thread should be using the surface when it is freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			DestroySurfaceNative((SDLSurface*)surface);
		}

		/// <summary>
		/// Free a surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// No other thread should be using the surface when it is freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				DestroySurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Get the properties associated with a surface.<br/>
		/// The following properties are understood by SDL:<br/>
		/// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.<br/>
		/// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. This defaults to 0.0, which disables tone<br/>
		/// mapping.<br/>
		/// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator<br/>
		/// used when compressing from a surface with high dynamic range to another<br/>
		/// with lower dynamic range. Currently this supports "chrome", which uses<br/>
		/// the same tone mapping that Chrome uses for HDR content, the form "*=N",<br/>
		/// where N is a floating point scale factor applied in linear space, and<br/>
		/// "none", which disables tone mapping. This defaults to "chrome".<br/>
		/// - `SDL_PROP_SURFACE_HOTSPOT_X_NUMBER`: the hotspot pixel offset from the<br/>
		/// left edge of the image, if this surface is being used as a cursor.<br/>
		/// - `SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the<br/>
		/// top edge of the image, if this surface is being used as a cursor.<br/>
		/// - `SDL_PROP_SURFACE_ROTATION_FLOAT`: the number of degrees a surface's data<br/>
		/// is meant to be rotated clockwise to make the image right-side up. Default<br/>
		/// 0. This is used by the camera API, if a mobile device is oriented<br/>
		/// differently than what its camera provides (i.e. - the camera always<br/>
		/// provides portrait images but the phone is being held in landscape<br/>
		/// orientation). Since SDL 3.4.0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSurfacePropertiesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint>)funcTable[394])(surface);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[394])((nint)surface);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a surface.<br/>
		/// The following properties are understood by SDL:<br/>
		/// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.<br/>
		/// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. This defaults to 0.0, which disables tone<br/>
		/// mapping.<br/>
		/// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator<br/>
		/// used when compressing from a surface with high dynamic range to another<br/>
		/// with lower dynamic range. Currently this supports "chrome", which uses<br/>
		/// the same tone mapping that Chrome uses for HDR content, the form "*=N",<br/>
		/// where N is a floating point scale factor applied in linear space, and<br/>
		/// "none", which disables tone mapping. This defaults to "chrome".<br/>
		/// - `SDL_PROP_SURFACE_HOTSPOT_X_NUMBER`: the hotspot pixel offset from the<br/>
		/// left edge of the image, if this surface is being used as a cursor.<br/>
		/// - `SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the<br/>
		/// top edge of the image, if this surface is being used as a cursor.<br/>
		/// - `SDL_PROP_SURFACE_ROTATION_FLOAT`: the number of degrees a surface's data<br/>
		/// is meant to be rotated clockwise to make the image right-side up. Default<br/>
		/// 0. This is used by the camera API, if a mobile device is oriented<br/>
		/// differently than what its camera provides (i.e. - the camera always<br/>
		/// provides portrait images but the phone is being held in landscape<br/>
		/// orientation). Since SDL 3.4.0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSurfaceProperties([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			uint ret = GetSurfacePropertiesNative((SDLSurface*)surface);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a surface.<br/>
		/// The following properties are understood by SDL:<br/>
		/// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.<br/>
		/// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. This defaults to 0.0, which disables tone<br/>
		/// mapping.<br/>
		/// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator<br/>
		/// used when compressing from a surface with high dynamic range to another<br/>
		/// with lower dynamic range. Currently this supports "chrome", which uses<br/>
		/// the same tone mapping that Chrome uses for HDR content, the form "*=N",<br/>
		/// where N is a floating point scale factor applied in linear space, and<br/>
		/// "none", which disables tone mapping. This defaults to "chrome".<br/>
		/// - `SDL_PROP_SURFACE_HOTSPOT_X_NUMBER`: the hotspot pixel offset from the<br/>
		/// left edge of the image, if this surface is being used as a cursor.<br/>
		/// - `SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the<br/>
		/// top edge of the image, if this surface is being used as a cursor.<br/>
		/// - `SDL_PROP_SURFACE_ROTATION_FLOAT`: the number of degrees a surface's data<br/>
		/// is meant to be rotated clockwise to make the image right-side up. Default<br/>
		/// 0. This is used by the camera API, if a mobile device is oriented<br/>
		/// differently than what its camera provides (i.e. - the camera always<br/>
		/// provides portrait images but the phone is being held in landscape<br/>
		/// orientation). Since SDL 3.4.0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSurfaceProperties([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				uint ret = GetSurfacePropertiesNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Set the colorspace used by a surface.<br/>
		/// Setting the colorspace doesn't change the pixels, only how they are<br/>
		/// interpreted in color operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceColorspaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLColorspace, byte>)funcTable[395])(surface, colorspace);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLColorspace, byte>)funcTable[395])((nint)surface, colorspace);
			#endif
		}

		/// <summary>
		/// Set the colorspace used by a surface.<br/>
		/// Setting the colorspace doesn't change the pixels, only how they are<br/>
		/// interpreted in color operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace)
		{
			byte ret = SetSurfaceColorspaceNative((SDLSurface*)surface, colorspace);
			return ret != 0;
		}

		/// <summary>
		/// Set the colorspace used by a surface.<br/>
		/// Setting the colorspace doesn't change the pixels, only how they are<br/>
		/// interpreted in color operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceColorspaceNative((SDLSurface*)psurface, colorspace);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the colorspace used by a surface.<br/>
		/// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point<br/>
		/// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for<br/>
		/// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Colorspace")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLColorspace GetSurfaceColorspaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLColorspace>)funcTable[396])(surface);
			#else
			return (SDLColorspace)((delegate* unmanaged[Cdecl]<nint, SDLColorspace>)funcTable[396])((nint)surface);
			#endif
		}

		/// <summary>
		/// Get the colorspace used by a surface.<br/>
		/// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point<br/>
		/// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for<br/>
		/// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Colorspace")]
		public static SDLColorspace GetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			SDLColorspace ret = GetSurfaceColorspaceNative((SDLSurface*)surface);
			return ret;
		}

		/// <summary>
		/// Get the colorspace used by a surface.<br/>
		/// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point<br/>
		/// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for<br/>
		/// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Colorspace")]
		public static SDLColorspace GetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLColorspace ret = GetSurfaceColorspaceNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Create a palette and associate it with a surface.<br/>
		/// This function creates a palette compatible with the provided surface. The<br/>
		/// palette is then returned for you to modify, and the surface will<br/>
		/// automatically use the new palette in future operations. You do not need to<br/>
		/// destroy the returned palette, it will be freed when the reference count<br/>
		/// reaches 0, usually when the surface is destroyed.<br/>
		/// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or<br/>
		/// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as<br/>
		/// white and 1 as black. Other surfaces will get a palette initialized with<br/>
		/// white in every entry.<br/>
		/// If this function is called for a surface that already has a palette, a new<br/>
		/// palette will be created to replace it.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPalette* CreateSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPalette*>)funcTable[397])(surface);
			#else
			return (SDLPalette*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[397])((nint)surface);
			#endif
		}

		/// <summary>
		/// Create a palette and associate it with a surface.<br/>
		/// This function creates a palette compatible with the provided surface. The<br/>
		/// palette is then returned for you to modify, and the surface will<br/>
		/// automatically use the new palette in future operations. You do not need to<br/>
		/// destroy the returned palette, it will be freed when the reference count<br/>
		/// reaches 0, usually when the surface is destroyed.<br/>
		/// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or<br/>
		/// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as<br/>
		/// white and 1 as black. Other surfaces will get a palette initialized with<br/>
		/// white in every entry.<br/>
		/// If this function is called for a surface that already has a palette, a new<br/>
		/// palette will be created to replace it.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		public static SDLPalettePtr CreateSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			SDLPalettePtr ret = CreateSurfacePaletteNative((SDLSurface*)surface);
			return ret;
		}

		/// <summary>
		/// Create a palette and associate it with a surface.<br/>
		/// This function creates a palette compatible with the provided surface. The<br/>
		/// palette is then returned for you to modify, and the surface will<br/>
		/// automatically use the new palette in future operations. You do not need to<br/>
		/// destroy the returned palette, it will be freed when the reference count<br/>
		/// reaches 0, usually when the surface is destroyed.<br/>
		/// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or<br/>
		/// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as<br/>
		/// white and 1 as black. Other surfaces will get a palette initialized with<br/>
		/// white in every entry.<br/>
		/// If this function is called for a surface that already has a palette, a new<br/>
		/// palette will be created to replace it.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		public static SDLPalettePtr CreateSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLPalettePtr ret = CreateSurfacePaletteNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// Setting the palette keeps an internal reference to the palette, which can<br/>
		/// be safely destroyed afterwards.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPalette*, byte>)funcTable[398])(surface, palette);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[398])((nint)surface, (nint)palette);
			#endif
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// Setting the palette keeps an internal reference to the palette, which can<br/>
		/// be safely destroyed afterwards.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] SDLPalettePtr palette)
		{
			byte ret = SetSurfacePaletteNative((SDLSurface*)surface, (SDLPalette*)palette);
			return ret != 0;
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// Setting the palette keeps an internal reference to the palette, which can<br/>
		/// be safely destroyed afterwards.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] SDLPalettePtr palette)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfacePaletteNative((SDLSurface*)psurface, (SDLPalette*)palette);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// Setting the palette keeps an internal reference to the palette, which can<br/>
		/// be safely destroyed afterwards.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				byte ret = SetSurfacePaletteNative((SDLSurface*)surface, (SDLPalette*)ppalette);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// Setting the palette keeps an internal reference to the palette, which can<br/>
		/// be safely destroyed afterwards.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] ref SDLPalette palette)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					byte ret = SetSurfacePaletteNative((SDLSurface*)psurface, (SDLPalette*)ppalette);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the palette used by a surface.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPalette* GetSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPalette*>)funcTable[399])(surface);
			#else
			return (SDLPalette*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[399])((nint)surface);
			#endif
		}

		/// <summary>
		/// Get the palette used by a surface.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		public static SDLPalettePtr GetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			SDLPalettePtr ret = GetSurfacePaletteNative((SDLSurface*)surface);
			return ret;
		}

		/// <summary>
		/// Get the palette used by a surface.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		public static SDLPalettePtr GetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLPalettePtr ret = GetSurfacePaletteNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Add an alternate version of a surface.<br/>
		/// This function adds an alternate version of this surface, usually used for<br/>
		/// content with high DPI representations like cursors or icons. The size,<br/>
		/// format, and content do not need to match the original surface, and these<br/>
		/// alternate versions will not be updated when the original surface changes.<br/>
		/// This function adds a reference to the alternate version, so you should call<br/>
		/// SDL_DestroySurface() on the image after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddSurfaceAlternateImage")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AddSurfaceAlternateImageNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* image)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLSurface*, byte>)funcTable[400])(surface, image);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[400])((nint)surface, (nint)image);
			#endif
		}

		/// <summary>
		/// Add an alternate version of a surface.<br/>
		/// This function adds an alternate version of this surface, usually used for<br/>
		/// content with high DPI representations like cursors or icons. The size,<br/>
		/// format, and content do not need to match the original surface, and these<br/>
		/// alternate versions will not be updated when the original surface changes.<br/>
		/// This function adds a reference to the alternate version, so you should call<br/>
		/// SDL_DestroySurface() on the image after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddSurfaceAlternateImage")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddSurfaceAlternateImage([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr image)
		{
			byte ret = AddSurfaceAlternateImageNative((SDLSurface*)surface, (SDLSurface*)image);
			return ret != 0;
		}

		/// <summary>
		/// Add an alternate version of a surface.<br/>
		/// This function adds an alternate version of this surface, usually used for<br/>
		/// content with high DPI representations like cursors or icons. The size,<br/>
		/// format, and content do not need to match the original surface, and these<br/>
		/// alternate versions will not be updated when the original surface changes.<br/>
		/// This function adds a reference to the alternate version, so you should call<br/>
		/// SDL_DestroySurface() on the image after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddSurfaceAlternateImage")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddSurfaceAlternateImage([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr image)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = AddSurfaceAlternateImageNative((SDLSurface*)psurface, (SDLSurface*)image);
				return ret != 0;
			}
		}

		/// <summary>
		/// Add an alternate version of a surface.<br/>
		/// This function adds an alternate version of this surface, usually used for<br/>
		/// content with high DPI representations like cursors or icons. The size,<br/>
		/// format, and content do not need to match the original surface, and these<br/>
		/// alternate versions will not be updated when the original surface changes.<br/>
		/// This function adds a reference to the alternate version, so you should call<br/>
		/// SDL_DestroySurface() on the image after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddSurfaceAlternateImage")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddSurfaceAlternateImage([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface image)
		{
			fixed (SDLSurface* pimage = &image)
			{
				byte ret = AddSurfaceAlternateImageNative((SDLSurface*)surface, (SDLSurface*)pimage);
				return ret != 0;
			}
		}

		/// <summary>
		/// Add an alternate version of a surface.<br/>
		/// This function adds an alternate version of this surface, usually used for<br/>
		/// content with high DPI representations like cursors or icons. The size,<br/>
		/// format, and content do not need to match the original surface, and these<br/>
		/// alternate versions will not be updated when the original surface changes.<br/>
		/// This function adds a reference to the alternate version, so you should call<br/>
		/// SDL_DestroySurface() on the image after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddSurfaceAlternateImage")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddSurfaceAlternateImage([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface image)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLSurface* pimage = &image)
				{
					byte ret = AddSurfaceAlternateImageNative((SDLSurface*)psurface, (SDLSurface*)pimage);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Return whether a surface has alternate versions available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasAlternateImages")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SurfaceHasAlternateImagesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[401])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[401])((nint)surface);
			#endif
		}

		/// <summary>
		/// Return whether a surface has alternate versions available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasAlternateImages")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasAlternateImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			byte ret = SurfaceHasAlternateImagesNative((SDLSurface*)surface);
			return ret != 0;
		}

		/// <summary>
		/// Return whether a surface has alternate versions available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasAlternateImages")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasAlternateImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SurfaceHasAlternateImagesNative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface** GetSurfaceImagesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int*, SDLSurface**>)funcTable[402])(surface, count);
			#else
			return (SDLSurface**)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[402])((nint)surface, (nint)count);
			#endif
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurfacePtrPtr GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			SDLSurfacePtrPtr ret = GetSurfaceImagesNative((SDLSurface*)surface, count);
			return ret;
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurfacePtrPtr GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurfacePtrPtr ret = GetSurfaceImagesNative((SDLSurface*)psurface, count);
				return ret;
			}
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurfacePtrPtr GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLSurfacePtrPtr ret = GetSurfaceImagesNative((SDLSurface*)surface, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurfacePtrPtr GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (int* pcount = &count)
				{
					SDLSurfacePtrPtr ret = GetSurfaceImagesNative((SDLSurface*)psurface, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Remove all alternate versions of a surface.<br/>
		/// This function removes a reference from all the alternative versions,<br/>
		/// destroying them if this is the last reference to them.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveSurfaceAlternateImages")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveSurfaceAlternateImagesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[403])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[403])((nint)surface);
			#endif
		}

		/// <summary>
		/// Remove all alternate versions of a surface.<br/>
		/// This function removes a reference from all the alternative versions,<br/>
		/// destroying them if this is the last reference to them.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveSurfaceAlternateImages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveSurfaceAlternateImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			RemoveSurfaceAlternateImagesNative((SDLSurface*)surface);
		}

		/// <summary>
		/// Remove all alternate versions of a surface.<br/>
		/// This function removes a reference from all the alternative versions,<br/>
		/// destroying them if this is the last reference to them.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveSurfaceAlternateImages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveSurfaceAlternateImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				RemoveSurfaceAlternateImagesNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces. The locking referred to by this function<br/>
		/// is making the pixels available for direct access, not<br/>
		/// thread-safe locking.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[404])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[404])((nint)surface);
			#endif
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces. The locking referred to by this function<br/>
		/// is making the pixels available for direct access, not<br/>
		/// thread-safe locking.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			byte ret = LockSurfaceNative((SDLSurface*)surface);
			return ret != 0;
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces. The locking referred to by this function<br/>
		/// is making the pixels available for direct access, not<br/>
		/// thread-safe locking.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = LockSurfaceNative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe. The locking referred to by<br/>
		/// this function is making the pixels available for direct<br/>
		/// access, not thread-safe locking.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[405])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[405])((nint)surface);
			#endif
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe. The locking referred to by<br/>
		/// this function is making the pixels available for direct<br/>
		/// access, not thread-safe locking.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			UnlockSurfaceNative((SDLSurface*)surface);
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe. The locking referred to by<br/>
		/// this function is making the pixels available for direct<br/>
		/// access, not thread-safe locking.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				UnlockSurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Load a BMP or PNG image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadSurfaceIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, SDLSurface*>)funcTable[406])(src, closeio);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, byte, nint>)funcTable[406])((nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load a BMP or PNG image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadSurfaceIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			SDLSurfacePtr ret = LoadSurfaceIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load a BMP or PNG image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadSurfaceIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurfacePtr ret = LoadSurfaceIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP or PNG image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadSurfaceNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSurface*>)funcTable[407])(file);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[407])((nint)file);
			#endif
		}

		/// <summary>
		/// Load a BMP or PNG image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadSurface([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLSurfacePtr ret = LoadSurfaceNative(file);
			return ret;
		}

		/// <summary>
		/// Load a BMP or PNG image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadSurface([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLSurfacePtr ret = LoadSurfaceNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP or PNG image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadSurface([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLSurfacePtr ret = LoadSurfaceNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP or PNG image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadSurface([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurfacePtr ret = LoadSurfaceNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadBMPIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, SDLSurface*>)funcTable[408])(src, closeio);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, byte, nint>)funcTable[408])((nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadBMPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			SDLSurfacePtr ret = LoadBMPIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadBMPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurfacePtr ret = LoadBMPIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadBMPNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSurface*>)funcTable[409])(file);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[409])((nint)file);
			#endif
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLSurfacePtr ret = LoadBMPNative(file);
			return ret;
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLSurfacePtr ret = LoadBMPNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLSurfacePtr ret = LoadBMPNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurfacePtr ret = LoadBMPNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveBMPIONative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLIOStream*, byte, byte>)funcTable[410])(surface, dst, closeio);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte>)funcTable[410])((nint)surface, (nint)dst, closeio);
			#endif
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			byte ret = SaveBMPIONative((SDLSurface*)surface, (SDLIOStream*)dst, closeio ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveBMPIONative((SDLSurface*)psurface, (SDLIOStream*)dst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				byte ret = SaveBMPIONative((SDLSurface*)surface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLIOStream* pdst = &dst)
				{
					byte ret = SaveBMPIONative((SDLSurface*)psurface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveBMPNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[411])(surface, file);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[411])((nint)surface, (nint)file);
			#endif
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			byte ret = SaveBMPNative((SDLSurface*)surface, file);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveBMPNative((SDLSurface*)psurface, file);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SaveBMPNative((SDLSurface*)surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SaveBMPNative((SDLSurface*)surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveBMPNative((SDLSurface*)surface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					byte ret = SaveBMPNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					byte ret = SaveBMPNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SaveBMPNative((SDLSurface*)psurface, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Load a PNG image from a seekable SDL data stream.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPNGIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, SDLSurface*>)funcTable[412])(src, closeio);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, byte, nint>)funcTable[412])((nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load a PNG image from a seekable SDL data stream.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadPNGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			SDLSurfacePtr ret = LoadPNGIONative((SDLIOStream*)src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load a PNG image from a seekable SDL data stream.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadPNGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurfacePtr ret = LoadPNGIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNG image from a file.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPNGNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSurface*>)funcTable[413])(file);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[413])((nint)file);
			#endif
		}

		/// <summary>
		/// Load a PNG image from a file.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadPNG([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLSurfacePtr ret = LoadPNGNative(file);
			return ret;
		}

		/// <summary>
		/// Load a PNG image from a file.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadPNG([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLSurfacePtr ret = LoadPNGNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNG image from a file.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadPNG([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLSurfacePtr ret = LoadPNGNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNG image from a file.<br/>
		/// This is intended as a convenience function for loading images from trusted<br/>
		/// sources. If you want to load arbitrary images you should use libpng or<br/>
		/// another image loading library designed with security in mind.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadPNG")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurfacePtr LoadPNG([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurfacePtr ret = LoadPNGNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SavePNGIONative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLIOStream*, byte, byte>)funcTable[414])(surface, dst, closeio);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte>)funcTable[414])((nint)surface, (nint)dst, closeio);
			#endif
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			byte ret = SavePNGIONative((SDLSurface*)surface, (SDLIOStream*)dst, closeio ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStreamPtr dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SavePNGIONative((SDLSurface*)psurface, (SDLIOStream*)dst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				byte ret = SavePNGIONative((SDLSurface*)surface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLIOStream* pdst = &dst)
				{
					byte ret = SavePNGIONative((SDLSurface*)psurface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SavePNGNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[415])(surface, file);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[415])((nint)surface, (nint)file);
			#endif
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			byte ret = SavePNGNative((SDLSurface*)surface, file);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SavePNGNative((SDLSurface*)psurface, file);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SavePNGNative((SDLSurface*)surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SavePNGNative((SDLSurface*)surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SavePNGNative((SDLSurface*)surface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] in byte file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					byte ret = SavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					byte ret = SavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file in PNG format.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SavePNGNative((SDLSurface*)psurface, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[416])(surface, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[416])((nint)surface, enabled);
			#endif
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			byte ret = SetSurfaceRLENative((SDLSurface*)surface, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceRLENative((SDLSurface*)psurface, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SurfaceHasRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[417])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[417])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			byte ret = SurfaceHasRLENative((SDLSurface*)surface);
			return ret != 0;
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SurfaceHasRLENative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, uint, byte>)funcTable[418])(surface, enabled, key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, uint, byte>)funcTable[418])((nint)surface, enabled, key);
			#endif
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			byte ret = SetSurfaceColorKeyNative((SDLSurface*)surface, enabled ? (byte)1 : (byte)0, key);
			return ret != 0;
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceColorKeyNative((SDLSurface*)psurface, enabled ? (byte)1 : (byte)0, key);
				return ret != 0;
			}
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SurfaceHasColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[419])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[419])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface)
		{
			byte ret = SurfaceHasColorKeyNative((SDLSurface*)surface);
			return ret != 0;
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SurfaceHasColorKeyNative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint*, byte>)funcTable[420])(surface, key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[420])((nint)surface, (nint)key);
			#endif
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* key)
		{
			byte ret = GetSurfaceColorKeyNative((SDLSurface*)surface, key);
			return ret != 0;
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceColorKeyNative((SDLSurface*)psurface, key);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint key)
		{
			fixed (uint* pkey = &key)
			{
				byte ret = GetSurfaceColorKeyNative((SDLSurface*)surface, (uint*)pkey);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (uint* pkey = &key)
				{
					byte ret = GetSurfaceColorKeyNative((SDLSurface*)psurface, (uint*)pkey);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte, byte, byte>)funcTable[421])(surface, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte>)funcTable[421])((nint)surface, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			byte ret = SetSurfaceColorModNative((SDLSurface*)surface, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte*, byte*, byte>)funcTable[422])(surface, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[422])((nint)surface, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			byte ret = GetSurfaceColorModNative((SDLSurface*)surface, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				byte ret = GetSurfaceColorModNative((SDLSurface*)surface, (byte*)pr, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				byte ret = GetSurfaceColorModNative((SDLSurface*)surface, r, (byte*)pg, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)surface, (byte*)pr, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, b);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				byte ret = GetSurfaceColorModNative((SDLSurface*)surface, r, g, (byte*)pb);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)surface, (byte*)pr, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)surface, r, (byte*)pg, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)surface, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[423])(surface, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[423])((nint)surface, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			byte ret = SetSurfaceAlphaModNative((SDLSurface*)surface, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[424])(surface, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[424])((nint)surface, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* alpha)
		{
			byte ret = GetSurfaceAlphaModNative((SDLSurface*)surface, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				byte ret = GetSurfaceAlphaModNative((SDLSurface*)surface, (byte*)palpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* palpha = &alpha)
				{
					byte ret = GetSurfaceAlphaModNative((SDLSurface*)psurface, (byte*)palpha);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] uint blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint, byte>)funcTable[425])(surface, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, byte>)funcTable[425])((nint)surface, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] uint blendMode)
		{
			byte ret = SetSurfaceBlendModeNative((SDLSurface*)surface, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// This function can be called on different threads with<br/>
		/// different surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] uint blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] uint* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint*, byte>)funcTable[426])(surface, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[426])((nint)surface, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] uint* blendMode)
		{
			byte ret = GetSurfaceBlendModeNative((SDLSurface*)surface, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] uint* blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] ref uint blendMode)
		{
			fixed (uint* pblendMode = &blendMode)
			{
				byte ret = GetSurfaceBlendModeNative((SDLSurface*)surface, (uint*)pblendMode);
				return ret != 0;
			}
		}
	}
}
