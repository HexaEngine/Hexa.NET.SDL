// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				void* ret = GetClipboardDataNative(mimeType, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ref byte mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			fixed (byte* pmimeType = &mimeType)
			{
				fixed (nuint* psize = &size)
				{
					void* ret = GetClipboardDataNative((byte*)pmimeType, (nuint*)psize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			fixed (byte* pmimeType = mimeType)
			{
				fixed (nuint* psize = &size)
				{
					void* ret = GetClipboardDataNative((byte*)pmimeType, (nuint*)psize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the data from clipboard for a given mime type.<br/>
		/// The size of text data does not include the terminator, but the text is<br/>
		/// guaranteed to be null terminated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] string mimeType, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mimeType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mimeType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mimeType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* psize = &size)
			{
				void* ret = GetClipboardDataNative(pStr0, (nuint*)psize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasClipboardDataNative([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[541])(mimeType);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[541])((nint)mimeType);
			#endif
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] byte* mimeType)
		{
			int ret = HasClipboardDataNative(mimeType);
			return ret;
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ref byte mimeType)
		{
			fixed (byte* pmimeType = &mimeType)
			{
				int ret = HasClipboardDataNative((byte*)pmimeType);
				return ret;
			}
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mimeType)
		{
			fixed (byte* pmimeType = mimeType)
			{
				int ret = HasClipboardDataNative((byte*)pmimeType);
				return ret;
			}
		}

		/// <summary>
		/// Query whether there is data in the clipboard for the provided mime type.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardData")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasClipboardData([NativeName(NativeNameType.Param, "mime_type")] [NativeName(NativeNameType.Type, "char const *")] string mimeType)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mimeType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mimeType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mimeType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = HasClipboardDataNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the number of CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCPUCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[542])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[542])();
			#endif
		}

		/// <summary>
		/// Get the number of CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCPUCount()
		{
			int ret = GetCPUCountNative();
			return ret;
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCacheLineSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCPUCacheLineSizeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[543])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[543])();
			#endif
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCacheLineSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCPUCacheLineSize()
		{
			int ret = GetCPUCacheLineSizeNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAltiVec")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasAltiVecNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[544])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[544])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAltiVec")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasAltiVec()
		{
			int ret = HasAltiVecNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMMX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasMMXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[545])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[545])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMMX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasMMX()
		{
			int ret = HasMMXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasSSENative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[546])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[546])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasSSE()
		{
			int ret = HasSSENative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasSSE2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[547])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[547])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasSSE2()
		{
			int ret = HasSSE2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE3")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasSSE3Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[548])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[548])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE3")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasSSE3()
		{
			int ret = HasSSE3Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE41")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasSSE41Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[549])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[549])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE41")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasSSE41()
		{
			int ret = HasSSE41Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE42")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasSSE42Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[550])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[550])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE42")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasSSE42()
		{
			int ret = HasSSE42Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasAVXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[551])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[551])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasAVX()
		{
			int ret = HasAVXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasAVX2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[552])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[552])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasAVX2()
		{
			int ret = HasAVX2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX512F")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasAVX512FNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[553])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[553])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX512F")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasAVX512F()
		{
			int ret = HasAVX512FNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
		/// This is different from ARM NEON, which is a different instruction set.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasARMSIMD")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasARMSIMDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[554])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[554])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
		/// This is different from ARM NEON, which is a different instruction set.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasARMSIMD")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasARMSIMD()
		{
			int ret = HasARMSIMDNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasNEON")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasNEONNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[555])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[555])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasNEON")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasNEON()
		{
			int ret = HasNEONNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasLSX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasLSXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[556])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[556])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasLSX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasLSX()
		{
			int ret = HasLSXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasLASX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasLASXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[557])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[557])();
			#endif
		}

		/// <summary>
		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasLASX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasLASX()
		{
			int ret = HasLASXNative();
			return ret;
		}

		/// <summary>
		/// Get the amount of RAM configured in the system.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSystemRAM")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSystemRAMNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[558])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[558])();
			#endif
		}

		/// <summary>
		/// Get the amount of RAM configured in the system.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSystemRAM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSystemRAM()
		{
			int ret = GetSystemRAMNative();
			return ret;
		}

		/// <summary>
		/// Report the alignment this system needs for SIMD allocations.<br/>
		/// This will return the minimum number of bytes to which a pointer must be<br/>
		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
		/// example, if the machine supports SSE only, it will return 16, but if it<br/>
		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
		/// Plan accordingly.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSIMDAlignment")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint GetSIMDAlignmentNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint>)funcTable[559])();
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nuint>)funcTable[559])();
			#endif
		}

		/// <summary>
		/// Report the alignment this system needs for SIMD allocations.<br/>
		/// This will return the minimum number of bytes to which a pointer must be<br/>
		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
		/// example, if the machine supports SSE only, it will return 16, but if it<br/>
		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
		/// Plan accordingly.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSIMDAlignment")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint GetSIMDAlignment()
		{
			nuint ret = GetSIMDAlignmentNative();
			return ret;
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFileDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, int, void>)funcTable[560])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, filters, nfilters, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, int, void>)funcTable[560])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, defaultLocation, allowMany);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, defaultLocation, allowMany);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation, allowMany);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation, allowMany);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, pStr0, allowMany);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation, allowMany);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation, allowMany);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, pStr0, allowMany);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowSaveFileDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, void>)funcTable[561])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, filters, nfilters, defaultLocation);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, void>)funcTable[561])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, defaultLocation);
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFolderDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, byte*, int, void>)funcTable[562])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, void>)funcTable[562])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			ShowOpenFolderDialogNative(callback, userdata, window, defaultLocation, allowMany);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, defaultLocation, allowMany);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, window, (byte*)pdefaultLocation, allowMany);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, window, (byte*)pdefaultLocation, allowMany);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFolderDialogNative(callback, userdata, window, pStr0, allowMany);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "SDL_bool")] int allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, pStr0, allowMany);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GUIDToStringNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, byte*, int, void>)funcTable[563])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, int, void>)funcTable[563])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			GUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] ref byte pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				GUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] ref string pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid StringToGUIDNative([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SdlGuid>)funcTable[564])(pchGUID);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[564])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] byte* pchGUID)
		{
			SdlGuid ret = StringToGUIDNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdlGuid ret = StringToGUIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetPowerInfoNative([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, SDLPowerState>)funcTable[565])(seconds, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[565])((nint)seconds, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			SDLPowerState ret = GetPowerInfoNative(seconds, percent);
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			fixed (int* pseconds = &seconds)
			{
				SDLPowerState ret = GetPowerInfoNative((int*)pseconds, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetPowerInfoNative(seconds, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (int* pseconds = &seconds)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetPowerInfoNative((int*)pseconds, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetSensorsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[566])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[566])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		public static int* GetSensors([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = GetSensorsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		public static int* GetSensors([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetSensorsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[567])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[567])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			byte* ret = GetSensorNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[568])(instanceId);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[568])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensorType ret = GetSensorTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableTypeForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[569])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[569])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableTypeForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			int ret = GetSensorNonPortableTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* OpenSensorNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[570])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[570])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		public static SDLSensor* OpenSensor([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensor* ret = OpenSensorNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* GetSensorFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[571])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[571])(instanceId);
			#endif
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		public static SDLSensor* GetSensorFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensor* ret = GetSensorFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSensorPropertiesNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, uint>)funcTable[572])(sensor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[572])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSensorProperties([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			uint ret = GetSensorPropertiesNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSensorProperties([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				uint ret = GetSensorPropertiesNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, byte*>)funcTable[573])(sensor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[573])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			byte* ret = GetSensorNameNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameNative(sensor));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte* ret = GetSensorNameNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				string ret = Utils.DecodeStringUTF8(GetSensorNameNative((SDLSensor*)psensor));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, SDLSensorType>)funcTable[574])(sensor);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<nint, SDLSensorType>)funcTable[574])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			SDLSensorType ret = GetSensorTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorType ret = GetSensorTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[575])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[575])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			int ret = GetSensorNonPortableTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorNonPortableTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorIDNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[576])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[576])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int GetSensorID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			int ret = GetSensorIDNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int GetSensorID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorIDNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorDataNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, float*, int, int>)funcTable[577])(sensor, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[577])((nint)sensor, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = GetSensorDataNative(sensor, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorDataNative((SDLSensor*)psensor, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = GetSensorDataNative(sensor, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					int ret = GetSensorDataNative((SDLSensor*)psensor, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseSensorNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSensor*, void>)funcTable[578])(sensor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[578])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseSensor([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			CloseSensorNative(sensor);
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseSensor([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				CloseSensorNative((SDLSensor*)psensor);
			}
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[579])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[579])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateSensors()
		{
			UpdateSensorsNative();
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[580])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[580])();
			#endif
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockJoysticks()
		{
			LockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[581])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[581])();
			#endif
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockJoysticks()
		{
			UnlockJoysticksNative();
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasJoystickNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[582])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[582])();
			#endif
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasJoystick()
		{
			int ret = HasJoystickNative();
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetJoysticksNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[583])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[583])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		public static int* GetJoysticks([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = GetJoysticksNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		public static int* GetJoysticks([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetJoysticksNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[584])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[584])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte* ret = GetJoystickNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickPathForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[585])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[585])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickPathForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte* ret = GetJoystickPathForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickPathForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickPathForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndexForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickPlayerIndexForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[586])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[586])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndexForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetJoystickPlayerIndexForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			int ret = GetJoystickPlayerIndexForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDForID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetJoystickGUIDForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[587])(instanceId);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[587])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDForID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid GetJoystickGUIDForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SdlGuid ret = GetJoystickGUIDForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendorForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickVendorForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[588])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[588])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendorForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickVendorForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickVendorForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[589])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[589])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickProductForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersionForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductVersionForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[590])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[590])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersionForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductVersionForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickProductVersionForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType GetJoystickTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[591])(instanceId);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[591])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType GetJoystickTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystickType ret = GetJoystickTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* OpenJoystickNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[592])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[592])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystick* OpenJoystick([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystick* ret = OpenJoystickNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetJoystickFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[593])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[593])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystick* GetJoystickFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystick* ret = GetJoystickFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetJoystickFromPlayerIndexNative([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[594])(playerIndex);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[594])(playerIndex);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystick* GetJoystickFromPlayerIndex([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLJoystick* ret = GetJoystickFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AttachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AttachVirtualJoystickNative([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "SDL_VirtualJoystickDesc const *")] SDLVirtualJoystickDesc* desc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLVirtualJoystickDesc*, int>)funcTable[595])(desc);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[595])((nint)desc);
			#endif
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AttachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int AttachVirtualJoystick([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "SDL_VirtualJoystickDesc const *")] SDLVirtualJoystickDesc* desc)
		{
			int ret = AttachVirtualJoystickNative(desc);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AttachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int AttachVirtualJoystick([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "SDL_VirtualJoystickDesc const *")] ref SDLVirtualJoystickDesc desc)
		{
			fixed (SDLVirtualJoystickDesc* pdesc = &desc)
			{
				int ret = AttachVirtualJoystickNative((SDLVirtualJoystickDesc*)pdesc);
				return ret;
			}
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DetachVirtualJoystickNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[596])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[596])(instanceId);
			#endif
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DetachVirtualJoystick([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			int ret = DetachVirtualJoystickNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Query whether or not a joystick is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickVirtual")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsJoystickVirtualNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[597])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[597])(instanceId);
			#endif
		}

		/// <summary>
		/// Query whether or not a joystick is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickVirtual")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int IsJoystickVirtual([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			int ret = IsJoystickVirtualNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetJoystickVirtualAxisNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, int>)funcTable[598])(joystick, axis, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, short, int>)funcTable[598])((nint)joystick, axis, value);
			#endif
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			int ret = SetJoystickVirtualAxisNative(joystick, axis, value);
			return ret;
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SetJoystickVirtualAxisNative((SDLJoystick*)pjoystick, axis, value);
				return ret;
			}
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetJoystickVirtualBallNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "xrel")] [NativeName(NativeNameType.Type, "Sint16")] short xrel, [NativeName(NativeNameType.Param, "yrel")] [NativeName(NativeNameType.Type, "Sint16")] short yrel)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, short, int>)funcTable[599])(joystick, ball, xrel, yrel);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, short, short, int>)funcTable[599])((nint)joystick, ball, xrel, yrel);
			#endif
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "xrel")] [NativeName(NativeNameType.Type, "Sint16")] short xrel, [NativeName(NativeNameType.Param, "yrel")] [NativeName(NativeNameType.Type, "Sint16")] short yrel)
		{
			int ret = SetJoystickVirtualBallNative(joystick, ball, xrel, yrel);
			return ret;
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "xrel")] [NativeName(NativeNameType.Type, "Sint16")] short xrel, [NativeName(NativeNameType.Param, "yrel")] [NativeName(NativeNameType.Type, "Sint16")] short yrel)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SetJoystickVirtualBallNative((SDLJoystick*)pjoystick, ball, xrel, yrel);
				return ret;
			}
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetJoystickVirtualButtonNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)funcTable[600])(joystick, button, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, byte, int>)funcTable[600])((nint)joystick, button, value);
			#endif
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			int ret = SetJoystickVirtualButtonNative(joystick, button, value);
			return ret;
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SetJoystickVirtualButtonNative((SDLJoystick*)pjoystick, button, value);
				return ret;
			}
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetJoystickVirtualHatNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)funcTable[601])(joystick, hat, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, byte, int>)funcTable[601])((nint)joystick, hat, value);
			#endif
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			int ret = SetJoystickVirtualHatNative(joystick, hat, value);
			return ret;
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SetJoystickVirtualHatNative((SDLJoystick*)pjoystick, hat, value);
				return ret;
			}
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualTouchpad")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetJoystickVirtualTouchpadNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8")] byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float")] float pressure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, int, byte, float, float, float, int>)funcTable[602])(joystick, touchpad, finger, state, x, y, pressure);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, byte, float, float, float, int>)funcTable[602])((nint)joystick, touchpad, finger, state, x, y, pressure);
			#endif
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualTouchpad")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualTouchpad([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8")] byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float")] float pressure)
		{
			int ret = SetJoystickVirtualTouchpadNative(joystick, touchpad, finger, state, x, y, pressure);
			return ret;
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualTouchpad")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickVirtualTouchpad([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8")] byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float")] float pressure)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SetJoystickVirtualTouchpadNative((SDLJoystick*)pjoystick, touchpad, finger, state, x, y, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SendJoystickVirtualSensorDataNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLSensorType, ulong, float*, int, int>)funcTable[603])(joystick, type, sensorTimestamp, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, ulong, nint, int, int>)funcTable[603])((nint)joystick, type, sensorTimestamp, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = SendJoystickVirtualSensorDataNative(joystick, type, sensorTimestamp, data, numValues);
			return ret;
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SendJoystickVirtualSensorDataNative((SDLJoystick*)pjoystick, type, sensorTimestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SendJoystickVirtualSensorDataNative(joystick, type, sensorTimestamp, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (float* pdata = &data)
				{
					int ret = SendJoystickVirtualSensorDataNative((SDLJoystick*)pjoystick, type, sensorTimestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetJoystickPropertiesNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, uint>)funcTable[604])(joystick);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[604])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetJoystickProperties([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			uint ret = GetJoystickPropertiesNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetJoystickProperties([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				uint ret = GetJoystickPropertiesNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[605])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[605])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte* ret = GetJoystickNameNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickNameNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickNameNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickPathNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[606])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[606])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte* ret = GetJoystickPathNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickPathNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickPathNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickPathNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[607])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[607])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			int ret = GetJoystickPlayerIndexNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetJoystickPlayerIndexNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetJoystickPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, int>)funcTable[608])(joystick, playerIndex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[608])((nint)joystick, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			int ret = SetJoystickPlayerIndexNative(joystick, playerIndex);
			return ret;
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SetJoystickPlayerIndexNative((SDLJoystick*)pjoystick, playerIndex);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetJoystickGUIDNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SdlGuid>)funcTable[609])(joystick);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[609])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid GetJoystickGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			SdlGuid ret = GetJoystickGUIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid GetJoystickGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SdlGuid ret = GetJoystickGUIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickVendorNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[610])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[610])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickVendorNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickVendorNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[611])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[611])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickProductNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickProductNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[612])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[612])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickProductVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickProductVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickFirmwareVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[613])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[613])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickFirmwareVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickFirmwareVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickSerialNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[614])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[614])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickSerial([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte* ret = GetJoystickSerialNative(joystick);
			return ret;
		}
	}
}
