// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowAspectRatioNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float*, float*, byte>)funcTable[514])(window, minAspect, maxAspect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[514])((nint)window, (nint)minAspect, (nint)maxAspect);
			#endif
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			byte ret = GetWindowAspectRatioNative(window, minAspect, maxAspect);
			return ret != 0;
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, minAspect, maxAspect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			fixed (float* pminAspect = &minAspect)
			{
				byte ret = GetWindowAspectRatioNative(window, (float*)pminAspect, maxAspect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] float* maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pminAspect = &minAspect)
				{
					byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, (float*)pminAspect, maxAspect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (float* pmaxAspect = &maxAspect)
			{
				byte ret = GetWindowAspectRatioNative(window, minAspect, (float*)pmaxAspect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] float* minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pmaxAspect = &maxAspect)
				{
					byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, minAspect, (float*)pmaxAspect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (float* pminAspect = &minAspect)
			{
				fixed (float* pmaxAspect = &maxAspect)
				{
					byte ret = GetWindowAspectRatioNative(window, (float*)pminAspect, (float*)pmaxAspect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowAspectRatio")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowAspectRatio([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float minAspect, [NativeName(NativeNameType.Param, "max_aspect")] [NativeName(NativeNameType.Type, "float *")] ref float maxAspect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pminAspect = &minAspect)
				{
					fixed (float* pmaxAspect = &maxAspect)
					{
						byte ret = GetWindowAspectRatioNative((SDLWindow*)pwindow, (float*)pminAspect, (float*)pmaxAspect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowBordersSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, int*, int*, byte>)funcTable[515])(window, top, left, bottom, right);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[515])((nint)window, (nint)top, (nint)left, (nint)bottom, (nint)right);
			#endif
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			byte ret = GetWindowBordersSizeNative(window, top, left, bottom, right);
			return ret != 0;
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				byte ret = GetWindowBordersSizeNative(window, (int*)ptop, left, bottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* pleft = &left)
			{
				byte ret = GetWindowBordersSizeNative(window, top, (int*)pleft, bottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					byte ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, bottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* pbottom = &bottom)
			{
				byte ret = GetWindowBordersSizeNative(window, top, left, (int*)pbottom, right);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, right);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pright = &right)
			{
				byte ret = GetWindowBordersSizeNative(window, top, left, bottom, (int*)pright);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative(window, (int*)ptop, left, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative(window, top, (int*)pleft, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pbottom = &bottom)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative(window, top, left, (int*)pbottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int *")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int *")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int *")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int *")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							fixed (int* pright = &right)
							{
								byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowSizeInPixelsNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[516])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[516])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			byte ret = GetWindowSizeInPixelsNative(window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowSizeInPixelsNative(window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowSizeInPixelsNative(window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowSizeInPixelsNative(window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMinimumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[517])(window, minW, minH);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[517])((nint)window, minW, minH);
			#endif
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			byte ret = SetWindowMinimumSizeNative(window, minW, minH);
			return ret != 0;
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMinimumSizeNative((SDLWindow*)pwindow, minW, minH);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMinimumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[518])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[518])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			byte ret = GetWindowMinimumSizeNative(window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowMinimumSizeNative(window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowMinimumSizeNative(window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMinimumSizeNative(window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMaximumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[519])(window, maxW, maxH);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[519])((nint)window, maxW, maxH);
			#endif
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			byte ret = SetWindowMaximumSizeNative(window, maxW, maxH);
			return ret != 0;
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMaximumSizeNative((SDLWindow*)pwindow, maxW, maxH);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMaximumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[520])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[520])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			byte ret = GetWindowMaximumSizeNative(window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowMaximumSizeNative(window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowMaximumSizeNative(window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMaximumSizeNative(window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int *")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int *")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowBorderedNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "bool")] byte bordered)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[521])(window, bordered);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[521])((nint)window, bordered);
			#endif
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowBordered([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "bool")] bool bordered)
		{
			byte ret = SetWindowBorderedNative(window, bordered ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowBordered([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "bool")] bool bordered)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowBorderedNative((SDLWindow*)pwindow, bordered ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowResizableNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "bool")] byte resizable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[522])(window, resizable);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[522])((nint)window, resizable);
			#endif
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowResizable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "bool")] bool resizable)
		{
			byte ret = SetWindowResizableNative(window, resizable ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowResizable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "bool")] bool resizable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowResizableNative((SDLWindow*)pwindow, resizable ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowAlwaysOnTopNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "bool")] byte onTop)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[523])(window, onTop);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[523])((nint)window, onTop);
			#endif
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowAlwaysOnTop([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "bool")] bool onTop)
		{
			byte ret = SetWindowAlwaysOnTopNative(window, onTop ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowAlwaysOnTop([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "bool")] bool onTop)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowAlwaysOnTopNative((SDLWindow*)pwindow, onTop ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[524])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[524])((nint)window);
			#endif
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = ShowWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ShowWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HideWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[525])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[525])((nint)window);
			#endif
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HideWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = HideWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HideWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = HideWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RaiseWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[526])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[526])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RaiseWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = RaiseWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RaiseWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = RaiseWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MaximizeWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[527])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[527])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MaximizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = MaximizeWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MaximizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = MaximizeWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MinimizeWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[528])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[528])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MinimizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = MinimizeWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool MinimizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = MinimizeWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RestoreWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[529])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[529])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RestoreWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = RestoreWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RestoreWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = RestoreWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowFullscreenNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "fullscreen")] [NativeName(NativeNameType.Type, "bool")] byte fullscreen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[530])(window, fullscreen);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[530])((nint)window, fullscreen);
			#endif
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFullscreen([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "fullscreen")] [NativeName(NativeNameType.Type, "bool")] bool fullscreen)
		{
			byte ret = SetWindowFullscreenNative(window, fullscreen ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFullscreen([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "fullscreen")] [NativeName(NativeNameType.Type, "bool")] bool fullscreen)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowFullscreenNative((SDLWindow*)pwindow, fullscreen ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SyncWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SyncWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[531])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[531])((nint)window);
			#endif
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SyncWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SyncWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = SyncWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SyncWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SyncWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SyncWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowHasSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowHasSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[532])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[532])((nint)window);
			#endif
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowHasSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowHasSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = WindowHasSurfaceNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowHasSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowHasSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowHasSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* GetWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*>)funcTable[533])(window);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[533])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* GetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			SDLSurface* ret = GetWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* GetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSurface* ret = GetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowSurfaceVSyncNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, byte>)funcTable[534])(window, vsync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[534])((nint)window, vsync);
			#endif
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			byte ret = SetWindowSurfaceVSyncNative(window, vsync);
			return ret != 0;
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowSurfaceVSyncNative((SDLWindow*)pwindow, vsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowSurfaceVSyncNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] int* vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, byte>)funcTable[535])(window, vsync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[535])((nint)window, (nint)vsync);
			#endif
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] int* vsync)
		{
			byte ret = GetWindowSurfaceVSyncNative(window, vsync);
			return ret != 0;
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] int* vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)pwindow, vsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] ref int vsync)
		{
			fixed (int* pvsync = &vsync)
			{
				byte ret = GetWindowSurfaceVSyncNative(window, (int*)pvsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurfaceVSync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowSurfaceVSync([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int *")] ref int vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pvsync = &vsync)
				{
					byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)pwindow, (int*)pvsync);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[536])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[536])((nint)window);
			#endif
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = UpdateWindowSurfaceNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = UpdateWindowSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateWindowSurfaceRectsNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int, byte>)funcTable[537])(window, rects, numrects);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[537])((nint)window, (nint)rects, numrects);
			#endif
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			byte ret = UpdateWindowSurfaceRectsNative(window, rects, numrects);
			return ret != 0;
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, rects, numrects);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLRect* prects = &rects)
			{
				byte ret = UpdateWindowSurfaceRectsNative(window, (SDLRect*)prects, numrects);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prects = &rects)
				{
					byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)prects, numrects);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DestroyWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[538])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[538])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DestroyWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = DestroyWindowSurfaceNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DestroyWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = DestroyWindowSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowKeyboardGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] byte grabbed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[539])(window, grabbed);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[539])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			byte ret = SetWindowKeyboardGrabNative(window, grabbed ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowKeyboardGrabNative((SDLWindow*)pwindow, grabbed ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMouseGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] byte grabbed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[540])(window, grabbed);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[540])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			byte ret = SetWindowMouseGrabNative(window, grabbed ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "bool")] bool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMouseGrabNative((SDLWindow*)pwindow, grabbed ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowKeyboardGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[541])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[541])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = GetWindowKeyboardGrabNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowKeyboardGrabNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMouseGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[542])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[542])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = GetWindowMouseGrabNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMouseGrabNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGrabbedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetGrabbedWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[543])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[543])();
			#endif
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGrabbedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindow* GetGrabbedWindow()
		{
			SDLWindow* ret = GetGrabbedWindowNative();
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMouseRectNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, byte>)funcTable[544])(window, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[544])((nint)window, (nint)rect);
			#endif
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect)
		{
			byte ret = SetWindowMouseRectNative(window, rect);
			return ret != 0;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMouseRectNative((SDLWindow*)pwindow, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetWindowMouseRectNative(window, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "SDL_Rect const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRect* GetWindowMouseRectNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*>)funcTable[545])(window);
			#else
			return (SDLRect*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[545])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "SDL_Rect const *")]
		public static SDLRect* GetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			SDLRect* ret = GetWindowMouseRectNative(window);
			return ret;
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "SDL_Rect const *")]
		public static SDLRect* GetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRect* ret = GetWindowMouseRectNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowOpacityNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, byte>)funcTable[546])(window, opacity);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, byte>)funcTable[546])((nint)window, opacity);
			#endif
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			byte ret = SetWindowOpacityNative(window, opacity);
			return ret != 0;
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowOpacityNative((SDLWindow*)pwindow, opacity);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowOpacityNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float>)funcTable[547])(window);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[547])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			float ret = GetWindowOpacityNative(window);
			return ret;
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				float ret = GetWindowOpacityNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModalFor() to cancel the modal status<br/>
		/// before attempting to change the parent.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowParentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLWindow*, byte>)funcTable[548])(window, parent);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[548])((nint)window, (nint)parent);
			#endif
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModalFor() to cancel the modal status<br/>
		/// before attempting to change the parent.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* parent)
		{
			byte ret = SetWindowParentNative(window, parent);
			return ret != 0;
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModalFor() to cancel the modal status<br/>
		/// before attempting to change the parent.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* parent)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowParentNative((SDLWindow*)pwindow, parent);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModalFor() to cancel the modal status<br/>
		/// before attempting to change the parent.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow parent)
		{
			fixed (SDLWindow* pparent = &parent)
			{
				byte ret = SetWindowParentNative(window, (SDLWindow*)pparent);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModalFor() to cancel the modal status<br/>
		/// before attempting to change the parent.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowParent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowParent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "parent")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow parent)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindow* pparent = &parent)
				{
					byte ret = SetWindowParentNative((SDLWindow*)pwindow, (SDLWindow*)pparent);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowModal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowModalNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "modal")] [NativeName(NativeNameType.Type, "bool")] byte modal)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[549])(window, modal);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[549])((nint)window, modal);
			#endif
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowModal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowModal([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "modal")] [NativeName(NativeNameType.Type, "bool")] bool modal)
		{
			byte ret = SetWindowModalNative(window, modal ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowModal")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowModal([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "modal")] [NativeName(NativeNameType.Type, "bool")] bool modal)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowModalNative((SDLWindow*)pwindow, modal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFocusable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowFocusableNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "focusable")] [NativeName(NativeNameType.Type, "bool")] byte focusable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[550])(window, focusable);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[550])((nint)window, focusable);
			#endif
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFocusable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFocusable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "focusable")] [NativeName(NativeNameType.Type, "bool")] bool focusable)
		{
			byte ret = SetWindowFocusableNative(window, focusable ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFocusable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowFocusable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "focusable")] [NativeName(NativeNameType.Type, "bool")] bool focusable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowFocusableNative((SDLWindow*)pwindow, focusable ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindowSystemMenu")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowWindowSystemMenuNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[551])(window, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[551])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindowSystemMenu")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindowSystemMenu([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			byte ret = ShowWindowSystemMenuNative(window, x, y);
			return ret != 0;
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindowSystemMenu")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShowWindowSystemMenu([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ShowWindowSystemMenuNative((SDLWindow*)pwindow, x, y);
				return ret != 0;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowHitTestNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>, void*, byte>)funcTable[552])(window, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), callbackData);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[552])((nint)window, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)callbackData);
			#endif
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			byte ret = SetWindowHitTestNative(window, callback, callbackData);
			return ret != 0;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void *")] void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowHitTestNative((SDLWindow*)pwindow, callback, callbackData);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for setting<br/>
		/// the alpha channel of the window yourself.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowShapeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*, byte>)funcTable[553])(window, shape);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[553])((nint)window, (nint)shape);
			#endif
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for setting<br/>
		/// the alpha channel of the window yourself.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* shape)
		{
			byte ret = SetWindowShapeNative(window, shape);
			return ret != 0;
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for setting<br/>
		/// the alpha channel of the window yourself.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* shape)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowShapeNative((SDLWindow*)pwindow, shape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for setting<br/>
		/// the alpha channel of the window yourself.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface shape)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				byte ret = SetWindowShapeNative(window, (SDLSurface*)pshape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for setting<br/>
		/// the alpha channel of the window yourself.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface shape)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					byte ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FlashWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLFlashOperation, byte>)funcTable[554])(window, operation);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLFlashOperation, byte>)funcTable[554])((nint)window, operation);
			#endif
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			byte ret = FlashWindowNative(window, operation);
			return ret != 0;
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = FlashWindowNative((SDLWindow*)pwindow, operation);
				return ret != 0;
			}
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any popups or modal windows owned by the window will be recursively<br/>
		/// destroyed as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[555])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[555])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any popups or modal windows owned by the window will be recursively<br/>
		/// destroyed as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			DestroyWindowNative(window);
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any popups or modal windows owned by the window will be recursively<br/>
		/// destroyed as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				DestroyWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ScreenSaverEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[556])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[556])();
			#endif
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ScreenSaverEnabled()
		{
			byte ret = ScreenSaverEnabledNative();
			return ret != 0;
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EnableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[557])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[557])();
			#endif
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnableScreenSaver()
		{
			byte ret = EnableScreenSaverNative();
			return ret != 0;
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default, but this may by changed by<br/>
		/// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DisableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[558])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[558])();
			#endif
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default, but this may by changed by<br/>
		/// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DisableScreenSaver()
		{
			byte ret = DisableScreenSaverNative();
			return ret != 0;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLLoadLibraryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[559])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[559])((nint)path);
			#endif
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			byte ret = GLLoadLibraryNative(path);
			return ret != 0;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = GLLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				byte ret = GLLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GLLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> GLGetProcAddressNative([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[560])(proc);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[560])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			delegate*<void> ret = GLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] ref byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				delegate*<void> ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				delegate*<void> ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> GLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = GLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> EGLGetProcAddressNative([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[561])(proc);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[561])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] byte* proc)
		{
			delegate*<void> ret = EGLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] ref byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				delegate*<void> ret = EGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				delegate*<void> ret = EGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> EGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "char const *")] string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = EGLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLUnloadLibraryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[562])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[562])();
			#endif
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GLUnloadLibrary()
		{
			GLUnloadLibraryNative();
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLExtensionSupportedNative([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[563])(extension);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[563])((nint)extension);
			#endif
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] byte* extension)
		{
			byte ret = GLExtensionSupportedNative(extension);
			return ret != 0;
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				byte ret = GLExtensionSupportedNative((byte*)pextension);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				byte ret = GLExtensionSupportedNative((byte*)pextension);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GLExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLResetAttributesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[564])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[564])();
			#endif
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GLResetAttributes()
		{
			GLResetAttributesNative();
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int, byte>)funcTable[565])(attr, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLattr, int, byte>)funcTable[565])(attr, value);
			#endif
		}
	}
}
