// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(byte* path, SDLAudioSpec* spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				byte ret = LoadWAVNative(path, spec, (byte**)paudioBuf, audioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ref byte path, SDLAudioSpec* spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative((byte*)ppath, spec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ReadOnlySpan<byte> path, SDLAudioSpec* spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative((byte*)ppath, spec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(string path, SDLAudioSpec* spec, ref byte* audioBuf, uint* audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** paudioBuf = &audioBuf)
			{
				byte ret = LoadWAVNative(pStr0, spec, (byte**)paudioBuf, audioLen);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(byte* path, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative(path, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ref byte path, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ReadOnlySpan<byte> path, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(string path, ref SDLAudioSpec spec, ref byte* audioBuf, uint* audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(byte* path, SDLAudioSpec* spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (uint* paudioLen = &audioLen)
			{
				byte ret = LoadWAVNative(path, spec, audioBuf, (uint*)paudioLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ref byte path, SDLAudioSpec* spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative((byte*)ppath, spec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ReadOnlySpan<byte> path, SDLAudioSpec* spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative((byte*)ppath, spec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(string path, SDLAudioSpec* spec, byte** audioBuf, ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* paudioLen = &audioLen)
			{
				byte ret = LoadWAVNative(pStr0, spec, audioBuf, (uint*)paudioLen);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(byte* path, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(path, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ref byte path, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ReadOnlySpan<byte> path, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(string path, ref SDLAudioSpec spec, byte** audioBuf, ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(byte* path, SDLAudioSpec* spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(path, spec, (byte**)paudioBuf, (uint*)paudioLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ref byte path, SDLAudioSpec* spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ReadOnlySpan<byte> path, SDLAudioSpec* spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative((byte*)ppath, spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(string path, SDLAudioSpec* spec, ref byte* audioBuf, ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					byte ret = LoadWAVNative(pStr0, spec, (byte**)paudioBuf, (uint*)paudioLen);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(byte* path, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative(path, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ref byte path, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(ReadOnlySpan<byte> path, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							byte ret = LoadWAVNative((byte*)ppath, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Loads a WAV from a file path.<br/>
		/// This is a convenience function that is effectively the same as:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns false if the .WAV file cannot be opened,<br/>
		/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
		/// for more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LoadWAV(string path, ref SDLAudioSpec spec, ref byte* audioBuf, ref uint audioLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						byte ret = LoadWAVNative(pStr0, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MixAudioNative(byte* dst, byte* src, SDLAudioFormat format, uint len, float volume)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLAudioFormat, uint, float, byte>)funcTable[362])(dst, src, format, len, volume);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLAudioFormat, uint, float, byte>)funcTable[362])((nint)dst, (nint)src, format, len, volume);
			#endif
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool MixAudio(byte* dst, byte* src, SDLAudioFormat format, uint len, float volume)
		{
			byte ret = MixAudioNative(dst, src, format, len, volume);
			return ret != 0;
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool MixAudio(ref byte dst, byte* src, SDLAudioFormat format, uint len, float volume)
		{
			fixed (byte* pdst = &dst)
			{
				byte ret = MixAudioNative((byte*)pdst, src, format, len, volume);
				return ret != 0;
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool MixAudio(byte* dst, ref byte src, SDLAudioFormat format, uint len, float volume)
		{
			fixed (byte* psrc = &src)
			{
				byte ret = MixAudioNative(dst, (byte*)psrc, format, len, volume);
				return ret != 0;
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
		/// stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool MixAudio(ref byte dst, ref byte src, SDLAudioFormat format, uint len, float volume)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					byte ret = MixAudioNative((byte*)pdst, (byte*)psrc, format, len, volume);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ConvertAudioSamplesNative(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, int* dstLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioSpec*, byte*, int, SDLAudioSpec*, byte**, int*, byte>)funcTable[363])(srcSpec, srcData, srcLen, dstSpec, dstData, dstLen);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, nint, nint, byte>)funcTable[363])((nint)srcSpec, (nint)srcData, srcLen, (nint)dstSpec, (nint)dstData, (nint)dstLen);
			#endif
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, int* dstLen)
		{
			byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, dstSpec, dstData, dstLen);
			return ret != 0;
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, dstSpec, dstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, dstSpec, dstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, dstSpec, dstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (byte** pdstData = &dstData)
			{
				byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, dstSpec, (byte**)pdstData, dstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, dstSpec, (byte**)pdstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (byte** pdstData = &dstData)
				{
					byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, dstSpec, (byte**)pdstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (byte** pdstData = &dstData)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, dstSpec, (byte**)pdstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, int* dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						fixed (byte** pdstData = &dstData)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, dstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (int* pdstLen = &dstLen)
			{
				byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, dstSpec, dstData, (int*)pdstLen);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, dstSpec, dstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, dstSpec, dstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, dstSpec, dstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, byte** dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, dstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (byte** pdstData = &dstData)
			{
				fixed (int* pdstLen = &dstLen)
				{
					byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, dstSpec, (byte**)pdstData, (int*)pdstLen);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, dstSpec, (byte**)pdstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (byte** pdstData = &dstData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, dstSpec, (byte**)pdstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, SDLAudioSpec* dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (byte** pdstData = &dstData)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, dstSpec, (byte**)pdstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* pdstSpec = &dstSpec)
			{
				fixed (byte** pdstData = &dstData)
				{
					fixed (int* pdstLen = &dstLen)
					{
						byte ret = ConvertAudioSamplesNative(srcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, byte* srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, srcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(SDLAudioSpec* srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (byte* psrcData = &srcData)
			{
				fixed (SDLAudioSpec* pdstSpec = &dstSpec)
				{
					fixed (byte** pdstData = &dstData)
					{
						fixed (int* pdstLen = &dstLen)
						{
							byte ret = ConvertAudioSamplesNative(srcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert some audio data of one format to another format.<br/>
		/// Please note that this function is for convenience, but should not be used<br/>
		/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
		/// boundaries. You should only use this function if you are converting audio<br/>
		/// data in its entirety in one call. If you want to convert audio in smaller<br/>
		/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
		/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
		/// use, so it's also less efficient than using one directly, if you need to<br/>
		/// convert multiple times.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ConvertAudioSamples(ref SDLAudioSpec srcSpec, ref byte srcData, int srcLen, ref SDLAudioSpec dstSpec, ref byte* dstData, ref int dstLen)
		{
			fixed (SDLAudioSpec* psrcSpec = &srcSpec)
			{
				fixed (byte* psrcData = &srcData)
				{
					fixed (SDLAudioSpec* pdstSpec = &dstSpec)
					{
						fixed (byte** pdstData = &dstData)
						{
							fixed (int* pdstLen = &dstLen)
							{
								byte ret = ConvertAudioSamplesNative((SDLAudioSpec*)psrcSpec, (byte*)psrcData, srcLen, (SDLAudioSpec*)pdstSpec, (byte**)pdstData, (int*)pdstLen);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the human readable name of an audio format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioFormatNameNative(SDLAudioFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioFormat, byte*>)funcTable[364])(format);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLAudioFormat, nint>)funcTable[364])(format);
			#endif
		}

		/// <summary>
		/// Get the human readable name of an audio format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* GetAudioFormatName(SDLAudioFormat format)
		{
			byte* ret = GetAudioFormatNameNative(format);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of an audio format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string GetAudioFormatNameS(SDLAudioFormat format)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioFormatNameNative(format));
			return ret;
		}

		/// <summary>
		/// Get the appropriate memset value for silencing an audio format.<br/>
		/// The value returned by this function can be used as the second argument to<br/>
		/// memset (or SDL_memset) to set an audio buffer in a specific format to<br/>
		/// silence.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSilenceValueForFormatNative(SDLAudioFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioFormat, int>)funcTable[365])(format);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLAudioFormat, int>)funcTable[365])(format);
			#endif
		}

		/// <summary>
		/// Get the appropriate memset value for silencing an audio format.<br/>
		/// The value returned by this function can be used as the second argument to<br/>
		/// memset (or SDL_memset) to set an audio buffer in a specific format to<br/>
		/// silence.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static int GetSilenceValueForFormat(SDLAudioFormat format)
		{
			int ret = GetSilenceValueForFormatNative(format);
			return ret;
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer.<br/>
		/// All renderers support the four blend modes listed in the SDL_BlendMode<br/>
		/// enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLBlendMode ComposeCustomBlendModeNative(SDLBlendFactor srcColorFactor, SDLBlendFactor dstColorFactor, SDLBlendOperation colorOperation, SDLBlendFactor srcAlphaFactor, SDLBlendFactor dstAlphaFactor, SDLBlendOperation alphaOperation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendMode>)funcTable[366])(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			#else
			return (SDLBlendMode)((delegate* unmanaged[Cdecl]<SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendFactor, SDLBlendFactor, SDLBlendOperation, SDLBlendMode>)funcTable[366])(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			#endif
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer.<br/>
		/// All renderers support the four blend modes listed in the SDL_BlendMode<br/>
		/// enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLBlendMode ComposeCustomBlendMode(SDLBlendFactor srcColorFactor, SDLBlendFactor dstColorFactor, SDLBlendOperation colorOperation, SDLBlendFactor srcAlphaFactor, SDLBlendFactor dstAlphaFactor, SDLBlendOperation alphaOperation)
		{
			SDLBlendMode ret = ComposeCustomBlendModeNative(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPixelFormatNameNative(SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat, byte*>)funcTable[367])(format);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLPixelFormat, nint>)funcTable[367])(format);
			#endif
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static byte* GetPixelFormatName(SDLPixelFormat format)
		{
			byte* ret = GetPixelFormatNameNative(format);
			return ret;
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static string GetPixelFormatNameS(SDLPixelFormat format)
		{
			string ret = Utils.DecodeStringUTF8(GetPixelFormatNameNative(format));
			return ret;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetMasksForPixelFormatNative(SDLPixelFormat format, int* bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat, int*, uint*, uint*, uint*, uint*, byte>)funcTable[368])(format, bpp, rmask, gmask, bmask, amask);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLPixelFormat, nint, nint, nint, nint, nint, byte>)funcTable[368])(format, (nint)bpp, (nint)rmask, (nint)gmask, (nint)bmask, (nint)amask);
			#endif
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, bmask, amask);
			return ret != 0;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, bmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, bmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, uint* gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, bmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, ref uint gmask, uint* bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, (uint*)pbmask, amask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, uint* gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, ref uint gmask, ref uint bmask, uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* pamask = &amask)
			{
				byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, bmask, (uint*)pamask);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, bmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, uint* gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, ref uint gmask, uint* bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				fixed (uint* pamask = &amask)
				{
					byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, uint* gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, uint* rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						byte ret = GetMasksForPixelFormatNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, uint* rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, int* bpp, ref uint rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							byte ret = GetMasksForPixelFormatNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetMasksForPixelFormat(SDLPixelFormat format, ref int bpp, ref uint rmask, ref uint gmask, ref uint bmask, ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							fixed (uint* pamask = &amask)
							{
								byte ret = GetMasksForPixelFormatNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPixelFormat GetPixelFormatForMasksNative(int bpp, uint rmask, uint gmask, uint bmask, uint amask)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, SDLPixelFormat>)funcTable[369])(bpp, rmask, gmask, bmask, amask);
			#else
			return (SDLPixelFormat)((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, SDLPixelFormat>)funcTable[369])(bpp, rmask, gmask, bmask, amask);
			#endif
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPixelFormat GetPixelFormatForMasks(int bpp, uint rmask, uint gmask, uint bmask, uint amask)
		{
			SDLPixelFormat ret = GetPixelFormatForMasksNative(bpp, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Create an SDL_PixelFormatDetails structure corresponding to a pixel format.<br/>
		/// Returned structure may come from a shared global cache (i.e. not newly<br/>
		/// allocated), and hence should not be modified, especially the palette. Weird<br/>
		/// errors such as `Blit combination not supported` may occur.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPixelFormatDetails* GetPixelFormatDetailsNative(SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat, SDLPixelFormatDetails*>)funcTable[370])(format);
			#else
			return (SDLPixelFormatDetails*)((delegate* unmanaged[Cdecl]<SDLPixelFormat, nint>)funcTable[370])(format);
			#endif
		}

		/// <summary>
		/// Create an SDL_PixelFormatDetails structure corresponding to a pixel format.<br/>
		/// Returned structure may come from a shared global cache (i.e. not newly<br/>
		/// allocated), and hence should not be modified, especially the palette. Weird<br/>
		/// errors such as `Blit combination not supported` may occur.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLPixelFormatDetails* GetPixelFormatDetails(SDLPixelFormat format)
		{
			SDLPixelFormatDetails* ret = GetPixelFormatDetailsNative(format);
			return ret;
		}

		/// <summary>
		/// Create a palette structure with the specified number of color entries.<br/>
		/// The palette entries are initialized to white.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPalette* CreatePaletteNative(int ncolors)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLPalette*>)funcTable[371])(ncolors);
			#else
			return (SDLPalette*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[371])(ncolors);
			#endif
		}

		/// <summary>
		/// Create a palette structure with the specified number of color entries.<br/>
		/// The palette entries are initialized to white.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPalette* CreatePalette(int ncolors)
		{
			SDLPalette* ret = CreatePaletteNative(ncolors);
			return ret;
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetPaletteColorsNative(SDLPalette* palette, SDLColor* colors, int firstcolor, int ncolors)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPalette*, SDLColor*, int, int, byte>)funcTable[372])(palette, colors, firstcolor, ncolors);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, int, byte>)funcTable[372])((nint)palette, (nint)colors, firstcolor, ncolors);
			#endif
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetPaletteColors(SDLPalette* palette, SDLColor* colors, int firstcolor, int ncolors)
		{
			byte ret = SetPaletteColorsNative(palette, colors, firstcolor, ncolors);
			return ret != 0;
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetPaletteColors(ref SDLPalette palette, SDLColor* colors, int firstcolor, int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				byte ret = SetPaletteColorsNative((SDLPalette*)ppalette, colors, firstcolor, ncolors);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetPaletteColors(SDLPalette* palette, ref SDLColor colors, int firstcolor, int ncolors)
		{
			fixed (SDLColor* pcolors = &colors)
			{
				byte ret = SetPaletteColorsNative(palette, (SDLColor*)pcolors, firstcolor, ncolors);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetPaletteColors(ref SDLPalette palette, ref SDLColor colors, int firstcolor, int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (SDLColor* pcolors = &colors)
				{
					byte ret = SetPaletteColorsNative((SDLPalette*)ppalette, (SDLColor*)pcolors, firstcolor, ncolors);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Free a palette created with SDL_CreatePalette().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPaletteNative(SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLPalette*, void>)funcTable[373])(palette);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[373])((nint)palette);
			#endif
		}

		/// <summary>
		/// Free a palette created with SDL_CreatePalette().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyPalette(SDLPalette* palette)
		{
			DestroyPaletteNative(palette);
		}

		/// <summary>
		/// Free a palette created with SDL_CreatePalette().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified or destroyed in another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyPalette(ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				DestroyPaletteNative((SDLPalette*)ppalette);
			}
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapRGBNative(SDLPixelFormatDetails* format, SDLPalette* palette, byte r, byte g, byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormatDetails*, SDLPalette*, byte, byte, byte, uint>)funcTable[374])(format, palette, r, g, b);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte, byte, uint>)funcTable[374])((nint)format, (nint)palette, r, g, b);
			#endif
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(SDLPixelFormatDetails* format, SDLPalette* palette, byte r, byte g, byte b)
		{
			uint ret = MapRGBNative(format, palette, r, g, b);
			return ret;
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(ref SDLPixelFormatDetails format, SDLPalette* palette, byte r, byte g, byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				uint ret = MapRGBNative((SDLPixelFormatDetails*)pformat, palette, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(SDLPixelFormatDetails* format, ref SDLPalette palette, byte r, byte g, byte b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				uint ret = MapRGBNative(format, (SDLPalette*)ppalette, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGB(ref SDLPixelFormatDetails format, ref SDLPalette palette, byte r, byte g, byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					uint ret = MapRGBNative((SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MapRGBANative(SDLPixelFormatDetails* format, SDLPalette* palette, byte r, byte g, byte b, byte a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormatDetails*, SDLPalette*, byte, byte, byte, byte, uint>)funcTable[375])(format, palette, r, g, b, a);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte, byte, byte, uint>)funcTable[375])((nint)format, (nint)palette, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(SDLPixelFormatDetails* format, SDLPalette* palette, byte r, byte g, byte b, byte a)
		{
			uint ret = MapRGBANative(format, palette, r, g, b, a);
			return ret;
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(ref SDLPixelFormatDetails format, SDLPalette* palette, byte r, byte g, byte b, byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				uint ret = MapRGBANative((SDLPixelFormatDetails*)pformat, palette, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(SDLPixelFormatDetails* format, ref SDLPalette palette, byte r, byte g, byte b, byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				uint ret = MapRGBANative(format, (SDLPalette*)ppalette, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint MapRGBA(ref SDLPixelFormatDetails format, ref SDLPalette palette, byte r, byte g, byte b, byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					uint ret = MapRGBANative((SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, b, a);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRGBNative(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, byte* g, byte* b)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, SDLPixelFormatDetails*, SDLPalette*, byte*, byte*, byte*, void>)funcTable[376])(pixel, format, palette, r, g, b);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, nint, void>)funcTable[376])(pixel, (nint)format, (nint)palette, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, byte* g, byte* b)
		{
			GetRGBNative(pixel, format, palette, r, g, b);
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, byte* g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, g, b);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, byte* g, byte* b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				GetRGBNative(pixel, format, (SDLPalette*)ppalette, r, g, b);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, byte* r, byte* g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, ref byte r, byte* g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				GetRGBNative(pixel, format, palette, (byte*)pr, g, b);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, ref byte r, byte* g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, g, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, ref byte r, byte* g, byte* b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					GetRGBNative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, g, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, ref byte r, byte* g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, g, b);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, ref byte g, byte* b)
		{
			fixed (byte* pg = &g)
			{
				GetRGBNative(pixel, format, palette, r, (byte*)pg, b);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, ref byte g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, (byte*)pg, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, ref byte g, byte* b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pg = &g)
				{
					GetRGBNative(pixel, format, (SDLPalette*)ppalette, r, (byte*)pg, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, byte* r, ref byte g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pg = &g)
					{
						GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, (byte*)pg, b);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, ref byte r, ref byte g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					GetRGBNative(pixel, format, palette, (byte*)pr, (byte*)pg, b);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, (byte*)pg, b);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBNative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pg = &g)
						{
							GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, byte* g, ref byte b)
		{
			fixed (byte* pb = &b)
			{
				GetRGBNative(pixel, format, palette, r, g, (byte*)pb);
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, byte* g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, g, (byte*)pb);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, byte* g, ref byte b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pb = &b)
				{
					GetRGBNative(pixel, format, (SDLPalette*)ppalette, r, g, (byte*)pb);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, byte* r, byte* g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, ref byte r, byte* g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					GetRGBNative(pixel, format, palette, (byte*)pr, g, (byte*)pb);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, g, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pb = &b)
						{
							GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, ref byte g, ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					GetRGBNative(pixel, format, palette, r, (byte*)pg, (byte*)pb);
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, (byte*)pg, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, format, (SDLPalette*)ppalette, r, (byte*)pg, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, (byte*)pg, (byte*)pb);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, ref byte r, ref byte g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBNative(pixel, format, palette, (byte*)pr, (byte*)pg, (byte*)pb);
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, (byte*)pg, (byte*)pb);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBNative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, (byte*)pb);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGB(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pg = &g)
						{
							fixed (byte* pb = &b)
							{
								GetRGBNative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, (byte*)pb);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRGBANative(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, byte* g, byte* b, byte* a)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, SDLPixelFormatDetails*, SDLPalette*, byte*, byte*, byte*, byte*, void>)funcTable[377])(pixel, format, palette, r, g, b, a);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, nint, nint, void>)funcTable[377])(pixel, (nint)format, (nint)palette, (nint)r, (nint)g, (nint)b, (nint)a);
			#endif
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, byte* g, byte* b, byte* a)
		{
			GetRGBANative(pixel, format, palette, r, g, b, a);
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, g, b, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, g, b, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, byte* r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				GetRGBANative(pixel, format, palette, (byte*)pr, g, b, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, g, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, g, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, g, b, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (byte* pg = &g)
			{
				GetRGBANative(pixel, format, palette, r, (byte*)pg, b, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pg = &g)
				{
					GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pg = &g)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, (byte*)pg, b, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					GetRGBANative(pixel, format, palette, (byte*)pr, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, (byte*)pg, b, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pg = &g)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (byte* pb = &b)
			{
				GetRGBANative(pixel, format, palette, r, g, (byte*)pb, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, palette, (byte*)pr, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, ref SDLPalette palette, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pb = &b)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, byte* r, ref byte g, ref byte b, byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, palette, r, (byte*)pg, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, ref SDLPixelFormatDetails format, SDLPalette* palette, byte* r, ref byte g, ref byte b, byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetRGBA(uint pixel, SDLPixelFormatDetails* format, ref SDLPalette palette, byte* r, ref byte g, ref byte b, byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}
	}
}
