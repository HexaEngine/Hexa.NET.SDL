// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetGamepadButtonNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, byte>)funcTable[693])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, byte>)funcTable[693])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte GetGamepadButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			byte ret = GetGamepadButtonNative(gamepad, button);
			return ret;
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte GetGamepadButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GetGamepadButtonNative((SDLGamepad*)pgamepad, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabelForType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButtonLabel GetGamepadButtonLabelForTypeNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GamepadType")] SDLGamepadType type, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadType, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[694])(type, button);
			#else
			return (SDLGamepadButtonLabel)((delegate* unmanaged[Cdecl]<SDLGamepadType, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[694])(type, button);
			#endif
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabelForType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		public static SDLGamepadButtonLabel GetGamepadButtonLabelForType([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GamepadType")] SDLGamepadType type, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			SDLGamepadButtonLabel ret = GetGamepadButtonLabelForTypeNative(type, button);
			return ret;
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabel")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButtonLabel GetGamepadButtonLabelNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[695])(gamepad, button);
			#else
			return (SDLGamepadButtonLabel)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[695])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabel")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		public static SDLGamepadButtonLabel GetGamepadButtonLabel([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			SDLGamepadButtonLabel ret = GetGamepadButtonLabelNative(gamepad, button);
			return ret;
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabel")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		public static SDLGamepadButtonLabel GetGamepadButtonLabel([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadButtonLabel ret = GetGamepadButtonLabelNative((SDLGamepad*)pgamepad, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGamepadTouchpadsNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int>)funcTable[696])(gamepad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[696])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpads([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			int ret = GetNumGamepadTouchpadsNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpads([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetNumGamepadTouchpadsNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGamepadTouchpadFingersNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, int>)funcTable[697])(gamepad, touchpad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[697])((nint)gamepad, touchpad);
			#endif
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpadFingers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			int ret = GetNumGamepadTouchpadFingersNative(gamepad, touchpad);
			return ret;
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpadFingers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetNumGamepadTouchpadFingersNative((SDLGamepad*)pgamepad, touchpad);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadTouchpadFingerNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, int, byte*, float*, float*, float*, int>)funcTable[698])(gamepad, touchpad, finger, state, x, y, pressure);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, nint, nint, int>)funcTable[698])((nint)gamepad, touchpad, finger, (nint)state, (nint)x, (nint)y, (nint)pressure);
			#endif
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, x, y, pressure);
			return ret;
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, x, y, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, x, y, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, x, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (float* px = &x)
			{
				int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, (float*)px, y, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, (float*)px, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, (float*)px, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, (float*)px, y, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (float* py = &y)
			{
				int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, x, (float*)py, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* py = &y)
				{
					int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, x, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* py = &y)
				{
					int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, x, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* py = &y)
					{
						int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, x, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, (float*)px, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, (float*)px, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, pressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* ppressure = &pressure)
			{
				int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, x, y, (float*)ppressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, x, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, x, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, x, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, (float*)px, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, (float*)px, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, (float*)px, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, (float*)px, y, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* py = &y)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, x, (float*)py, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, x, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, x, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, x, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, state, (float*)px, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, state, (float*)px, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							fixed (float* ppressure = &pressure)
							{
								int ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, (float*)ppressure);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GamepadHasSensorNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, int>)funcTable[699])(gamepad, type);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, int>)funcTable[699])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GamepadHasSensor([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			int ret = GamepadHasSensorNative(gamepad, type);
			return ret;
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GamepadHasSensor([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GamepadHasSensorNative((SDLGamepad*)pgamepad, type);
				return ret;
			}
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetGamepadSensorEnabledNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, int, int>)funcTable[700])(gamepad, type, enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, int, int>)funcTable[700])((nint)gamepad, type, enabled);
			#endif
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			int ret = SetGamepadSensorEnabledNative(gamepad, type, enabled);
			return ret;
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = SetGamepadSensorEnabledNative((SDLGamepad*)pgamepad, type, enabled);
				return ret;
			}
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GamepadSensorEnabledNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, int>)funcTable[701])(gamepad, type);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, int>)funcTable[701])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			int ret = GamepadSensorEnabledNative(gamepad, type);
			return ret;
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GamepadSensorEnabledNative((SDLGamepad*)pgamepad, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetGamepadSensorDataRateNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, float>)funcTable[702])(gamepad, type);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, float>)funcTable[702])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGamepadSensorDataRate([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			float ret = GetGamepadSensorDataRateNative(gamepad, type);
			return ret;
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGamepadSensorDataRate([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				float ret = GetGamepadSensorDataRateNative((SDLGamepad*)pgamepad, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadSensorDataNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, float*, int, int>)funcTable[703])(gamepad, type, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, nint, int, int>)funcTable[703])((nint)gamepad, type, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = GetGamepadSensorDataNative(gamepad, type, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetGamepadSensorDataNative((SDLGamepad*)pgamepad, type, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = GetGamepadSensorDataNative(gamepad, type, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* pdata = &data)
				{
					int ret = GetGamepadSensorDataNative((SDLGamepad*)pgamepad, type, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepad")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RumbleGamepadNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort, ushort, uint, int>)funcTable[704])(gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)funcTable[704])((nint)gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepad")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RumbleGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = RumbleGamepadNative(gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepad")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RumbleGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = RumbleGamepadNative((SDLGamepad*)pgamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepadTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RumbleGamepadTriggersNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort, ushort, uint, int>)funcTable[705])(gamepad, leftRumble, rightRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)funcTable[705])((nint)gamepad, leftRumble, rightRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepadTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RumbleGamepadTriggers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = RumbleGamepadTriggersNative(gamepad, leftRumble, rightRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepadTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RumbleGamepadTriggers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = RumbleGamepadTriggersNative((SDLGamepad*)pgamepad, leftRumble, rightRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetGamepadLEDNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte, byte, byte, int>)funcTable[706])(gamepad, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)funcTable[706])((nint)gamepad, red, green, blue);
			#endif
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadLED([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			int ret = SetGamepadLEDNative(gamepad, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadLED([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = SetGamepadLEDNative((SDLGamepad*)pgamepad, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SendGamepadEffectNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, void*, int, int>)funcTable[707])(gamepad, data, size);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[707])((nint)gamepad, (nint)data, size);
			#endif
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SendGamepadEffect([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			int ret = SendGamepadEffectNative(gamepad, data, size);
			return ret;
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SendGamepadEffect([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = SendGamepadEffectNative((SDLGamepad*)pgamepad, data, size);
				return ret;
			}
		}

		/// <summary>
		/// Close a gamepad previously opened with SDL_OpenGamepad().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseGamepad")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseGamepadNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGamepad*, void>)funcTable[708])(gamepad);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[708])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Close a gamepad previously opened with SDL_OpenGamepad().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseGamepad")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			CloseGamepadNative(gamepad);
		}

		/// <summary>
		/// Close a gamepad previously opened with SDL_OpenGamepad().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseGamepad")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				CloseGamepadNative((SDLGamepad*)pgamepad);
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadAppleSFSymbolsNameForButtonNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, byte*>)funcTable[709])(gamepad, button);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, nint>)funcTable[709])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			byte* ret = GetGamepadAppleSFSymbolsNameForButtonNative(gamepad, button);
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForButtonNative(gamepad, button));
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadAppleSFSymbolsNameForButtonNative((SDLGamepad*)pgamepad, button);
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForButtonNative((SDLGamepad*)pgamepad, button));
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadAppleSFSymbolsNameForAxisNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadAxis, byte*>)funcTable[710])(gamepad, axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis, nint>)funcTable[710])((nint)gamepad, axis);
			#endif
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			byte* ret = GetGamepadAppleSFSymbolsNameForAxisNative(gamepad, axis);
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForAxisNative(gamepad, axis));
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadAppleSFSymbolsNameForAxisNative((SDLGamepad*)pgamepad, axis);
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForAxisNative((SDLGamepad*)pgamepad, axis));
				return ret;
			}
		}

		/// <summary>
		/// Return whether a keyboard is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasKeyboard")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasKeyboardNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[711])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[711])();
			#endif
		}

		/// <summary>
		/// Return whether a keyboard is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasKeyboard")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasKeyboard()
		{
			int ret = HasKeyboardNative();
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected keyboards.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// keyboard functionality, including some mice, KVM switches, motherboard<br/>
		/// power buttons, etc. You should wait for input from a device before you<br/>
		/// consider it actively in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboards")]
		[return: NativeName(NativeNameType.Type, "SDL_KeyboardID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetKeyboardsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[712])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[712])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected keyboards.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// keyboard functionality, including some mice, KVM switches, motherboard<br/>
		/// power buttons, etc. You should wait for input from a device before you<br/>
		/// consider it actively in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboards")]
		[return: NativeName(NativeNameType.Type, "SDL_KeyboardID *")]
		public static uint* GetKeyboards([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetKeyboardsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected keyboards.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// keyboard functionality, including some mice, KVM switches, motherboard<br/>
		/// power buttons, etc. You should wait for input from a device before you<br/>
		/// consider it actively in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboards")]
		[return: NativeName(NativeNameType.Type, "SDL_KeyboardID *")]
		public static uint* GetKeyboards([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetKeyboardsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the name of a keyboard.<br/>
		/// This function returns "" if the keyboard doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyboardNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_KeyboardID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[713])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[713])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the name of a keyboard.<br/>
		/// This function returns "" if the keyboard doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetKeyboardNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_KeyboardID")] uint instanceId)
		{
			byte* ret = GetKeyboardNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the name of a keyboard.<br/>
		/// This function returns "" if the keyboard doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetKeyboardNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_KeyboardID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyboardNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetKeyboardFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[714])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[714])();
			#endif
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindow* GetKeyboardFocus()
		{
			SDLWindow* ret = GetKeyboardFocusNative();
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "Uint8 const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyboardStateNative([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] int* numkeys)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte*>)funcTable[715])(numkeys);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[715])((nint)numkeys);
			#endif
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "Uint8 const *")]
		public static byte* GetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] int* numkeys)
		{
			byte* ret = GetKeyboardStateNative(numkeys);
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "Uint8 const *")]
		public static string GetKeyboardStateS([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] int* numkeys)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyboardStateNative(numkeys));
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "Uint8 const *")]
		public static byte* GetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				byte* ret = GetKeyboardStateNative((int*)pnumkeys);
				return ret;
			}
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "Uint8 const *")]
		public static string GetKeyboardStateS([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				string ret = Utils.DecodeStringUTF8(GetKeyboardStateNative((int*)pnumkeys));
				return ret;
			}
		}

		/// <summary>
		/// Clear the state of the keyboard.<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetKeyboardNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[716])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[716])();
			#endif
		}

		/// <summary>
		/// Clear the state of the keyboard.<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetKeyboard()
		{
			ResetKeyboardNative();
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLKeymod GetModStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLKeymod>)funcTable[717])();
			#else
			return (SDLKeymod)((delegate* unmanaged[Cdecl]<SDLKeymod>)funcTable[717])();
			#endif
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		public static SDLKeymod GetModState()
		{
			SDLKeymod ret = GetModStateNative();
			return ret;
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetModStateNative([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLKeymod, void>)funcTable[718])(modstate);
			#else
			((delegate* unmanaged[Cdecl]<SDLKeymod, void>)funcTable[718])(modstate);
			#endif
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetModState([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate)
		{
			SetModStateNative(modstate);
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// If you want to get the keycode as it would be delivered in key events,<br/>
		/// including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should<br/>
		/// pass `key_event` as SDL_TRUE. Otherwise this function simply translates the<br/>
		/// scancode based on the given modifier state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromScancodeNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate, [NativeName(NativeNameType.Param, "key_event")] [NativeName(NativeNameType.Type, "SDL_bool")] int keyEvent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, SDLKeymod, int, int>)funcTable[719])(scancode, modstate, keyEvent);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLScancode, SDLKeymod, int, int>)funcTable[719])(scancode, modstate, keyEvent);
			#endif
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// If you want to get the keycode as it would be delivered in key events,<br/>
		/// including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should<br/>
		/// pass `key_event` as SDL_TRUE. Otherwise this function simply translates the<br/>
		/// scancode based on the given modifier state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromScancode([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate, [NativeName(NativeNameType.Param, "key_event")] [NativeName(NativeNameType.Type, "SDL_bool")] int keyEvent)
		{
			int ret = GetKeyFromScancodeNative(scancode, modstate, keyEvent);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// Note that there may be multiple scancode+modifier states that can generate<br/>
		/// this keycode, this will just return the first one found.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromKeyNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod *")] SDLKeymod* modstate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLKeymod*, SDLScancode>)funcTable[720])(key, modstate);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<int, nint, SDLScancode>)funcTable[720])(key, (nint)modstate);
			#endif
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// Note that there may be multiple scancode+modifier states that can generate<br/>
		/// this keycode, this will just return the first one found.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromKey([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod *")] SDLKeymod* modstate)
		{
			SDLScancode ret = GetScancodeFromKeyNative(key, modstate);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// Note that there may be multiple scancode+modifier states that can generate<br/>
		/// this keycode, this will just return the first one found.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromKey([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod *")] ref SDLKeymod modstate)
		{
			fixed (SDLKeymod* pmodstate = &modstate)
			{
				SDLScancode ret = GetScancodeFromKeyNative(key, (SDLKeymod*)pmodstate);
				return ret;
			}
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetScancodeNameNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, byte*, int>)funcTable[721])(scancode, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLScancode, nint, int>)funcTable[721])(scancode, (nint)name);
			#endif
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			int ret = SetScancodeNameNative(scancode, name);
			return ret;
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetScancodeNameNative(scancode, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = SetScancodeNameNative(scancode, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetScancodeNameNative(scancode, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetScancodeNameNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, byte*>)funcTable[722])(scancode);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLScancode, nint>)funcTable[722])(scancode);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			byte* ret = GetScancodeNameNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetScancodeNameS([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			string ret = Utils.DecodeStringUTF8(GetScancodeNameNative(scancode));
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLScancode>)funcTable[723])(name);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<nint, SDLScancode>)funcTable[723])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			SDLScancode ret = GetScancodeFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLScancode ret = GetScancodeFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// If the key doesn't have a name, this function returns an empty string ("").<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyNameNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[724])(key);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[724])(key);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// If the key doesn't have a name, this function returns an empty string ("").<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetKeyName([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// If the key doesn't have a name, this function returns an empty string ("").<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetKeyNameS([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[725])(name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[725])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			int ret = GetKeyFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetKeyFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StartTextInputNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[726])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[726])((nint)window);
			#endif
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StartTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			int ret = StartTextInputNative(window);
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StartTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = StartTextInputNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window, with properties<br/>
		/// describing the input.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that<br/>
		/// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.<br/>
		/// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value<br/>
		/// that describes how text should be capitalized, defaults to<br/>
		/// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for<br/>
		/// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail<br/>
		/// addresses, usernames, and passwords.<br/>
		/// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion<br/>
		/// and auto correction, defaults to SDL_TRUE.<br/>
		/// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text<br/>
		/// are allowed. This defaults to SDL_TRUE if SDL_HINT_RETURN_KEY_HIDES_IME<br/>
		/// is "0" or is not set, and defaults to SDL_FALSE if<br/>
		/// SDL_HINT_RETURN_KEY_HIDES_IME is "1".<br/>
		/// On Android you can directly specify the input type:<br/>
		/// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to<br/>
		/// use, overriding other properties. This is documented at<br/>
		/// https://developer.android.com/reference/android/text/InputType<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInputWithProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StartTextInputWithPropertiesNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, uint, int>)funcTable[727])(window, props);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[727])((nint)window, props);
			#endif
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window, with properties<br/>
		/// describing the input.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that<br/>
		/// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.<br/>
		/// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value<br/>
		/// that describes how text should be capitalized, defaults to<br/>
		/// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for<br/>
		/// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail<br/>
		/// addresses, usernames, and passwords.<br/>
		/// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion<br/>
		/// and auto correction, defaults to SDL_TRUE.<br/>
		/// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text<br/>
		/// are allowed. This defaults to SDL_TRUE if SDL_HINT_RETURN_KEY_HIDES_IME<br/>
		/// is "0" or is not set, and defaults to SDL_FALSE if<br/>
		/// SDL_HINT_RETURN_KEY_HIDES_IME is "1".<br/>
		/// On Android you can directly specify the input type:<br/>
		/// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to<br/>
		/// use, overriding other properties. This is documented at<br/>
		/// https://developer.android.com/reference/android/text/InputType<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInputWithProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StartTextInputWithProperties([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			int ret = StartTextInputWithPropertiesNative(window, props);
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window, with properties<br/>
		/// describing the input.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that<br/>
		/// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.<br/>
		/// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value<br/>
		/// that describes how text should be capitalized, defaults to<br/>
		/// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for<br/>
		/// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail<br/>
		/// addresses, usernames, and passwords.<br/>
		/// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion<br/>
		/// and auto correction, defaults to SDL_TRUE.<br/>
		/// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text<br/>
		/// are allowed. This defaults to SDL_TRUE if SDL_HINT_RETURN_KEY_HIDES_IME<br/>
		/// is "0" or is not set, and defaults to SDL_FALSE if<br/>
		/// SDL_HINT_RETURN_KEY_HIDES_IME is "1".<br/>
		/// On Android you can directly specify the input type:<br/>
		/// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to<br/>
		/// use, overriding other properties. This is documented at<br/>
		/// https://developer.android.com/reference/android/text/InputType<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInputWithProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StartTextInputWithProperties([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = StartTextInputWithPropertiesNative((SDLWindow*)pwindow, props);
				return ret;
			}
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TextInputActive")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TextInputActiveNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[728])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[728])((nint)window);
			#endif
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TextInputActive")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int TextInputActive([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			int ret = TextInputActiveNative(window);
			return ret;
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TextInputActive")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int TextInputActive([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = TextInputActiveNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Stop receiving any text input events in a window.<br/>
		/// If SDL_StartTextInput() showed the screen keyboard, this function will hide<br/>
		/// it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int StopTextInputNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[729])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[729])((nint)window);
			#endif
		}

		/// <summary>
		/// Stop receiving any text input events in a window.<br/>
		/// If SDL_StartTextInput() showed the screen keyboard, this function will hide<br/>
		/// it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			int ret = StopTextInputNative(window);
			return ret;
		}

		/// <summary>
		/// Stop receiving any text input events in a window.<br/>
		/// If SDL_StartTextInput() showed the screen keyboard, this function will hide<br/>
		/// it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int StopTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = StopTextInputNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ClearCompositionNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[730])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[730])((nint)window);
			#endif
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ClearComposition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			int ret = ClearCompositionNative(window);
			return ret;
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ClearComposition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ClearCompositionNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTextInputAreaNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int, int>)funcTable[731])(window, rect, cursor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[731])((nint)window, (nint)rect, cursor);
			#endif
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			int ret = SetTextInputAreaNative(window, rect, cursor);
			return ret;
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetTextInputAreaNative((SDLWindow*)pwindow, rect, cursor);
				return ret;
			}
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SetTextInputAreaNative(window, (SDLRect*)prect, cursor);
				return ret;
			}
		}

		/// <summary>
		/// Set the area used to type Unicode text input.<br/>
		/// Native input methods may place a window with word suggestions near the<br/>
		/// cursor, without covering the text being entered.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)prect, cursor);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextInputAreaNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int*, int>)funcTable[732])(window, rect, cursor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[732])((nint)window, (nint)rect, (nint)cursor);
			#endif
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			int ret = GetTextInputAreaNative(window, rect, cursor);
			return ret;
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetTextInputAreaNative((SDLWindow*)pwindow, rect, cursor);
				return ret;
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = GetTextInputAreaNative(window, (SDLRect*)prect, cursor);
				return ret;
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] int* cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = GetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)prect, cursor);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (int* pcursor = &cursor)
			{
				int ret = GetTextInputAreaNative(window, rect, (int*)pcursor);
				return ret;
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pcursor = &cursor)
				{
					int ret = GetTextInputAreaNative((SDLWindow*)pwindow, rect, (int*)pcursor);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* pcursor = &cursor)
				{
					int ret = GetTextInputAreaNative(window, (SDLRect*)prect, (int*)pcursor);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the area used to type Unicode text input.<br/>
		/// This returns the values previously set by SDL_SetTextInputArea().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextInputArea")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTextInputArea([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int *")] ref int cursor)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (int* pcursor = &cursor)
					{
						int ret = GetTextInputAreaNative((SDLWindow*)pwindow, (SDLRect*)prect, (int*)pcursor);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasScreenKeyboardSupportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[733])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[733])();
			#endif
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasScreenKeyboardSupport()
		{
			int ret = HasScreenKeyboardSupportNative();
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ScreenKeyboardShownNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[734])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[734])((nint)window);
			#endif
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			int ret = ScreenKeyboardShownNative(window);
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = ScreenKeyboardShownNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Return whether a mouse is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasMouseNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[735])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[735])();
			#endif
		}

		/// <summary>
		/// Return whether a mouse is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasMouse()
		{
			int ret = HasMouseNative();
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected mice.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// mouse functionality, including some game controllers, KVM switches, etc.<br/>
		/// You should wait for input from a device before you consider it actively in<br/>
		/// use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMice")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetMiceNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[736])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[736])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected mice.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// mouse functionality, including some game controllers, KVM switches, etc.<br/>
		/// You should wait for input from a device before you consider it actively in<br/>
		/// use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMice")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseID *")]
		public static uint* GetMice([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetMiceNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected mice.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// mouse functionality, including some game controllers, KVM switches, etc.<br/>
		/// You should wait for input from a device before you consider it actively in<br/>
		/// use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMice")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseID *")]
		public static uint* GetMice([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetMiceNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the name of a mouse.<br/>
		/// This function returns "" if the mouse doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetMouseNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_MouseID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[737])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[737])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the name of a mouse.<br/>
		/// This function returns "" if the mouse doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetMouseNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_MouseID")] uint instanceId)
		{
			byte* ret = GetMouseNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the name of a mouse.<br/>
		/// This function returns "" if the mouse doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetMouseNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_MouseID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetMouseNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetMouseFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[738])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[738])();
			#endif
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindow* GetMouseFocus()
		{
			SDLWindow* ret = GetMouseFocusNative();
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the SDL_BUTTON(X) macro (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLMouseButtonFlags GetMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, float*, SDLMouseButtonFlags>)funcTable[739])(x, y);
			#else
			return (SDLMouseButtonFlags)((delegate* unmanaged[Cdecl]<nint, nint, SDLMouseButtonFlags>)funcTable[739])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the SDL_BUTTON(X) macro (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			SDLMouseButtonFlags ret = GetMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the SDL_BUTTON(X) macro (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			fixed (float* px = &x)
			{
				SDLMouseButtonFlags ret = GetMouseStateNative((float*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the SDL_BUTTON(X) macro (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* py = &y)
			{
				SDLMouseButtonFlags ret = GetMouseStateNative(x, (float*)py);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the SDL_BUTTON(X) macro (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					SDLMouseButtonFlags ret = GetMouseStateNative((float*)px, (float*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLMouseButtonFlags GetGlobalMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, float*, SDLMouseButtonFlags>)funcTable[740])(x, y);
			#else
			return (SDLMouseButtonFlags)((delegate* unmanaged[Cdecl]<nint, nint, SDLMouseButtonFlags>)funcTable[740])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			SDLMouseButtonFlags ret = GetGlobalMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			fixed (float* px = &x)
			{
				SDLMouseButtonFlags ret = GetGlobalMouseStateNative((float*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* py = &y)
			{
				SDLMouseButtonFlags ret = GetGlobalMouseStateNative(x, (float*)py);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					SDLMouseButtonFlags ret = GetGlobalMouseStateNative((float*)px, (float*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLMouseButtonFlags GetRelativeMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, float*, SDLMouseButtonFlags>)funcTable[741])(x, y);
			#else
			return (SDLMouseButtonFlags)((delegate* unmanaged[Cdecl]<nint, nint, SDLMouseButtonFlags>)funcTable[741])((nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			SDLMouseButtonFlags ret = GetRelativeMouseStateNative(x, y);
			return ret;
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			fixed (float* px = &x)
			{
				SDLMouseButtonFlags ret = GetRelativeMouseStateNative((float*)px, y);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* py = &y)
			{
				SDLMouseButtonFlags ret = GetRelativeMouseStateNative(x, (float*)py);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "SDL_MouseButtonFlags")]
		public static SDLMouseButtonFlags GetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					SDLMouseButtonFlags ret = GetRelativeMouseStateNative((float*)px, (float*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarpMouseInWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, float, float, void>)funcTable[742])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, void>)funcTable[742])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			WarpMouseInWindowNative(window, x, y);
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				WarpMouseInWindowNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WarpMouseGlobalNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, int>)funcTable[743])(x, y);
			#else
			return (int)((delegate* unmanaged[Cdecl]<float, float, int>)funcTable[743])(x, y);
			#endif
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WarpMouseGlobal([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			int ret = WarpMouseGlobalNative(x, y);
			return ret;
		}

		/// <summary>
		/// Set relative mouse mode for a window.<br/>
		/// While the window has focus and relative mouse mode is enabled, the cursor<br/>
		/// is hidden, the mouse position is constrained to the window, and SDL will<br/>
		/// report continuous relative mouse motion even if the mouse is at the edge of<br/>
		/// the window.<br/>
		/// This function will flush any pending mouse motion for this window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetWindowRelativeMouseModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int>)funcTable[744])(window, enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[744])((nint)window, enabled);
			#endif
		}

		/// <summary>
		/// Set relative mouse mode for a window.<br/>
		/// While the window has focus and relative mouse mode is enabled, the cursor<br/>
		/// is hidden, the mouse position is constrained to the window, and SDL will<br/>
		/// report continuous relative mouse motion even if the mouse is at the edge of<br/>
		/// the window.<br/>
		/// This function will flush any pending mouse motion for this window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			int ret = SetWindowRelativeMouseModeNative(window, enabled);
			return ret;
		}

		/// <summary>
		/// Set relative mouse mode for a window.<br/>
		/// While the window has focus and relative mouse mode is enabled, the cursor<br/>
		/// is hidden, the mouse position is constrained to the window, and SDL will<br/>
		/// report continuous relative mouse motion even if the mouse is at the edge of<br/>
		/// the window.<br/>
		/// This function will flush any pending mouse motion for this window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SetWindowRelativeMouseModeNative((SDLWindow*)pwindow, enabled);
				return ret;
			}
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetWindowRelativeMouseModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int>)funcTable[745])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[745])((nint)window);
			#endif
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			int ret = GetWindowRelativeMouseModeNative(window);
			return ret;
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetWindowRelativeMouseMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = GetWindowRelativeMouseModeNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),<br/>
		/// depending on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that SDL will attempt to "auto capture" the mouse while the<br/>
		/// user is pressing a button; this is to try and make mouse behavior more<br/>
		/// consistent between platforms, and deal with the common case of a user<br/>
		/// dragging the mouse outside of the window. This means that if you are<br/>
		/// calling SDL_CaptureMouse() only to deal with this situation, you do not<br/>
		/// have to (although it is safe to do so). If this causes problems for your<br/>
		/// app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CaptureMouseNative([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[746])(enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[746])(enabled);
			#endif
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),<br/>
		/// depending on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that SDL will attempt to "auto capture" the mouse while the<br/>
		/// user is pressing a button; this is to try and make mouse behavior more<br/>
		/// consistent between platforms, and deal with the common case of a user<br/>
		/// dragging the mouse outside of the window. This means that if you are<br/>
		/// calling SDL_CaptureMouse() only to deal with this situation, you do not<br/>
		/// have to (although it is safe to do so). If this causes problems for your<br/>
		/// app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CaptureMouse([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] int enabled)
		{
			int ret = CaptureMouseNative(enabled);
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateCursorNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int, int, int, SDLCursor*>)funcTable[747])(data, mask, w, h, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int, nint>)funcTable[747])((nint)data, (nint)mask, w, h, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursor* ret = CreateCursorNative(data, mask, w, h, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] ref byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				SDLCursor* ret = CreateCursorNative((byte*)pdata, mask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] ref byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pmask = &mask)
			{
				SDLCursor* ret = CreateCursorNative(data, (byte*)pmask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
		/// readily-available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* CreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "Uint8 const *")] ref byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "Uint8 const *")] ref byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pmask = &mask)
				{
					SDLCursor* ret = CreateCursorNative((byte*)pdata, (byte*)pmask, w, h, hotX, hotY);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// If this function is passed a surface with alternate representations, the<br/>
		/// surface will be interpreted as the content to be used for 100% display<br/>
		/// scale, and the alternate representations will be used for high DPI<br/>
		/// situations. For example, if the original surface is 32x32, then on a 2x<br/>
		/// macOS display or 200% display scale on Windows, a 64x64 version of the<br/>
		/// image will be used, if available. If a matching version of the image isn't<br/>
		/// available, the closest larger size image will be downscaled to the<br/>
		/// appropriate size and be used instead, if available. Otherwise, the closest<br/>
		/// smaller image will be upscaled and be used instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateColorCursorNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, SDLCursor*>)funcTable[748])(surface, hotX, hotY);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)funcTable[748])((nint)surface, hotX, hotY);
			#endif
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// If this function is passed a surface with alternate representations, the<br/>
		/// surface will be interpreted as the content to be used for 100% display<br/>
		/// scale, and the alternate representations will be used for high DPI<br/>
		/// situations. For example, if the original surface is 32x32, then on a 2x<br/>
		/// macOS display or 200% display scale on Windows, a 64x64 version of the<br/>
		/// image will be used, if available. If a matching version of the image isn't<br/>
		/// available, the closest larger size image will be downscaled to the<br/>
		/// appropriate size and be used instead, if available. Otherwise, the closest<br/>
		/// smaller image will be upscaled and be used instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* CreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursor* ret = CreateColorCursorNative(surface, hotX, hotY);
			return ret;
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// If this function is passed a surface with alternate representations, the<br/>
		/// surface will be interpreted as the content to be used for 100% display<br/>
		/// scale, and the alternate representations will be used for high DPI<br/>
		/// situations. For example, if the original surface is 32x32, then on a 2x<br/>
		/// macOS display or 200% display scale on Windows, a 64x64 version of the<br/>
		/// image will be used, if available. If a matching version of the image isn't<br/>
		/// available, the closest larger size image will be downscaled to the<br/>
		/// appropriate size and be used instead, if available. Otherwise, the closest<br/>
		/// smaller image will be upscaled and be used instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* CreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLCursor* ret = CreateColorCursorNative((SDLSurface*)psurface, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* CreateSystemCursorNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSystemCursor, SDLCursor*>)funcTable[749])(id);
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<SDLSystemCursor, nint>)funcTable[749])(id);
			#endif
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* CreateSystemCursor([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id)
		{
			SDLCursor* ret = CreateSystemCursorNative(id);
			return ret;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*, int>)funcTable[750])(cursor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[750])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursor* cursor)
		{
			int ret = SetCursorNative(cursor);
			return ret;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				int ret = SetCursorNative((SDLCursor*)pcursor);
				return ret;
			}
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_DestroyCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[751])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[751])();
			#endif
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_DestroyCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* GetCursor()
		{
			SDLCursor* ret = GetCursorNative();
			return ret;
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_DestroyCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCursor* GetDefaultCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)funcTable[752])();
			#else
			return (SDLCursor*)((delegate* unmanaged[Cdecl]<nint>)funcTable[752])();
			#endif
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_DestroyCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor *")]
		public static SDLCursor* GetDefaultCursor()
		{
			SDLCursor* ret = GetDefaultCursorNative();
			return ret;
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursor* cursor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)funcTable[753])(cursor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[753])((nint)cursor);
			#endif
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] SDLCursor* cursor)
		{
			DestroyCursorNative(cursor);
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor *")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				DestroyCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Show the cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShowCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[754])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[754])();
			#endif
		}

		/// <summary>
		/// Show the cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ShowCursor()
		{
			int ret = ShowCursorNative();
			return ret;
		}

		/// <summary>
		/// Hide the cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HideCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[755])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[755])();
			#endif
		}

		/// <summary>
		/// Hide the cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HideCursor()
		{
			int ret = HideCursorNative();
			return ret;
		}

		/// <summary>
		/// Return whether the cursor is currently being shown.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CursorVisible")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CursorVisibleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[756])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[756])();
			#endif
		}

		/// <summary>
		/// Return whether the cursor is currently being shown.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CursorVisible")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int CursorVisible()
		{
			int ret = CursorVisibleNative();
			return ret;
		}

		/// <summary>
		/// Get a list of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore the returned list might be empty, although devices are available.<br/>
		/// After using all devices at least once the number will be correct.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long* GetTouchDevicesNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, long*>)funcTable[757])(count);
			#else
			return (long*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[757])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore the returned list might be empty, although devices are available.<br/>
		/// After using all devices at least once the number will be correct.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID *")]
		public static long* GetTouchDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			long* ret = GetTouchDevicesNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore the returned list might be empty, although devices are available.<br/>
		/// After using all devices at least once the number will be correct.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID *")]
		public static long* GetTouchDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				long* ret = GetTouchDevicesNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the touch device name as reported from the driver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTouchDeviceNameNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, byte*>)funcTable[758])(touchID);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<long, nint>)funcTable[758])(touchID);
			#endif
		}

		/// <summary>
		/// Get the touch device name as reported from the driver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetTouchDeviceName([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			byte* ret = GetTouchDeviceNameNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get the touch device name as reported from the driver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetTouchDeviceNameS([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			string ret = Utils.DecodeStringUTF8(GetTouchDeviceNameNative(touchID));
			return ret;
		}

		/// <summary>
		/// Get the type of the given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTouchDeviceType GetTouchDeviceTypeNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, SDLTouchDeviceType>)funcTable[759])(touchID);
			#else
			return (SDLTouchDeviceType)((delegate* unmanaged[Cdecl]<long, SDLTouchDeviceType>)funcTable[759])(touchID);
			#endif
		}

		/// <summary>
		/// Get the type of the given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		public static SDLTouchDeviceType GetTouchDeviceType([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			SDLTouchDeviceType ret = GetTouchDeviceTypeNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get a list of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFingers")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLFinger** GetTouchFingersNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, int*, SDLFinger**>)funcTable[760])(touchID, count);
			#else
			return (SDLFinger**)((delegate* unmanaged[Cdecl]<long, nint, nint>)funcTable[760])(touchID, (nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFingers")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger * *")]
		public static SDLFinger** GetTouchFingers([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			SDLFinger** ret = GetTouchFingersNative(touchID, count);
			return ret;
		}

		/// <summary>
		/// Get a list of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFingers")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger * *")]
		public static SDLFinger** GetTouchFingers([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLFinger** ret = GetTouchFingersNative(touchID, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Pump the event loop, gathering events from the input devices.<br/>
		/// This function updates the event queue and internal input device state.<br/>
		/// **WARNING**: This should only be run in the thread that initialized the<br/>
		/// video subsystem, and for extra safety, you should consider only doing those<br/>
		/// things on the main thread in any case.<br/>
		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
		/// would ever be placed on the queue. Often the need for calls to<br/>
		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
		/// call SDL_PumpEvents() to force an event queue update.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PumpEventsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[761])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[761])();
			#endif
		}

		/// <summary>
		/// Pump the event loop, gathering events from the input devices.<br/>
		/// This function updates the event queue and internal input device state.<br/>
		/// **WARNING**: This should only be run in the thread that initialized the<br/>
		/// video subsystem, and for extra safety, you should consider only doing those<br/>
		/// things on the main thread in any case.<br/>
		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
		/// would ever be placed on the queue. Often the need for calls to<br/>
		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
		/// call SDL_PumpEvents() to force an event queue update.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PumpEvents()
		{
			PumpEventsNative();
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// This function is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PeepEventsNative([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_EventAction")] SDLEventAction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int, SDLEventAction, uint, uint, int>)funcTable[762])(events, numevents, action, minType, maxType);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, SDLEventAction, uint, uint, int>)funcTable[762])((nint)events, numevents, action, minType, maxType);
			#endif
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// This function is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_EventAction")] SDLEventAction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			int ret = PeepEventsNative(events, numevents, action, minType, maxType);
			return ret;
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// This function is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int PeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_EventAction")] SDLEventAction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			fixed (SDLEvent* pevents = &events)
			{
				int ret = PeepEventsNative((SDLEvent*)pevents, numevents, action, minType, maxType);
				return ret;
			}
		}

		/// <summary>
		/// Check for the existence of a certain event type in the event queue.<br/>
		/// If you need to check for a range of event types, use SDL_HasEvents()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasEventNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int>)funcTable[763])(type);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, int>)funcTable[763])(type);
			#endif
		}
	}
}
