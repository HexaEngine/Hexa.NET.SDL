// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return false. In such a case, you should<br/>
		/// probably retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLSetSwapInterval(int interval)
		{
			byte ret = GLSetSwapIntervalNative(interval);
			return ret != 0;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLGetSwapIntervalNative(int* interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte>)funcTable[596])(interval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[596])((nint)interval);
			#endif
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLGetSwapInterval(int* interval)
		{
			byte ret = GLGetSwapIntervalNative(interval);
			return ret != 0;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLGetSwapInterval(ref int interval)
		{
			fixed (int* pinterval = &interval)
			{
				byte ret = GLGetSwapIntervalNative((int*)pinterval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSwapWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[597])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[597])((nint)window);
			#endif
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GLSwapWindow(SDLWindow* window)
		{
			byte ret = GLSwapWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GLSwapWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GLSwapWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLDestroyContextNative(SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLContext, byte>)funcTable[598])(context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLContext, byte>)funcTable[598])(context);
			#endif
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLDestroyContext(SDLGLContext context)
		{
			byte ret = GLDestroyContextNative(context);
			return ret != 0;
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFileDialogNative(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, byte* defaultLocation, byte allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, byte, void>)funcTable[599])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, filters, nfilters, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, byte, void>)funcTable[599])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, byte* defaultLocation, bool allowMany)
		{
			ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, byte* defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, byte* defaultLocation, bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, byte* defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, ref byte defaultLocation, bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, ReadOnlySpan<byte> defaultLocation, bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, string defaultLocation, bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, ref byte defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, ReadOnlySpan<byte> defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, string defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, ref byte defaultLocation, bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, ReadOnlySpan<byte> defaultLocation, bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, string defaultLocation, bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, ref byte defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, ReadOnlySpan<byte> defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, string defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowSaveFileDialogNative(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, byte* defaultLocation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, void>)funcTable[600])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, filters, nfilters, defaultLocation);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, void>)funcTable[600])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, byte* defaultLocation)
		{
			ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, defaultLocation);
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, byte* defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, ref byte defaultLocation)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, ReadOnlySpan<byte> defaultLocation)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, SDLDialogFileFilter* filters, int nfilters, string defaultLocation)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, ref byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, SDLDialogFileFilter* filters, int nfilters, string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, ref byte defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref SDLDialogFileFilter filters, int nfilters, string defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, ref byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowSaveFileDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref SDLDialogFileFilter filters, int nfilters, string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFolderDialogNative(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, byte* defaultLocation, byte allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, byte*, byte, void>)funcTable[601])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte, void>)funcTable[601])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, byte* defaultLocation, bool allowMany)
		{
			ShowOpenFolderDialogNative(callback, userdata, window, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, byte* defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ref byte defaultLocation, bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, ReadOnlySpan<byte> defaultLocation, bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, SDLWindow* window, string defaultLocation, bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFolderDialogNative(callback, userdata, window, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ref byte defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, ReadOnlySpan<byte> defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowOpenFolderDialog(SDLDialogFileCallback callback, void* userdata, ref SDLWindow window, string defaultLocation, bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Create and launch a file dialog with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of<br/>
		/// SDL_DialogFileFilter structs, which will be used as filters for<br/>
		/// file-based selections. Ignored if the dialog is an "Open Folder" dialog.<br/>
		/// If non-NULL, the array of filters must remain valid at least until the<br/>
		/// callback is invoked.<br/>
		/// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the<br/>
		/// array of filters, if it exists.<br/>
		/// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should<br/>
		/// be modal for.<br/>
		/// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to<br/>
		/// start the dialog at.<br/>
		/// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select<br/>
		/// more than one entry.<br/>
		/// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.<br/>
		/// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button<br/>
		/// should have.<br/>
		/// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button<br/>
		/// should have.<br/>
		/// Note that each platform may or may not support any of the properties.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowFileDialogWithPropertiesNative(SDLFileDialogType type, SDLDialogFileCallback callback, void* userdata, uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLFileDialogType, delegate*<void*, byte**, int, void>, void*, uint, void>)funcTable[602])(type, (delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, props);
			#else
			((delegate* unmanaged[Cdecl]<SDLFileDialogType, nint, nint, uint, void>)funcTable[602])(type, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, props);
			#endif
		}

		/// <summary>
		/// Create and launch a file dialog with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of<br/>
		/// SDL_DialogFileFilter structs, which will be used as filters for<br/>
		/// file-based selections. Ignored if the dialog is an "Open Folder" dialog.<br/>
		/// If non-NULL, the array of filters must remain valid at least until the<br/>
		/// callback is invoked.<br/>
		/// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the<br/>
		/// array of filters, if it exists.<br/>
		/// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should<br/>
		/// be modal for.<br/>
		/// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to<br/>
		/// start the dialog at.<br/>
		/// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select<br/>
		/// more than one entry.<br/>
		/// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.<br/>
		/// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button<br/>
		/// should have.<br/>
		/// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button<br/>
		/// should have.<br/>
		/// Note that each platform may or may not support any of the properties.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ShowFileDialogWithProperties(SDLFileDialogType type, SDLDialogFileCallback callback, void* userdata, uint props)
		{
			ShowFileDialogWithPropertiesNative(type, callback, userdata, props);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GUIDToStringNative(SdlGuid guid, byte* pszGUID, int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, byte*, int, void>)funcTable[603])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, int, void>)funcTable[603])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, byte* pszGUID, int cbGUID)
		{
			GUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, ref byte pszGUID, int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				GUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GUIDToString(SdlGuid guid, ref string pszGUID, int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid StringToGUIDNative(byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SdlGuid>)funcTable[604])(pchGUID);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[604])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid StringToGUID(byte* pchGUID)
		{
			SdlGuid ret = StringToGUIDNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid StringToGUID(ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid StringToGUID(ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid StringToGUID(string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdlGuid ret = StringToGUIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetPowerInfoNative(int* seconds, int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, SDLPowerState>)funcTable[605])(seconds, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[605])((nint)seconds, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(int* seconds, int* percent)
		{
			SDLPowerState ret = GetPowerInfoNative(seconds, percent);
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(ref int seconds, int* percent)
		{
			fixed (int* pseconds = &seconds)
			{
				SDLPowerState ret = GetPowerInfoNative((int*)pseconds, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(int* seconds, ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetPowerInfoNative(seconds, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetPowerInfo(ref int seconds, ref int percent)
		{
			fixed (int* pseconds = &seconds)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetPowerInfoNative((int*)pseconds, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetSensorsNative(int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[606])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[606])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int* GetSensors(int* count)
		{
			int* ret = GetSensorsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int* GetSensors(ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetSensorsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[607])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[607])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetSensorNameForID(int instanceId)
		{
			byte* ret = GetSensorNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetSensorNameForIDS(int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[608])(instanceId);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[608])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType GetSensorTypeForID(int instanceId)
		{
			SDLSensorType ret = GetSensorTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[609])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[609])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetSensorNonPortableTypeForID(int instanceId)
		{
			int ret = GetSensorNonPortableTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* OpenSensorNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[610])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[610])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensor* OpenSensor(int instanceId)
		{
			SDLSensor* ret = OpenSensorNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* GetSensorFromIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[611])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[611])(instanceId);
			#endif
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensor* GetSensorFromID(int instanceId)
		{
			SDLSensor* ret = GetSensorFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSensorPropertiesNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, uint>)funcTable[612])(sensor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[612])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetSensorProperties(SDLSensor* sensor)
		{
			uint ret = GetSensorPropertiesNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetSensorProperties(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				uint ret = GetSensorPropertiesNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, byte*>)funcTable[613])(sensor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[613])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetSensorName(SDLSensor* sensor)
		{
			byte* ret = GetSensorNameNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetSensorNameS(SDLSensor* sensor)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameNative(sensor));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetSensorName(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte* ret = GetSensorNameNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetSensorNameS(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				string ret = Utils.DecodeStringUTF8(GetSensorNameNative((SDLSensor*)psensor));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, SDLSensorType>)funcTable[614])(sensor);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<nint, SDLSensorType>)funcTable[614])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType GetSensorType(SDLSensor* sensor)
		{
			SDLSensorType ret = GetSensorTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSensorType GetSensorType(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorType ret = GetSensorTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[615])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[615])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetSensorNonPortableType(SDLSensor* sensor)
		{
			int ret = GetSensorNonPortableTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetSensorNonPortableType(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorNonPortableTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorIDNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[616])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[616])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetSensorID(SDLSensor* sensor)
		{
			int ret = GetSensorIDNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetSensorID(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorIDNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSensorDataNative(SDLSensor* sensor, float* data, int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, float*, int, byte>)funcTable[617])(sensor, data, numValues);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[617])((nint)sensor, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSensorData(SDLSensor* sensor, float* data, int numValues)
		{
			byte ret = GetSensorDataNative(sensor, data, numValues);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSensorData(ref SDLSensor sensor, float* data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte ret = GetSensorDataNative((SDLSensor*)psensor, data, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSensorData(SDLSensor* sensor, ref float data, int numValues)
		{
			fixed (float* pdata = &data)
			{
				byte ret = GetSensorDataNative(sensor, (float*)pdata, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetSensorData(ref SDLSensor sensor, ref float data, int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					byte ret = GetSensorDataNative((SDLSensor*)psensor, (float*)pdata, numValues);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseSensorNative(SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSensor*, void>)funcTable[618])(sensor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[618])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseSensor(SDLSensor* sensor)
		{
			CloseSensorNative(sensor);
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseSensor(ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				CloseSensorNative((SDLSensor*)psensor);
			}
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[619])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[619])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		public static void UpdateSensors()
		{
			UpdateSensorsNative();
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[620])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[620])();
			#endif
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		public static void LockJoysticks()
		{
			LockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[621])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[621])();
			#endif
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// </summary>
		public static void UnlockJoysticks()
		{
			UnlockJoysticksNative();
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasJoystickNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[622])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[622])();
			#endif
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HasJoystick()
		{
			byte ret = HasJoystickNative();
			return ret != 0;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetJoysticksNative(int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[623])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[623])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int* GetJoysticks(int* count)
		{
			int* ret = GetJoysticksNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int* GetJoysticks(ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetJoysticksNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[624])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[624])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickNameForID(int instanceId)
		{
			byte* ret = GetJoystickNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickNameForIDS(int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickPathForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[625])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[625])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickPathForID(int instanceId)
		{
			byte* ret = GetJoystickPathForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickPathForIDS(int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickPathForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickPlayerIndexForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[626])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[626])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetJoystickPlayerIndexForID(int instanceId)
		{
			int ret = GetJoystickPlayerIndexForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetJoystickGUIDForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[627])(instanceId);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[627])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GetJoystickGUIDForID(int instanceId)
		{
			SdlGuid ret = GetJoystickGUIDForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickVendorForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[628])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[628])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickVendorForID(int instanceId)
		{
			ushort ret = GetJoystickVendorForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[629])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[629])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickProductForID(int instanceId)
		{
			ushort ret = GetJoystickProductForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductVersionForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[630])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[630])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickProductVersionForID(int instanceId)
		{
			ushort ret = GetJoystickProductVersionForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType GetJoystickTypeForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[631])(instanceId);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[631])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType GetJoystickTypeForID(int instanceId)
		{
			SDLJoystickType ret = GetJoystickTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* OpenJoystickNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[632])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[632])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* OpenJoystick(int instanceId)
		{
			SDLJoystick* ret = OpenJoystickNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetJoystickFromIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[633])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[633])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* GetJoystickFromID(int instanceId)
		{
			SDLJoystick* ret = GetJoystickFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetJoystickFromPlayerIndexNative(int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[634])(playerIndex);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[634])(playerIndex);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* GetJoystickFromPlayerIndex(int playerIndex)
		{
			SDLJoystick* ret = GetJoystickFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AttachVirtualJoystickNative(SDLVirtualJoystickDesc* desc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLVirtualJoystickDesc*, int>)funcTable[635])(desc);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[635])((nint)desc);
			#endif
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AttachVirtualJoystick(SDLVirtualJoystickDesc* desc)
		{
			int ret = AttachVirtualJoystickNative(desc);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AttachVirtualJoystick(ref SDLVirtualJoystickDesc desc)
		{
			fixed (SDLVirtualJoystickDesc* pdesc = &desc)
			{
				int ret = AttachVirtualJoystickNative((SDLVirtualJoystickDesc*)pdesc);
				return ret;
			}
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DetachVirtualJoystickNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[636])(instanceId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[636])(instanceId);
			#endif
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool DetachVirtualJoystick(int instanceId)
		{
			byte ret = DetachVirtualJoystickNative(instanceId);
			return ret != 0;
		}

		/// <summary>
		/// Query whether or not a joystick is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJoystickVirtualNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[637])(instanceId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[637])(instanceId);
			#endif
		}

		/// <summary>
		/// Query whether or not a joystick is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool IsJoystickVirtual(int instanceId)
		{
			byte ret = IsJoystickVirtualNative(instanceId);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualAxisNative(SDLJoystick* joystick, int axis, short value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, byte>)funcTable[638])(joystick, axis, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, short, byte>)funcTable[638])((nint)joystick, axis, value);
			#endif
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualAxis(SDLJoystick* joystick, int axis, short value)
		{
			byte ret = SetJoystickVirtualAxisNative(joystick, axis, value);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualAxis(ref SDLJoystick joystick, int axis, short value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualAxisNative((SDLJoystick*)pjoystick, axis, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualBallNative(SDLJoystick* joystick, int ball, short xrel, short yrel)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, short, byte>)funcTable[639])(joystick, ball, xrel, yrel);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, short, short, byte>)funcTable[639])((nint)joystick, ball, xrel, yrel);
			#endif
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualBall(SDLJoystick* joystick, int ball, short xrel, short yrel)
		{
			byte ret = SetJoystickVirtualBallNative(joystick, ball, xrel, yrel);
			return ret != 0;
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualBall(ref SDLJoystick joystick, int ball, short xrel, short yrel)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualBallNative((SDLJoystick*)pjoystick, ball, xrel, yrel);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualButtonNative(SDLJoystick* joystick, int button, byte down)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, byte>)funcTable[640])(joystick, button, down);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte, byte>)funcTable[640])((nint)joystick, button, down);
			#endif
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualButton(SDLJoystick* joystick, int button, bool down)
		{
			byte ret = SetJoystickVirtualButtonNative(joystick, button, down ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualButton(ref SDLJoystick joystick, int button, bool down)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualButtonNative((SDLJoystick*)pjoystick, button, down ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualHatNative(SDLJoystick* joystick, int hat, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, byte>)funcTable[641])(joystick, hat, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte, byte>)funcTable[641])((nint)joystick, hat, value);
			#endif
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualHat(SDLJoystick* joystick, int hat, byte value)
		{
			byte ret = SetJoystickVirtualHatNative(joystick, hat, value);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualHat(ref SDLJoystick joystick, int hat, byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualHatNative((SDLJoystick*)pjoystick, hat, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualTouchpadNative(SDLJoystick* joystick, int touchpad, int finger, byte down, float x, float y, float pressure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, int, byte, float, float, float, byte>)funcTable[642])(joystick, touchpad, finger, down, x, y, pressure);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte, float, float, float, byte>)funcTable[642])((nint)joystick, touchpad, finger, down, x, y, pressure);
			#endif
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualTouchpad(SDLJoystick* joystick, int touchpad, int finger, bool down, float x, float y, float pressure)
		{
			byte ret = SetJoystickVirtualTouchpadNative(joystick, touchpad, finger, down ? (byte)1 : (byte)0, x, y, pressure);
			return ret != 0;
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickVirtualTouchpad(ref SDLJoystick joystick, int touchpad, int finger, bool down, float x, float y, float pressure)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualTouchpadNative((SDLJoystick*)pjoystick, touchpad, finger, down ? (byte)1 : (byte)0, x, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SendJoystickVirtualSensorDataNative(SDLJoystick* joystick, SDLSensorType type, ulong sensorTimestamp, float* data, int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLSensorType, ulong, float*, int, byte>)funcTable[643])(joystick, type, sensorTimestamp, data, numValues);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, ulong, nint, int, byte>)funcTable[643])((nint)joystick, type, sensorTimestamp, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendJoystickVirtualSensorData(SDLJoystick* joystick, SDLSensorType type, ulong sensorTimestamp, float* data, int numValues)
		{
			byte ret = SendJoystickVirtualSensorDataNative(joystick, type, sensorTimestamp, data, numValues);
			return ret != 0;
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendJoystickVirtualSensorData(ref SDLJoystick joystick, SDLSensorType type, ulong sensorTimestamp, float* data, int numValues)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SendJoystickVirtualSensorDataNative((SDLJoystick*)pjoystick, type, sensorTimestamp, data, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendJoystickVirtualSensorData(SDLJoystick* joystick, SDLSensorType type, ulong sensorTimestamp, ref float data, int numValues)
		{
			fixed (float* pdata = &data)
			{
				byte ret = SendJoystickVirtualSensorDataNative(joystick, type, sensorTimestamp, (float*)pdata, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendJoystickVirtualSensorData(ref SDLJoystick joystick, SDLSensorType type, ulong sensorTimestamp, ref float data, int numValues)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (float* pdata = &data)
				{
					byte ret = SendJoystickVirtualSensorDataNative((SDLJoystick*)pjoystick, type, sensorTimestamp, (float*)pdata, numValues);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetJoystickPropertiesNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, uint>)funcTable[644])(joystick);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[644])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetJoystickProperties(SDLJoystick* joystick)
		{
			uint ret = GetJoystickPropertiesNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetJoystickProperties(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				uint ret = GetJoystickPropertiesNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[645])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[645])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickName(SDLJoystick* joystick)
		{
			byte* ret = GetJoystickNameNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickNameS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickName(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickNameNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickNameS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickNameNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickPathNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[646])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[646])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickPath(SDLJoystick* joystick)
		{
			byte* ret = GetJoystickPathNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickPathS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickPathNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickPath(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickPathNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickPathS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickPathNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickPlayerIndexNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[647])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[647])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetJoystickPlayerIndex(SDLJoystick* joystick)
		{
			int ret = GetJoystickPlayerIndexNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetJoystickPlayerIndex(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetJoystickPlayerIndexNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickPlayerIndexNative(SDLJoystick* joystick, int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[648])(joystick, playerIndex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[648])((nint)joystick, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickPlayerIndex(SDLJoystick* joystick, int playerIndex)
		{
			byte ret = SetJoystickPlayerIndexNative(joystick, playerIndex);
			return ret != 0;
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickPlayerIndex(ref SDLJoystick joystick, int playerIndex)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickPlayerIndexNative((SDLJoystick*)pjoystick, playerIndex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetJoystickGUIDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SdlGuid>)funcTable[649])(joystick);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[649])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GetJoystickGUID(SDLJoystick* joystick)
		{
			SdlGuid ret = GetJoystickGUIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GetJoystickGUID(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SdlGuid ret = GetJoystickGUIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickVendorNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[650])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[650])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickVendor(SDLJoystick* joystick)
		{
			ushort ret = GetJoystickVendorNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickVendor(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickVendorNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[651])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[651])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickProduct(SDLJoystick* joystick)
		{
			ushort ret = GetJoystickProductNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickProduct(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickProductNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductVersionNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[652])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[652])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickProductVersion(SDLJoystick* joystick)
		{
			ushort ret = GetJoystickProductVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickProductVersion(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickProductVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickFirmwareVersionNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[653])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[653])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickFirmwareVersion(SDLJoystick* joystick)
		{
			ushort ret = GetJoystickFirmwareVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetJoystickFirmwareVersion(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickFirmwareVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickSerialNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[654])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[654])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickSerial(SDLJoystick* joystick)
		{
			byte* ret = GetJoystickSerialNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickSerialS(SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickSerialNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetJoystickSerial(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickSerialNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetJoystickSerialS(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickSerialNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType GetJoystickTypeNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickType>)funcTable[655])(joystick);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<nint, SDLJoystickType>)funcTable[655])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType GetJoystickType(SDLJoystick* joystick)
		{
			SDLJoystickType ret = GetJoystickTypeNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickType GetJoystickType(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickType ret = GetJoystickTypeNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetJoystickGUIDInfoNative(SdlGuid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, ushort*, ushort*, ushort*, ushort*, void>)funcTable[656])(guid, vendor, product, version, crc16);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, nint, nint, nint, void>)funcTable[656])(guid, (nint)vendor, (nint)product, (nint)version, (nint)crc16);
			#endif
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16)
		{
			GetJoystickGUIDInfoNative(guid, vendor, product, version, crc16);
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ushort* product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ref ushort product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ref ushort product, ushort* version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ushort* product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pversion = &version)
			{
				GetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ushort* product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ref ushort product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ref ushort product, ref ushort version, ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, crc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ushort* product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pcrc16 = &crc16)
			{
				GetJoystickGUIDInfoNative(guid, vendor, product, version, (ushort*)pcrc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ushort* product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ref ushort product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ref ushort product, ushort* version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ushort* product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pversion = &version)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					GetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ushort* product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ushort* vendor, ref ushort product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GetJoystickGUIDInfo(SdlGuid guid, ref ushort vendor, ref ushort product, ref ushort version, ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						fixed (ushort* pcrc16 = &crc16)
						{
							GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JoystickConnectedNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte>)funcTable[657])(joystick);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[657])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool JoystickConnected(SDLJoystick* joystick)
		{
			byte ret = JoystickConnectedNative(joystick);
			return ret != 0;
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool JoystickConnected(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = JoystickConnectedNative((SDLJoystick*)pjoystick);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickIDNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[658])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[658])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetJoystickID(SDLJoystick* joystick)
		{
			int ret = GetJoystickIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetJoystickID(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetJoystickIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumJoystickAxesNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[659])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[659])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickAxes(SDLJoystick* joystick)
		{
			int ret = GetNumJoystickAxesNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickAxes(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetNumJoystickAxesNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumJoystickBallsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[660])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[660])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickBalls(SDLJoystick* joystick)
		{
			int ret = GetNumJoystickBallsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickBalls(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetNumJoystickBallsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumJoystickHatsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[661])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[661])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickHats(SDLJoystick* joystick)
		{
			int ret = GetNumJoystickHatsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickHats(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetNumJoystickHatsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumJoystickButtonsNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[662])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[662])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickButtons(SDLJoystick* joystick)
		{
			int ret = GetNumJoystickButtonsNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumJoystickButtons(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetNumJoystickButtonsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the state of joystick event processing.<br/>
		/// If joystick events are disabled, you must call SDL_UpdateJoysticks()<br/>
		/// yourself and check the state of the joystick when you want joystick<br/>
		/// information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetJoystickEventsEnabledNative(byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[663])(enabled);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[663])(enabled);
			#endif
		}

		/// <summary>
		/// Set the state of joystick event processing.<br/>
		/// If joystick events are disabled, you must call SDL_UpdateJoysticks()<br/>
		/// yourself and check the state of the joystick when you want joystick<br/>
		/// information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetJoystickEventsEnabled(bool enabled)
		{
			SetJoystickEventsEnabledNative(enabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Query the state of joystick event processing.<br/>
		/// If joystick events are disabled, you must call SDL_UpdateJoysticks()<br/>
		/// yourself and check the state of the joystick when you want joystick<br/>
		/// information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JoystickEventsEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[664])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[664])();
			#endif
		}

		/// <summary>
		/// Query the state of joystick event processing.<br/>
		/// If joystick events are disabled, you must call SDL_UpdateJoysticks()<br/>
		/// yourself and check the state of the joystick when you want joystick<br/>
		/// information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool JoystickEventsEnabled()
		{
			byte ret = JoystickEventsEnabledNative();
			return ret != 0;
		}

		/// <summary>
		/// Update the current state of the open joysticks.<br/>
		/// This is called automatically by the event loop if any joystick events are<br/>
		/// enabled.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[665])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[665])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open joysticks.<br/>
		/// This is called automatically by the event loop if any joystick events are<br/>
		/// enabled.<br/>
		/// <br/>
		/// </summary>
		public static void UpdateJoysticks()
		{
			UpdateJoysticksNative();
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short GetJoystickAxisNative(SDLJoystick* joystick, int axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short>)funcTable[666])(joystick, axis);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)funcTable[666])((nint)joystick, axis);
			#endif
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short GetJoystickAxis(SDLJoystick* joystick, int axis)
		{
			short ret = GetJoystickAxisNative(joystick, axis);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short GetJoystickAxis(ref SDLJoystick joystick, int axis)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				short ret = GetJoystickAxisNative((SDLJoystick*)pjoystick, axis);
				return ret;
			}
		}
	}
}
