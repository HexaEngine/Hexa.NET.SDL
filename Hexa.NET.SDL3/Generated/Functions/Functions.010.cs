// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface** GetSurfaceImagesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int*, SDLSurface**>)funcTable[380])(surface, count);
			#else
			return (SDLSurface**)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[380])((nint)surface, (nint)count);
			#endif
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurface** GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			SDLSurface** ret = GetSurfaceImagesNative(surface, count);
			return ret;
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurface** GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface** ret = GetSurfaceImagesNative((SDLSurface*)psurface, count);
				return ret;
			}
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurface** GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLSurface** ret = GetSurfaceImagesNative(surface, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get an array including all versions of a surface.<br/>
		/// This returns all versions of a surface, with the surface being queried as<br/>
		/// the first element in the returned array.<br/>
		/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
		/// They are still referenced by the surface being queried and will be cleaned<br/>
		/// up normally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceImages")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface * *")]
		public static SDLSurface** GetSurfaceImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (int* pcount = &count)
				{
					SDLSurface** ret = GetSurfaceImagesNative((SDLSurface*)psurface, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Remove all alternate versions of a surface.<br/>
		/// This function removes a reference from all the alternative versions,<br/>
		/// destroying them if this is the last reference to them.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveSurfaceAlternateImages")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveSurfaceAlternateImagesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[381])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[381])((nint)surface);
			#endif
		}

		/// <summary>
		/// Remove all alternate versions of a surface.<br/>
		/// This function removes a reference from all the alternative versions,<br/>
		/// destroying them if this is the last reference to them.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveSurfaceAlternateImages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveSurfaceAlternateImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			RemoveSurfaceAlternateImagesNative(surface);
		}

		/// <summary>
		/// Remove all alternate versions of a surface.<br/>
		/// This function removes a reference from all the alternative versions,<br/>
		/// destroying them if this is the last reference to them.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveSurfaceAlternateImages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveSurfaceAlternateImages([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				RemoveSurfaceAlternateImagesNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[382])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[382])((nint)surface);
			#endif
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			byte ret = LockSurfaceNative(surface);
			return ret != 0;
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = LockSurfaceNative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[383])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[383])((nint)surface);
			#endif
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			UnlockSurfaceNative(surface);
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				UnlockSurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadBMPIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, SDLSurface*>)funcTable[384])(src, closeio);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, byte, nint>)funcTable[384])((nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			SDLSurface* ret = LoadBMPIONative(src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadBMPIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadBMPNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSurface*>)funcTable[385])(file);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[385])((nint)file);
			#endif
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLSurface* ret = LoadBMPNative(file);
			return ret;
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLSurface* ret = LoadBMPNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLSurface* ret = LoadBMPNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image from a file.<br/>
		/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
		/// will result in a memory leak.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMP([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurface* ret = LoadBMPNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveBMPIONative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLIOStream*, byte, byte>)funcTable[386])(surface, dst, closeio);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte>)funcTable[386])((nint)surface, (nint)dst, closeio);
			#endif
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			byte ret = SaveBMPIONative(surface, dst, closeio ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveBMPIONative((SDLSurface*)psurface, dst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				byte ret = SaveBMPIONative(surface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMPIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLIOStream* pdst = &dst)
				{
					byte ret = SaveBMPIONative((SDLSurface*)psurface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveBMPNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[387])(surface, file);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[387])((nint)surface, (nint)file);
			#endif
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			byte ret = SaveBMPNative(surface, file);
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveBMPNative((SDLSurface*)psurface, file);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SaveBMPNative(surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SaveBMPNative(surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveBMPNative(surface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					byte ret = SaveBMPNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					byte ret = SaveBMPNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save a surface to a file.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveBMP([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SaveBMPNative((SDLSurface*)psurface, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[388])(surface, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[388])((nint)surface, enabled);
			#endif
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			byte ret = SetSurfaceRLENative(surface, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceRLENative((SDLSurface*)psurface, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SurfaceHasRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[389])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[389])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			byte ret = SurfaceHasRLENative(surface);
			return ret != 0;
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasRLE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SurfaceHasRLENative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, uint, byte>)funcTable[390])(surface, enabled, key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, uint, byte>)funcTable[390])((nint)surface, enabled, key);
			#endif
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			byte ret = SetSurfaceColorKeyNative(surface, enabled ? (byte)1 : (byte)0, key);
			return ret != 0;
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceColorKeyNative((SDLSurface*)psurface, enabled ? (byte)1 : (byte)0, key);
				return ret != 0;
			}
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SurfaceHasColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte>)funcTable[391])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[391])((nint)surface);
			#endif
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			byte ret = SurfaceHasColorKeyNative(surface);
			return ret != 0;
		}

		/// <summary>
		/// Returns whether the surface has a color key.<br/>
		/// It is safe to pass a NULL `surface` here; it will return false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SurfaceHasColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SurfaceHasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SurfaceHasColorKeyNative((SDLSurface*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint*, byte>)funcTable[392])(surface, key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[392])((nint)surface, (nint)key);
			#endif
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* key)
		{
			byte ret = GetSurfaceColorKeyNative(surface, key);
			return ret != 0;
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceColorKeyNative((SDLSurface*)psurface, key);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint key)
		{
			fixed (uint* pkey = &key)
			{
				byte ret = GetSurfaceColorKeyNative(surface, (uint*)pkey);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorKey")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (uint* pkey = &key)
				{
					byte ret = GetSurfaceColorKeyNative((SDLSurface*)psurface, (uint*)pkey);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte, byte, byte>)funcTable[393])(surface, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte>)funcTable[393])((nint)surface, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			byte ret = SetSurfaceColorModNative(surface, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte*, byte*, byte>)funcTable[394])(surface, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[394])((nint)surface, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			byte ret = GetSurfaceColorModNative(surface, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				byte ret = GetSurfaceColorModNative(surface, (byte*)pr, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				byte ret = GetSurfaceColorModNative(surface, r, (byte*)pg, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, b);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				byte ret = GetSurfaceColorModNative(surface, r, g, (byte*)pb);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative(surface, (byte*)pr, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetSurfaceColorModNative(surface, r, (byte*)pg, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							byte ret = GetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[395])(surface, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[395])((nint)surface, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			byte ret = SetSurfaceAlphaModNative(surface, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[396])(surface, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[396])((nint)surface, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* alpha)
		{
			byte ret = GetSurfaceAlphaModNative(surface, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				byte ret = GetSurfaceAlphaModNative(surface, (byte*)palpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* palpha = &alpha)
				{
					byte ret = GetSurfaceAlphaModNative((SDLSurface*)psurface, (byte*)palpha);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLBlendMode, byte>)funcTable[397])(surface, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, byte>)funcTable[397])((nint)surface, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			byte ret = SetSurfaceBlendModeNative(surface, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLBlendMode*, byte>)funcTable[398])(surface, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[398])((nint)surface, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] SDLBlendMode* blendMode)
		{
			byte ret = GetSurfaceBlendModeNative(surface, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] SDLBlendMode* blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				byte ret = GetSurfaceBlendModeNative(surface, (SDLBlendMode*)pblendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode *")] ref SDLBlendMode blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					byte ret = GetSurfaceBlendModeNative((SDLSurface*)psurface, (SDLBlendMode*)pblendMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetSurfaceClipRectNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, byte>)funcTable[399])(surface, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[399])((nint)surface, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect)
		{
			byte ret = SetSurfaceClipRectNative(surface, rect);
			return ret != 0;
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SetSurfaceClipRectNative((SDLSurface*)psurface, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetSurfaceClipRectNative(surface, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetSurfaceClipRectNative((SDLSurface*)psurface, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSurfaceClipRectNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, byte>)funcTable[400])(surface, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[400])((nint)surface, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect)
		{
			byte ret = GetSurfaceClipRectNative(surface, rect);
			return ret != 0;
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = GetSurfaceClipRectNative((SDLSurface*)psurface, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = GetSurfaceClipRectNative(surface, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceClipRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSurfaceClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = GetSurfaceClipRectNative((SDLSurface*)psurface, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Flip a surface vertically or horizontally.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlipSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FlipSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "SDL_FlipMode")] SDLFlipMode flip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLFlipMode, byte>)funcTable[401])(surface, flip);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLFlipMode, byte>)funcTable[401])((nint)surface, flip);
			#endif
		}

		/// <summary>
		/// Flip a surface vertically or horizontally.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlipSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlipSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "SDL_FlipMode")] SDLFlipMode flip)
		{
			byte ret = FlipSurfaceNative(surface, flip);
			return ret != 0;
		}

		/// <summary>
		/// Flip a surface vertically or horizontally.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlipSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlipSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "SDL_FlipMode")] SDLFlipMode flip)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = FlipSurfaceNative((SDLSurface*)psurface, flip);
				return ret != 0;
			}
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* DuplicateSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLSurface*>)funcTable[402])(surface);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[402])((nint)surface);
			#endif
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* DuplicateSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			SDLSurface* ret = DuplicateSurfaceNative(surface);
			return ret;
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* DuplicateSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = DuplicateSurfaceNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface, scaled to the<br/>
		/// desired size.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScaleSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ScaleSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, SDLScaleMode, SDLSurface*>)funcTable[403])(surface, width, height, scaleMode);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, int, SDLScaleMode, nint>)funcTable[403])((nint)surface, width, height, scaleMode);
			#endif
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface, scaled to the<br/>
		/// desired size.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScaleSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ScaleSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			SDLSurface* ret = ScaleSurfaceNative(surface, width, height, scaleMode);
			return ret;
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface, scaled to the<br/>
		/// desired size.<br/>
		/// The returned surface should be freed with SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ScaleSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ScaleSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = ScaleSurfaceNative((SDLSurface*)psurface, width, height, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// If you are converting to an indexed surface and want to map colors to a<br/>
		/// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ConvertSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPixelFormat, SDLSurface*>)funcTable[404])(surface, format);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, SDLPixelFormat, nint>)funcTable[404])((nint)surface, format);
			#endif
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// If you are converting to an indexed surface and want to map colors to a<br/>
		/// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ConvertSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			SDLSurface* ret = ConvertSurfaceNative(surface, format);
			return ret;
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// If you are converting to an indexed surface and want to map colors to a<br/>
		/// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ConvertSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = ConvertSurfaceNative((SDLSurface*)psurface, format);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceAndColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ConvertSurfaceAndColorspaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPixelFormat, SDLPalette*, SDLColorspace, uint, SDLSurface*>)funcTable[405])(surface, format, palette, colorspace, props);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, SDLPixelFormat, nint, SDLColorspace, uint, nint>)funcTable[405])((nint)surface, format, (nint)palette, colorspace, props);
			#endif
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceAndColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ConvertSurfaceAndColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			SDLSurface* ret = ConvertSurfaceAndColorspaceNative(surface, format, palette, colorspace, props);
			return ret;
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceAndColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ConvertSurfaceAndColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = ConvertSurfaceAndColorspaceNative((SDLSurface*)psurface, format, palette, colorspace, props);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceAndColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ConvertSurfaceAndColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				SDLSurface* ret = ConvertSurfaceAndColorspaceNative(surface, format, (SDLPalette*)ppalette, colorspace, props);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format and<br/>
		/// colorspace.<br/>
		/// This function converts an existing surface to a new format and colorspace<br/>
		/// and returns the new surface. This will perform any pixel format and<br/>
		/// colorspace conversion needed.<br/>
		/// If the original surface has alternate images, the new surface will have a<br/>
		/// reference to them as well.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceAndColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ConvertSurfaceAndColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					SDLSurface* ret = ConvertSurfaceAndColorspaceNative((SDLSurface*)psurface, format, (SDLPalette*)ppalette, colorspace, props);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a block of pixels of one format to another format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ConvertPixelsNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, void*, int, SDLPixelFormat, void*, int, byte>)funcTable[406])(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint, int, SDLPixelFormat, nint, int, byte>)funcTable[406])(width, height, srcFormat, (nint)src, srcPitch, dstFormat, (nint)dst, dstPitch);
			#endif
		}

		/// <summary>
		/// Copy a block of pixels of one format to another format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertPixels")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertPixels([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			byte ret = ConvertPixelsNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			return ret != 0;
		}

		/// <summary>
		/// Copy a block of pixels of one format and colorspace to another format and<br/>
		/// colorspace.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertPixelsAndColorspace")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ConvertPixelsAndColorspaceNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat srcFormat, [NativeName(NativeNameType.Param, "src_colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace srcColorspace, [NativeName(NativeNameType.Param, "src_properties")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint srcProperties, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat dstFormat, [NativeName(NativeNameType.Param, "dst_colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace dstColorspace, [NativeName(NativeNameType.Param, "dst_properties")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dstProperties, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, SDLColorspace, uint, void*, int, SDLPixelFormat, SDLColorspace, uint, void*, int, byte>)funcTable[407])(width, height, srcFormat, srcColorspace, srcProperties, src, srcPitch, dstFormat, dstColorspace, dstProperties, dst, dstPitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, SDLColorspace, uint, nint, int, SDLPixelFormat, SDLColorspace, uint, nint, int, byte>)funcTable[407])(width, height, srcFormat, srcColorspace, srcProperties, (nint)src, srcPitch, dstFormat, dstColorspace, dstProperties, (nint)dst, dstPitch);
			#endif
		}

		/// <summary>
		/// Copy a block of pixels of one format and colorspace to another format and<br/>
		/// colorspace.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertPixelsAndColorspace")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ConvertPixelsAndColorspace([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat srcFormat, [NativeName(NativeNameType.Param, "src_colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace srcColorspace, [NativeName(NativeNameType.Param, "src_properties")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint srcProperties, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat dstFormat, [NativeName(NativeNameType.Param, "dst_colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace dstColorspace, [NativeName(NativeNameType.Param, "dst_properties")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dstProperties, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			byte ret = ConvertPixelsAndColorspaceNative(width, height, srcFormat, srcColorspace, srcProperties, src, srcPitch, dstFormat, dstColorspace, dstProperties, dst, dstPitch);
			return ret != 0;
		}

		/// <summary>
		/// Premultiply the alpha on a block of pixels.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PremultiplyAlpha")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PremultiplyAlphaNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch, [NativeName(NativeNameType.Param, "linear")] [NativeName(NativeNameType.Type, "bool")] byte linear)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, void*, int, SDLPixelFormat, void*, int, byte, byte>)funcTable[408])(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch, linear);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint, int, SDLPixelFormat, nint, int, byte, byte>)funcTable[408])(width, height, srcFormat, (nint)src, srcPitch, dstFormat, (nint)dst, dstPitch, linear);
			#endif
		}

		/// <summary>
		/// Premultiply the alpha on a block of pixels.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PremultiplyAlpha")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PremultiplyAlpha([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "void const *")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void *")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch, [NativeName(NativeNameType.Param, "linear")] [NativeName(NativeNameType.Type, "bool")] bool linear)
		{
			byte ret = PremultiplyAlphaNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch, linear ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Premultiply the alpha in a surface.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PremultiplySurfaceAlpha")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PremultiplySurfaceAlphaNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "linear")] [NativeName(NativeNameType.Type, "bool")] byte linear)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte, byte>)funcTable[409])(surface, linear);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[409])((nint)surface, linear);
			#endif
		}

		/// <summary>
		/// Premultiply the alpha in a surface.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PremultiplySurfaceAlpha")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PremultiplySurfaceAlpha([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "linear")] [NativeName(NativeNameType.Type, "bool")] bool linear)
		{
			byte ret = PremultiplySurfaceAlphaNative(surface, linear ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Premultiply the alpha in a surface.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PremultiplySurfaceAlpha")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PremultiplySurfaceAlpha([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "linear")] [NativeName(NativeNameType.Type, "bool")] bool linear)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = PremultiplySurfaceAlphaNative((SDLSurface*)psurface, linear ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a surface with a specific color, with floating point precision.<br/>
		/// This function handles all surface formats, and ignores any clip rectangle.<br/>
		/// If the surface is YUV, the color is assumed to be in the sRGB colorspace,<br/>
		/// otherwise the color is assumed to be in the colorspace of the suface.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, float, float, float, float, byte>)funcTable[410])(surface, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, byte>)funcTable[410])((nint)surface, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Clear a surface with a specific color, with floating point precision.<br/>
		/// This function handles all surface formats, and ignores any clip rectangle.<br/>
		/// If the surface is YUV, the color is assumed to be in the sRGB colorspace,<br/>
		/// otherwise the color is assumed to be in the colorspace of the suface.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			byte ret = ClearSurfaceNative(surface, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Clear a surface with a specific color, with floating point precision.<br/>
		/// This function handles all surface formats, and ignores any clip rectangle.<br/>
		/// If the surface is YUV, the color is assumed to be in the sRGB colorspace,<br/>
		/// otherwise the color is assumed to be in the colorspace of the suface.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = ClearSurfaceNative((SDLSurface*)psurface, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FillSurfaceRectNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, uint, byte>)funcTable[411])(dst, rect, color);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, uint, byte>)funcTable[411])((nint)dst, (nint)rect, color);
			#endif
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			byte ret = FillSurfaceRectNative(dst, rect, color);
			return ret != 0;
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = FillSurfaceRectNative((SDLSurface*)pdst, rect, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = FillSurfaceRectNative(dst, (SDLRect*)prect, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = FillSurfaceRectNative((SDLSurface*)pdst, (SDLRect*)prect, color);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FillSurfaceRectsNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, int, uint, byte>)funcTable[412])(dst, rects, count, color);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, uint, byte>)funcTable[412])((nint)dst, (nint)rects, count, color);
			#endif
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			byte ret = FillSurfaceRectsNative(dst, rects, count, color);
			return ret != 0;
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = FillSurfaceRectsNative((SDLSurface*)pdst, rects, count, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLRect* prects = &rects)
			{
				byte ret = FillSurfaceRectsNative(dst, (SDLRect*)prects, count, color);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
		/// intersection of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FillSurfaceRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* prects = &rects)
				{
					byte ret = FillSurfaceRectsNative((SDLSurface*)pdst, (SDLRect*)prects, count, color);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, byte>)funcTable[413])(src, srcrect, dst, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[413])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			byte ret = BlitSurfaceNative(src, srcrect, dst, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurfaceNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Performs a fast blit from the source surface to the destination surface.<br/>
		/// This assumes that the source and destination rectangles are the same size.<br/>
		/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
		/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
		/// `dstrect` after all clipping is performed.<br/>
		/// The blit function should not be called on a locked surface.<br/>
		/// The blit semantics for surfaces with and without blending and colorkey are<br/>
		/// defined as follows:<br/>
		/// ```<br/>
		/// RGBA->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// RGBA->RGBA:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
		/// SDL_SRCCOLORKEY ignored.<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy all of RGBA to the destination.<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// RGB values of the source color key, ignoring alpha in the<br/>
		/// comparison.<br/>
		/// RGB->RGB:<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
		/// alpha-blend (using the source per-surface alpha)<br/>
		/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
		/// copy RGB.<br/>
		/// both:<br/>
		/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
		/// source color key.<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceUncheckedNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, byte>)funcTable[414])(src, srcrect, dst, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[414])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			byte ret = BlitSurfaceUncheckedNative(src, srcrect, dst, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceUncheckedNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurfaceUncheckedNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceUncheckedNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceUncheckedNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUnchecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUnchecked([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceUncheckedNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceScaledNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, SDLScaleMode, byte>)funcTable[415])(src, srcrect, dst, dstrect, scaleMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, SDLScaleMode, byte>)funcTable[415])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect, scaleMode);
			#endif
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			byte ret = BlitSurfaceScaledNative(src, srcrect, dst, dstrect, scaleMode);
			return ret != 0;
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				byte ret = BlitSurfaceScaledNative(src, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					byte ret = BlitSurfaceScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						byte ret = BlitSurfaceScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled blit to a destination surface, which may be of a different<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							byte ret = BlitSurfaceScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect, scaleMode);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BlitSurfaceUncheckedScaledNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRect*, SDLSurface*, SDLRect*, SDLScaleMode, byte>)funcTable[416])(src, srcrect, dst, dstrect, scaleMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, SDLScaleMode, byte>)funcTable[416])((nint)src, (nint)srcrect, (nint)dst, (nint)dstrect, scaleMode);
			#endif
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			byte ret = BlitSurfaceUncheckedScaledNative(src, srcrect, dst, dstrect, scaleMode);
			return ret != 0;
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, srcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				byte ret = BlitSurfaceUncheckedScaledNative(src, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				byte ret = BlitSurfaceUncheckedScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					byte ret = BlitSurfaceUncheckedScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// The same destination surface should not be used from two<br/>
		/// threads at once. It is safe to use the same source surface<br/>
		/// from multiple threads.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitSurfaceUncheckedScaled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BlitSurfaceUncheckedScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						byte ret = BlitSurfaceUncheckedScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect, scaleMode);
						return ret != 0;
					}
				}
			}
		}
	}
}
