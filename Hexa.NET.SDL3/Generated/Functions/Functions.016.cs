// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetJoystickAxisInitialStateNative(SDLJoystick* joystick, int axis, short* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short*, byte>)funcTable[667])(joystick, axis, state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, byte>)funcTable[667])((nint)joystick, axis, (nint)state);
			#endif
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickAxisInitialState(SDLJoystick* joystick, int axis, short* state)
		{
			byte ret = GetJoystickAxisInitialStateNative(joystick, axis, state);
			return ret != 0;
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickAxisInitialState(ref SDLJoystick joystick, int axis, short* state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = GetJoystickAxisInitialStateNative((SDLJoystick*)pjoystick, axis, state);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickAxisInitialState(SDLJoystick* joystick, int axis, ref short state)
		{
			fixed (short* pstate = &state)
			{
				byte ret = GetJoystickAxisInitialStateNative(joystick, axis, (short*)pstate);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickAxisInitialState(ref SDLJoystick joystick, int axis, ref short state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (short* pstate = &state)
				{
					byte ret = GetJoystickAxisInitialStateNative((SDLJoystick*)pjoystick, axis, (short*)pstate);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetJoystickBallNative(SDLJoystick* joystick, int ball, int* dx, int* dy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, int*, int*, byte>)funcTable[668])(joystick, ball, dx, dy);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, byte>)funcTable[668])((nint)joystick, ball, (nint)dx, (nint)dy);
			#endif
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(SDLJoystick* joystick, int ball, int* dx, int* dy)
		{
			byte ret = GetJoystickBallNative(joystick, ball, dx, dy);
			return ret != 0;
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(ref SDLJoystick joystick, int ball, int* dx, int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = GetJoystickBallNative((SDLJoystick*)pjoystick, ball, dx, dy);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(SDLJoystick* joystick, int ball, ref int dx, int* dy)
		{
			fixed (int* pdx = &dx)
			{
				byte ret = GetJoystickBallNative(joystick, ball, (int*)pdx, dy);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(ref SDLJoystick joystick, int ball, ref int dx, int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					byte ret = GetJoystickBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, dy);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(SDLJoystick* joystick, int ball, int* dx, ref int dy)
		{
			fixed (int* pdy = &dy)
			{
				byte ret = GetJoystickBallNative(joystick, ball, dx, (int*)pdy);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(ref SDLJoystick joystick, int ball, int* dx, ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdy = &dy)
				{
					byte ret = GetJoystickBallNative((SDLJoystick*)pjoystick, ball, dx, (int*)pdy);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(SDLJoystick* joystick, int ball, ref int dx, ref int dy)
		{
			fixed (int* pdx = &dx)
			{
				fixed (int* pdy = &dy)
				{
					byte ret = GetJoystickBallNative(joystick, ball, (int*)pdx, (int*)pdy);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickBall(ref SDLJoystick joystick, int ball, ref int dx, ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					fixed (int* pdy = &dy)
					{
						byte ret = GetJoystickBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, (int*)pdy);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the `SDL_HAT_*` values.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetJoystickHatNative(SDLJoystick* joystick, int hat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[669])(joystick, hat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[669])((nint)joystick, hat);
			#endif
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the `SDL_HAT_*` values.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte GetJoystickHat(SDLJoystick* joystick, int hat)
		{
			byte ret = GetJoystickHatNative(joystick, hat);
			return ret;
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the `SDL_HAT_*` values.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte GetJoystickHat(ref SDLJoystick joystick, int hat)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = GetJoystickHatNative((SDLJoystick*)pjoystick, hat);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetJoystickButtonNative(SDLJoystick* joystick, int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[670])(joystick, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[670])((nint)joystick, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickButton(SDLJoystick* joystick, int button)
		{
			byte ret = GetJoystickButtonNative(joystick, button);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetJoystickButton(ref SDLJoystick joystick, int button)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = GetJoystickButtonNative((SDLJoystick*)pjoystick, button);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RumbleJoystickNative(SDLJoystick* joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort, ushort, uint, byte>)funcTable[671])(joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, byte>)funcTable[671])((nint)joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleJoystick(SDLJoystick* joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			byte ret = RumbleJoystickNative(joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret != 0;
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleJoystick(ref SDLJoystick joystick, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = RumbleJoystickNative((SDLJoystick*)pjoystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_RumbleJoystick()<br/>
		/// instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RumbleJoystickTriggersNative(SDLJoystick* joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort, ushort, uint, byte>)funcTable[672])(joystick, leftRumble, rightRumble, durationMs);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, byte>)funcTable[672])((nint)joystick, leftRumble, rightRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_RumbleJoystick()<br/>
		/// instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleJoystickTriggers(SDLJoystick* joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			byte ret = RumbleJoystickTriggersNative(joystick, leftRumble, rightRumble, durationMs);
			return ret != 0;
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_RumbleJoystick()<br/>
		/// instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleJoystickTriggers(ref SDLJoystick joystick, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = RumbleJoystickTriggersNative((SDLJoystick*)pjoystick, leftRumble, rightRumble, durationMs);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For joysticks with a single color LED, the maximum of the RGB values will<br/>
		/// be used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickLEDNative(SDLJoystick* joystick, byte red, byte green, byte blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte, byte, byte, byte>)funcTable[673])(joystick, red, green, blue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte>)funcTable[673])((nint)joystick, red, green, blue);
			#endif
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For joysticks with a single color LED, the maximum of the RGB values will<br/>
		/// be used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickLED(SDLJoystick* joystick, byte red, byte green, byte blue)
		{
			byte ret = SetJoystickLEDNative(joystick, red, green, blue);
			return ret != 0;
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For joysticks with a single color LED, the maximum of the RGB values will<br/>
		/// be used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetJoystickLED(ref SDLJoystick joystick, byte red, byte green, byte blue)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickLEDNative((SDLJoystick*)pjoystick, red, green, blue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a joystick specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SendJoystickEffectNative(SDLJoystick* joystick, void* data, int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, void*, int, byte>)funcTable[674])(joystick, data, size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[674])((nint)joystick, (nint)data, size);
			#endif
		}

		/// <summary>
		/// Send a joystick specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendJoystickEffect(SDLJoystick* joystick, void* data, int size)
		{
			byte ret = SendJoystickEffectNative(joystick, data, size);
			return ret != 0;
		}

		/// <summary>
		/// Send a joystick specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendJoystickEffect(ref SDLJoystick joystick, void* data, int size)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SendJoystickEffectNative((SDLJoystick*)pjoystick, data, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_OpenJoystick().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseJoystickNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLJoystick*, void>)funcTable[675])(joystick);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[675])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_OpenJoystick().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseJoystick(SDLJoystick* joystick)
		{
			CloseJoystickNative(joystick);
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_OpenJoystick().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseJoystick(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				CloseJoystickNative((SDLJoystick*)pjoystick);
			}
		}

		/// <summary>
		/// Get the connection state of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickConnectionState GetJoystickConnectionStateNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickConnectionState>)funcTable[676])(joystick);
			#else
			return (SDLJoystickConnectionState)((delegate* unmanaged[Cdecl]<nint, SDLJoystickConnectionState>)funcTable[676])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the connection state of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickConnectionState GetJoystickConnectionState(SDLJoystick* joystick)
		{
			SDLJoystickConnectionState ret = GetJoystickConnectionStateNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the connection state of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickConnectionState GetJoystickConnectionState(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickConnectionState ret = GetJoystickConnectionStateNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a joystick.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetJoystickPowerInfoNative(SDLJoystick* joystick, int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int*, SDLPowerState>)funcTable[677])(joystick, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[677])((nint)joystick, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the battery state of a joystick.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetJoystickPowerInfo(SDLJoystick* joystick, int* percent)
		{
			SDLPowerState ret = GetJoystickPowerInfoNative(joystick, percent);
			return ret;
		}

		/// <summary>
		/// Get the battery state of a joystick.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetJoystickPowerInfo(ref SDLJoystick joystick, int* percent)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLPowerState ret = GetJoystickPowerInfoNative((SDLJoystick*)pjoystick, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a joystick.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetJoystickPowerInfo(SDLJoystick* joystick, ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetJoystickPowerInfoNative(joystick, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a joystick.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetJoystickPowerInfo(ref SDLJoystick joystick, ref int percent)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetJoystickPowerInfoNative((SDLJoystick*)pjoystick, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Add support for gamepads that SDL is unaware of or change the binding of an<br/>
		/// existing gamepad.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_GUIDToString(), name is the human readable string for<br/>
		/// the device and mappings are gamepad mappings to joystick ones. Under<br/>
		/// Windows there is a reserved GUID of "xinput" that covers all XInput<br/>
		/// devices. The mapping format for joystick is:<br/>
		/// - `bX`: a joystick button, index X<br/>
		/// - `hX.Y`: hat X with value Y<br/>
		/// - `aX`: axis X of the joystick<br/>
		/// Buttons can be used as a gamepad axes and vice versa.<br/>
		/// If a device with this GUID is already plugged in, SDL will generate an<br/>
		/// SDL_EVENT_GAMEPAD_ADDED event.<br/>
		/// This string shows an example of a valid mapping for a gamepad:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddGamepadMappingNative(byte* mapping)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[678])(mapping);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[678])((nint)mapping);
			#endif
		}

		/// <summary>
		/// Add support for gamepads that SDL is unaware of or change the binding of an<br/>
		/// existing gamepad.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_GUIDToString(), name is the human readable string for<br/>
		/// the device and mappings are gamepad mappings to joystick ones. Under<br/>
		/// Windows there is a reserved GUID of "xinput" that covers all XInput<br/>
		/// devices. The mapping format for joystick is:<br/>
		/// - `bX`: a joystick button, index X<br/>
		/// - `hX.Y`: hat X with value Y<br/>
		/// - `aX`: axis X of the joystick<br/>
		/// Buttons can be used as a gamepad axes and vice versa.<br/>
		/// If a device with this GUID is already plugged in, SDL will generate an<br/>
		/// SDL_EVENT_GAMEPAD_ADDED event.<br/>
		/// This string shows an example of a valid mapping for a gamepad:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMapping(byte* mapping)
		{
			int ret = AddGamepadMappingNative(mapping);
			return ret;
		}

		/// <summary>
		/// Add support for gamepads that SDL is unaware of or change the binding of an<br/>
		/// existing gamepad.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_GUIDToString(), name is the human readable string for<br/>
		/// the device and mappings are gamepad mappings to joystick ones. Under<br/>
		/// Windows there is a reserved GUID of "xinput" that covers all XInput<br/>
		/// devices. The mapping format for joystick is:<br/>
		/// - `bX`: a joystick button, index X<br/>
		/// - `hX.Y`: hat X with value Y<br/>
		/// - `aX`: axis X of the joystick<br/>
		/// Buttons can be used as a gamepad axes and vice versa.<br/>
		/// If a device with this GUID is already plugged in, SDL will generate an<br/>
		/// SDL_EVENT_GAMEPAD_ADDED event.<br/>
		/// This string shows an example of a valid mapping for a gamepad:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMapping(ref byte mapping)
		{
			fixed (byte* pmapping = &mapping)
			{
				int ret = AddGamepadMappingNative((byte*)pmapping);
				return ret;
			}
		}

		/// <summary>
		/// Add support for gamepads that SDL is unaware of or change the binding of an<br/>
		/// existing gamepad.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_GUIDToString(), name is the human readable string for<br/>
		/// the device and mappings are gamepad mappings to joystick ones. Under<br/>
		/// Windows there is a reserved GUID of "xinput" that covers all XInput<br/>
		/// devices. The mapping format for joystick is:<br/>
		/// - `bX`: a joystick button, index X<br/>
		/// - `hX.Y`: hat X with value Y<br/>
		/// - `aX`: axis X of the joystick<br/>
		/// Buttons can be used as a gamepad axes and vice versa.<br/>
		/// If a device with this GUID is already plugged in, SDL will generate an<br/>
		/// SDL_EVENT_GAMEPAD_ADDED event.<br/>
		/// This string shows an example of a valid mapping for a gamepad:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMapping(ReadOnlySpan<byte> mapping)
		{
			fixed (byte* pmapping = mapping)
			{
				int ret = AddGamepadMappingNative((byte*)pmapping);
				return ret;
			}
		}

		/// <summary>
		/// Add support for gamepads that SDL is unaware of or change the binding of an<br/>
		/// existing gamepad.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_GUIDToString(), name is the human readable string for<br/>
		/// the device and mappings are gamepad mappings to joystick ones. Under<br/>
		/// Windows there is a reserved GUID of "xinput" that covers all XInput<br/>
		/// devices. The mapping format for joystick is:<br/>
		/// - `bX`: a joystick button, index X<br/>
		/// - `hX.Y`: hat X with value Y<br/>
		/// - `aX`: axis X of the joystick<br/>
		/// Buttons can be used as a gamepad axes and vice versa.<br/>
		/// If a device with this GUID is already plugged in, SDL will generate an<br/>
		/// SDL_EVENT_GAMEPAD_ADDED event.<br/>
		/// This string shows an example of a valid mapping for a gamepad:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMapping(string mapping)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mapping != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mapping);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mapping, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AddGamepadMappingNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load a set of gamepad mappings from an SDL_IOStream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddGamepadMappingsFromIONative(SDLIOStream* src, byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, int>)funcTable[679])(src, closeio);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)funcTable[679])((nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load a set of gamepad mappings from an SDL_IOStream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMappingsFromIO(SDLIOStream* src, bool closeio)
		{
			int ret = AddGamepadMappingsFromIONative(src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load a set of gamepad mappings from an SDL_IOStream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMappingsFromIO(ref SDLIOStream src, bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = AddGamepadMappingsFromIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load a set of gamepad mappings from a file.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AddGamepadMappingsFromFileNative(byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[680])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[680])((nint)file);
			#endif
		}

		/// <summary>
		/// Load a set of gamepad mappings from a file.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMappingsFromFile(byte* file)
		{
			int ret = AddGamepadMappingsFromFileNative(file);
			return ret;
		}

		/// <summary>
		/// Load a set of gamepad mappings from a file.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMappingsFromFile(ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				int ret = AddGamepadMappingsFromFileNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a set of gamepad mappings from a file.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMappingsFromFile(ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				int ret = AddGamepadMappingsFromFileNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load a set of gamepad mappings from a file.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Any new mappings for already plugged in controllers will generate<br/>
		/// SDL_EVENT_GAMEPAD_ADDED events.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int AddGamepadMappingsFromFile(string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AddGamepadMappingsFromFileNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reinitialize the SDL mapping database to its initial state.<br/>
		/// This will generate gamepad events as needed if device mappings change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReloadGamepadMappingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[681])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[681])();
			#endif
		}

		/// <summary>
		/// Reinitialize the SDL mapping database to its initial state.<br/>
		/// This will generate gamepad events as needed if device mappings change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ReloadGamepadMappings()
		{
			byte ret = ReloadGamepadMappingsNative();
			return ret != 0;
		}

		/// <summary>
		/// Get the current gamepad mappings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GetGamepadMappingsNative(int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte**>)funcTable[682])(count);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[682])((nint)count);
			#endif
		}

		/// <summary>
		/// Get the current gamepad mappings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte** GetGamepadMappings(int* count)
		{
			byte** ret = GetGamepadMappingsNative(count);
			return ret;
		}

		/// <summary>
		/// Get the current gamepad mappings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte** GetGamepadMappings(ref int count)
		{
			fixed (int* pcount = &count)
			{
				byte** ret = GetGamepadMappingsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the gamepad mapping string for a given GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadMappingForGUIDNative(SdlGuid guid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SdlGuid, byte*>)funcTable[683])(guid);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SdlGuid, nint>)funcTable[683])(guid);
			#endif
		}

		/// <summary>
		/// Get the gamepad mapping string for a given GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadMappingForGUID(SdlGuid guid)
		{
			byte* ret = GetGamepadMappingForGUIDNative(guid);
			return ret;
		}

		/// <summary>
		/// Get the gamepad mapping string for a given GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadMappingForGUIDS(SdlGuid guid)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadMappingForGUIDNative(guid));
			return ret;
		}

		/// <summary>
		/// Get the current mapping of a gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadMappingNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte*>)funcTable[684])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[684])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the current mapping of a gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadMapping(SDLGamepad* gamepad)
		{
			byte* ret = GetGamepadMappingNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the current mapping of a gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadMappingS(SDLGamepad* gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadMappingNative(gamepad));
			return ret;
		}

		/// <summary>
		/// Get the current mapping of a gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadMapping(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadMappingNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the current mapping of a gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadMappingS(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadMappingNative((SDLGamepad*)pgamepad));
				return ret;
			}
		}

		/// <summary>
		/// Set the current mapping of a joystick or gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGamepadMappingNative(int instanceId, byte* mapping)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, byte>)funcTable[685])(instanceId, mapping);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, nint, byte>)funcTable[685])(instanceId, (nint)mapping);
			#endif
		}

		/// <summary>
		/// Set the current mapping of a joystick or gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadMapping(int instanceId, byte* mapping)
		{
			byte ret = SetGamepadMappingNative(instanceId, mapping);
			return ret != 0;
		}

		/// <summary>
		/// Set the current mapping of a joystick or gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadMapping(int instanceId, ref byte mapping)
		{
			fixed (byte* pmapping = &mapping)
			{
				byte ret = SetGamepadMappingNative(instanceId, (byte*)pmapping);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the current mapping of a joystick or gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadMapping(int instanceId, ReadOnlySpan<byte> mapping)
		{
			fixed (byte* pmapping = mapping)
			{
				byte ret = SetGamepadMappingNative(instanceId, (byte*)pmapping);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the current mapping of a joystick or gamepad.<br/>
		/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadMapping(int instanceId, string mapping)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mapping != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mapping);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mapping, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetGamepadMappingNative(instanceId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Return whether a gamepad is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasGamepadNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[686])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[686])();
			#endif
		}

		/// <summary>
		/// Return whether a gamepad is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HasGamepad()
		{
			byte ret = HasGamepadNative();
			return ret != 0;
		}

		/// <summary>
		/// Get a list of currently connected gamepads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetGamepadsNative(int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[687])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[687])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected gamepads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int* GetGamepads(int* count)
		{
			int* ret = GetGamepadsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected gamepads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int* GetGamepads(ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetGamepadsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Check if the given joystick is supported by the gamepad interface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGamepadNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[688])(instanceId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[688])(instanceId);
			#endif
		}

		/// <summary>
		/// Check if the given joystick is supported by the gamepad interface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool IsGamepad(int instanceId)
		{
			byte ret = IsGamepadNative(instanceId);
			return ret != 0;
		}

		/// <summary>
		/// Get the implementation dependent name of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadNameForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[689])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[689])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadNameForID(int instanceId)
		{
			byte* ret = GetGamepadNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadNameForIDS(int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadPathForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[690])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[690])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadPathForID(int instanceId)
		{
			byte* ret = GetGamepadPathForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadPathForIDS(int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadPathForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the player index of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadPlayerIndexForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[691])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[691])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the player index of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetGamepadPlayerIndexForID(int instanceId)
		{
			int ret = GetGamepadPlayerIndexForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetGamepadGUIDForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[692])(instanceId);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[692])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SdlGuid GetGamepadGUIDForID(int instanceId)
		{
			SdlGuid ret = GetGamepadGUIDForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a gamepad, if available.<br/>
		/// This can be called before any gamepads are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadVendorForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[693])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[693])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of a gamepad, if available.<br/>
		/// This can be called before any gamepads are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadVendorForID(int instanceId)
		{
			ushort ret = GetGamepadVendorForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a gamepad, if available.<br/>
		/// This can be called before any gamepads are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadProductForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[694])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[694])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of a gamepad, if available.<br/>
		/// This can be called before any gamepads are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadProductForID(int instanceId)
		{
			ushort ret = GetGamepadProductForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the product version of a gamepad, if available.<br/>
		/// This can be called before any gamepads are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadProductVersionForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[695])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[695])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the product version of a gamepad, if available.<br/>
		/// This can be called before any gamepads are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadProductVersionForID(int instanceId)
		{
			ushort ret = GetGamepadProductVersionForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the type of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetGamepadTypeForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGamepadType>)funcTable[696])(instanceId);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<int, SDLGamepadType>)funcTable[696])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetGamepadTypeForID(int instanceId)
		{
			SDLGamepadType ret = GetGamepadTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the type of a gamepad, ignoring any mapping override.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetRealGamepadTypeForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGamepadType>)funcTable[697])(instanceId);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<int, SDLGamepadType>)funcTable[697])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a gamepad, ignoring any mapping override.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetRealGamepadTypeForID(int instanceId)
		{
			SDLGamepadType ret = GetRealGamepadTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the mapping of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadMappingForIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[698])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[698])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the mapping of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadMappingForID(int instanceId)
		{
			byte* ret = GetGamepadMappingForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the mapping of a gamepad.<br/>
		/// This can be called before any gamepads are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadMappingForIDS(int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadMappingForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Open a gamepad for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepad* OpenGamepadNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGamepad*>)funcTable[699])(instanceId);
			#else
			return (SDLGamepad*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[699])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a gamepad for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepad* OpenGamepad(int instanceId)
		{
			SDLGamepad* ret = OpenGamepadNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Gamepad associated with a joystick instance ID, if it has been<br/>
		/// opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepad* GetGamepadFromIDNative(int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGamepad*>)funcTable[700])(instanceId);
			#else
			return (SDLGamepad*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[700])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Gamepad associated with a joystick instance ID, if it has been<br/>
		/// opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepad* GetGamepadFromID(int instanceId)
		{
			SDLGamepad* ret = GetGamepadFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Gamepad associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepad* GetGamepadFromPlayerIndexNative(int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLGamepad*>)funcTable[701])(playerIndex);
			#else
			return (SDLGamepad*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[701])(playerIndex);
			#endif
		}

		/// <summary>
		/// Get the SDL_Gamepad associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepad* GetGamepadFromPlayerIndex(int playerIndex)
		{
			SDLGamepad* ret = GetGamepadFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with an opened gamepad.<br/>
		/// These properties are shared with the underlying joystick object.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED<br/>
		/// that has adjustable brightness<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGamepadPropertiesNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, uint>)funcTable[702])(gamepad);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[702])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the properties associated with an opened gamepad.<br/>
		/// These properties are shared with the underlying joystick object.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED<br/>
		/// that has adjustable brightness<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGamepadProperties(SDLGamepad* gamepad)
		{
			uint ret = GetGamepadPropertiesNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with an opened gamepad.<br/>
		/// These properties are shared with the underlying joystick object.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED<br/>
		/// that has adjustable brightness<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetGamepadProperties(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				uint ret = GetGamepadPropertiesNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadIDNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int>)funcTable[703])(gamepad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[703])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetGamepadID(SDLGamepad* gamepad)
		{
			int ret = GetGamepadIDNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetGamepadID(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetGamepadIDNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadNameNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte*>)funcTable[704])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[704])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadName(SDLGamepad* gamepad)
		{
			byte* ret = GetGamepadNameNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadNameS(SDLGamepad* gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadNameNative(gamepad));
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadName(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadNameNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadNameS(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadNameNative((SDLGamepad*)pgamepad));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadPathNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte*>)funcTable[705])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[705])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadPath(SDLGamepad* gamepad)
		{
			byte* ret = GetGamepadPathNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadPathS(SDLGamepad* gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadPathNative(gamepad));
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadPath(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadPathNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadPathS(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadPathNative((SDLGamepad*)pgamepad));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetGamepadTypeNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadType>)funcTable[706])(gamepad);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<nint, SDLGamepadType>)funcTable[706])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the type of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetGamepadType(SDLGamepad* gamepad)
		{
			SDLGamepadType ret = GetGamepadTypeNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetGamepadType(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadType ret = GetGamepadTypeNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened gamepad, ignoring any mapping override.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetRealGamepadTypeNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadType>)funcTable[707])(gamepad);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<nint, SDLGamepadType>)funcTable[707])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the type of an opened gamepad, ignoring any mapping override.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetRealGamepadType(SDLGamepad* gamepad)
		{
			SDLGamepadType ret = GetRealGamepadTypeNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened gamepad, ignoring any mapping override.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetRealGamepadType(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadType ret = GetRealGamepadTypeNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened gamepad.<br/>
		/// For XInput gamepads this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadPlayerIndexNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int>)funcTable[708])(gamepad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[708])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened gamepad.<br/>
		/// For XInput gamepads this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetGamepadPlayerIndex(SDLGamepad* gamepad)
		{
			int ret = GetGamepadPlayerIndexNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened gamepad.<br/>
		/// For XInput gamepads this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetGamepadPlayerIndex(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetGamepadPlayerIndexNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGamepadPlayerIndexNative(SDLGamepad* gamepad, int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, byte>)funcTable[709])(gamepad, playerIndex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[709])((nint)gamepad, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadPlayerIndex(SDLGamepad* gamepad, int playerIndex)
		{
			byte ret = SetGamepadPlayerIndexNative(gamepad, playerIndex);
			return ret != 0;
		}

		/// <summary>
		/// Set the player index of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadPlayerIndex(ref SDLGamepad gamepad, int playerIndex)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SetGamepadPlayerIndexNative((SDLGamepad*)pgamepad, playerIndex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened gamepad, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadVendorNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[710])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[710])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened gamepad, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadVendor(SDLGamepad* gamepad)
		{
			ushort ret = GetGamepadVendorNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened gamepad, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadVendor(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadVendorNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened gamepad, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadProductNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[711])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[711])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened gamepad, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadProduct(SDLGamepad* gamepad)
		{
			ushort ret = GetGamepadProductNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened gamepad, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadProduct(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadProductNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened gamepad, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadProductVersionNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[712])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[712])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened gamepad, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadProductVersion(SDLGamepad* gamepad)
		{
			ushort ret = GetGamepadProductVersionNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened gamepad, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadProductVersion(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadProductVersionNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened gamepad, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadFirmwareVersionNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[713])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[713])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened gamepad, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadFirmwareVersion(SDLGamepad* gamepad)
		{
			ushort ret = GetGamepadFirmwareVersionNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened gamepad, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ushort GetGamepadFirmwareVersion(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadFirmwareVersionNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadSerialNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte*>)funcTable[714])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[714])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadSerial(SDLGamepad* gamepad)
		{
			byte* ret = GetGamepadSerialNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadSerialS(SDLGamepad* gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadSerialNative(gamepad));
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadSerial(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadSerialNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadSerialS(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadSerialNative((SDLGamepad*)pgamepad));
				return ret;
			}
		}

		/// <summary>
		/// Get the Steam Input handle of an opened gamepad, if available.<br/>
		/// Returns an InputHandle_t for the gamepad that can be used with Steam Input<br/>
		/// API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetGamepadSteamHandleNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ulong>)funcTable[715])(gamepad);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[715])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the Steam Input handle of an opened gamepad, if available.<br/>
		/// Returns an InputHandle_t for the gamepad that can be used with Steam Input<br/>
		/// API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetGamepadSteamHandle(SDLGamepad* gamepad)
		{
			ulong ret = GetGamepadSteamHandleNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the Steam Input handle of an opened gamepad, if available.<br/>
		/// Returns an InputHandle_t for the gamepad that can be used with Steam Input<br/>
		/// API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetGamepadSteamHandle(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ulong ret = GetGamepadSteamHandleNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the connection state of a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickConnectionState GetGamepadConnectionStateNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLJoystickConnectionState>)funcTable[716])(gamepad);
			#else
			return (SDLJoystickConnectionState)((delegate* unmanaged[Cdecl]<nint, SDLJoystickConnectionState>)funcTable[716])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the connection state of a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickConnectionState GetGamepadConnectionState(SDLGamepad* gamepad)
		{
			SDLJoystickConnectionState ret = GetGamepadConnectionStateNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the connection state of a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystickConnectionState GetGamepadConnectionState(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLJoystickConnectionState ret = GetGamepadConnectionStateNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetGamepadPowerInfoNative(SDLGamepad* gamepad, int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int*, SDLPowerState>)funcTable[717])(gamepad, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[717])((nint)gamepad, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetGamepadPowerInfo(SDLGamepad* gamepad, int* percent)
		{
			SDLPowerState ret = GetGamepadPowerInfoNative(gamepad, percent);
			return ret;
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetGamepadPowerInfo(ref SDLGamepad gamepad, int* percent)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLPowerState ret = GetGamepadPowerInfoNative((SDLGamepad*)pgamepad, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetGamepadPowerInfo(SDLGamepad* gamepad, ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetGamepadPowerInfoNative(gamepad, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLPowerState GetGamepadPowerInfo(ref SDLGamepad gamepad, ref int percent)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetGamepadPowerInfoNative((SDLGamepad*)pgamepad, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Check if a gamepad has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadConnectedNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte>)funcTable[718])(gamepad);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[718])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Check if a gamepad has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadConnected(SDLGamepad* gamepad)
		{
			byte ret = GamepadConnectedNative(gamepad);
			return ret != 0;
		}

		/// <summary>
		/// Check if a gamepad has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadConnected(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadConnectedNative((SDLGamepad*)pgamepad);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the underlying joystick from a gamepad.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful<br/>
		/// for getting a joystick's position at any given time, even if it hasn't<br/>
		/// moved (moving it would produce an event, which would have the axis' value).<br/>
		/// The pointer returned is owned by the SDL_Gamepad. You should not call<br/>
		/// SDL_CloseJoystick() on it, for example, since doing so will likely cause<br/>
		/// SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetGamepadJoystickNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLJoystick*>)funcTable[719])(gamepad);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[719])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the underlying joystick from a gamepad.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful<br/>
		/// for getting a joystick's position at any given time, even if it hasn't<br/>
		/// moved (moving it would produce an event, which would have the axis' value).<br/>
		/// The pointer returned is owned by the SDL_Gamepad. You should not call<br/>
		/// SDL_CloseJoystick() on it, for example, since doing so will likely cause<br/>
		/// SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* GetGamepadJoystick(SDLGamepad* gamepad)
		{
			SDLJoystick* ret = GetGamepadJoystickNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the underlying joystick from a gamepad.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful<br/>
		/// for getting a joystick's position at any given time, even if it hasn't<br/>
		/// moved (moving it would produce an event, which would have the axis' value).<br/>
		/// The pointer returned is owned by the SDL_Gamepad. You should not call<br/>
		/// SDL_CloseJoystick() on it, for example, since doing so will likely cause<br/>
		/// SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLJoystick* GetGamepadJoystick(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLJoystick* ret = GetGamepadJoystickNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Set the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGamepadEventsEnabledNative(byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[720])(enabled);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[720])(enabled);
			#endif
		}

		/// <summary>
		/// Set the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetGamepadEventsEnabled(bool enabled)
		{
			SetGamepadEventsEnabledNative(enabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Query the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadEventsEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[721])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[721])();
			#endif
		}

		/// <summary>
		/// Query the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadEventsEnabled()
		{
			byte ret = GamepadEventsEnabledNative();
			return ret != 0;
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadBinding** GetGamepadBindingsNative(SDLGamepad* gamepad, int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int*, SDLGamepadBinding**>)funcTable[722])(gamepad, count);
			#else
			return (SDLGamepadBinding**)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[722])((nint)gamepad, (nint)count);
			#endif
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadBinding** GetGamepadBindings(SDLGamepad* gamepad, int* count)
		{
			SDLGamepadBinding** ret = GetGamepadBindingsNative(gamepad, count);
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadBinding** GetGamepadBindings(ref SDLGamepad gamepad, int* count)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadBinding** ret = GetGamepadBindingsNative((SDLGamepad*)pgamepad, count);
				return ret;
			}
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadBinding** GetGamepadBindings(SDLGamepad* gamepad, ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLGamepadBinding** ret = GetGamepadBindingsNative(gamepad, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadBinding** GetGamepadBindings(ref SDLGamepad gamepad, ref int count)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (int* pcount = &count)
				{
					SDLGamepadBinding** ret = GetGamepadBindingsNative((SDLGamepad*)pgamepad, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Manually pump gamepad updates if not using the loop.<br/>
		/// This function is called automatically by the event loop if events are<br/>
		/// enabled. Under such circumstances, it will not be necessary to call this<br/>
		/// function.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateGamepadsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[723])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[723])();
			#endif
		}

		/// <summary>
		/// Manually pump gamepad updates if not using the loop.<br/>
		/// This function is called automatically by the event loop if events are<br/>
		/// enabled. Under such circumstances, it will not be necessary to call this<br/>
		/// function.<br/>
		/// <br/>
		/// </summary>
		public static void UpdateGamepads()
		{
			UpdateGamepadsNative();
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetGamepadTypeFromStringNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGamepadType>)funcTable[724])(str);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<nint, SDLGamepadType>)funcTable[724])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetGamepadTypeFromString(byte* str)
		{
			SDLGamepadType ret = GetGamepadTypeFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetGamepadTypeFromString(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGamepadType ret = GetGamepadTypeFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetGamepadTypeFromString(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGamepadType ret = GetGamepadTypeFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadType GetGamepadTypeFromString(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGamepadType ret = GetGamepadTypeFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadType enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadStringForTypeNative(SDLGamepadType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadType, byte*>)funcTable[725])(type);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGamepadType, nint>)funcTable[725])(type);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GamepadType enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadStringForType(SDLGamepadType type)
		{
			byte* ret = GetGamepadStringForTypeNative(type);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadType enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadStringForTypeS(SDLGamepadType type)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadStringForTypeNative(type));
			return ret;
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadAxis GetGamepadAxisFromStringNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGamepadAxis>)funcTable[726])(str);
			#else
			return (SDLGamepadAxis)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis>)funcTable[726])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadAxis GetGamepadAxisFromString(byte* str)
		{
			SDLGamepadAxis ret = GetGamepadAxisFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadAxis GetGamepadAxisFromString(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGamepadAxis ret = GetGamepadAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadAxis GetGamepadAxisFromString(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGamepadAxis ret = GetGamepadAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadAxis GetGamepadAxisFromString(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGamepadAxis ret = GetGamepadAxisFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadAxis enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadStringForAxisNative(SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadAxis, byte*>)funcTable[727])(axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGamepadAxis, nint>)funcTable[727])(axis);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GamepadAxis enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadStringForAxis(SDLGamepadAxis axis)
		{
			byte* ret = GetGamepadStringForAxisNative(axis);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadAxis enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadStringForAxisS(SDLGamepadAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadStringForAxisNative(axis));
			return ret;
		}

		/// <summary>
		/// Query whether a gamepad has a given axis.<br/>
		/// This merely reports whether the gamepad's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadHasAxisNative(SDLGamepad* gamepad, SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadAxis, byte>)funcTable[728])(gamepad, axis);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis, byte>)funcTable[728])((nint)gamepad, axis);
			#endif
		}

		/// <summary>
		/// Query whether a gamepad has a given axis.<br/>
		/// This merely reports whether the gamepad's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadHasAxis(SDLGamepad* gamepad, SDLGamepadAxis axis)
		{
			byte ret = GamepadHasAxisNative(gamepad, axis);
			return ret != 0;
		}

		/// <summary>
		/// Query whether a gamepad has a given axis.<br/>
		/// This merely reports whether the gamepad's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadHasAxis(ref SDLGamepad gamepad, SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadHasAxisNative((SDLGamepad*)pgamepad, axis);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an axis control on a gamepad.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short GetGamepadAxisNative(SDLGamepad* gamepad, SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadAxis, short>)funcTable[729])(gamepad, axis);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis, short>)funcTable[729])((nint)gamepad, axis);
			#endif
		}

		/// <summary>
		/// Get the current state of an axis control on a gamepad.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short GetGamepadAxis(SDLGamepad* gamepad, SDLGamepadAxis axis)
		{
			short ret = GetGamepadAxisNative(gamepad, axis);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a gamepad.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static short GetGamepadAxis(ref SDLGamepad gamepad, SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				short ret = GetGamepadAxisNative((SDLGamepad*)pgamepad, axis);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButton GetGamepadButtonFromStringNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGamepadButton>)funcTable[730])(str);
			#else
			return (SDLGamepadButton)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton>)funcTable[730])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadButton GetGamepadButtonFromString(byte* str)
		{
			SDLGamepadButton ret = GetGamepadButtonFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadButton GetGamepadButtonFromString(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGamepadButton ret = GetGamepadButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadButton GetGamepadButtonFromString(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGamepadButton ret = GetGamepadButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadButton GetGamepadButtonFromString(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGamepadButton ret = GetGamepadButtonFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadButton enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadStringForButtonNative(SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadButton, byte*>)funcTable[731])(button);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGamepadButton, nint>)funcTable[731])(button);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GamepadButton enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadStringForButton(SDLGamepadButton button)
		{
			byte* ret = GetGamepadStringForButtonNative(button);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadButton enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadStringForButtonS(SDLGamepadButton button)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadStringForButtonNative(button));
			return ret;
		}

		/// <summary>
		/// Query whether a gamepad has a given button.<br/>
		/// This merely reports whether the gamepad's mapping defined this button, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadHasButtonNative(SDLGamepad* gamepad, SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, byte>)funcTable[732])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, byte>)funcTable[732])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Query whether a gamepad has a given button.<br/>
		/// This merely reports whether the gamepad's mapping defined this button, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadHasButton(SDLGamepad* gamepad, SDLGamepadButton button)
		{
			byte ret = GamepadHasButtonNative(gamepad, button);
			return ret != 0;
		}

		/// <summary>
		/// Query whether a gamepad has a given button.<br/>
		/// This merely reports whether the gamepad's mapping defined this button, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadHasButton(ref SDLGamepad gamepad, SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadHasButtonNative((SDLGamepad*)pgamepad, button);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetGamepadButtonNative(SDLGamepad* gamepad, SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, byte>)funcTable[733])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, byte>)funcTable[733])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadButton(SDLGamepad* gamepad, SDLGamepadButton button)
		{
			byte ret = GetGamepadButtonNative(gamepad, button);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadButton(ref SDLGamepad gamepad, SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GetGamepadButtonNative((SDLGamepad*)pgamepad, button);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButtonLabel GetGamepadButtonLabelForTypeNative(SDLGamepadType type, SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadType, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[734])(type, button);
			#else
			return (SDLGamepadButtonLabel)((delegate* unmanaged[Cdecl]<SDLGamepadType, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[734])(type, button);
			#endif
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadButtonLabel GetGamepadButtonLabelForType(SDLGamepadType type, SDLGamepadButton button)
		{
			SDLGamepadButtonLabel ret = GetGamepadButtonLabelForTypeNative(type, button);
			return ret;
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButtonLabel GetGamepadButtonLabelNative(SDLGamepad* gamepad, SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[735])(gamepad, button);
			#else
			return (SDLGamepadButtonLabel)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[735])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadButtonLabel GetGamepadButtonLabel(SDLGamepad* gamepad, SDLGamepadButton button)
		{
			SDLGamepadButtonLabel ret = GetGamepadButtonLabelNative(gamepad, button);
			return ret;
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGamepadButtonLabel GetGamepadButtonLabel(ref SDLGamepad gamepad, SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadButtonLabel ret = GetGamepadButtonLabelNative((SDLGamepad*)pgamepad, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGamepadTouchpadsNative(SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int>)funcTable[736])(gamepad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[736])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumGamepadTouchpads(SDLGamepad* gamepad)
		{
			int ret = GetNumGamepadTouchpadsNative(gamepad);
			return ret;
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumGamepadTouchpads(ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetNumGamepadTouchpadsNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGamepadTouchpadFingersNative(SDLGamepad* gamepad, int touchpad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, int>)funcTable[737])(gamepad, touchpad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[737])((nint)gamepad, touchpad);
			#endif
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumGamepadTouchpadFingers(SDLGamepad* gamepad, int touchpad)
		{
			int ret = GetNumGamepadTouchpadFingersNative(gamepad, touchpad);
			return ret;
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumGamepadTouchpadFingers(ref SDLGamepad gamepad, int touchpad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetNumGamepadTouchpadFingersNative((SDLGamepad*)pgamepad, touchpad);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetGamepadTouchpadFingerNative(SDLGamepad* gamepad, int touchpad, int finger, bool* down, float* x, float* y, float* pressure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, int, bool*, float*, float*, float*, byte>)funcTable[738])(gamepad, touchpad, finger, down, x, y, pressure);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, nint, nint, byte>)funcTable[738])((nint)gamepad, touchpad, finger, (nint)down, (nint)x, (nint)y, (nint)pressure);
			#endif
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, float* x, float* y, float* pressure)
		{
			byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, x, y, pressure);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, float* x, float* y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, float* x, float* y, float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, x, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, float* x, float* y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, y, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, ref float x, float* y, float* pressure)
		{
			fixed (float* px = &x)
			{
				byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, (float*)px, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, ref float x, float* y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, y, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, ref float x, float* y, float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, (float*)px, y, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, ref float x, float* y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, y, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, float* x, ref float y, float* pressure)
		{
			fixed (float* py = &y)
			{
				byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, x, (float*)py, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, float* x, ref float y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* py = &y)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, (float*)py, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, float* x, ref float y, float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* py = &y)
				{
					byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, x, (float*)py, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, float* x, ref float y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* py = &y)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, (float*)py, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, ref float x, ref float y, float* pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, (float*)px, (float*)py, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, ref float x, ref float y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, (float*)py, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, ref float x, ref float y, float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, ref float x, ref float y, float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, pressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, float* x, float* y, ref float pressure)
		{
			fixed (float* ppressure = &pressure)
			{
				byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, x, y, (float*)ppressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, float* x, float* y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, y, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, float* x, float* y, ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, x, y, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, float* x, float* y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, y, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, ref float x, float* y, ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, (float*)px, y, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, ref float x, float* y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, y, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, ref float x, float* y, ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, (float*)px, y, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, ref float x, float* y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, y, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, float* x, ref float y, ref float pressure)
		{
			fixed (float* py = &y)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, x, (float*)py, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, float* x, ref float y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, (float*)py, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, float* x, ref float y, ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, x, (float*)py, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, float* x, ref float y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, (float*)py, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, bool* down, ref float x, ref float y, ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, down, (float*)px, (float*)py, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, bool* down, ref float x, ref float y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, (float*)py, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(SDLGamepad* gamepad, int touchpad, int finger, ref bool down, ref float x, ref float y, ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative(gamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadTouchpadFinger(ref SDLGamepad gamepad, int touchpad, int finger, ref bool down, ref float x, ref float y, ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							fixed (float* ppressure = &pressure)
							{
								byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, (float*)ppressure);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadHasSensorNative(SDLGamepad* gamepad, SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, byte>)funcTable[739])(gamepad, type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, byte>)funcTable[739])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadHasSensor(SDLGamepad* gamepad, SDLSensorType type)
		{
			byte ret = GamepadHasSensorNative(gamepad, type);
			return ret != 0;
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadHasSensor(ref SDLGamepad gamepad, SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadHasSensorNative((SDLGamepad*)pgamepad, type);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGamepadSensorEnabledNative(SDLGamepad* gamepad, SDLSensorType type, byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, byte, byte>)funcTable[740])(gamepad, type, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, byte, byte>)funcTable[740])((nint)gamepad, type, enabled);
			#endif
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadSensorEnabled(SDLGamepad* gamepad, SDLSensorType type, bool enabled)
		{
			byte ret = SetGamepadSensorEnabledNative(gamepad, type, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadSensorEnabled(ref SDLGamepad gamepad, SDLSensorType type, bool enabled)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SetGamepadSensorEnabledNative((SDLGamepad*)pgamepad, type, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadSensorEnabledNative(SDLGamepad* gamepad, SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, byte>)funcTable[741])(gamepad, type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, byte>)funcTable[741])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadSensorEnabled(SDLGamepad* gamepad, SDLSensorType type)
		{
			byte ret = GamepadSensorEnabledNative(gamepad, type);
			return ret != 0;
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GamepadSensorEnabled(ref SDLGamepad gamepad, SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadSensorEnabledNative((SDLGamepad*)pgamepad, type);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetGamepadSensorDataRateNative(SDLGamepad* gamepad, SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, float>)funcTable[742])(gamepad, type);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, float>)funcTable[742])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetGamepadSensorDataRate(SDLGamepad* gamepad, SDLSensorType type)
		{
			float ret = GetGamepadSensorDataRateNative(gamepad, type);
			return ret;
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetGamepadSensorDataRate(ref SDLGamepad gamepad, SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				float ret = GetGamepadSensorDataRateNative((SDLGamepad*)pgamepad, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetGamepadSensorDataNative(SDLGamepad* gamepad, SDLSensorType type, float* data, int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, float*, int, byte>)funcTable[743])(gamepad, type, data, numValues);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, nint, int, byte>)funcTable[743])((nint)gamepad, type, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadSensorData(SDLGamepad* gamepad, SDLSensorType type, float* data, int numValues)
		{
			byte ret = GetGamepadSensorDataNative(gamepad, type, data, numValues);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadSensorData(ref SDLGamepad gamepad, SDLSensorType type, float* data, int numValues)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GetGamepadSensorDataNative((SDLGamepad*)pgamepad, type, data, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadSensorData(SDLGamepad* gamepad, SDLSensorType type, ref float data, int numValues)
		{
			fixed (float* pdata = &data)
			{
				byte ret = GetGamepadSensorDataNative(gamepad, type, (float*)pdata, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetGamepadSensorData(ref SDLGamepad gamepad, SDLSensorType type, ref float data, int numValues)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* pdata = &data)
				{
					byte ret = GetGamepadSensorDataNative((SDLGamepad*)pgamepad, type, (float*)pdata, numValues);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RumbleGamepadNative(SDLGamepad* gamepad, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort, ushort, uint, byte>)funcTable[744])(gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, byte>)funcTable[744])((nint)gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleGamepad(SDLGamepad* gamepad, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			byte ret = RumbleGamepadNative(gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret != 0;
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleGamepad(ref SDLGamepad gamepad, ushort lowFrequencyRumble, ushort highFrequencyRumble, uint durationMs)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = RumbleGamepadNative((SDLGamepad*)pgamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RumbleGamepadTriggersNative(SDLGamepad* gamepad, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort, ushort, uint, byte>)funcTable[745])(gamepad, leftRumble, rightRumble, durationMs);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, byte>)funcTable[745])((nint)gamepad, leftRumble, rightRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleGamepadTriggers(SDLGamepad* gamepad, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			byte ret = RumbleGamepadTriggersNative(gamepad, leftRumble, rightRumble, durationMs);
			return ret != 0;
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RumbleGamepadTriggers(ref SDLGamepad gamepad, ushort leftRumble, ushort rightRumble, uint durationMs)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = RumbleGamepadTriggersNative((SDLGamepad*)pgamepad, leftRumble, rightRumble, durationMs);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGamepadLEDNative(SDLGamepad* gamepad, byte red, byte green, byte blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte, byte, byte, byte>)funcTable[746])(gamepad, red, green, blue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte>)funcTable[746])((nint)gamepad, red, green, blue);
			#endif
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadLED(SDLGamepad* gamepad, byte red, byte green, byte blue)
		{
			byte ret = SetGamepadLEDNative(gamepad, red, green, blue);
			return ret != 0;
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGamepadLED(ref SDLGamepad gamepad, byte red, byte green, byte blue)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SetGamepadLEDNative((SDLGamepad*)pgamepad, red, green, blue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SendGamepadEffectNative(SDLGamepad* gamepad, void* data, int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, void*, int, byte>)funcTable[747])(gamepad, data, size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[747])((nint)gamepad, (nint)data, size);
			#endif
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendGamepadEffect(SDLGamepad* gamepad, void* data, int size)
		{
			byte ret = SendGamepadEffectNative(gamepad, data, size);
			return ret != 0;
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SendGamepadEffect(ref SDLGamepad gamepad, void* data, int size)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SendGamepadEffectNative((SDLGamepad*)pgamepad, data, size);
				return ret != 0;
			}
		}
	}
}
