// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							fixed (byte* pvplane = &vplane)
							{
								byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateNVTextureNative(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, byte*, int, byte*, int, byte>)funcTable[1064])(texture, rect, yplane, ypitch, uVplane, uVpitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, byte>)funcTable[1064])((nint)texture, (nint)rect, (nint)yplane, ypitch, (nint)uVplane, uVpitch);
			#endif
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			byte ret = UpdateNVTextureNative(texture, rect, yplane, ypitch, uVplane, uVpitch);
			return ret != 0;
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, SDLRect* rect, byte* yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uVplane, uVpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, ref SDLRect rect, byte* yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = UpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, ref SDLRect rect, byte* yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, SDLRect* rect, ref byte yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				byte ret = UpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, SDLRect* rect, ref byte yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, ref SDLRect rect, ref byte yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					byte ret = UpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, ref SDLRect rect, ref byte yplane, int ypitch, byte* uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (byte* puVplane = &uVplane)
			{
				byte ret = UpdateNVTextureNative(texture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, SDLRect* rect, byte* yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puVplane = &uVplane)
				{
					byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, ref SDLRect rect, byte* yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puVplane = &uVplane)
				{
					byte ret = UpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, ref SDLRect rect, byte* yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puVplane = &uVplane)
					{
						byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, SDLRect* rect, ref byte yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puVplane = &uVplane)
				{
					byte ret = UpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, SDLRect* rect, ref byte yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(SDLTexture* texture, ref SDLRect rect, ref byte yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						byte ret = UpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateNVTexture(ref SDLTexture texture, ref SDLRect rect, ref byte yplane, int ypitch, ref byte uVplane, int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puVplane = &uVplane)
						{
							byte ret = UpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LockTextureNative(SDLTexture* texture, SDLRect* rect, void** pixels, int* pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, void**, int*, byte>)funcTable[1065])(texture, rect, pixels, pitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[1065])((nint)texture, (nint)rect, (nint)pixels, (nint)pitch);
			#endif
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(SDLTexture* texture, SDLRect* rect, void** pixels, int* pitch)
		{
			byte ret = LockTextureNative(texture, rect, pixels, pitch);
			return ret != 0;
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(ref SDLTexture texture, SDLRect* rect, void** pixels, int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = LockTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(SDLTexture* texture, ref SDLRect rect, void** pixels, int* pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = LockTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(ref SDLTexture texture, ref SDLRect rect, void** pixels, int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = LockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(SDLTexture* texture, SDLRect* rect, void** pixels, ref int pitch)
		{
			fixed (int* ppitch = &pitch)
			{
				byte ret = LockTextureNative(texture, rect, pixels, (int*)ppitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(ref SDLTexture texture, SDLRect* rect, void** pixels, ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ppitch = &pitch)
				{
					byte ret = LockTextureNative((SDLTexture*)ptexture, rect, pixels, (int*)ppitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(SDLTexture* texture, ref SDLRect rect, void** pixels, ref int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* ppitch = &pitch)
				{
					byte ret = LockTextureNative(texture, (SDLRect*)prect, pixels, (int*)ppitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTexture(ref SDLTexture texture, ref SDLRect rect, void** pixels, ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (int* ppitch = &pitch)
					{
						byte ret = LockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, (int*)ppitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LockTextureToSurfaceNative(SDLTexture* texture, SDLRect* rect, SDLSurface** surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, SDLSurface**, byte>)funcTable[1066])(texture, rect, surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[1066])((nint)texture, (nint)rect, (nint)surface);
			#endif
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(SDLTexture* texture, SDLRect* rect, SDLSurface** surface)
		{
			byte ret = LockTextureToSurfaceNative(texture, rect, surface);
			return ret != 0;
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(ref SDLTexture texture, SDLRect* rect, SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, rect, surface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(SDLTexture* texture, ref SDLRect rect, SDLSurface** surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = LockTextureToSurfaceNative(texture, (SDLRect*)prect, surface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(ref SDLTexture texture, ref SDLRect rect, SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, surface);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(SDLTexture* texture, SDLRect* rect, ref SDLSurface* surface)
		{
			fixed (SDLSurface** psurface = &surface)
			{
				byte ret = LockTextureToSurfaceNative(texture, rect, (SDLSurface**)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(ref SDLTexture texture, SDLRect* rect, ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					byte ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, rect, (SDLSurface**)psurface);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(SDLTexture* texture, ref SDLRect rect, ref SDLSurface* surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					byte ret = LockTextureToSurfaceNative(texture, (SDLRect*)prect, (SDLSurface**)psurface);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool LockTextureToSurface(ref SDLTexture texture, ref SDLRect rect, ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (SDLSurface** psurface = &surface)
					{
						byte ret = LockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, (SDLSurface**)psurface);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockTextureNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTexture*, void>)funcTable[1067])(texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1067])((nint)texture);
			#endif
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockTexture(SDLTexture* texture)
		{
			UnlockTextureNative(texture);
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void UnlockTexture(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				UnlockTextureNative((SDLTexture*)ptexture);
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// Viewport, cliprect, scale, and logical presentation are unique to each<br/>
		/// render target. Get and set functions for these states apply to the current<br/>
		/// render target set by this function, and those states persist on each target<br/>
		/// when the current render target changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderTargetNative(SDLRenderer* renderer, SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, byte>)funcTable[1068])(renderer, texture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1068])((nint)renderer, (nint)texture);
			#endif
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// Viewport, cliprect, scale, and logical presentation are unique to each<br/>
		/// render target. Get and set functions for these states apply to the current<br/>
		/// render target set by this function, and those states persist on each target<br/>
		/// when the current render target changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderTarget(SDLRenderer* renderer, SDLTexture* texture)
		{
			byte ret = SetRenderTargetNative(renderer, texture);
			return ret != 0;
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// Viewport, cliprect, scale, and logical presentation are unique to each<br/>
		/// render target. Get and set functions for these states apply to the current<br/>
		/// render target set by this function, and those states persist on each target<br/>
		/// when the current render target changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderTarget(ref SDLRenderer renderer, SDLTexture* texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderTargetNative((SDLRenderer*)prenderer, texture);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// Viewport, cliprect, scale, and logical presentation are unique to each<br/>
		/// render target. Get and set functions for these states apply to the current<br/>
		/// render target set by this function, and those states persist on each target<br/>
		/// when the current render target changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderTarget(SDLRenderer* renderer, ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = SetRenderTargetNative(renderer, (SDLTexture*)ptexture);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// Viewport, cliprect, scale, and logical presentation are unique to each<br/>
		/// render target. Get and set functions for these states apply to the current<br/>
		/// render target set by this function, and those states persist on each target<br/>
		/// when the current render target changes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderTarget(ref SDLRenderer renderer, ref SDLTexture texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = SetRenderTargetNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* GetRenderTargetNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*>)funcTable[1069])(renderer);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1069])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* GetRenderTarget(SDLRenderer* renderer)
		{
			SDLTexture* ret = GetRenderTargetNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* GetRenderTarget(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = GetRenderTargetNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set a device-independent resolution and presentation mode for rendering.<br/>
		/// This function sets the width and height of the logical rendering output.<br/>
		/// The renderer will act as if the current render target is always the<br/>
		/// requested dimensions, scaling to the actual resolution as necessary.<br/>
		/// This can be useful for games that expect a fixed size, but would like to<br/>
		/// scale the output to whatever is available, regardless of how a user resizes<br/>
		/// a window, or if the display is high DPI.<br/>
		/// Logical presentation can be used with both render target textures and the<br/>
		/// renderer's window; the state is unique to each render target, and this<br/>
		/// function sets the state for the current render target. It might be useful<br/>
		/// to draw to a texture that matches the window dimensions with logical<br/>
		/// presentation enabled, and then draw that texture across the entire window<br/>
		/// with logical presentation disabled. Be careful not to render both with<br/>
		/// logical presentation enabled, however, as this could produce<br/>
		/// double-letterboxing, etc.<br/>
		/// You can disable logical coordinates by setting the mode to<br/>
		/// SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel<br/>
		/// resolution of the render target; it is safe to toggle logical presentation<br/>
		/// during the rendering of a frame: perhaps most of the rendering is done to<br/>
		/// specific dimensions but to make fonts look sharp, the app turns off logical<br/>
		/// presentation while drawing text, for example.<br/>
		/// For the renderer's window, letterboxing is drawn into the framebuffer if<br/>
		/// logical presentation is enabled during SDL_RenderPresent; be sure to<br/>
		/// reenable it before presenting if you were toggling it, otherwise the<br/>
		/// letterbox areas might have artifacts from previous frames (or artifacts<br/>
		/// from external overlays, etc). Letterboxing is never drawn into texture<br/>
		/// render targets; be sure to call SDL_RenderClear() before drawing into the<br/>
		/// texture so the letterboxing areas are cleared, if appropriate.<br/>
		/// You can convert coordinates in an event into rendering coordinates using<br/>
		/// SDL_ConvertEventToRenderCoordinates().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderLogicalPresentationNative(SDLRenderer* renderer, int w, int h, SDLRendererLogicalPresentation mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int, int, SDLRendererLogicalPresentation, byte>)funcTable[1070])(renderer, w, h, mode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, SDLRendererLogicalPresentation, byte>)funcTable[1070])((nint)renderer, w, h, mode);
			#endif
		}

		/// <summary>
		/// Set a device-independent resolution and presentation mode for rendering.<br/>
		/// This function sets the width and height of the logical rendering output.<br/>
		/// The renderer will act as if the current render target is always the<br/>
		/// requested dimensions, scaling to the actual resolution as necessary.<br/>
		/// This can be useful for games that expect a fixed size, but would like to<br/>
		/// scale the output to whatever is available, regardless of how a user resizes<br/>
		/// a window, or if the display is high DPI.<br/>
		/// Logical presentation can be used with both render target textures and the<br/>
		/// renderer's window; the state is unique to each render target, and this<br/>
		/// function sets the state for the current render target. It might be useful<br/>
		/// to draw to a texture that matches the window dimensions with logical<br/>
		/// presentation enabled, and then draw that texture across the entire window<br/>
		/// with logical presentation disabled. Be careful not to render both with<br/>
		/// logical presentation enabled, however, as this could produce<br/>
		/// double-letterboxing, etc.<br/>
		/// You can disable logical coordinates by setting the mode to<br/>
		/// SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel<br/>
		/// resolution of the render target; it is safe to toggle logical presentation<br/>
		/// during the rendering of a frame: perhaps most of the rendering is done to<br/>
		/// specific dimensions but to make fonts look sharp, the app turns off logical<br/>
		/// presentation while drawing text, for example.<br/>
		/// For the renderer's window, letterboxing is drawn into the framebuffer if<br/>
		/// logical presentation is enabled during SDL_RenderPresent; be sure to<br/>
		/// reenable it before presenting if you were toggling it, otherwise the<br/>
		/// letterbox areas might have artifacts from previous frames (or artifacts<br/>
		/// from external overlays, etc). Letterboxing is never drawn into texture<br/>
		/// render targets; be sure to call SDL_RenderClear() before drawing into the<br/>
		/// texture so the letterboxing areas are cleared, if appropriate.<br/>
		/// You can convert coordinates in an event into rendering coordinates using<br/>
		/// SDL_ConvertEventToRenderCoordinates().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderLogicalPresentation(SDLRenderer* renderer, int w, int h, SDLRendererLogicalPresentation mode)
		{
			byte ret = SetRenderLogicalPresentationNative(renderer, w, h, mode);
			return ret != 0;
		}

		/// <summary>
		/// Set a device-independent resolution and presentation mode for rendering.<br/>
		/// This function sets the width and height of the logical rendering output.<br/>
		/// The renderer will act as if the current render target is always the<br/>
		/// requested dimensions, scaling to the actual resolution as necessary.<br/>
		/// This can be useful for games that expect a fixed size, but would like to<br/>
		/// scale the output to whatever is available, regardless of how a user resizes<br/>
		/// a window, or if the display is high DPI.<br/>
		/// Logical presentation can be used with both render target textures and the<br/>
		/// renderer's window; the state is unique to each render target, and this<br/>
		/// function sets the state for the current render target. It might be useful<br/>
		/// to draw to a texture that matches the window dimensions with logical<br/>
		/// presentation enabled, and then draw that texture across the entire window<br/>
		/// with logical presentation disabled. Be careful not to render both with<br/>
		/// logical presentation enabled, however, as this could produce<br/>
		/// double-letterboxing, etc.<br/>
		/// You can disable logical coordinates by setting the mode to<br/>
		/// SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel<br/>
		/// resolution of the render target; it is safe to toggle logical presentation<br/>
		/// during the rendering of a frame: perhaps most of the rendering is done to<br/>
		/// specific dimensions but to make fonts look sharp, the app turns off logical<br/>
		/// presentation while drawing text, for example.<br/>
		/// For the renderer's window, letterboxing is drawn into the framebuffer if<br/>
		/// logical presentation is enabled during SDL_RenderPresent; be sure to<br/>
		/// reenable it before presenting if you were toggling it, otherwise the<br/>
		/// letterbox areas might have artifacts from previous frames (or artifacts<br/>
		/// from external overlays, etc). Letterboxing is never drawn into texture<br/>
		/// render targets; be sure to call SDL_RenderClear() before drawing into the<br/>
		/// texture so the letterboxing areas are cleared, if appropriate.<br/>
		/// You can convert coordinates in an event into rendering coordinates using<br/>
		/// SDL_ConvertEventToRenderCoordinates().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderLogicalPresentation(ref SDLRenderer renderer, int w, int h, SDLRendererLogicalPresentation mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderLogicalPresentationNative((SDLRenderer*)prenderer, w, h, mode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderLogicalPresentationNative(SDLRenderer* renderer, int* w, int* h, SDLRendererLogicalPresentation* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int*, int*, SDLRendererLogicalPresentation*, byte>)funcTable[1071])(renderer, w, h, mode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[1071])((nint)renderer, (nint)w, (nint)h, (nint)mode);
			#endif
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, int* w, int* h, SDLRendererLogicalPresentation* mode)
		{
			byte ret = GetRenderLogicalPresentationNative(renderer, w, h, mode);
			return ret != 0;
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, int* w, int* h, SDLRendererLogicalPresentation* mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, w, h, mode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, ref int w, int* h, SDLRendererLogicalPresentation* mode)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetRenderLogicalPresentationNative(renderer, (int*)pw, h, mode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, ref int w, int* h, SDLRendererLogicalPresentation* mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, (int*)pw, h, mode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, int* w, ref int h, SDLRendererLogicalPresentation* mode)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetRenderLogicalPresentationNative(renderer, w, (int*)ph, mode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, int* w, ref int h, SDLRendererLogicalPresentation* mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, w, (int*)ph, mode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, ref int w, ref int h, SDLRendererLogicalPresentation* mode)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetRenderLogicalPresentationNative(renderer, (int*)pw, (int*)ph, mode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, ref int w, ref int h, SDLRendererLogicalPresentation* mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph, mode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, int* w, int* h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (SDLRendererLogicalPresentation* pmode = &mode)
			{
				byte ret = GetRenderLogicalPresentationNative(renderer, w, h, (SDLRendererLogicalPresentation*)pmode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, int* w, int* h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRendererLogicalPresentation* pmode = &mode)
				{
					byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, w, h, (SDLRendererLogicalPresentation*)pmode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, ref int w, int* h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (int* pw = &w)
			{
				fixed (SDLRendererLogicalPresentation* pmode = &mode)
				{
					byte ret = GetRenderLogicalPresentationNative(renderer, (int*)pw, h, (SDLRendererLogicalPresentation*)pmode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, ref int w, int* h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (SDLRendererLogicalPresentation* pmode = &mode)
					{
						byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, (int*)pw, h, (SDLRendererLogicalPresentation*)pmode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, int* w, ref int h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (int* ph = &h)
			{
				fixed (SDLRendererLogicalPresentation* pmode = &mode)
				{
					byte ret = GetRenderLogicalPresentationNative(renderer, w, (int*)ph, (SDLRendererLogicalPresentation*)pmode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, int* w, ref int h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					fixed (SDLRendererLogicalPresentation* pmode = &mode)
					{
						byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, w, (int*)ph, (SDLRendererLogicalPresentation*)pmode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(SDLRenderer* renderer, ref int w, ref int h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					fixed (SDLRendererLogicalPresentation* pmode = &mode)
					{
						byte ret = GetRenderLogicalPresentationNative(renderer, (int*)pw, (int*)ph, (SDLRendererLogicalPresentation*)pmode);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get device independent resolution and presentation mode for rendering.<br/>
		/// This function gets the width and height of the logical rendering output, or<br/>
		/// the output size in pixels if a logical resolution is not enabled.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the state for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentation(ref SDLRenderer renderer, ref int w, ref int h, ref SDLRendererLogicalPresentation mode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						fixed (SDLRendererLogicalPresentation* pmode = &mode)
						{
							byte ret = GetRenderLogicalPresentationNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph, (SDLRendererLogicalPresentation*)pmode);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the final presentation rectangle for rendering.<br/>
		/// This function returns the calculated rectangle used for logical<br/>
		/// presentation, based on the presentation mode and output size. If logical<br/>
		/// presentation is disabled, it will fill the rectangle with the output size,<br/>
		/// in pixels.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the rectangle for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderLogicalPresentationRectNative(SDLRenderer* renderer, SDLFRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, byte>)funcTable[1072])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1072])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the final presentation rectangle for rendering.<br/>
		/// This function returns the calculated rectangle used for logical<br/>
		/// presentation, based on the presentation mode and output size. If logical<br/>
		/// presentation is disabled, it will fill the rectangle with the output size,<br/>
		/// in pixels.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the rectangle for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentationRect(SDLRenderer* renderer, SDLFRect* rect)
		{
			byte ret = GetRenderLogicalPresentationRectNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Get the final presentation rectangle for rendering.<br/>
		/// This function returns the calculated rectangle used for logical<br/>
		/// presentation, based on the presentation mode and output size. If logical<br/>
		/// presentation is disabled, it will fill the rectangle with the output size,<br/>
		/// in pixels.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the rectangle for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentationRect(ref SDLRenderer renderer, SDLFRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderLogicalPresentationRectNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the final presentation rectangle for rendering.<br/>
		/// This function returns the calculated rectangle used for logical<br/>
		/// presentation, based on the presentation mode and output size. If logical<br/>
		/// presentation is disabled, it will fill the rectangle with the output size,<br/>
		/// in pixels.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the rectangle for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentationRect(SDLRenderer* renderer, ref SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				byte ret = GetRenderLogicalPresentationRectNative(renderer, (SDLFRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the final presentation rectangle for rendering.<br/>
		/// This function returns the calculated rectangle used for logical<br/>
		/// presentation, based on the presentation mode and output size. If logical<br/>
		/// presentation is disabled, it will fill the rectangle with the output size,<br/>
		/// in pixels.<br/>
		/// Each render target has its own logical presentation state. This function<br/>
		/// gets the rectangle for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderLogicalPresentationRect(ref SDLRenderer renderer, ref SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					byte ret = GetRenderLogicalPresentationRectNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderCoordinatesFromWindowNative(SDLRenderer* renderer, float windowX, float windowY, float* x, float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, float*, float*, byte>)funcTable[1073])(renderer, windowX, windowY, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, nint, nint, byte>)funcTable[1073])((nint)renderer, windowX, windowY, (nint)x, (nint)y);
			#endif
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(SDLRenderer* renderer, float windowX, float windowY, float* x, float* y)
		{
			byte ret = RenderCoordinatesFromWindowNative(renderer, windowX, windowY, x, y);
			return ret != 0;
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(ref SDLRenderer renderer, float windowX, float windowY, float* x, float* y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderCoordinatesFromWindowNative((SDLRenderer*)prenderer, windowX, windowY, x, y);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(SDLRenderer* renderer, float windowX, float windowY, ref float x, float* y)
		{
			fixed (float* px = &x)
			{
				byte ret = RenderCoordinatesFromWindowNative(renderer, windowX, windowY, (float*)px, y);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(ref SDLRenderer renderer, float windowX, float windowY, ref float x, float* y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* px = &x)
				{
					byte ret = RenderCoordinatesFromWindowNative((SDLRenderer*)prenderer, windowX, windowY, (float*)px, y);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(SDLRenderer* renderer, float windowX, float windowY, float* x, ref float y)
		{
			fixed (float* py = &y)
			{
				byte ret = RenderCoordinatesFromWindowNative(renderer, windowX, windowY, x, (float*)py);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(ref SDLRenderer renderer, float windowX, float windowY, float* x, ref float y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* py = &y)
				{
					byte ret = RenderCoordinatesFromWindowNative((SDLRenderer*)prenderer, windowX, windowY, x, (float*)py);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(SDLRenderer* renderer, float windowX, float windowY, ref float x, ref float y)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					byte ret = RenderCoordinatesFromWindowNative(renderer, windowX, windowY, (float*)px, (float*)py);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get a point in render coordinates when given a point in window coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesFromWindow(ref SDLRenderer renderer, float windowX, float windowY, ref float x, ref float y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						byte ret = RenderCoordinatesFromWindowNative((SDLRenderer*)prenderer, windowX, windowY, (float*)px, (float*)py);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderCoordinatesToWindowNative(SDLRenderer* renderer, float x, float y, float* windowX, float* windowY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, float*, float*, byte>)funcTable[1074])(renderer, x, y, windowX, windowY);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, nint, nint, byte>)funcTable[1074])((nint)renderer, x, y, (nint)windowX, (nint)windowY);
			#endif
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(SDLRenderer* renderer, float x, float y, float* windowX, float* windowY)
		{
			byte ret = RenderCoordinatesToWindowNative(renderer, x, y, windowX, windowY);
			return ret != 0;
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(ref SDLRenderer renderer, float x, float y, float* windowX, float* windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderCoordinatesToWindowNative((SDLRenderer*)prenderer, x, y, windowX, windowY);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(SDLRenderer* renderer, float x, float y, ref float windowX, float* windowY)
		{
			fixed (float* pwindowX = &windowX)
			{
				byte ret = RenderCoordinatesToWindowNative(renderer, x, y, (float*)pwindowX, windowY);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(ref SDLRenderer renderer, float x, float y, ref float windowX, float* windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pwindowX = &windowX)
				{
					byte ret = RenderCoordinatesToWindowNative((SDLRenderer*)prenderer, x, y, (float*)pwindowX, windowY);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(SDLRenderer* renderer, float x, float y, float* windowX, ref float windowY)
		{
			fixed (float* pwindowY = &windowY)
			{
				byte ret = RenderCoordinatesToWindowNative(renderer, x, y, windowX, (float*)pwindowY);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(ref SDLRenderer renderer, float x, float y, float* windowX, ref float windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pwindowY = &windowY)
				{
					byte ret = RenderCoordinatesToWindowNative((SDLRenderer*)prenderer, x, y, windowX, (float*)pwindowY);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(SDLRenderer* renderer, float x, float y, ref float windowX, ref float windowY)
		{
			fixed (float* pwindowX = &windowX)
			{
				fixed (float* pwindowY = &windowY)
				{
					byte ret = RenderCoordinatesToWindowNative(renderer, x, y, (float*)pwindowX, (float*)pwindowY);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get a point in window coordinates when given a point in render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderCoordinatesToWindow(ref SDLRenderer renderer, float x, float y, ref float windowX, ref float windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pwindowX = &windowX)
				{
					fixed (float* pwindowY = &windowY)
					{
						byte ret = RenderCoordinatesToWindowNative((SDLRenderer*)prenderer, x, y, (float*)pwindowX, (float*)pwindowY);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Convert the coordinates in an event to render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// Various event types are converted with this function: mouse, touch, pen,<br/>
		/// etc.<br/>
		/// Touch coordinates are converted from normalized coordinates in the window<br/>
		/// to non-normalized rendering coordinates.<br/>
		/// Relative mouse coordinates (xrel and yrel event fields) are _also_<br/>
		/// converted. Applications that do not want these fields converted should use<br/>
		/// SDL_RenderCoordinatesFromWindow() on the specific event fields instead of<br/>
		/// converting the entire event structure.<br/>
		/// Once converted, coordinates may be outside the rendering area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ConvertEventToRenderCoordinatesNative(SDLRenderer* renderer, SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLEvent*, byte>)funcTable[1075])(renderer, evnt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1075])((nint)renderer, (nint)evnt);
			#endif
		}

		/// <summary>
		/// Convert the coordinates in an event to render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// Various event types are converted with this function: mouse, touch, pen,<br/>
		/// etc.<br/>
		/// Touch coordinates are converted from normalized coordinates in the window<br/>
		/// to non-normalized rendering coordinates.<br/>
		/// Relative mouse coordinates (xrel and yrel event fields) are _also_<br/>
		/// converted. Applications that do not want these fields converted should use<br/>
		/// SDL_RenderCoordinatesFromWindow() on the specific event fields instead of<br/>
		/// converting the entire event structure.<br/>
		/// Once converted, coordinates may be outside the rendering area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ConvertEventToRenderCoordinates(SDLRenderer* renderer, SDLEvent* evnt)
		{
			byte ret = ConvertEventToRenderCoordinatesNative(renderer, evnt);
			return ret != 0;
		}

		/// <summary>
		/// Convert the coordinates in an event to render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// Various event types are converted with this function: mouse, touch, pen,<br/>
		/// etc.<br/>
		/// Touch coordinates are converted from normalized coordinates in the window<br/>
		/// to non-normalized rendering coordinates.<br/>
		/// Relative mouse coordinates (xrel and yrel event fields) are _also_<br/>
		/// converted. Applications that do not want these fields converted should use<br/>
		/// SDL_RenderCoordinatesFromWindow() on the specific event fields instead of<br/>
		/// converting the entire event structure.<br/>
		/// Once converted, coordinates may be outside the rendering area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ConvertEventToRenderCoordinates(ref SDLRenderer renderer, SDLEvent* evnt)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = ConvertEventToRenderCoordinatesNative((SDLRenderer*)prenderer, evnt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert the coordinates in an event to render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// Various event types are converted with this function: mouse, touch, pen,<br/>
		/// etc.<br/>
		/// Touch coordinates are converted from normalized coordinates in the window<br/>
		/// to non-normalized rendering coordinates.<br/>
		/// Relative mouse coordinates (xrel and yrel event fields) are _also_<br/>
		/// converted. Applications that do not want these fields converted should use<br/>
		/// SDL_RenderCoordinatesFromWindow() on the specific event fields instead of<br/>
		/// converting the entire event structure.<br/>
		/// Once converted, coordinates may be outside the rendering area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ConvertEventToRenderCoordinates(SDLRenderer* renderer, ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte ret = ConvertEventToRenderCoordinatesNative(renderer, (SDLEvent*)pevnt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Convert the coordinates in an event to render coordinates.<br/>
		/// This takes into account several states:<br/>
		/// - The window dimensions.<br/>
		/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
		/// - The scale (SDL_SetRenderScale)<br/>
		/// - The viewport (SDL_SetRenderViewport)<br/>
		/// Various event types are converted with this function: mouse, touch, pen,<br/>
		/// etc.<br/>
		/// Touch coordinates are converted from normalized coordinates in the window<br/>
		/// to non-normalized rendering coordinates.<br/>
		/// Relative mouse coordinates (xrel and yrel event fields) are _also_<br/>
		/// converted. Applications that do not want these fields converted should use<br/>
		/// SDL_RenderCoordinatesFromWindow() on the specific event fields instead of<br/>
		/// converting the entire event structure.<br/>
		/// Once converted, coordinates may be outside the rendering area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ConvertEventToRenderCoordinates(ref SDLRenderer renderer, ref SDLEvent evnt)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLEvent* pevnt = &evnt)
				{
					byte ret = ConvertEventToRenderCoordinatesNative((SDLRenderer*)prenderer, (SDLEvent*)pevnt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// Drawing will clip to this area (separately from any clipping done with<br/>
		/// SDL_SetRenderClipRect), and the top left of the area will become coordinate<br/>
		/// (0, 0) for future drawing commands.<br/>
		/// The area's width and height must be >= 0.<br/>
		/// Each render target has its own viewport. This function sets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderViewportNative(SDLRenderer* renderer, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, byte>)funcTable[1076])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1076])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// Drawing will clip to this area (separately from any clipping done with<br/>
		/// SDL_SetRenderClipRect), and the top left of the area will become coordinate<br/>
		/// (0, 0) for future drawing commands.<br/>
		/// The area's width and height must be >= 0.<br/>
		/// Each render target has its own viewport. This function sets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderViewport(SDLRenderer* renderer, SDLRect* rect)
		{
			byte ret = SetRenderViewportNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// Drawing will clip to this area (separately from any clipping done with<br/>
		/// SDL_SetRenderClipRect), and the top left of the area will become coordinate<br/>
		/// (0, 0) for future drawing commands.<br/>
		/// The area's width and height must be >= 0.<br/>
		/// Each render target has its own viewport. This function sets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderViewport(ref SDLRenderer renderer, SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderViewportNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// Drawing will clip to this area (separately from any clipping done with<br/>
		/// SDL_SetRenderClipRect), and the top left of the area will become coordinate<br/>
		/// (0, 0) for future drawing commands.<br/>
		/// The area's width and height must be >= 0.<br/>
		/// Each render target has its own viewport. This function sets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderViewport(SDLRenderer* renderer, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetRenderViewportNative(renderer, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// Drawing will clip to this area (separately from any clipping done with<br/>
		/// SDL_SetRenderClipRect), and the top left of the area will become coordinate<br/>
		/// (0, 0) for future drawing commands.<br/>
		/// The area's width and height must be >= 0.<br/>
		/// Each render target has its own viewport. This function sets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderViewport(ref SDLRenderer renderer, ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetRenderViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// Each render target has its own viewport. This function gets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderViewportNative(SDLRenderer* renderer, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, byte>)funcTable[1077])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1077])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// Each render target has its own viewport. This function gets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderViewport(SDLRenderer* renderer, SDLRect* rect)
		{
			byte ret = GetRenderViewportNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// Each render target has its own viewport. This function gets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderViewport(ref SDLRenderer renderer, SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderViewportNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// Each render target has its own viewport. This function gets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderViewport(SDLRenderer* renderer, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = GetRenderViewportNative(renderer, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// Each render target has its own viewport. This function gets the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderViewport(ref SDLRenderer renderer, ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = GetRenderViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Return whether an explicit rectangle was set as the viewport.<br/>
		/// This is useful if you're saving and restoring the viewport and want to know<br/>
		/// whether you should restore a specific rectangle or NULL.<br/>
		/// Each render target has its own viewport. This function checks the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderViewportSetNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte>)funcTable[1078])(renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1078])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Return whether an explicit rectangle was set as the viewport.<br/>
		/// This is useful if you're saving and restoring the viewport and want to know<br/>
		/// whether you should restore a specific rectangle or NULL.<br/>
		/// Each render target has its own viewport. This function checks the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderViewportSet(SDLRenderer* renderer)
		{
			byte ret = RenderViewportSetNative(renderer);
			return ret != 0;
		}

		/// <summary>
		/// Return whether an explicit rectangle was set as the viewport.<br/>
		/// This is useful if you're saving and restoring the viewport and want to know<br/>
		/// whether you should restore a specific rectangle or NULL.<br/>
		/// Each render target has its own viewport. This function checks the viewport<br/>
		/// for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderViewportSet(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderViewportSetNative((SDLRenderer*)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the safe area for rendering within the current viewport.<br/>
		/// Some devices have portions of the screen which are partially obscured or<br/>
		/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
		/// notches, TV overscan, etc. This function provides the area of the current<br/>
		/// viewport which is safe to have interactible content. You should continue<br/>
		/// rendering into the rest of the render target, but it should not contain<br/>
		/// visually important or interactible content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderSafeAreaNative(SDLRenderer* renderer, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, byte>)funcTable[1079])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1079])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the safe area for rendering within the current viewport.<br/>
		/// Some devices have portions of the screen which are partially obscured or<br/>
		/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
		/// notches, TV overscan, etc. This function provides the area of the current<br/>
		/// viewport which is safe to have interactible content. You should continue<br/>
		/// rendering into the rest of the render target, but it should not contain<br/>
		/// visually important or interactible content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderSafeArea(SDLRenderer* renderer, SDLRect* rect)
		{
			byte ret = GetRenderSafeAreaNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Get the safe area for rendering within the current viewport.<br/>
		/// Some devices have portions of the screen which are partially obscured or<br/>
		/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
		/// notches, TV overscan, etc. This function provides the area of the current<br/>
		/// viewport which is safe to have interactible content. You should continue<br/>
		/// rendering into the rest of the render target, but it should not contain<br/>
		/// visually important or interactible content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderSafeArea(ref SDLRenderer renderer, SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderSafeAreaNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the safe area for rendering within the current viewport.<br/>
		/// Some devices have portions of the screen which are partially obscured or<br/>
		/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
		/// notches, TV overscan, etc. This function provides the area of the current<br/>
		/// viewport which is safe to have interactible content. You should continue<br/>
		/// rendering into the rest of the render target, but it should not contain<br/>
		/// visually important or interactible content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderSafeArea(SDLRenderer* renderer, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = GetRenderSafeAreaNative(renderer, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the safe area for rendering within the current viewport.<br/>
		/// Some devices have portions of the screen which are partially obscured or<br/>
		/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
		/// notches, TV overscan, etc. This function provides the area of the current<br/>
		/// viewport which is safe to have interactible content. You should continue<br/>
		/// rendering into the rest of the render target, but it should not contain<br/>
		/// visually important or interactible content.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderSafeArea(ref SDLRenderer renderer, ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = GetRenderSafeAreaNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// Each render target has its own clip rectangle. This function sets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderClipRectNative(SDLRenderer* renderer, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, byte>)funcTable[1080])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1080])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// Each render target has its own clip rectangle. This function sets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderClipRect(SDLRenderer* renderer, SDLRect* rect)
		{
			byte ret = SetRenderClipRectNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// Each render target has its own clip rectangle. This function sets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderClipRect(ref SDLRenderer renderer, SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderClipRectNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// Each render target has its own clip rectangle. This function sets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderClipRect(SDLRenderer* renderer, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetRenderClipRectNative(renderer, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// Each render target has its own clip rectangle. This function sets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderClipRect(ref SDLRenderer renderer, ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetRenderClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// Each render target has its own clip rectangle. This function gets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderClipRectNative(SDLRenderer* renderer, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, byte>)funcTable[1081])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1081])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// Each render target has its own clip rectangle. This function gets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderClipRect(SDLRenderer* renderer, SDLRect* rect)
		{
			byte ret = GetRenderClipRectNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// Each render target has its own clip rectangle. This function gets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderClipRect(ref SDLRenderer renderer, SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderClipRectNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// Each render target has its own clip rectangle. This function gets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderClipRect(SDLRenderer* renderer, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = GetRenderClipRectNative(renderer, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// Each render target has its own clip rectangle. This function gets the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderClipRect(ref SDLRenderer renderer, ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = GetRenderClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get whether clipping is enabled on the given render target.<br/>
		/// Each render target has its own clip rectangle. This function checks the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderClipEnabledNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte>)funcTable[1082])(renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1082])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get whether clipping is enabled on the given render target.<br/>
		/// Each render target has its own clip rectangle. This function checks the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderClipEnabled(SDLRenderer* renderer)
		{
			byte ret = RenderClipEnabledNative(renderer);
			return ret != 0;
		}

		/// <summary>
		/// Get whether clipping is enabled on the given render target.<br/>
		/// Each render target has its own clip rectangle. This function checks the<br/>
		/// cliprect for the current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderClipEnabled(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderClipEnabledNative((SDLRenderer*)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// Each render target has its own scale. This function sets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderScaleNative(SDLRenderer* renderer, float scaleX, float scaleY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, byte>)funcTable[1083])(renderer, scaleX, scaleY);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, byte>)funcTable[1083])((nint)renderer, scaleX, scaleY);
			#endif
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// Each render target has its own scale. This function sets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderScale(SDLRenderer* renderer, float scaleX, float scaleY)
		{
			byte ret = SetRenderScaleNative(renderer, scaleX, scaleY);
			return ret != 0;
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// Each render target has its own scale. This function sets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderScale(ref SDLRenderer renderer, float scaleX, float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderScaleNative(SDLRenderer* renderer, float* scaleX, float* scaleY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float*, float*, byte>)funcTable[1084])(renderer, scaleX, scaleY);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[1084])((nint)renderer, (nint)scaleX, (nint)scaleY);
			#endif
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(SDLRenderer* renderer, float* scaleX, float* scaleY)
		{
			byte ret = GetRenderScaleNative(renderer, scaleX, scaleY);
			return ret != 0;
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(ref SDLRenderer renderer, float* scaleX, float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(SDLRenderer* renderer, ref float scaleX, float* scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				byte ret = GetRenderScaleNative(renderer, (float*)pscaleX, scaleY);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(ref SDLRenderer renderer, ref float scaleX, float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					byte ret = GetRenderScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, scaleY);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(SDLRenderer* renderer, float* scaleX, ref float scaleY)
		{
			fixed (float* pscaleY = &scaleY)
			{
				byte ret = GetRenderScaleNative(renderer, scaleX, (float*)pscaleY);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(ref SDLRenderer renderer, float* scaleX, ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleY = &scaleY)
				{
					byte ret = GetRenderScaleNative((SDLRenderer*)prenderer, scaleX, (float*)pscaleY);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(SDLRenderer* renderer, ref float scaleX, ref float scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				fixed (float* pscaleY = &scaleY)
				{
					byte ret = GetRenderScaleNative(renderer, (float*)pscaleX, (float*)pscaleY);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// Each render target has its own scale. This function gets the scale for the<br/>
		/// current render target.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderScale(ref SDLRenderer renderer, ref float scaleX, ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					fixed (float* pscaleY = &scaleY)
					{
						byte ret = GetRenderScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, (float*)pscaleY);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the color used for drawing operations.<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderDrawColorNative(SDLRenderer* renderer, byte r, byte g, byte b, byte a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte, byte, byte, byte, byte>)funcTable[1085])(renderer, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte, byte>)funcTable[1085])((nint)renderer, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Set the color used for drawing operations.<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderDrawColor(SDLRenderer* renderer, byte r, byte g, byte b, byte a)
		{
			byte ret = SetRenderDrawColorNative(renderer, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Set the color used for drawing operations.<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderDrawColor(ref SDLRenderer renderer, byte r, byte g, byte b, byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderDrawColorFloatNative(SDLRenderer* renderer, float r, float g, float b, float a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, float, float, byte>)funcTable[1086])(renderer, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, byte>)funcTable[1086])((nint)renderer, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderDrawColorFloat(SDLRenderer* renderer, float r, float g, float b, float a)
		{
			byte ret = SetRenderDrawColorFloatNative(renderer, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderDrawColorFloat(ref SDLRenderer renderer, float r, float g, float b, float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderDrawColorNative(SDLRenderer* renderer, byte* r, byte* g, byte* b, byte* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte*, byte*, byte*, byte*, byte>)funcTable[1087])(renderer, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[1087])((nint)renderer, (nint)r, (nint)g, (nint)b, (nint)a);
			#endif
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, byte* g, byte* b, byte* a)
		{
			byte ret = GetRenderDrawColorNative(renderer, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, byte* g, byte* b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, byte* g, byte* b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (byte* pg = &g)
			{
				byte ret = GetRenderDrawColorNative(renderer, r, (byte*)pg, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, ref byte g, byte* b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, b, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (byte* pb = &b)
			{
				byte ret = GetRenderDrawColorNative(renderer, r, g, (byte*)pb, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, (byte*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, g, (byte*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, byte* g, ref byte b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, (byte*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, ref byte g, ref byte b, byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetRenderDrawColorNative(renderer, r, (byte*)pg, (byte*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, ref byte g, ref byte b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, (byte*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, ref byte g, ref byte b, byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, (byte*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, ref byte g, ref byte b, byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, (byte*)pb, a);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, byte* g, byte* b, ref byte a)
		{
			fixed (byte* pa = &a)
			{
				byte ret = GetRenderDrawColorNative(renderer, r, g, b, (byte*)pa);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, byte* g, byte* b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pa = &a)
				{
					byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, byte* g, byte* b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, g, b, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, byte* g, byte* b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, b, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, ref byte g, byte* b, ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					byte ret = GetRenderDrawColorNative(renderer, r, (byte*)pg, b, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, ref byte g, byte* b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, b, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, ref byte g, byte* b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, b, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, ref byte g, byte* b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, b, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, byte* g, ref byte b, ref byte a)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pa = &a)
				{
					byte ret = GetRenderDrawColorNative(renderer, r, g, (byte*)pb, (byte*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, byte* g, ref byte b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, (byte*)pb, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, byte* g, ref byte b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, g, (byte*)pb, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, byte* g, ref byte b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, (byte*)pb, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, byte* r, ref byte g, ref byte b, ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						byte ret = GetRenderDrawColorNative(renderer, r, (byte*)pg, (byte*)pb, (byte*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, byte* r, ref byte g, ref byte b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, (byte*)pb, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(SDLRenderer* renderer, ref byte r, ref byte g, ref byte b, ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							byte ret = GetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColor(ref SDLRenderer renderer, ref byte r, ref byte g, ref byte b, ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								byte ret = GetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderDrawColorFloatNative(SDLRenderer* renderer, float* r, float* g, float* b, float* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float*, float*, float*, float*, byte>)funcTable[1088])(renderer, r, g, b, a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[1088])((nint)renderer, (nint)r, (nint)g, (nint)b, (nint)a);
			#endif
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, float* g, float* b, float* a)
		{
			byte ret = GetRenderDrawColorFloatNative(renderer, r, g, b, a);
			return ret != 0;
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, float* g, float* b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, float* g, float* b, float* a)
		{
			fixed (float* pr = &r)
			{
				byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, g, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, float* g, float* b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, g, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, ref float g, float* b, float* a)
		{
			fixed (float* pg = &g)
			{
				byte ret = GetRenderDrawColorFloatNative(renderer, r, (float*)pg, b, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, ref float g, float* b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pg = &g)
				{
					byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, (float*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, ref float g, float* b, float* a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, (float*)pg, b, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, ref float g, float* b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, (float*)pg, b, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, float* g, ref float b, float* a)
		{
			fixed (float* pb = &b)
			{
				byte ret = GetRenderDrawColorFloatNative(renderer, r, g, (float*)pb, a);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, float* g, ref float b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pb = &b)
				{
					byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, g, (float*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, float* g, ref float b, float* a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pb = &b)
				{
					byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, g, (float*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, float* g, ref float b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pb = &b)
					{
						byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, g, (float*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, ref float g, ref float b, float* a)
		{
			fixed (float* pg = &g)
			{
				fixed (float* pb = &b)
				{
					byte ret = GetRenderDrawColorFloatNative(renderer, r, (float*)pg, (float*)pb, a);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, ref float g, ref float b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, (float*)pg, (float*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, ref float g, ref float b, float* a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, (float*)pg, (float*)pb, a);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, ref float g, ref float b, float* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						fixed (float* pb = &b)
						{
							byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, (float*)pg, (float*)pb, a);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, float* g, float* b, ref float a)
		{
			fixed (float* pa = &a)
			{
				byte ret = GetRenderDrawColorFloatNative(renderer, r, g, b, (float*)pa);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, float* g, float* b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pa = &a)
				{
					byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, g, b, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, float* g, float* b, ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pa = &a)
				{
					byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, g, b, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, float* g, float* b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pa = &a)
					{
						byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, g, b, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, ref float g, float* b, ref float a)
		{
			fixed (float* pg = &g)
			{
				fixed (float* pa = &a)
				{
					byte ret = GetRenderDrawColorFloatNative(renderer, r, (float*)pg, b, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, ref float g, float* b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pa = &a)
					{
						byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, (float*)pg, b, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, ref float g, float* b, ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pa = &a)
					{
						byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, (float*)pg, b, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, ref float g, float* b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						fixed (float* pa = &a)
						{
							byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, (float*)pg, b, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, float* g, ref float b, ref float a)
		{
			fixed (float* pb = &b)
			{
				fixed (float* pa = &a)
				{
					byte ret = GetRenderDrawColorFloatNative(renderer, r, g, (float*)pb, (float*)pa);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, float* g, ref float b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pb = &b)
				{
					fixed (float* pa = &a)
					{
						byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, g, (float*)pb, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, float* g, ref float b, ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pb = &b)
				{
					fixed (float* pa = &a)
					{
						byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, g, (float*)pb, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, float* g, ref float b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pb = &b)
					{
						fixed (float* pa = &a)
						{
							byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, g, (float*)pb, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, float* r, ref float g, ref float b, ref float a)
		{
			fixed (float* pg = &g)
			{
				fixed (float* pb = &b)
				{
					fixed (float* pa = &a)
					{
						byte ret = GetRenderDrawColorFloatNative(renderer, r, (float*)pg, (float*)pb, (float*)pa);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, float* r, ref float g, ref float b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						fixed (float* pa = &a)
						{
							byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, r, (float*)pg, (float*)pb, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(SDLRenderer* renderer, ref float r, ref float g, ref float b, ref float a)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						fixed (float* pa = &a)
						{
							byte ret = GetRenderDrawColorFloatNative(renderer, (float*)pr, (float*)pg, (float*)pb, (float*)pa);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawColorFloat(ref SDLRenderer renderer, ref float r, ref float g, ref float b, ref float a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						fixed (float* pb = &b)
						{
							fixed (float* pa = &a)
							{
								byte ret = GetRenderDrawColorFloatNative((SDLRenderer*)prenderer, (float*)pr, (float*)pg, (float*)pb, (float*)pa);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Set the color scale used for render operations.<br/>
		/// The color scale is an additional scale multiplied into the pixel color<br/>
		/// value while rendering. This can be used to adjust the brightness of colors<br/>
		/// during HDR rendering, or changing HDR video brightness when playing on an<br/>
		/// SDR display.<br/>
		/// The color scale does not affect the alpha channel, only the color<br/>
		/// brightness.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderColorScaleNative(SDLRenderer* renderer, float scale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, byte>)funcTable[1089])(renderer, scale);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, byte>)funcTable[1089])((nint)renderer, scale);
			#endif
		}

		/// <summary>
		/// Set the color scale used for render operations.<br/>
		/// The color scale is an additional scale multiplied into the pixel color<br/>
		/// value while rendering. This can be used to adjust the brightness of colors<br/>
		/// during HDR rendering, or changing HDR video brightness when playing on an<br/>
		/// SDR display.<br/>
		/// The color scale does not affect the alpha channel, only the color<br/>
		/// brightness.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderColorScale(SDLRenderer* renderer, float scale)
		{
			byte ret = SetRenderColorScaleNative(renderer, scale);
			return ret != 0;
		}

		/// <summary>
		/// Set the color scale used for render operations.<br/>
		/// The color scale is an additional scale multiplied into the pixel color<br/>
		/// value while rendering. This can be used to adjust the brightness of colors<br/>
		/// during HDR rendering, or changing HDR video brightness when playing on an<br/>
		/// SDR display.<br/>
		/// The color scale does not affect the alpha channel, only the color<br/>
		/// brightness.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderColorScale(ref SDLRenderer renderer, float scale)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderColorScaleNative((SDLRenderer*)prenderer, scale);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color scale used for render operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderColorScaleNative(SDLRenderer* renderer, float* scale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float*, byte>)funcTable[1090])(renderer, scale);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1090])((nint)renderer, (nint)scale);
			#endif
		}

		/// <summary>
		/// Get the color scale used for render operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderColorScale(SDLRenderer* renderer, float* scale)
		{
			byte ret = GetRenderColorScaleNative(renderer, scale);
			return ret != 0;
		}

		/// <summary>
		/// Get the color scale used for render operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderColorScale(ref SDLRenderer renderer, float* scale)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderColorScaleNative((SDLRenderer*)prenderer, scale);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color scale used for render operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderColorScale(SDLRenderer* renderer, ref float scale)
		{
			fixed (float* pscale = &scale)
			{
				byte ret = GetRenderColorScaleNative(renderer, (float*)pscale);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the color scale used for render operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderColorScale(ref SDLRenderer renderer, ref float scale)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscale = &scale)
				{
					byte ret = GetRenderColorScaleNative((SDLRenderer*)prenderer, (float*)pscale);
					return ret != 0;
				}
			}
		}
	}
}
